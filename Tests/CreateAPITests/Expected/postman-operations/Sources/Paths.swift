// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import APIClient
import HTTPHeaders

extension Paths {
    /// Get all APIs
    ///
    /// This call fetches all the APIs present in the specified workspace
    /// 
    /// Response contains an array named `apis` which would contain all the details of APIs present in the workspace.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getAllAPIs(parameters: GetAllAPIsParameters? = nil) -> Request<Void> {
        .get("/apis", query: parameters?.asQuery())
    }

    public struct GetAllAPIsParameters {
        /// Example: "c90a3482-f80d-43d6-9dfb-0830f5e43605"
        public var workspace: String?
        /// Example: "{{since}}"
        public var since: String?
        /// Example: "{{until}}"
        public var until: String?
        /// Example: "{{createdBy}}"
        public var createdBy: String?
        /// Example: "{{updatedBy}}"
        public var updatedBy: String?
        /// Example: "{{isPublic}}"
        public var isPublic: String?
        /// Example: "{{name}}"
        public var name: String?
        /// Example: "{{summary}}"
        public var summary: String?
        /// Example: "{{description}}"
        public var description: String?
        /// Example: "{{sort}}"
        public var sort: String?
        /// Example: "{{direction}}"
        public var direction: String?

        public init(workspace: String? = nil, since: String? = nil, until: String? = nil, createdBy: String? = nil, updatedBy: String? = nil, isPublic: String? = nil, name: String? = nil, summary: String? = nil, description: String? = nil, sort: String? = nil, direction: String? = nil) {
            self.workspace = workspace
            self.since = since
            self.until = until
            self.createdBy = createdBy
            self.updatedBy = updatedBy
            self.isPublic = isPublic
            self.name = name
            self.summary = summary
            self.description = description
            self.sort = sort
            self.direction = direction
        }

        public func asQuery() -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("workspace", workspace?.asQueryValue)
            query.addQueryItem("since", since?.asQueryValue)
            query.addQueryItem("until", until?.asQueryValue)
            query.addQueryItem("createdBy", createdBy?.asQueryValue)
            query.addQueryItem("updatedBy", updatedBy?.asQueryValue)
            query.addQueryItem("isPublic", isPublic?.asQueryValue)
            query.addQueryItem("name", name?.asQueryValue)
            query.addQueryItem("summary", summary?.asQueryValue)
            query.addQueryItem("description", description?.asQueryValue)
            query.addQueryItem("sort", sort?.asQueryValue)
            query.addQueryItem("direction", direction?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    /// Create API
    ///
    /// This call creates a new API with a default API Version.  
    /// 
    /// Request body should contain an `api` object which should atleast have a property `name`.
    /// 
    /// Response contains an `api` object with all the details related to the created API, namely, `id`, `name`, `summary`, `description`, etc. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createAPI(workspace: String? = nil, api: CreateAPIRequest.API? = nil) -> Request<CreateAPIResponse> {
        .post("/apis", query: makeCreateAPIQuery(workspace), body: CreateAPIRequest(api: api))
    }

    public struct CreateAPIResponse: Decodable {
        public var api: API?

        public struct API: Decodable {
            /// Example: "2019-02-12 19:34:49"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "This is supposed to handle markdown *descriptions*."
            public var description: String?
            /// Example: "387c2863-6ee3-4a56-8210-225f774edade"
            public var id: String?
            /// Example: "Sync API"
            public var name: String?
            /// Example: "This is a summary"
            public var summary: String?
            /// Example: "2019-02-12 19:34:49"
            public var updatedAt: String?

            public init(createdAt: String? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, summary: String? = nil, updatedAt: String? = nil) {
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.description = description
                self.id = id
                self.name = name
                self.summary = summary
                self.updatedAt = updatedAt
            }
        }

        public init(api: API? = nil) {
            self.api = api
        }
    }

    private static func makeCreateAPIQuery(_ workspace: String?) -> [(String, String?)] {
        var query: [(String, String?)] = []
        query.addQueryItem("workspace", workspace?.asQueryValue)
        return query
    }

    public struct CreateAPIRequest: Encodable {
        public var api: API?

        public struct API: Encodable {
            /// Example: "This is description."
            public var description: String?
            /// Example: "Sync Service API"
            public var name: String?
            /// Example: "This is supposed to be a short summary."
            public var summary: String?

            public init(description: String? = nil, name: String? = nil, summary: String? = nil) {
                self.description = description
                self.name = name
                self.summary = summary
            }
        }

        public init(api: API? = nil) {
            self.api = api
        }
    }
}

extension Paths {
    /// Single API
    ///
    /// This call fetches a single API having the specified id.
    /// 
    /// Response contains an `api` object with all the details related to the queried API, namely, `id`, `name`, `summary`, `description` etc. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func singleAPI(apiID: String) -> Request<SingleAPIResponse> {
        .get("/apis/\(apiID)")
    }

    public struct SingleAPIResponse: Decodable {
        public var api: API?

        public struct API: Decodable {
            /// Example: "2019-02-12 19:34:49"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "This is a description.This is a description."
            public var description: String?
            /// Example: "387c2863-6ee3-4a56-8210-225f774edade"
            public var id: String?
            /// Example: "Sync API"
            public var name: String?
            /// Example: "This is a summary"
            public var summary: String?
            /// Example: "2019-02-12 19:34:49"
            public var updatedAt: String?

            public init(createdAt: String? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, summary: String? = nil, updatedAt: String? = nil) {
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.description = description
                self.id = id
                self.name = name
                self.summary = summary
                self.updatedAt = updatedAt
            }
        }

        public init(api: API? = nil) {
            self.api = api
        }
    }
}

extension Paths {
    /// Update an API
    ///
    /// This call updates an existing API .  
    /// 
    /// Request body should contain an `api` object which should have the fields to be updated. Only `name`, `summary` and `description` fields can be edited for an API.
    /// 
    /// Response contains an `api` object with all the details related to the created API, namely, `id`, `name`, `summary`, `description` etc. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func updateAnAPI(apiID: String, api: UpdateAnAPIRequest.API? = nil) -> Request<UpdateAnAPIResponse> {
        .put("/apis/\(apiID)", body: UpdateAnAPIRequest(api: api))
    }

    public struct UpdateAnAPIResponse: Decodable {
        public var api: API?

        public struct API: Decodable {
            /// Example: "2019-02-12 19:34:49"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "This is a description."
            public var description: String?
            /// Example: "387c2863-6ee3-4a56-8210-225f774edade"
            public var id: String?
            /// Example: "Sync API"
            public var name: String?
            /// Example: "This is a summary"
            public var summary: String?
            /// Example: "2019-02-12 19:34:49"
            public var updatedAt: String?

            public init(createdAt: String? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, summary: String? = nil, updatedAt: String? = nil) {
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.description = description
                self.id = id
                self.name = name
                self.summary = summary
                self.updatedAt = updatedAt
            }
        }

        public init(api: API? = nil) {
            self.api = api
        }
    }

    public struct UpdateAnAPIRequest: Encodable {
        public var api: API?

        public struct API: Encodable {
            /// Example: "This is an updated Description"
            public var description: String?
            /// Example: "New name"
            public var name: String?

            public init(description: String? = nil, name: String? = nil) {
                self.description = description
                self.name = name
            }
        }

        public init(api: API? = nil) {
            self.api = api
        }
    }
}

extension Paths {
    /// Delete an API
    ///
    /// This call deletes an existing API having the specified id.  
    /// 
    /// Response contains an `api` object with `id` of the API which was deleted.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteAnAPI(apiID: String) -> Request<DeleteAnAPIResponse> {
        .delete("/apis/\(apiID)")
    }

    public struct DeleteAnAPIResponse: Decodable {
        public var api: API?

        public struct API: Decodable {
            /// Example: "387c2863-6ee3-4a56-8210-225f774edade"
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public init(api: API? = nil) {
            self.api = api
        }
    }
}

extension Paths {
    /// Get All API Versions
    ///
    /// This call fetches details about the all the API Versions in the specified API.
    /// 
    /// The response will contain an array `versions` object which would be a list of all the API Version along with their details.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getAllAPIVersions(apiID: String) -> Request<GetAllAPIVersionsResponse> {
        .get("/apis/\(apiID)/versions")
    }

    public struct GetAllAPIVersionsResponse: Decodable {
        public var versions: [Version]?

        public struct Version: Decodable {
            /// Example: "2019-02-12 19:34:49"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "Description"
            public var description: String?
            /// Example: "024660a6-c837-46ca-91d8-7e8dd7c669de"
            public var id: String?
            /// Example: "0.1"
            public var name: String?
            /// Example: "Summary"
            public var summary: String?
            /// Example: "2019-02-12 19:34:49"
            public var updatedAt: String?

            public init(createdAt: String? = nil, createdBy: String? = nil, description: String? = nil, id: String? = nil, name: String? = nil, summary: String? = nil, updatedAt: String? = nil) {
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.description = description
                self.id = id
                self.name = name
                self.summary = summary
                self.updatedAt = updatedAt
            }
        }

        public init(versions: [Version]? = nil) {
            self.versions = versions
        }
    }
}

extension Paths {
    /// Create API Version
    ///
    /// This call creates a new API version in the specified API.  
    /// 
    /// Request body should contain a `version` object which should have fields:
    /// 
    /// <table>
    /// <tr>
    /// 	<td>name</td>
    /// 	<td>Required. Name of the API Version</td>
    /// </tr>
    /// <tr>
    /// 	<td>source</td>
    /// 	<td>
    /// 		If specified, it will copy the contents of the specified api version to create a new api verison.
    /// 		<table>
    /// 			<tr>
    /// 				<td>id</td>
    /// 				<td>Required. Id of the apiversion from where the details are to be copied</td>
    /// 			</tr>
    /// 			<tr>
    /// 				<td>schema</td>
    /// 				<td>Boolean. If true then copies the schema from the specified api version</td>
    /// 			</tr>
    /// 			<tr>
    /// 				<td>relations</td>
    /// 				<td>Object. {"&lt;relationType&gt;": true/false}.  
    /// 					Allowed relation types are `mock`, `monitor`, `documentation`, `contracttest`, `integrationtest`, `testsuite`, `environment`
    /// 				Relation types which should be copied over to the new api verison</td>
    /// 			</tr>
    /// 		</table>
    /// 	</td>
    /// </tr>
    /// </table>
    /// 
    /// Response contains a `version` object with all the details related to the created API Version, namely, `id`, `name`, `api`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createAPIVersion(apiID: String, version: CreateAPIVersionRequest.Version? = nil) -> Request<CreateAPIVersionResponse> {
        .post("/apis/\(apiID)/versions", body: CreateAPIVersionRequest(version: version))
    }

    public struct CreateAPIVersionResponse: Decodable {
        public var version: Version?

        public struct Version: Decodable {
            /// Example: "2b95d07c-8379-4bd1-924f-e7e1af185284"
            public var api: String?
            /// Example: "d71cf403-c549-4c7c-9dc6-a6a105acf67c"
            public var id: String?
            /// Example: "1.0"
            public var name: String?

            public init(api: String? = nil, id: String? = nil, name: String? = nil) {
                self.api = api
                self.id = id
                self.name = name
            }
        }

        public init(version: Version? = nil) {
            self.version = version
        }
    }

    public struct CreateAPIVersionRequest: Encodable {
        public var version: Version?

        public struct Version: Encodable {
            /// Example: "1.0"
            public var name: String?
            public var source: Source?

            public struct Source: Encodable {
                /// Example: "{{apiVersionId}}"
                public var id: String?
                public var relations: Relations?
                /// Example: true
                public var isSchema: Bool?

                public struct Relations: Encodable {
                    /// Example: true
                    public var isDocumentation: Bool?
                    /// Example: true
                    public var isMock: Bool?
                    /// Example: true
                    public var isMonitor: Bool?

                    public init(isDocumentation: Bool? = nil, isMock: Bool? = nil, isMonitor: Bool? = nil) {
                        self.isDocumentation = isDocumentation
                        self.isMock = isMock
                        self.isMonitor = isMonitor
                    }

                    private enum CodingKeys: String, CodingKey {
                        case isDocumentation = "documentation"
                        case isMock = "mock"
                        case isMonitor = "monitor"
                    }
                }

                public init(id: String? = nil, relations: Relations? = nil, isSchema: Bool? = nil) {
                    self.id = id
                    self.relations = relations
                    self.isSchema = isSchema
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case relations
                    case isSchema = "schema"
                }
            }

            public init(name: String? = nil, source: Source? = nil) {
                self.name = name
                self.source = source
            }
        }

        public init(version: Version? = nil) {
            self.version = version
        }
    }
}

extension Paths {
    /// Get an API Version
    ///
    /// This call fetches details about the specified API Version.
    /// 
    /// The response will contain a `version` object which would contain all the details of the API Version.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getAnAPIVersion(apiID: String, apiVersionID: String) -> Request<GetAnAPIVersionResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)")
    }

    public struct GetAnAPIVersionResponse: Decodable {
        public var version: Version?

        public struct Version: Decodable {
            /// Example: "06e41ca3-8bea-4bc5-a726-70338b9f1940"
            public var api: String?
            /// Example: "2019-07-21T16:31:15.000Z"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "03c17f53-7e2e-427d-b55a-006b244f29ff"
            public var id: String?
            /// Example: "0.1"
            public var name: String?
            public var schema: [String]?
            /// Example: "2019-07-21T16:31:15.000Z"
            public var updatedAt: String?
            /// Example: "5665"
            public var updatedBy: String?

            public init(api: String? = nil, createdAt: String? = nil, createdBy: String? = nil, id: String? = nil, name: String? = nil, schema: [String]? = nil, updatedAt: String? = nil, updatedBy: String? = nil) {
                self.api = api
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.id = id
                self.name = name
                self.schema = schema
                self.updatedAt = updatedAt
                self.updatedBy = updatedBy
            }
        }

        public init(version: Version? = nil) {
            self.version = version
        }
    }
}

extension Paths {
    /// Update an API Version
    ///
    /// This call updates an existing API Version.  
    /// 
    /// Request body should contain a `version` object with the fields which need to be updated. Only field which can be updated is `name`.
    /// 
    /// Response contains a `version` object with all the details related to the created API Version, namely, `id`, `name`, `api` etc.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func updateAnAPIVersion(apiID: String, apiVersionID: String, version: UpdateAnAPIVersionRequest.Version? = nil) -> Request<UpdateAnAPIVersionResponse> {
        .put("/apis/\(apiID)/versions/\(apiVersionID)", body: UpdateAnAPIVersionRequest(version: version))
    }

    public struct UpdateAnAPIVersionResponse: Decodable {
        public var version: Version?

        public struct Version: Decodable {
            /// Example: "2b95d07c-8379-4bd1-924f-e7e1af185284"
            public var api: String?
            /// Example: "2019-07-26T11:24:15.000Z"
            public var createdAt: String?
            /// Example: "12"
            public var createdBy: String?
            /// Example: "d71cf403-c549-4c7c-9dc6-a6a105acf67c"
            public var id: String?
            /// Example: "2.0"
            public var name: String?
            /// Example: "2019-08-09T09:27:36.000Z"
            public var updatedAt: String?
            /// Example: "5665"
            public var updatedBy: String?

            public init(api: String? = nil, createdAt: String? = nil, createdBy: String? = nil, id: String? = nil, name: String? = nil, updatedAt: String? = nil, updatedBy: String? = nil) {
                self.api = api
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.id = id
                self.name = name
                self.updatedAt = updatedAt
                self.updatedBy = updatedBy
            }
        }

        public init(version: Version? = nil) {
            self.version = version
        }
    }

    public struct UpdateAnAPIVersionRequest: Encodable {
        public var version: Version?

        public struct Version: Encodable {
            /// Example: "2.0"
            public var name: String?

            public init(name: String? = nil) {
                self.name = name
            }
        }

        public init(version: Version? = nil) {
            self.version = version
        }
    }
}

extension Paths {
    /// Delete an API Version
    ///
    /// This call deletes an existing API Version having the specified id.  
    /// 
    /// Response contains an `version` object with `id` of the API Version which was deleted.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteAnAPIVersion(apiID: String, apiVersionID: String) -> Request<DeleteAnAPIVersionResponse> {
        .delete("/apis/\(apiID)/versions/\(apiVersionID)")
    }

    public struct DeleteAnAPIVersionResponse: Decodable {
        public var version: Version?

        public struct Version: Decodable {
            /// Example: "03c17f53-7e2e-427d-b55a-006b244f29ff"
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public init(version: Version? = nil) {
            self.version = version
        }
    }
}

extension Paths {
    /// Get contract test relations
    ///
    /// This call fetches all the relations by type which are linked to the specified API version along with their details.
    /// 
    /// The response will contain an array with key `{{relationType}}`. Each of the item will consist of all the details related each of the relation.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getContractTestRelations(apiID: String, apiVersionID: String) -> Request<GetContractTestRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/contracttest")
    }

    public struct GetContractTestRelationsResponse: Decodable {
        public var contracttest: [ContracttestItem]?

        public struct ContracttestItem: Decodable {
            /// Example: "7732157-a8bcd149-2b01-4b4c-8c14-c7d05be77745"
            public var collectionID: String?
            /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
            public var id: String?
            /// Example: "C test"
            public var name: String?
            /// Example: "2019-08-29T10:18:11.000Z"
            public var updatedAt: String?

            public init(collectionID: String? = nil, id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                self.collectionID = collectionID
                self.id = id
                self.name = name
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case collectionID = "collectionId"
                case id
                case name
                case updatedAt
            }
        }

        public init(contracttest: [ContracttestItem]? = nil) {
            self.contracttest = contracttest
        }
    }
}

extension Paths {
    /// Get  documentation relations
    ///
    /// This call fetches all the relations by type which are linked to the specified API version along with their details.
    /// 
    /// The response will contain an array with key `{{relationType}}`. Each of the item will consist of all the details related each of the relation.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getDocumentationRelations(apiID: String, apiVersionID: String) -> Request<GetDocumentationRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/documentation")
    }

    public struct GetDocumentationRelationsResponse: Decodable {
        public var documentation: [Documantation]?

        public struct Documantation: Decodable {
            /// Example: "7732157-a8bcd149-2b01-4b4c-8c14-c7d05be77745"
            public var collectionID: String?
            /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
            public var id: String?
            /// Example: "C test"
            public var name: String?
            /// Example: "2019-08-29T10:18:11.000Z"
            public var updatedAt: String?

            public init(collectionID: String? = nil, id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                self.collectionID = collectionID
                self.id = id
                self.name = name
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case collectionID = "collectionId"
                case id
                case name
                case updatedAt
            }
        }

        public init(documentation: [Documantation]? = nil) {
            self.documentation = documentation
        }
    }
}

extension Paths {
    /// Get environment relations
    ///
    /// This call fetches all the relations by type which are linked to the specified API version along with their details.
    /// 
    /// The response will contain an array with key `{{relationType}}`. Each of the item will consist of all the details related each of the relation.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getEnvironmentRelations(apiID: String, apiVersionID: String) -> Request<GetEnvironmentRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/environment")
    }

    public struct GetEnvironmentRelationsResponse: Decodable {
        public var environment: [Environmant]?

        public struct Environmant: Decodable {
            /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
            public var id: String?
            /// Example: "C test"
            public var name: String?
            /// Example: "2019-08-29T10:18:11.000Z"
            public var updatedAt: String?

            public init(id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                self.id = id
                self.name = name
                self.updatedAt = updatedAt
            }
        }

        public init(environment: [Environmant]? = nil) {
            self.environment = environment
        }
    }
}

extension Paths {
    /// Get integration test relations
    ///
    /// This call fetches all the relations by type which are linked to the specified API version along with their details.
    /// 
    /// The response will contain an array with key `{{relationType}}`. Each of the item will consist of all the details related each of the relation.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getIntegrationTestRelations(apiID: String, apiVersionID: String) -> Request<GetIntegrationTestRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/integrationtest")
    }

    public struct GetIntegrationTestRelationsResponse: Decodable {
        public var integrationtest: [IntegrationtestItem]?

        public struct IntegrationtestItem: Decodable {
            /// Example: "7732157-a8bcd149-2b01-4b4c-8c14-c7d05be77745"
            public var collectionID: String?
            /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
            public var id: String?
            /// Example: "C test"
            public var name: String?
            /// Example: "2019-08-29T10:18:11.000Z"
            public var updatedAt: String?

            public init(collectionID: String? = nil, id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                self.collectionID = collectionID
                self.id = id
                self.name = name
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case collectionID = "collectionId"
                case id
                case name
                case updatedAt
            }
        }

        public init(integrationtest: [IntegrationtestItem]? = nil) {
            self.integrationtest = integrationtest
        }
    }
}

extension Paths {
    /// Get monitor relations
    ///
    /// This call fetches all the relations by type which are linked to the specified API version along with their details.
    /// 
    /// The response will contain an array with key `{{relationType}}`. Each of the item will consist of all the details related each of the relation.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getMonitorRelations(apiID: String, apiVersionID: String) -> Request<GetMonitorRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/monitor")
    }

    public struct GetMonitorRelationsResponse: Decodable {
        public var monitor: [MonitorItem]?

        public struct MonitorItem: Decodable {
            /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
            public var id: String?
            /// Example: "7732157-a8bcd149-2b01-4b4c-8c14-c7d05be77745"
            public var monitorID: String?
            /// Example: "C test"
            public var name: String?
            /// Example: "2019-08-29T10:18:11.000Z"
            public var updatedAt: String?

            public init(id: String? = nil, monitorID: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                self.id = id
                self.monitorID = monitorID
                self.name = name
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case monitorID = "monitorId"
                case name
                case updatedAt
            }
        }

        public init(monitor: [MonitorItem]? = nil) {
            self.monitor = monitor
        }
    }
}

extension Paths {
    /// Get linked relations
    ///
    /// This call fetches all the relations which are linked to the specified API version along with their details.
    /// 
    /// The response will contain a `relations` object which lists all the relation types which are linked to the API version. Each of the relation type will be an object which details the relations of this type. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getLinkedRelations(apiID: String, apiVersionID: String) -> Request<GetLinkedRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/relations")
    }

    public struct GetLinkedRelationsResponse: Decodable {
        public var relations: Relations?

        public struct Relations: Decodable {
            public var contracttest: Contracttest?
            public var integrationtest: Integrationtest?
            public var mock: Mock?

            public struct Contracttest: Decodable {
                public var _2a9b8fa888b74b8683728e3f6f6e07f2: _2a9b8fa888b74b8683728e3f6f6e07f2?

                public struct _2a9b8fa888b74b8683728e3f6f6e07f2: Decodable {
                    /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
                    public var id: String?
                    /// Example: "C test"
                    public var name: String?
                    /// Example: "2019-08-29T10:18:11.000Z"
                    public var updatedAt: String?

                    public init(id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                        self.id = id
                        self.name = name
                        self.updatedAt = updatedAt
                    }
                }

                public init(_2a9b8fa888b74b8683728e3f6f6e07f2: _2a9b8fa888b74b8683728e3f6f6e07f2? = nil) {
                    self._2a9b8fa888b74b8683728e3f6f6e07f2 = _2a9b8fa888b74b8683728e3f6f6e07f2
                }

                private enum CodingKeys: String, CodingKey {
                    case _2a9b8fa888b74b8683728e3f6f6e07f2 = "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
                }
            }

            public struct Integrationtest: Decodable {
                public var _521b0486Ab914d3a918943c9380a0533: _521b0486Ab914d3a918943c9380a0533?
                public var a236b715E682460b97b6C1db24f7612e: A236b715E682460b97b6C1db24f7612e?

                public struct _521b0486Ab914d3a918943c9380a0533: Decodable {
                    /// Example: "521b0486-ab91-4d3a-9189-43c9380a0533"
                    public var id: String?
                    /// Example: "C1"
                    public var name: String?
                    /// Example: "2019-08-29T11:40:39.000Z"
                    public var updatedAt: String?

                    public init(id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                        self.id = id
                        self.name = name
                        self.updatedAt = updatedAt
                    }
                }

                public struct A236b715E682460b97b6C1db24f7612e: Decodable {
                    /// Example: "a236b715-e682-460b-97b6-c1db24f7612e"
                    public var id: String?
                    /// Example: "C test"
                    public var name: String?
                    /// Example: "2019-08-29T10:18:11.000Z"
                    public var updatedAt: String?

                    public init(id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                        self.id = id
                        self.name = name
                        self.updatedAt = updatedAt
                    }
                }

                public init(_521b0486Ab914d3a918943c9380a0533: _521b0486Ab914d3a918943c9380a0533? = nil, a236b715E682460b97b6C1db24f7612e: A236b715E682460b97b6C1db24f7612e? = nil) {
                    self._521b0486Ab914d3a918943c9380a0533 = _521b0486Ab914d3a918943c9380a0533
                    self.a236b715E682460b97b6C1db24f7612e = a236b715E682460b97b6C1db24f7612e
                }

                private enum CodingKeys: String, CodingKey {
                    case _521b0486Ab914d3a918943c9380a0533 = "521b0486-ab91-4d3a-9189-43c9380a0533"
                    case a236b715E682460b97b6C1db24f7612e = "a236b715-e682-460b-97b6-c1db24f7612e"
                }
            }

            public struct Mock: Decodable {
                public var _4ccd755f2c80481bA26249b55e12f5e1: _4ccd755f2c80481bA26249b55e12f5e1?

                public struct _4ccd755f2c80481bA26249b55e12f5e1: Decodable {
                    /// Example: "4ccd755f-2c80-481b-a262-49b55e12f5e1"
                    public var id: String?
                    /// Example: "Mock"
                    public var name: String?
                    /// Example: "2019-08-20T10:18:13.000Z"
                    public var updatedAt: String?
                    /// Example: "https://4ccd755f-2c80-481b-a262-49b55e12f5e1.mock-beta.pstmn.io"
                    public var url: String?

                    public init(id: String? = nil, name: String? = nil, updatedAt: String? = nil, url: String? = nil) {
                        self.id = id
                        self.name = name
                        self.updatedAt = updatedAt
                        self.url = url
                    }
                }

                public init(_4ccd755f2c80481bA26249b55e12f5e1: _4ccd755f2c80481bA26249b55e12f5e1? = nil) {
                    self._4ccd755f2c80481bA26249b55e12f5e1 = _4ccd755f2c80481bA26249b55e12f5e1
                }

                private enum CodingKeys: String, CodingKey {
                    case _4ccd755f2c80481bA26249b55e12f5e1 = "4ccd755f-2c80-481b-a262-49b55e12f5e1"
                }
            }

            public init(contracttest: Contracttest? = nil, integrationtest: Integrationtest? = nil, mock: Mock? = nil) {
                self.contracttest = contracttest
                self.integrationtest = integrationtest
                self.mock = mock
            }
        }

        public init(relations: Relations? = nil) {
            self.relations = relations
        }
    }
}

extension Paths {
    /// Create relations
    ///
    /// This call allows you to add existing Postman entities as new relations to an API. The request body should contain the relations to be created along with an array of entity IDs. 
    /// 
    /// <table>
    ///   <tr>
    ///     <th>Relation</th>
    ///     <th>Entity ID type</th>
    ///   <tr>
    ///   <tr>
    ///     <td>contracttest</td>
    ///     <td>Collection UIDs</td>
    ///   </tr>
    ///   <tr>
    ///     <td>integrationtest</td>
    ///     <td>Collection UIDs</td>
    ///   </tr>
    ///   <tr>
    ///     <td>documentation</td>
    ///     <td>Collection UIDs</td>
    ///   </tr>
    ///   <tr>
    ///     <td>testsuite</td>
    ///     <td>Collection UIDs</td>
    ///   </tr>
    ///   <tr>
    ///     <td>environment</td>
    ///     <td>Environment UIDs</td>
    ///   </tr>
    ///   <tr>
    ///     <td>mock</td>
    ///     <td>Mock IDs</td>
    ///   </tr>
    ///   <tr>
    ///     <td>monitor</td>
    ///     <td>Monitor IDs</td>
    ///   </tr>
    /// </table>
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createRelations(apiID: String, apiVersionID: String, _ body: CreateRelationsRequest? = nil) -> Request<CreateRelationsResponse> {
        .post("/apis/\(apiID)/versions/\(apiVersionID)/relations", body: body)
    }

    public struct CreateRelationsResponse: Decodable {
        public var contracttest: [String]?
        public var documentation: [String]?
        public var testsuite: [String]?

        public init(contracttest: [String]? = nil, documentation: [String]? = nil, testsuite: [String]? = nil) {
            self.contracttest = contracttest
            self.documentation = documentation
            self.testsuite = testsuite
        }
    }

    public struct CreateRelationsRequest: Encodable {
        public var contracttest: [String]?
        public var documentation: [String]?
        public var mock: [String]?
        public var testsuite: [String]?

        public init(contracttest: [String]? = nil, documentation: [String]? = nil, mock: [String]? = nil, testsuite: [String]? = nil) {
            self.contracttest = contracttest
            self.documentation = documentation
            self.mock = mock
            self.testsuite = testsuite
        }
    }
}

extension Paths {
    /// Create Schema
    ///
    /// This call creates a new schema.
    /// 
    /// Request body should contain a `schema` object which should atleast have these properties with `string` values:
    /// 
    /// - **`type`**: Allowed types are `openapi3`, `openapi2`, `openapi1`, `raml` and `graphql`.
    /// - **`language`** : Allowed languages are `json` and `yaml` for OpenAPI and RAML schema types. GraphQL schema type accepts only `graphql` language.
    /// - **`schema`**: Optional. If passed, must be the content of the schema as a `string`.
    /// 
    /// Response contains a `schema` object with all the details related to the created schema, namely, `id`, `language`, `type` etc. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createSchema(apiID: String, apiVersionID: String, schema: CreateSchemaRequest.Schema? = nil) -> Request<CreateSchemaResponse> {
        .post("/apis/\(apiID)/versions/\(apiVersionID)/schemas", body: CreateSchemaRequest(schema: schema))
    }

    public struct CreateSchemaResponse: Decodable {
        public var schema: Schema?

        public struct Schema: Decodable {
            /// Example: "ad810c39-df60-434e-a76f-a2192cd8d81f"
            public var apiVersion: String?
            /// Example: "2021-05-22T13:17:07.000Z"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "e3b3a0b7-34d5-4fc5-83e0-118bd9e8c822"
            public var id: String?
            /// Example: "yaml"
            public var language: String?
            /// Example: "openapi3"
            public var type: String?
            /// Example: "5665"
            public var updatedBy: String?
            /// Example: "2021-05-22T13:17:07.000Z"
            public var updatedAt: String?

            public init(apiVersion: String? = nil, createdAt: String? = nil, createdBy: String? = nil, id: String? = nil, language: String? = nil, type: String? = nil, updatedBy: String? = nil, updatedAt: String? = nil) {
                self.apiVersion = apiVersion
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.id = id
                self.language = language
                self.type = type
                self.updatedBy = updatedBy
                self.updatedAt = updatedAt
            }
        }

        public init(schema: Schema? = nil) {
            self.schema = schema
        }
    }

    public struct CreateSchemaRequest: Encodable {
        public var schema: Schema?

        public struct Schema: Encodable {
            /// Example: "yaml"
            public var language: String?
            /// Example:
            ///
            /// "{
            ///   "openapi": "3.0.0",
            ///   "info": null,
            ///   "version": "v1.0",
            ///   "title": "API",
            ///   "servers": [
            ///     {
            ///       "url": "http://localhost:3000"
            ///     }
            ///   ],
            ///   "paths": {
            ///     "/user": {
            ///       "get": {
            ///         "summary": "Returns details about a particular user",
            ///         "operationId": "listUser",
            ///         "tags": [
            ///           "user"
            ///         ],
            ///         "parameters": [
            ///           {
            ///             "name": "id",
            ///             "in": "query",
            ///             "description": "ID of the user",
            ///             "required": true,
            ///             "schema": {
            ///               "type": "integer",
            ///               "format": "int32"
            ///             }
            ///           }
            ///         ],
            ///         "responses": {
            ///           "200": {
            ///             "description": "Details about a user by ID",
            ///             "headers": {
            ///               "x-next": {
            ///                 "description": "A link to the next page of responses",
            ///                 "schema": {
            ///                   "type": "string"
            ///                 }
            ///               }
            ///             },
            ///             "content": {
            ///               "application/json": {
            ///                 "schema": {
            ///                   "$ref": "\\'#/components/schemas/User\\'"
            ///                 }
            ///               }
            ///             }
            ///           },
            ///           "default": {
            ///             "description": "Unexpected error",
            ///             "content": {
            ///               "application/json": {
            ///                 "schema": {
            ///                   "$ref": "\\'#/components/schemas/Error\\'"
            ///                 }
            ///               }
            ///             }
            ///           }
            ///         }
            ///       }
            ///     }
            ///   },
            ///   "components": {
            ///     "schemas": {
            ///       "User": {
            ///         "type": "object",
            ///         "required": [
            ///           "id",
            ///           "name"
            ///         ],
            ///         "properties": {
            ///           "id": {
            ///             "type": "integer",
            ///             "format": "int64"
            ///           },
            ///           "name": {
            ///             "type": "string"
            ///           },
            ///           "tag": {
            ///             "type": "string"
            ///           }
            ///         }
            ///       },
            ///       "Error": {
            ///         "type": "object",
            ///         "required": [
            ///           "code",
            ///           "message"
            ///         ],
            ///         "properties": {
            ///           "code": {
            ///             "type": "integer",
            ///             "format": "int32"
            ///           },
            ///           "message": {
            ///             "type": "string"
            ///           }
            ///         }
            ///       }
            ///     }
            ///   }
            /// }"
            public var schema: String?
            /// Example: "openapi3"
            public var type: String?

            public init(language: String? = nil, schema: String? = nil, type: String? = nil) {
                self.language = language
                self.schema = schema
                self.type = type
            }
        }

        public init(schema: Schema? = nil) {
            self.schema = schema
        }
    }
}

extension Paths {
    /// Get Schema
    ///
    /// This call fetches a single schema having the specified id.
    /// 
    /// Response contains a `schema` object with all the details related to the schema, namely, `id`, `language`, `type`, `schema` etc. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getSchema(apiID: String, apiVersionID: String, schemaID: String) -> Request<GetSchemaResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/schemas/\(schemaID)")
    }

    public struct GetSchemaResponse: Decodable {
        public var schema: Schema?

        public struct Schema: Decodable {
            /// Example: "ad810c39-df60-434e-a76f-a2192cd8d81f"
            public var apiVersion: String?
            /// Example: "2021-05-22T13:17:07.000Z"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "e3b3a0b7-34d5-4fc5-83e0-118bd9e8c822"
            public var id: String?
            /// Example: "yaml"
            public var language: String?
            /// Example: "openapi3"
            public var type: String?
            /// Example: "5665"
            public var updatedBy: String?
            /// Example: "2021-05-22T13:17:07.000Z"
            public var updatedAt: String?
            /// Example:
            ///
            /// "{
            ///   "openapi": "3.0.0",
            ///   "info": null,
            ///   "version": "v1.0",
            ///   "title": "API",
            ///   "servers": [
            ///     {
            ///       "url": "http://localhost:3000"
            ///     }
            ///   ],
            ///   "paths": {
            ///     "/user": {
            ///       "get": {
            ///         "summary": "Returns details about a particular user",
            ///         "operationId": "listUser",
            ///         "tags": [
            ///           "user"
            ///         ],
            ///         "parameters": [
            ///           {
            ///             "name": "id",
            ///             "in": "query",
            ///             "description": "ID of the user",
            ///             "required": true,
            ///             "schema": {
            ///               "type": "integer",
            ///               "format": "int32"
            ///             }
            ///           }
            ///         ],
            ///         "responses": {
            ///           "200": {
            ///             "description": "Details about a user by ID",
            ///             "headers": {
            ///               "x-next": {
            ///                 "description": "A link to the next page of responses",
            ///                 "schema": {
            ///                   "type": "string"
            ///                 }
            ///               }
            ///             },
            ///             "content": {
            ///               "application/json": {
            ///                 "schema": {
            ///                   "$ref": "\\'#/components/schemas/User\\'"
            ///                 }
            ///               }
            ///             }
            ///           },
            ///           "default": {
            ///             "description": "Unexpected error",
            ///             "content": {
            ///               "application/json": {
            ///                 "schema": {
            ///                   "$ref": "\\'#/components/schemas/Error\\'"
            ///                 }
            ///               }
            ///             }
            ///           }
            ///         }
            ///       }
            ///     }
            ///   },
            ///   "components": {
            ///     "schemas": {
            ///       "User": {
            ///         "type": "object",
            ///         "required": [
            ///           "id",
            ///           "name"
            ///         ],
            ///         "properties": {
            ///           "id": {
            ///             "type": "integer",
            ///             "format": "int64"
            ///           },
            ///           "name": {
            ///             "type": "string"
            ///           },
            ///           "tag": {
            ///             "type": "string"
            ///           }
            ///         }
            ///       },
            ///       "Error": {
            ///         "type": "object",
            ///         "required": [
            ///           "code",
            ///           "message"
            ///         ],
            ///         "properties": {
            ///           "code": {
            ///             "type": "integer",
            ///             "format": "int32"
            ///           },
            ///           "message": {
            ///             "type": "string"
            ///           }
            ///         }
            ///       }
            ///     }
            ///   }
            /// }"
            public var schema: String?

            public init(apiVersion: String? = nil, createdAt: String? = nil, createdBy: String? = nil, id: String? = nil, language: String? = nil, type: String? = nil, updatedBy: String? = nil, updatedAt: String? = nil, schema: String? = nil) {
                self.apiVersion = apiVersion
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.id = id
                self.language = language
                self.type = type
                self.updatedBy = updatedBy
                self.updatedAt = updatedAt
                self.schema = schema
            }
        }

        public init(schema: Schema? = nil) {
            self.schema = schema
        }
    }
}

extension Paths {
    /// Update Schema
    ///
    /// This call updates an existing schema.
    /// 
    /// Request body should contain a `schema` object which should atleast have these properties with `string` values:
    /// 
    /// - **`type`**: Allowed types are `openapi3`, `openapi2`, `openapi1`, `raml` and `graphql`.
    /// - **`language`** : Allowed languages are `json` and `yaml` for OpenAPI and RAML schema types. GraphQL schema type accepts only `graphql` language.
    /// - **`schema`**: Optional. If passed, must be the content of the schema as a `string`.
    /// 
    /// Response contains a `schema` object with all the details related to the created schema, namely, `id`, `language`, `type` etc. 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func updateSchema(apiID: String, apiVersionID: String, schemaID: String, schema: UpdateSchemaRequest.Schema? = nil) -> Request<UpdateSchemaResponse> {
        .put("/apis/\(apiID)/versions/\(apiVersionID)/schemas/\(schemaID)", body: UpdateSchemaRequest(schema: schema))
    }

    public struct UpdateSchemaResponse: Decodable {
        public var schema: Schema?

        public struct Schema: Decodable {
            /// Example: "ad810c39-df60-434e-a76f-a2192cd8d81f"
            public var apiVersion: String?
            /// Example: "2021-05-22T13:17:07.000Z"
            public var createdAt: String?
            /// Example: "5665"
            public var createdBy: String?
            /// Example: "e3b3a0b7-34d5-4fc5-83e0-118bd9e8c822"
            public var id: String?
            /// Example: "yaml"
            public var language: String?
            /// Example: "openapi3"
            public var type: String?
            /// Example: "5665"
            public var updatedBy: String?
            /// Example: "2021-05-22T13:17:07.000Z"
            public var updatedAt: String?

            public init(apiVersion: String? = nil, createdAt: String? = nil, createdBy: String? = nil, id: String? = nil, language: String? = nil, type: String? = nil, updatedBy: String? = nil, updatedAt: String? = nil) {
                self.apiVersion = apiVersion
                self.createdAt = createdAt
                self.createdBy = createdBy
                self.id = id
                self.language = language
                self.type = type
                self.updatedBy = updatedBy
                self.updatedAt = updatedAt
            }
        }

        public init(schema: Schema? = nil) {
            self.schema = schema
        }
    }

    public struct UpdateSchemaRequest: Encodable {
        public var schema: Schema?

        public struct Schema: Encodable {
            /// Example: "json"
            public var language: String?
            /// Example:
            ///
            /// "{
            ///   "openapi": "3.0.0",
            ///   "info": null,
            ///   "version": "v1.0",
            ///   "title": "API",
            ///   "servers": [
            ///     {
            ///       "url": "http://localhost:3000"
            ///     }
            ///   ],
            ///   "paths": {
            ///     "/user": {
            ///       "get": {
            ///         "summary": "Returns details about a particular user",
            ///         "operationId": "listUser",
            ///         "tags": [
            ///           "user"
            ///         ],
            ///         "parameters": [
            ///           {
            ///             "name": "id",
            ///             "in": "query",
            ///             "description": "ID of the user",
            ///             "required": true,
            ///             "schema": {
            ///               "type": "integer",
            ///               "format": "int32"
            ///             }
            ///           }
            ///         ],
            ///         "responses": {
            ///           "200": {
            ///             "description": "Details about a user by ID",
            ///             "headers": {
            ///               "x-next": {
            ///                 "description": "A link to the next page of responses",
            ///                 "schema": {
            ///                   "type": "string"
            ///                 }
            ///               }
            ///             },
            ///             "content": {
            ///               "application/json": {
            ///                 "schema": {
            ///                   "$ref": "\\'#/components/schemas/User\\'"
            ///                 }
            ///               }
            ///             }
            ///           },
            ///           "default": {
            ///             "description": "Unexpected error",
            ///             "content": {
            ///               "application/json": {
            ///                 "schema": {
            ///                   "$ref": "\\'#/components/schemas/Error\\'"
            ///                 }
            ///               }
            ///             }
            ///           }
            ///         }
            ///       }
            ///     }
            ///   },
            ///   "components": {
            ///     "schemas": {
            ///       "User": {
            ///         "type": "object",
            ///         "required": [
            ///           "id",
            ///           "name"
            ///         ],
            ///         "properties": {
            ///           "id": {
            ///             "type": "integer",
            ///             "format": "int64"
            ///           },
            ///           "name": {
            ///             "type": "string"
            ///           },
            ///           "tag": {
            ///             "type": "string"
            ///           }
            ///         }
            ///       },
            ///       "Error": {
            ///         "type": "object",
            ///         "required": [
            ///           "code",
            ///           "message"
            ///         ],
            ///         "properties": {
            ///           "code": {
            ///             "type": "integer",
            ///             "format": "int32"
            ///           },
            ///           "message": {
            ///             "type": "string"
            ///           }
            ///         }
            ///       }
            ///     }
            ///   }
            /// }"
            public var schema: String?
            /// Example: "openapi3"
            public var type: String?

            public init(language: String? = nil, schema: String? = nil, type: String? = nil) {
                self.language = language
                self.schema = schema
                self.type = type
            }
        }

        public init(schema: Schema? = nil) {
            self.schema = schema
        }
    }
}

extension Paths {
    /// Create collection from schema
    ///
    /// This call creates a collection and links it to an API as one or multiple relations. 
    /// 
    /// Request body requires two keys:
    /// - `name` - Name of the collection to be created.
    /// - `relations` - A list of relation(s) to be created.
    /// 
    /// The allowed relation types are `contracttest`, `integrationtest`, `testsuite`, and `documentation`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createCollectionFromSchema(apiID: String, apiVersionID: String, schemaID: String, workspace: String? = nil, _ body: CreateCollectionFromSchemaRequest? = nil) -> Request<CreateCollectionFromSchemaResponse> {
        .post("/apis/\(apiID)/versions/\(apiVersionID)/schemas/\(schemaID)/collections", query: makeCreateCollectionFromSchemaQuery(workspace), body: body)
    }

    public struct CreateCollectionFromSchemaResponse: Decodable {
        public var collection: Collection?
        public var relations: [Relation]?

        public struct Collection: Decodable {
            /// Example: "e6b0d46a-8722-4f42-ab86-f5f473187ddf"
            public var id: String?
            /// Example: "112098-e6b0d46a-8722-4f42-ab86-f5f473187ddf"
            public var uid: String?

            public init(id: String? = nil, uid: String? = nil) {
                self.id = id
                self.uid = uid
            }
        }

        public struct Relation: Decodable {
            /// Example: "4b40f06a-5a6a-448f-bfcd-a6dbcb68da22"
            public var id: String?
            /// Example: "contracttest"
            public var type: String?

            public init(id: String? = nil, type: String? = nil) {
                self.id = id
                self.type = type
            }
        }

        public init(collection: Collection? = nil, relations: [Relation]? = nil) {
            self.collection = collection
            self.relations = relations
        }
    }

    private static func makeCreateCollectionFromSchemaQuery(_ workspace: String?) -> [(String, String?)] {
        var query: [(String, String?)] = []
        query.addQueryItem("workspace", workspace?.asQueryValue)
        return query
    }

    public struct CreateCollectionFromSchemaRequest: Encodable {
        /// Example: "My generated collection"
        public var name: String?
        public var relations: [Relation]?

        public struct Relation: Encodable {
            /// Example: "contracttest"
            public var type: String?

            public init(type: String? = nil) {
                self.type = type
            }
        }

        public init(name: String? = nil, relations: [Relation]? = nil) {
            self.name = name
            self.relations = relations
        }
    }
}

extension Paths {
    /// Get test suite relations
    ///
    /// This call fetches all the relations by type which are linked to the specified API version along with their details.
    /// 
    /// The response will contain an array with key `{{relationType}}`. Each of the item will consist of all the details related each of the relation.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func getTestSuiteRelations(apiID: String, apiVersionID: String) -> Request<GetTestSuiteRelationsResponse> {
        .get("/apis/\(apiID)/versions/\(apiVersionID)/testsuite")
    }

    public struct GetTestSuiteRelationsResponse: Decodable {
        public var testsuite: [TestsuiteItem]?

        public struct TestsuiteItem: Decodable {
            /// Example: "7732157-a8bcd149-2b01-4b4c-8c14-c7d05be77745"
            public var collectionID: String?
            /// Example: "2a9b8fa8-88b7-4b86-8372-8e3f6f6e07f2"
            public var id: String?
            /// Example: "C test"
            public var name: String?
            /// Example: "2019-08-29T10:18:11.000Z"
            public var updatedAt: String?

            public init(collectionID: String? = nil, id: String? = nil, name: String? = nil, updatedAt: String? = nil) {
                self.collectionID = collectionID
                self.id = id
                self.name = name
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case collectionID = "collectionId"
                case id
                case name
                case updatedAt
            }
        }

        public init(testsuite: [TestsuiteItem]? = nil) {
            self.testsuite = testsuite
        }
    }
}

extension Paths {
    /// Sync relations with schema
    ///
    /// This call allows you to keep the relation in sync with the API schema.
    /// 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func syncRelationsWithSchema(apiID: String, apiVersionID: String, entityType: String, entityID: String) -> Request<SyncRelationsWithSchemaResponse> {
        .put("/apis/\(apiID)/versions/\(apiVersionID)/\(entityType)/\(entityID)/syncWithSchema")
    }

    public struct SyncRelationsWithSchemaResponse: Decodable {
        /// Example: true
        public var isSuccess: Bool?

        public init(isSuccess: Bool? = nil) {
            self.isSuccess = isSuccess
        }

        private enum CodingKeys: String, CodingKey {
            case isSuccess = "success"
        }
    }
}

extension Paths {
    /// All Collections
    ///
    /// The `/collections` endpoint returns a list of all [collections](https://www.getpostman.com/docs/collections) that are accessible by you. The list includes your own collections and the collections that you have subscribed to.
    /// 
    /// The response contains an array of collection information containing the `name`, `id`, `owner` and `uid` of each collection.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public var allCollections: Request<AllCollectionsResponse> {
        .get("/collections")
    }

    public struct AllCollectionsResponse: Decodable {
        public var collections: [Collection]?

        public struct Collection: Decodable {
            /// Example: "dac5eac9-148d-a32e-b76b-3edee9da28f7"
            public var id: String?
            /// Example: "Cloud API"
            public var name: String?
            /// Example: "631643"
            public var owner: String?
            /// Example: "631643-dac5eac9-148d-a32e-b76b-3edee9da28f7"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, owner: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.owner = owner
                self.uid = uid
            }
        }

        public init(collections: [Collection]? = nil) {
            self.collections = collections
        }
    }
}

extension Paths {
    /// Create Collection
    ///
    /// This endpoint allows you to create collections using the Postman Collection v2 format. For more information about the v2 schema, check the format [here](https://schema.getpostman.com/json/collection/v2.0.0/docs/index.html).
    /// 
    /// On successful creation of the collection, the response returns the collection `name`, `id` and the `uid`.
    /// 
    /// You can also specify the context of a workspace to create a collection in directly by passing the `workspace` as a query param.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createCollection(collection: CreateCollectionRequest.Collection? = nil) -> Request<CreateCollectionResponse> {
        .post("/collections", body: CreateCollectionRequest(collection: collection))
    }

    public struct CreateCollectionResponse: Decodable {
        public var collection: Collection?

        public struct Collection: Decodable {
            /// Example: "2412a72c-1d8e-491b-aced-93809c0e94e9"
            public var id: String?
            /// Example: "Sample Collection"
            public var name: String?
            /// Example: "5852-2412a72c-1d8e-491b-aced-93809c0e94e9"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(collection: Collection? = nil) {
            self.collection = collection
        }
    }

    public struct CreateCollectionRequest: Encodable {
        public var collection: Collection?

        public struct Collection: Encodable {
            public var info: Info?
            public var item: [ItemItem]?

            public struct Info: Encodable {
                /// Example: "This is just a sample collection."
                public var description: String?
                /// Example: "Sample Collection 909"
                public var name: String?
                /// Example: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
                public var schema: String?

                public init(description: String? = nil, name: String? = nil, schema: String? = nil) {
                    self.description = description
                    self.name = name
                    self.schema = schema
                }
            }

            public struct ItemItem: Encodable {
                public var item: [ItemItem]?
                /// Example: "This is a folder"
                public var name: String?

                public struct ItemItem: Encodable {
                    /// Example: "Sample POST Request"
                    public var name: String?
                    public var request: Request?

                    public struct Request: Encodable {
                        public var body: Body?
                        /// Example: "This is a sample POST Request"
                        public var description: String?
                        public var header: [HeaderItem]?
                        /// Example: "POST"
                        public var method: String?
                        /// Example: "https://postman-echo.com/post"
                        public var url: String?

                        public struct Body: Encodable {
                            /// Example: "raw"
                            public var mode: String?
                            /// Example: "{"data": "123"}"
                            public var raw: String?

                            public init(mode: String? = nil, raw: String? = nil) {
                                self.mode = mode
                                self.raw = raw
                            }
                        }

                        public struct HeaderItem: Encodable {
                            /// Example: "Content-Type"
                            public var key: String?
                            /// Example: "application/json"
                            public var value: String?

                            public init(key: String? = nil, value: String? = nil) {
                                self.key = key
                                self.value = value
                            }
                        }

                        public init(body: Body? = nil, description: String? = nil, header: [HeaderItem]? = nil, method: String? = nil, url: String? = nil) {
                            self.body = body
                            self.description = description
                            self.header = header
                            self.method = method
                            self.url = url
                        }
                    }

                    public init(name: String? = nil, request: Request? = nil) {
                        self.name = name
                        self.request = request
                    }
                }

                public init(item: [ItemItem]? = nil, name: String? = nil) {
                    self.item = item
                    self.name = name
                }
            }

            public init(info: Info? = nil, item: [ItemItem]? = nil) {
                self.info = info
                self.item = item
            }
        }

        public init(collection: Collection? = nil) {
            self.collection = collection
        }
    }
}

extension Paths {
    /// Create a Fork
    ///
    /// This endpoint allows you to create a fork from an existing collection.
    /// 
    /// On successful creation of the collection, the response returns the collection `name`, `id`, `uid` along with `fork` information.
    /// 
    /// You can also specify the context of a workspace to fork a collection in by passing the `workspace` as a query param.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createAFork(collectionUid: String, workspace: String? = nil, label: String? = nil) -> Request<Void> {
        .post("/collections/fork/\(collectionUid)", query: makeCreateAForkQuery(workspace), body: ["label": label])
    }

    private static func makeCreateAForkQuery(_ workspace: String?) -> [(String, String?)] {
        var query: [(String, String?)] = []
        query.addQueryItem("workspace", workspace?.asQueryValue)
        return query
    }
}

extension Paths {
    /// Merge a Fork
    ///
    /// This endpoint allows you to merge a forked collection back to its destination collection.
    /// 
    /// On successful creation of the collection, the response returns the collection `name`, `id` and `uid`.
    /// 
    /// You need to specify the fork UID (as `source`) and destination collection UID (as `destination`) in the request body.
    /// 
    /// Optionally, you can also specify the merge strategy as either `deleteSource` or `updateSourceWithDestination`. Following is an explanation of the merge strategies
    /// 
    /// | Merge Strategy | Behaviour |
    /// | --- | --- |
    /// | deleteSource | Forked collection is deleted after merging |
    /// | updateSourceWithDestination | Forked collection is up to date with changes in destination collection |
    /// 
    /// If the collections cannot be merged (due to conflicts), appropriate error messages will be returned.
    /// 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func mergeAFork(_ body: MergeAForkRequest? = nil) -> Request<Void> {
        .post("/collections/merge", body: body)
    }

    public struct MergeAForkRequest: Encodable {
        /// Example: "{{destination_collection_uid}}"
        public var destination: String?
        /// Example: "{{source_collection_uid}}"
        public var source: String?
        /// Example: "deleteSource"
        public var strategy: String?

        public init(destination: String? = nil, source: String? = nil, strategy: String? = nil) {
            self.destination = destination
            self.source = source
            self.strategy = strategy
        }
    }
}

extension Paths {
    /// Single Collection 
    ///
    /// Access the contents of a collection that is accessible to you using its unique id (`uid`).
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func singleCollection(collectionUid: String) -> Request<SingleCollectionResponse> {
        .get("/collections/\(collectionUid)")
    }

    public struct SingleCollectionResponse: Decodable {
        public var collection: Collection?

        public struct Collection: Decodable {
            public var info: Info?
            public var item: [ItemItem]?
            public var variables: [AnyJSON]?

            public struct Info: Decodable {
                /// Example: "f2e66c2e-5297-e4a5-739e-20cbb90900e3"
                public var postmanID: String?
                /// Example: "This is a sample collection that makes a tiny request to Postman Echo service to get the list of request headers sent by a HTTP client."
                public var description: String?
                /// Example: "Sample Collection"
                public var name: String?
                /// Example: "https://schema.getpostman.com/json/collection/v2.0.0/collection.json"
                public var schema: String?

                public init(postmanID: String? = nil, description: String? = nil, name: String? = nil, schema: String? = nil) {
                    self.postmanID = postmanID
                    self.description = description
                    self.name = name
                    self.schema = schema
                }

                private enum CodingKeys: String, CodingKey {
                    case postmanID = "_postman_id"
                    case description
                    case name
                    case schema
                }
            }

            public struct ItemItem: Decodable {
                public var event: [EventItem]?
                /// Example: "82ee981b-e19f-962a-401e-ea34ebfb4848"
                public var id: String?
                /// Example: "Request Headers"
                public var name: String?
                public var request: Request?
                public var response: [AnyJSON]?

                public struct EventItem: Decodable {
                    /// Example: "test"
                    public var listen: String?
                    public var script: Script?

                    public struct Script: Decodable {
                        /// Example:
                        ///
                        /// "var responseJSON;
                        /// try {
                        ///     tests["Body contains headers"] = responseBody.has("headers");
                        ///     responseJSON = JSON.parse(responseBody);
                        ///     tests["Header contains host"] = "host" in responseJSON.headers;
                        ///     tests["Header contains test parameter sent as part of request header"] = "my-sample-header" in responseJSON.headers;
                        /// }
                        /// catch (e) { }
                        /// 
                        /// 
                        /// 
                        /// "
                        public var exec: String?
                        /// Example: "text/javascript"
                        public var type: String?

                        public init(exec: String? = nil, type: String? = nil) {
                            self.exec = exec
                            self.type = type
                        }
                    }

                    public init(listen: String? = nil, script: Script? = nil) {
                        self.listen = listen
                        self.script = script
                    }
                }

                public struct Request: Decodable {
                    public var body: Body?
                    public var description: String?
                    public var header: [HeaderItem]?
                    /// Example: "GET"
                    public var method: String?
                    /// Example: "https://echo.getpostman.com/headers"
                    public var url: String?

                    public struct Body: Decodable {
                        public var formdata: [AnyJSON]?
                        /// Example: "formdata"
                        public var mode: String?

                        public init(formdata: [AnyJSON]? = nil, mode: String? = nil) {
                            self.formdata = formdata
                            self.mode = mode
                        }
                    }

                    public struct HeaderItem: Decodable {
                        public var description: String?
                        /// Example: "my-sample-header"
                        public var key: String?
                        /// Example: "Lorem ipsum dolor sit amet"
                        public var value: String?

                        public init(description: String? = nil, key: String? = nil, value: String? = nil) {
                            self.description = description
                            self.key = key
                            self.value = value
                        }
                    }

                    public init(body: Body? = nil, description: String? = nil, header: [HeaderItem]? = nil, method: String? = nil, url: String? = nil) {
                        self.body = body
                        self.description = description
                        self.header = header
                        self.method = method
                        self.url = url
                    }
                }

                public init(event: [EventItem]? = nil, id: String? = nil, name: String? = nil, request: Request? = nil, response: [AnyJSON]? = nil) {
                    self.event = event
                    self.id = id
                    self.name = name
                    self.request = request
                    self.response = response
                }
            }

            public init(info: Info? = nil, item: [ItemItem]? = nil, variables: [AnyJSON]? = nil) {
                self.info = info
                self.item = item
                self.variables = variables
            }
        }

        public init(collection: Collection? = nil) {
            self.collection = collection
        }
    }
}

extension Paths {
    /// Update Collection
    ///
    /// This endpoint allows you to update an existing collection using the Postman Collection v2 format. For more information about the v2 schema, check the format [here](https://schema.getpostman.com/json/collection/v2.0.0/docs/index.html).
    /// 
    /// On successful updation of the collection, the response returns the collection `name`, `id` and `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    /// 
    /// Note: Please be careful when trying to update the collection, as the existing collection will be replaced by the request body.
    static public func updateCollection(collectionUid: String, collection: UpdateCollectionRequest.Collection? = nil) -> Request<UpdateCollectionResponse> {
        .put("/collections/\(collectionUid)", body: UpdateCollectionRequest(collection: collection))
    }

    public struct UpdateCollectionResponse: Decodable {
        public var collection: Collection?

        public struct Collection: Decodable {
            /// Example: "1d3daef4-2037-4584-ab86-bafd8c8f8a55"
            public var id: String?
            /// Example: "Sample Collection"
            public var name: String?
            /// Example: "5852-1d3daef4-2037-4584-ab86-bafd8c8f8a55"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(collection: Collection? = nil) {
            self.collection = collection
        }
    }

    public struct UpdateCollectionRequest: Encodable {
        public var collection: Collection?

        public struct Collection: Encodable {
            public var info: Info?
            public var item: [ItemItem]?

            public struct Info: Encodable {
                /// Example: "174bad7c-07e3-45f3-914f-36cf84e5586f"
                public var postmanID: String?
                /// Example: "This is just a sample collection."
                public var description: String?
                /// Example: "Sample Collection 530"
                public var name: String?
                /// Example: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
                public var schema: String?

                public init(postmanID: String? = nil, description: String? = nil, name: String? = nil, schema: String? = nil) {
                    self.postmanID = postmanID
                    self.description = description
                    self.name = name
                    self.schema = schema
                }

                private enum CodingKeys: String, CodingKey {
                    case postmanID = "_postman_id"
                    case description
                    case name
                    case schema
                }
            }

            public struct ItemItem: Encodable {
                public var item: [ItemItem]?
                /// Example: "This is a folder"
                public var name: String?

                public struct ItemItem: Encodable {
                    /// Example: "Sample POST Request"
                    public var name: String?
                    public var request: Request?

                    public struct Request: Encodable {
                        public var body: Body?
                        /// Example: "This is a sample POST Request"
                        public var description: String?
                        public var header: [HeaderItem]?
                        /// Example: "POST"
                        public var method: String?
                        /// Example: "https://postman-echo.com/post"
                        public var url: String?

                        public struct Body: Encodable {
                            /// Example: "raw"
                            public var mode: String?
                            /// Example: "{"data": "123"}"
                            public var raw: String?

                            public init(mode: String? = nil, raw: String? = nil) {
                                self.mode = mode
                                self.raw = raw
                            }
                        }

                        public struct HeaderItem: Encodable {
                            /// Example: "Content-Type"
                            public var key: String?
                            /// Example: "application/json"
                            public var value: String?

                            public init(key: String? = nil, value: String? = nil) {
                                self.key = key
                                self.value = value
                            }
                        }

                        public init(body: Body? = nil, description: String? = nil, header: [HeaderItem]? = nil, method: String? = nil, url: String? = nil) {
                            self.body = body
                            self.description = description
                            self.header = header
                            self.method = method
                            self.url = url
                        }
                    }

                    public init(name: String? = nil, request: Request? = nil) {
                        self.name = name
                        self.request = request
                    }
                }

                public init(item: [ItemItem]? = nil, name: String? = nil) {
                    self.item = item
                    self.name = name
                }
            }

            public init(info: Info? = nil, item: [ItemItem]? = nil) {
                self.info = info
                self.item = item
            }
        }

        public init(collection: Collection? = nil) {
            self.collection = collection
        }
    }
}

extension Paths {
    /// Delete Collection
    ///
    /// This endpoint allows you to delete an existing collection.
    /// 
    /// On successful deletion of the collection, the response returns the `id` and `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteCollection(collectionUid: String) -> Request<DeleteCollectionResponse> {
        .delete("/collections/\(collectionUid)")
    }

    public struct DeleteCollectionResponse: Decodable {
        public var collection: Collection?

        public struct Collection: Decodable {
            /// Example: "a14c6da7-afba-4a84-bf22-4febbaaced6c"
            public var id: String?
            /// Example: "5852-a14c6da7-afba-4a84-bf22-4febbaaced6c"
            public var uid: String?

            public init(id: String? = nil, uid: String? = nil) {
                self.id = id
                self.uid = uid
            }
        }

        public init(collection: Collection? = nil) {
            self.collection = collection
        }
    }
}

extension Paths {
    /// All Environments
    ///
    /// The `/environments` endpoint returns a list of all [environments](https://www.getpostman.com/docs/environments) that belong to you..
    /// 
    /// The response contains an array of environments' information containing the `name`, `id`, `owner` and `uid` of each environment.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public var allEnvironments: Request<AllEnvironmentsResponse> {
        .get("/environments")
    }

    public struct AllEnvironmentsResponse: Decodable {
        public var environments: [Environment]?

        public struct Environment: Decodable {
            /// Example: "2020-09-23T14:31:18.000Z"
            public var createdAt: String?
            /// Example: "5daabc50-8451-43f6-922d-96b403b4f28e"
            public var id: String?
            /// Example: false
            public var isPublic: Bool?
            /// Example: "Users API (prod)"
            public var name: String?
            /// Example: "10016724"
            public var owner: String?
            /// Example: "10016724-5daabc50-8451-43f6-922d-96b403b4f28e"
            public var uid: String?
            /// Example: "2020-12-04T14:13:40.000Z"
            public var updatedAt: String?

            public init(createdAt: String? = nil, id: String? = nil, isPublic: Bool? = nil, name: String? = nil, owner: String? = nil, uid: String? = nil, updatedAt: String? = nil) {
                self.createdAt = createdAt
                self.id = id
                self.isPublic = isPublic
                self.name = name
                self.owner = owner
                self.uid = uid
                self.updatedAt = updatedAt
            }
        }

        public init(environments: [Environment]? = nil) {
            self.environments = environments
        }
    }
}

extension Paths {
    /// Create Environment
    ///
    /// A sample body is added to the request that conforms to the following JSON schema:
    /// 
    /// ```json
    /// {
    ///   "type": "object",
    ///   "properties": {
    ///     "environment": {
    ///       "type": "object",
    ///       "properties": {
    ///         "name": {
    ///               "type": "string",
    ///               "maxLength": 254,
    ///               "minLength": 1
    ///             },
    ///         "values": {
    ///           "type": "array",
    ///           "maxItems": 100,
    ///           "additionalItems": false,
    ///           "items": {
    ///               "type": "object",
    ///               "properties": {
    ///                 "key": {
    ///                   "type": "string",
    ///                   "maxLength": 254
    ///                   "minLength": 1
    ///                 },
    ///                 "value": { "type": "string" },
    ///                 "enabled": { "type": "boolean" }
    ///               },
    ///               "required": ["key", "value"]
    ///             }
    ///         }
    ///       },
    ///       "required": ["name"]
    ///     }
    ///   },
    ///   "required": ["environment"]
    /// }
    /// ```
    /// 
    /// On successful creation of the environment, the API returns the environment name and `id`.
    /// 
    /// You can also specify the context of a workspace to create an environment in directly by passing the `workspace` as a query param.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createEnvironment(environment: CreateEnvironmentRequest.Environment? = nil) -> Request<CreateEnvironmentResponse> {
        .post("/environments", body: CreateEnvironmentRequest(environment: environment))
    }

    public struct CreateEnvironmentResponse: Decodable {
        public var environment: Environment?

        public struct Environment: Decodable {
            /// Example: "f158266e-306b-4702-a2b9-e4ede7878b7a"
            public var id: String?
            /// Example: "Sample Environment Name (required)"
            public var name: String?
            /// Example: "5665-f158266e-306b-4702-a2b9-e4ede7878b7a"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(environment: Environment? = nil) {
            self.environment = environment
        }
    }

    public struct CreateEnvironmentRequest: Encodable {
        public var environment: Environment?

        public struct Environment: Encodable {
            /// Example: "Sample Environment Name (required)"
            public var name: String?
            public var values: [Value]?

            public struct Value: Encodable {
                /// Example: "variable_name_1"
                public var key: String?
                /// Example: "The value of the variable"
                public var value: String?

                public init(key: String? = nil, value: String? = nil) {
                    self.key = key
                    self.value = value
                }
            }

            public init(name: String? = nil, values: [Value]? = nil) {
                self.name = name
                self.values = values
            }
        }

        public init(environment: Environment? = nil) {
            self.environment = environment
        }
    }
}

extension Paths {
    /// Single Environment
    ///
    /// Access the contents of an environment that is accessible to you using its unique id (`uid`).
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func singleEnvironment(environmentUid: String) -> Request<SingleEnvironmentResponse> {
        .get("/environments/\(environmentUid)")
    }

    public struct SingleEnvironmentResponse: Decodable {
        public var environment: Environment?

        public struct Environment: Decodable {
            /// Example: "2020-11-05T13:59:22.000Z"
            public var createdAt: String?
            /// Example: "1b163ddc-62ff-41d9-b74b-71424b9aa69d"
            public var id: String?
            /// Example: false
            public var isPublic: Bool?
            /// Example: "Contract Test Environment"
            public var name: String?
            /// Example: "10016724"
            public var owner: String?
            /// Example: "2020-11-05T13:59:23.000Z"
            public var updatedAt: String?
            public var values: [Value]?

            public struct Value: Decodable {
                /// Example: true
                public var isEnabled: Bool?
                /// Example: "env-apiKey"
                public var key: String?
                public var value: String?

                public init(isEnabled: Bool? = nil, key: String? = nil, value: String? = nil) {
                    self.isEnabled = isEnabled
                    self.key = key
                    self.value = value
                }

                private enum CodingKeys: String, CodingKey {
                    case isEnabled = "enabled"
                    case key
                    case value
                }
            }

            public init(createdAt: String? = nil, id: String? = nil, isPublic: Bool? = nil, name: String? = nil, owner: String? = nil, updatedAt: String? = nil, values: [Value]? = nil) {
                self.createdAt = createdAt
                self.id = id
                self.isPublic = isPublic
                self.name = name
                self.owner = owner
                self.updatedAt = updatedAt
                self.values = values
            }
        }

        public init(environment: Environment? = nil) {
            self.environment = environment
        }
    }
}

extension Paths {
    /// Update Environment
    ///
    /// This endpoint replaces an existing environment.
    /// 
    /// A sample body is added to the request that conforms to the following JSON schema:
    /// 
    /// ```json
    /// {
    /// 	"type": "object",
    /// 	"properties": {
    /// 		"environment": {
    /// 			"type": "object",
    /// 			"properties": {
    /// 				"name": {
    /// 					"type": "string",
    /// 					"maxLength": 254,
    /// 					"minLength": 1
    /// 				},
    /// 				"values": {
    /// 					"type": "array",
    /// 					"maxItems": 100,
    /// 					"additionalItems": false,
    /// 					"items": {
    /// 						"type": "object",
    /// 						"properties": {
    /// 							"key": {
    /// 								"type": "string",
    /// 								"maxLength": 254,
    /// 								"minLength": 1
    /// 							},
    /// 							"value": {
    /// 								"type": "string",
    /// 								"maxLength": 254,
    /// 								"minLength": 1
    /// 							},
    /// 							"type": {
    /// 								"type": "string"
    /// 							},
    /// 							"enabled": {
    /// 								"type": "boolean"
    /// 							}
    /// 						},
    /// 						"required": [
    /// 							"key",
    /// 							"value"
    /// 						]
    /// 					}
    /// 				}
    /// 			}
    /// 		}
    /// 	},
    /// 	"required": [
    /// 		"environment"
    /// 	]
    /// }
    /// ```
    /// 
    /// On successful updation of the environment, the API returns the environment name and `id`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func updateEnvironment(environmentUid: String, environment: UpdateEnvironmentRequest.Environment? = nil) -> Request<UpdateEnvironmentResponse> {
        .put("/environments/\(environmentUid)", body: UpdateEnvironmentRequest(environment: environment))
    }

    public struct UpdateEnvironmentResponse: Decodable {
        public var environment: Environment?

        public struct Environment: Decodable {
            /// Example: "357668d2-84f1-2264-438b-113095359f80"
            public var id: String?
            /// Example: "New Name"
            public var name: String?
            /// Example: "631643-357668d2-84f1-2264-438b-113095359f80"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(environment: Environment? = nil) {
            self.environment = environment
        }
    }

    public struct UpdateEnvironmentRequest: Encodable {
        public var environment: Environment?

        public struct Environment: Encodable {
            /// Example: "New Name"
            public var name: String?
            public var values: [Value]?

            public struct Value: Encodable {
                /// Example: "name"
                public var key: String?
                /// Example: "Bruce Wayne"
                public var value: String?

                public init(key: String? = nil, value: String? = nil) {
                    self.key = key
                    self.value = value
                }
            }

            public init(name: String? = nil, values: [Value]? = nil) {
                self.name = name
                self.values = values
            }
        }

        public init(environment: Environment? = nil) {
            self.environment = environment
        }
    }
}

extension Paths {
    /// Delete Environment
    ///
    /// This endpoint allows you to delete a single environment based on an environment's unique `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteEnvironment(environmentUid: String) -> Request<DeleteEnvironmentResponse> {
        .delete("/environments/\(environmentUid)")
    }

    public struct DeleteEnvironmentResponse: Decodable {
        public var environment: Environment?

        public struct Environment: Decodable {
            /// Example: "4dfb28a4-9a6c-4ce4-b31a-17c26a8b2cce"
            public var id: String?
            /// Example: "5852-4dfb28a4-9a6c-4ce4-b31a-17c26a8b2cce"
            public var uid: String?

            public init(id: String? = nil, uid: String? = nil) {
                self.id = id
                self.uid = uid
            }
        }

        public init(environment: Environment? = nil) {
            self.environment = environment
        }
    }
}

extension Paths {
    /// Import exported data
    ///
    /// This endpoint allows you to import your exported Postman data.
    /// For more information about how you can export your data, refer <a href="https://go.postman.co/me/export">Export your Postman data.</a>
    /// 
    /// On successful imports, the response will be an array with Each element contaning `id`, `name` and `uid` of entities created.
    /// 
    /// **Note**: Refer to examples for different scenarios.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header.
    static public func importExportedData(_ body: Data? = nil) -> Request<ImportExportedDataResponse> {
        .post("/import/exported", body: body)
    }

    public struct ImportExportedDataResponse: Decodable {
        public var collections: [Collection]?

        public struct Collection: Decodable {
            /// Example: "b31be584-1b1e-4444-b581-761edf88fe77"
            public var id: String?
            /// Example: "Swagger Petstore"
            public var name: String?
            /// Example: "2282-b31be584-1b1e-4444-b581-761edf88fe77"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(collections: [Collection]? = nil) {
            self.collections = collections
        }
    }
}

extension Paths {
    /// Import external API specification
    ///
    /// This endpoint allows you to import external API specifications into Postman.
    /// 
    /// Currently, this endpoint only supports the <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md">OpenAPI</a> specification, for which the `importType` will be `openapi`.
    /// 
    /// On a successful import, the response will be an array with each element contaning `id`, `name` and `uid` of entities created.
    /// 
    /// Supported `type`s:
    /// 
    /// - string
    /// - json
    /// - file
    /// 
    /// The `input` parameter should be defined based on the `type`.
    /// 
    /// > To import a file, request body must be form-data with `type` param set to `file`.
    /// 
    /// **Note**: Refer to examples for different scenarios.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header.
    static public func importExternalAPISpecification(_ body: ImportExternalAPISpecificationRequest? = nil) -> Request<ImportExternalAPISpecificationResponse> {
        .post("/import/openapi", body: body)
    }

    public struct ImportExternalAPISpecificationResponse: Decodable {
        public var collections: [Collection]?

        public struct Collection: Decodable {
            /// Example: "b31be584-1b1e-4444-b581-761edf88fe77"
            public var id: String?
            /// Example: "Swagger Petstore"
            public var name: String?
            /// Example: "2282-b31be584-1b1e-4444-b581-761edf88fe77"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(collections: [Collection]? = nil) {
            self.collections = collections
        }
    }

    public struct ImportExternalAPISpecificationRequest: Encodable {
        public var input: Input?
        /// Example: "json"
        public var type: String?

        public struct Input: Encodable {
            public var info: Info?
            /// Example: "3.0.0"
            public var openapi: String?
            public var paths: Paths?
            public var servers: [Server]?

            public struct Info: Encodable {
                public var license: License?
                /// Example: "Swagger Petstore"
                public var title: String?
                /// Example: "1.0.0"
                public var version: String?

                public struct License: Encodable {
                    /// Example: "MIT"
                    public var name: String?

                    public init(name: String? = nil) {
                        self.name = name
                    }
                }

                public init(license: License? = nil, title: String? = nil, version: String? = nil) {
                    self.license = license
                    self.title = title
                    self.version = version
                }
            }

            public struct Paths: Encodable {
                public var pets: Pets?

                public struct Pets: Encodable {
                    public var get: Get?

                    public struct Get: Encodable {
                        /// Example: "listPets"
                        public var operationID: String?
                        public var parameters: [Parameter]?
                        public var responses: Responses?
                        /// Example: "List all pets"
                        public var summary: String?

                        public struct Parameter: Encodable {
                            /// Example: "limit"
                            public var description: String?
                            /// Example: "query"
                            public var `in`: String?
                            /// Example: "limit"
                            public var name: String?
                            /// Example: false
                            public var isRequired: Bool?
                            public var schema: Schema?

                            public struct Schema: Encodable {
                                /// Example: "int32"
                                public var format: String?
                                /// Example: "integer"
                                public var type: String?

                                public init(format: String? = nil, type: String? = nil) {
                                    self.format = format
                                    self.type = type
                                }
                            }

                            public init(description: String? = nil, `in`: String? = nil, name: String? = nil, isRequired: Bool? = nil, schema: Schema? = nil) {
                                self.description = description
                                self.in = `in`
                                self.name = name
                                self.isRequired = isRequired
                                self.schema = schema
                            }

                            private enum CodingKeys: String, CodingKey {
                                case description
                                case `in` = "in"
                                case name
                                case isRequired = "required"
                                case schema
                            }
                        }

                        public struct Responses: Encodable {
                            public var `default`: Default?

                            public struct Default: Encodable {
                                public var content: Content?
                                /// Example: "unexpected error"
                                public var description: String?

                                public struct Content: Encodable {
                                    public var applicationJson: ApplicationJson?

                                    public struct ApplicationJson: Encodable {
                                        public var schema: Schema?

                                        public struct Schema: Encodable {
                                            public var properties: Properties?
                                            public var required: [String]?

                                            public struct Properties: Encodable {
                                                public var code: Code?
                                                public var message: Message?

                                                public struct Code: Encodable {
                                                    /// Example: "int32"
                                                    public var format: String?
                                                    /// Example: "integer"
                                                    public var type: String?

                                                    public init(format: String? = nil, type: String? = nil) {
                                                        self.format = format
                                                        self.type = type
                                                    }
                                                }

                                                public struct Message: Encodable {
                                                    /// Example: "string"
                                                    public var type: String?

                                                    public init(type: String? = nil) {
                                                        self.type = type
                                                    }
                                                }

                                                public init(code: Code? = nil, message: Message? = nil) {
                                                    self.code = code
                                                    self.message = message
                                                }
                                            }

                                            public init(properties: Properties? = nil, required: [String]? = nil) {
                                                self.properties = properties
                                                self.required = required
                                            }
                                        }

                                        public init(schema: Schema? = nil) {
                                            self.schema = schema
                                        }
                                    }

                                    public init(applicationJson: ApplicationJson? = nil) {
                                        self.applicationJson = applicationJson
                                    }

                                    private enum CodingKeys: String, CodingKey {
                                        case applicationJson = "application/json"
                                    }
                                }

                                public init(content: Content? = nil, description: String? = nil) {
                                    self.content = content
                                    self.description = description
                                }
                            }

                            public init(`default`: Default? = nil) {
                                self.default = `default`
                            }

                            private enum CodingKeys: String, CodingKey {
                                case `default` = "default"
                            }
                        }

                        public init(operationID: String? = nil, parameters: [Parameter]? = nil, responses: Responses? = nil, summary: String? = nil) {
                            self.operationID = operationID
                            self.parameters = parameters
                            self.responses = responses
                            self.summary = summary
                        }

                        private enum CodingKeys: String, CodingKey {
                            case operationID = "operationId"
                            case parameters
                            case responses
                            case summary
                        }
                    }

                    public init(get: Get? = nil) {
                        self.get = get
                    }
                }

                public init(pets: Pets? = nil) {
                    self.pets = pets
                }

                private enum CodingKeys: String, CodingKey {
                    case pets = "/pets"
                }
            }

            public struct Server: Encodable {
                /// Example: "http://petstore.swagger.io/v1"
                public var url: String?

                public init(url: String? = nil) {
                    self.url = url
                }
            }

            public init(info: Info? = nil, openapi: String? = nil, paths: Paths? = nil, servers: [Server]? = nil) {
                self.info = info
                self.openapi = openapi
                self.paths = paths
                self.servers = servers
            }
        }

        public init(input: Input? = nil, type: String? = nil) {
            self.input = input
            self.type = type
        }
    }
}

extension Paths {
    /// API Key Owner
    ///
    /// The `/me` Postman API endpoint lets you access information about the authenticated user. You can retrieve the authenticated user's username, full name, e-mail address, and any other available information.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public var apiKeyOwner: Request<APIKeyOwnerResponse> {
        .get("/me")
    }

    public struct APIKeyOwnerResponse: Decodable {
        public var operations: [Operation]?
        public var user: User?

        public struct Operation: Decodable {
            /// Example: 1000000
            public var limit: Double?
            /// Example: "mock_usage"
            public var name: String?
            public var overage: Double?
            /// Example: 2382
            public var usage: Double?

            public init(limit: Double? = nil, name: String? = nil, overage: Double? = nil, usage: Double? = nil) {
                self.limit = limit
                self.name = name
                self.overage = overage
                self.usage = usage
            }
        }

        public struct User: Decodable {
            /// Example: "https://www.gravatar.com/avatar/e1f3994f2632af3d1c8c2dcc168a10e6"
            public var avatar: String?
            /// Example: "janedoe@example.com"
            public var email: String?
            /// Example: "Jane Doe"
            public var fullName: String?
            /// Example: 631643
            public var id: Double?
            /// Example: false
            public var isPublic: Bool?
            /// Example: "janedoe"
            public var username: String?

            public init(avatar: String? = nil, email: String? = nil, fullName: String? = nil, id: Double? = nil, isPublic: Bool? = nil, username: String? = nil) {
                self.avatar = avatar
                self.email = email
                self.fullName = fullName
                self.id = id
                self.isPublic = isPublic
                self.username = username
            }
        }

        public init(operations: [Operation]? = nil, user: User? = nil) {
            self.operations = operations
            self.user = user
        }
    }
}

extension Paths {
    /// All Mocks
    ///
    /// This endpoint fetches all the mocks that you have created.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public var allMocks: Request<AllMocksResponse> {
        .get("/mocks")
    }

    public struct AllMocksResponse: Decodable {
        public var mocks: [Mock]?

        public struct Mock: Decodable {
            /// Example: "1686168-39fee52f-b806-3ffa-1173-00a6f5b183dc"
            public var collection: String?
            public var config: Config?
            /// Example: "2020-12-15T06:44:37.000Z"
            public var createdAt: String?
            /// Example: "1686168-2b90cdd8-e9ac-4086-91c2-bc4cad659511"
            public var environment: String?
            /// Example: "e782b64e-406b-4a6c-8fe9-9ebe84aeb706"
            public var id: String?
            /// Example: false
            public var isPublic: Bool?
            /// Example: "https://e782b64e-406b-4a6c-8fe9-9ebe84aeb706.mock.pstmn.io"
            public var mockURL: String?
            /// Example: "mock1"
            public var name: String?
            /// Example: "1686168"
            public var owner: String?
            /// Example: "1686168-e782b64e-406b-4a6c-8fe9-9ebe84aeb706"
            public var uid: String?
            /// Example: "2020-12-15T06:44:37.000Z"
            public var updatedAt: String?

            public struct Config: Decodable {
                public var delay: AnyJSON?
                public var headers: [AnyJSON]?
                /// Example: false
                public var isMatchBody: Bool?
                /// Example: true
                public var isMatchQueryParams: Bool?
                /// Example: true
                public var isMatchWildcards: Bool?

                public init(delay: AnyJSON? = nil, headers: [AnyJSON]? = nil, isMatchBody: Bool? = nil, isMatchQueryParams: Bool? = nil, isMatchWildcards: Bool? = nil) {
                    self.delay = delay
                    self.headers = headers
                    self.isMatchBody = isMatchBody
                    self.isMatchQueryParams = isMatchQueryParams
                    self.isMatchWildcards = isMatchWildcards
                }

                private enum CodingKeys: String, CodingKey {
                    case delay
                    case headers
                    case isMatchBody = "matchBody"
                    case isMatchQueryParams = "matchQueryParams"
                    case isMatchWildcards = "matchWildcards"
                }
            }

            public init(collection: String? = nil, config: Config? = nil, createdAt: String? = nil, environment: String? = nil, id: String? = nil, isPublic: Bool? = nil, mockURL: String? = nil, name: String? = nil, owner: String? = nil, uid: String? = nil, updatedAt: String? = nil) {
                self.collection = collection
                self.config = config
                self.createdAt = createdAt
                self.environment = environment
                self.id = id
                self.isPublic = isPublic
                self.mockURL = mockURL
                self.name = name
                self.owner = owner
                self.uid = uid
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case collection
                case config
                case createdAt
                case environment
                case id
                case isPublic
                case mockURL = "mockUrl"
                case name
                case owner
                case uid
                case updatedAt
            }
        }

        public init(mocks: [Mock]? = nil) {
            self.mocks = mocks
        }
    }
}

extension Paths {
    /// Create Mock
    ///
    /// This endpoint allows you to create a mock on a collection. You can also provide an environment UID to resolve any environment variables in the collection.
    /// 
    /// You can also specify the context of a workspace to create a mock in directly by passing the `workspace` as a query param.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createMock(mock: CreateMockRequest.Mock? = nil) -> Request<CreateMockResponse> {
        .post("/mocks", body: CreateMockRequest(mock: mock))
    }

    public struct CreateMockResponse: Decodable {
        public var mock: Mock?

        public struct Mock: Decodable {
            /// Example: "1679925-39fee52f-b806-3ffa-1173-00a6f5b183dc"
            public var collection: String?
            /// Example: "1679925-0b9e9f15-3208-a2b1-22e0-d58392f01524"
            public var environment: String?
            /// Example: "0fca2246-c108-41f5-8454-cc032def329f"
            public var id: String?
            /// Example: "https://0fca2246-c108-41f5-8454-cc032def329f.mock.pstmn.io"
            public var mockURL: String?
            /// Example: "1679925"
            public var owner: String?
            /// Example: "1679925-0fca2246-c108-41f5-8454-cc032def329f"
            public var uid: String?

            public init(collection: String? = nil, environment: String? = nil, id: String? = nil, mockURL: String? = nil, owner: String? = nil, uid: String? = nil) {
                self.collection = collection
                self.environment = environment
                self.id = id
                self.mockURL = mockURL
                self.owner = owner
                self.uid = uid
            }

            private enum CodingKeys: String, CodingKey {
                case collection
                case environment
                case id
                case mockURL = "mockUrl"
                case owner
                case uid
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }

    public struct CreateMockRequest: Encodable {
        public var mock: Mock?

        public struct Mock: Encodable {
            /// Example: "1679925-39fee52f-b806-3ffa-1173-00a6f5b183dc"
            public var collection: String?
            /// Example: "1679925-0b9e9f15-3208-a2b1-22e0-d58392f01524"
            public var environment: String?

            public init(collection: String? = nil, environment: String? = nil) {
                self.collection = collection
                self.environment = environment
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }
}

extension Paths {
    /// Single Mock
    ///
    /// This endpoint fetches you the basic information about a single mock using its `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func singleMock(mockUid: String) -> Request<SingleMockResponse> {
        .get("/mocks/\(mockUid)")
    }

    public struct SingleMockResponse: Decodable {
        public var mock: Mock?

        public struct Mock: Decodable {
            /// Example: "1679925-8aa4c661-e0f4-4db0-98bc-d52cb72b5cbf"
            public var collection: String?
            public var config: Config?
            /// Example: "2020-12-14T08:12:21.000Z"
            public var createdAt: String?
            /// Example: "1679925-2b90cdd8-e9ac-4086-91c2-bc4cad659511"
            public var environment: String?
            /// Example: "950dcaf2-ec37-4365-b106-ed659cc2ff5d"
            public var id: String?
            /// Example: false
            public var isPublic: Bool?
            /// Example: "https://950dcaf2-ec37-4365-b106-ed659cc2ff5d.mock.pstmn.io"
            public var mockURL: String?
            /// Example: "mock1"
            public var name: String?
            /// Example: "1679925"
            public var owner: String?
            /// Example: "1679925-950dcaf2-ec37-4365-b106-ed659cc2ff5d"
            public var uid: String?
            /// Example: "2020-12-15T06:44:37.000Z"
            public var updatedAt: String?

            public struct Config: Decodable {
                public var delay: AnyJSON?
                public var headers: [AnyJSON]?
                /// Example: false
                public var isMatchBody: Bool?
                /// Example: true
                public var isMatchQueryParams: Bool?
                /// Example: true
                public var isMatchWildcards: Bool?

                public init(delay: AnyJSON? = nil, headers: [AnyJSON]? = nil, isMatchBody: Bool? = nil, isMatchQueryParams: Bool? = nil, isMatchWildcards: Bool? = nil) {
                    self.delay = delay
                    self.headers = headers
                    self.isMatchBody = isMatchBody
                    self.isMatchQueryParams = isMatchQueryParams
                    self.isMatchWildcards = isMatchWildcards
                }

                private enum CodingKeys: String, CodingKey {
                    case delay
                    case headers
                    case isMatchBody = "matchBody"
                    case isMatchQueryParams = "matchQueryParams"
                    case isMatchWildcards = "matchWildcards"
                }
            }

            public init(collection: String? = nil, config: Config? = nil, createdAt: String? = nil, environment: String? = nil, id: String? = nil, isPublic: Bool? = nil, mockURL: String? = nil, name: String? = nil, owner: String? = nil, uid: String? = nil, updatedAt: String? = nil) {
                self.collection = collection
                self.config = config
                self.createdAt = createdAt
                self.environment = environment
                self.id = id
                self.isPublic = isPublic
                self.mockURL = mockURL
                self.name = name
                self.owner = owner
                self.uid = uid
                self.updatedAt = updatedAt
            }

            private enum CodingKeys: String, CodingKey {
                case collection
                case config
                case createdAt
                case environment
                case id
                case isPublic
                case mockURL = "mockUrl"
                case name
                case owner
                case uid
                case updatedAt
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }
}

extension Paths {
    /// Update Mock
    ///
    /// This endpoint allows you to update a mock you have created using its `uid`. The endpoint allows you to edit fields,
    /// * name
    /// * environment
    /// * description
    /// * private
    /// * versionTag
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func updateMock(mockUid: String, mock: UpdateMockRequest.Mock? = nil) -> Request<UpdateMockResponse> {
        .put("/mocks/\(mockUid)", body: UpdateMockRequest(mock: mock))
    }

    public struct UpdateMockResponse: Decodable {
        public var mock: Mock?

        public struct Mock: Decodable {
            /// Example: "11582779-fd6797e2-de6b-4699-975c-85290e4c2499"
            public var collection: String?
            public var config: Config?
            /// Example: "11582779-ac1b6608-deb7-4c05-9d48-ee775aabfc19"
            public var environment: String?
            /// Example: "06040138-dd6b-4cce-9a02-7e1c1ab59723"
            public var id: String?
            /// Example: "https://06040138-dd6b-4cce-9a02-7e1c1ab59723.mock.pstmn.io"
            public var mockURL: String?
            /// Example: "My Mock Server"
            public var name: String?
            /// Example: "11582779"
            public var owner: String?
            /// Example: "11582779-06040138-dd6b-4cce-9a02-7e1c1ab59723"
            public var uid: String?

            public struct Config: Decodable {
                public var headers: [AnyJSON]?
                /// Example: false
                public var isMatchBody: Bool?
                /// Example: true
                public var isMatchQueryParams: Bool?
                /// Example: true
                public var isMatchWildcards: Bool?

                public init(headers: [AnyJSON]? = nil, isMatchBody: Bool? = nil, isMatchQueryParams: Bool? = nil, isMatchWildcards: Bool? = nil) {
                    self.headers = headers
                    self.isMatchBody = isMatchBody
                    self.isMatchQueryParams = isMatchQueryParams
                    self.isMatchWildcards = isMatchWildcards
                }

                private enum CodingKeys: String, CodingKey {
                    case headers
                    case isMatchBody = "matchBody"
                    case isMatchQueryParams = "matchQueryParams"
                    case isMatchWildcards = "matchWildcards"
                }
            }

            public init(collection: String? = nil, config: Config? = nil, environment: String? = nil, id: String? = nil, mockURL: String? = nil, name: String? = nil, owner: String? = nil, uid: String? = nil) {
                self.collection = collection
                self.config = config
                self.environment = environment
                self.id = id
                self.mockURL = mockURL
                self.name = name
                self.owner = owner
                self.uid = uid
            }

            private enum CodingKeys: String, CodingKey {
                case collection
                case config
                case environment
                case id
                case mockURL = "mockUrl"
                case name
                case owner
                case uid
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }

    public struct UpdateMockRequest: Encodable {
        public var mock: Mock?

        public struct Mock: Encodable {
            /// Example: "example describing update mock description"
            public var description: String?
            /// Example: "11582779-ac1b6608-deb7-4c05-9d48-ee775aabfc19"
            public var environment: String?
            /// Example: "My Mock Server"
            public var name: String?
            /// Example: false
            public var isPrivate: Bool?
            /// Example: "abf07d3d-f8ec-47d4-8015-9fe83078b4ec"
            public var versionTag: String?

            public init(description: String? = nil, environment: String? = nil, name: String? = nil, isPrivate: Bool? = nil, versionTag: String? = nil) {
                self.description = description
                self.environment = environment
                self.name = name
                self.isPrivate = isPrivate
                self.versionTag = versionTag
            }

            private enum CodingKeys: String, CodingKey {
                case description
                case environment
                case name
                case isPrivate = "private"
                case versionTag
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }
}

extension Paths {
    /// Delete Mock
    ///
    /// This endpoint allows you to delete an existing mock using its `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteMock(mockUid: String) -> Request<DeleteMockResponse> {
        .delete("/mocks/\(mockUid)")
    }

    public struct DeleteMockResponse: Decodable {
        public var mock: Mock?

        public struct Mock: Decodable {
            /// Example: "0fca2246-c108-41f5-8454-cc032def329f"
            public var id: String?
            /// Example: "1679925-0fca2246-c108-41f5-8454-cc032def329f"
            public var uid: String?

            public init(id: String? = nil, uid: String? = nil) {
                self.id = id
                self.uid = uid
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }
}

extension Paths {
    /// Publish Mock
    ///
    /// This endpoint publishes the mock you have created using its `uid`
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key ` request header or `apikey` URL query parameter.
    static public func publishMock(mockUid: String) -> Request<PublishMockResponse> {
        .post("/mocks/\(mockUid)/publish")
    }

    public struct PublishMockResponse: Decodable {
        public var mock: Mock?

        public struct Mock: Decodable {
            /// Example: "06040138-dd6b-4cce-9a02-7e1c1ab59723"
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }
}

extension Paths {
    /// Unpublish Mock
    ///
    /// This endpoint unpublishes the mock you have created using its `uid`
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key ` request header or `apikey` URL query parameter.
    static public func unpublishMock(mockUid: String) -> Request<UnpublishMockResponse> {
        .delete("/mocks/\(mockUid)/unpublish")
    }

    public struct UnpublishMockResponse: Decodable {
        public var mock: Mock?

        public struct Mock: Decodable {
            /// Example: "06040138-dd6b-4cce-9a02-7e1c1ab59723"
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public init(mock: Mock? = nil) {
            self.mock = mock
        }
    }
}

extension Paths {
    /// All Monitors
    ///
    /// The `/monitors` endpoint returns a list of all [monitors](https://monitor.getpostman.com/) that are accessible by you.
    /// 
    /// The response contains an array of monitors information containing the `name`, `id`, `owner` and `uid` of each monitor.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public var allMonitors: Request<AllMonitorsResponse> {
        .get("/monitors")
    }

    public struct AllMonitorsResponse: Decodable {
        public var monitors: [Monitor]?

        public struct Monitor: Decodable {
            /// Example: "1e6b6c77-2031-42d0-9948-76d7251b2dd1"
            public var id: String?
            /// Example: "Batman & Sherlock Holmes Monitor"
            public var name: String?
            /// Example: "5852"
            public var owner: String?
            /// Example: "5852-1e6b6c77-2031-42d0-9948-76d7251b2dd1"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, owner: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.owner = owner
                self.uid = uid
            }
        }

        public init(monitors: [Monitor]? = nil) {
            self.monitors = monitors
        }
    }
}

extension Paths {
    /// Create Monitor
    ///
    /// This endpoint allows you to create a monitor.
    /// 
    /// Some sample `cron` values are:
    /// 
    /// | Frequency                  | Cron Pattern   |
    /// |-----------------------|----------------|
    /// | Every 5 minutes       | `*/5 * * * *`  |
    /// | Every 30 minutes     | `*/30 * * * *` |
    /// | Every Hour         | `0 */1 * * *`  |
    /// | Every 6 Hours      | `0 */6 * * *`  |
    /// | Every day at 5pm    | `0 17 * * *`   |
    /// | Every Monday at 12pm  | `0 12 * * MON` |
    /// | Every weekday (Monday - Friday) at 6am | `0 6 * * MON-FRI` |
    /// 
    /// Note: Currently, you can only create monitors at some limited schedules. You can head to [Postman Monitors](https://monitor.getpostman.com) to see the allowed schedules. 
    /// 
    /// For more information about the format of the `timezone` value, check this [list of time zones.](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
    /// 
    /// You can also specify the context of a workspace to create a monitor in directly by passing the `workspace` as a query param.
    /// 
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createMonitor(monitor: CreateMonitorRequest.Monitor? = nil) -> Request<CreateMonitorResponse> {
        .post("/monitors", body: CreateMonitorRequest(monitor: monitor))
    }

    public struct CreateMonitorResponse: Decodable {
        public var monitor: Monitor?

        public struct Monitor: Decodable {
            /// Example: "1e6b6dfd-7ba4-4590-9ee1-5948102d7797"
            public var id: String?
            /// Example: "Monitor Name"
            public var name: String?
            /// Example: "5852-1e6b6dfd-7ba4-4590-9ee1-5948102d7797"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(monitor: Monitor? = nil) {
            self.monitor = monitor
        }
    }

    public struct CreateMonitorRequest: Encodable {
        public var monitor: Monitor?

        public struct Monitor: Encodable {
            /// Example: "5852-8d05dd85-222c-1452-553b-e76a531b71ed"
            public var collection: String?
            /// Example: "5852-8a4c21ea-2a36-40d1-a82d-d717fac9d6ef"
            public var environment: String?
            /// Example: "This is a Monitor Name"
            public var name: String?
            public var schedule: Schedule?

            public struct Schedule: Encodable {
                /// Example: "0 0 * * *"
                public var cron: String?
                /// Example: "Asia/Kolkata"
                public var timezone: String?

                public init(cron: String? = nil, timezone: String? = nil) {
                    self.cron = cron
                    self.timezone = timezone
                }
            }

            public init(collection: String? = nil, environment: String? = nil, name: String? = nil, schedule: Schedule? = nil) {
                self.collection = collection
                self.environment = environment
                self.name = name
                self.schedule = schedule
            }
        }

        public init(monitor: Monitor? = nil) {
            self.monitor = monitor
        }
    }
}

extension Paths {
    /// Single Monitor
    ///
    /// This endpoint fetches you basic information about the monitor using its `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func singleMonitor(monitorUid: String) -> Request<SingleMonitorResponse> {
        .get("/monitors/\(monitorUid)")
    }

    public struct SingleMonitorResponse: Decodable {
        public var monitor: Monitor?

        public struct Monitor: Decodable {
            /// Example: "5852-8d05dd85-222c-1452-553b-e76a531b71ed"
            public var collectionUid: String?
            public var distribution: [AnyJSON]?
            /// Example: "5851-8d05dd85-222c-1452-553b-e76a531b71ed"
            public var environmentUid: String?
            /// Example: "1e6b6cc1-c760-48e0-968f-4bfaeeae9af1"
            public var id: String?
            public var lastRun: LastRun?
            /// Example: "Postman Echo Monitor"
            public var name: String?
            public var notifications: Notifications?
            public var options: Options?
            /// Example: "5852"
            public var owner: String?
            public var schedule: Schedule?
            /// Example: "5852-1e6b6cc1-c760-48e0-968f-4bfaeeae9af1"
            public var uid: String?

            public struct LastRun: Decodable {
                /// Example: "2020-03-25T15:45:31.340Z"
                public var finishedAt: String?
                /// Example: "2020-03-25T15:45:29.218Z"
                public var startedAt: String?
                public var stats: Stats?
                /// Example: "failed"
                public var status: String?

                public struct Stats: Decodable {
                    public var assertions: Assertions?
                    public var requests: Requests?

                    public struct Assertions: Decodable {
                        public var failed: Double?
                        public var total: Double?

                        public init(failed: Double? = nil, total: Double? = nil) {
                            self.failed = failed
                            self.total = total
                        }
                    }

                    public struct Requests: Decodable {
                        public var total: Double?

                        public init(total: Double? = nil) {
                            self.total = total
                        }
                    }

                    public init(assertions: Assertions? = nil, requests: Requests? = nil) {
                        self.assertions = assertions
                        self.requests = requests
                    }
                }

                public init(finishedAt: String? = nil, startedAt: String? = nil, stats: Stats? = nil, status: String? = nil) {
                    self.finishedAt = finishedAt
                    self.startedAt = startedAt
                    self.stats = stats
                    self.status = status
                }
            }

            public struct Notifications: Decodable {
                public var onError: [OnErrorItem]?
                public var onFailure: [OnFailureItem]?

                public struct OnErrorItem: Decodable {
                    /// Example: "john.appleseed@example.com"
                    public var email: String?

                    public init(email: String? = nil) {
                        self.email = email
                    }
                }

                public struct OnFailureItem: Decodable {
                    /// Example: "john.appleseed@example.com"
                    public var email: String?

                    public init(email: String? = nil) {
                        self.email = email
                    }
                }

                public init(onError: [OnErrorItem]? = nil, onFailure: [OnFailureItem]? = nil) {
                    self.onError = onError
                    self.onFailure = onFailure
                }
            }

            public struct Options: Decodable {
                /// Example: true
                public var isFollowRedirects: Bool?
                public var requestDelay: Double?
                /// Example: 3000
                public var requestTimeout: Double?
                /// Example: true
                public var isStrictSSL: Bool?

                public init(isFollowRedirects: Bool? = nil, requestDelay: Double? = nil, requestTimeout: Double? = nil, isStrictSSL: Bool? = nil) {
                    self.isFollowRedirects = isFollowRedirects
                    self.requestDelay = requestDelay
                    self.requestTimeout = requestTimeout
                    self.isStrictSSL = isStrictSSL
                }

                private enum CodingKeys: String, CodingKey {
                    case isFollowRedirects = "followRedirects"
                    case requestDelay
                    case requestTimeout
                    case isStrictSSL = "strictSSL"
                }
            }

            public struct Schedule: Decodable {
                /// Example: "0 0 * * * *"
                public var cron: String?
                /// Example: "2016-11-30T09:30:00.000Z"
                public var nextRun: String?
                /// Example: "Asia/Calcutta"
                public var timezone: String?

                public init(cron: String? = nil, nextRun: String? = nil, timezone: String? = nil) {
                    self.cron = cron
                    self.nextRun = nextRun
                    self.timezone = timezone
                }
            }

            public init(collectionUid: String? = nil, distribution: [AnyJSON]? = nil, environmentUid: String? = nil, id: String? = nil, lastRun: LastRun? = nil, name: String? = nil, notifications: Notifications? = nil, options: Options? = nil, owner: String? = nil, schedule: Schedule? = nil, uid: String? = nil) {
                self.collectionUid = collectionUid
                self.distribution = distribution
                self.environmentUid = environmentUid
                self.id = id
                self.lastRun = lastRun
                self.name = name
                self.notifications = notifications
                self.options = options
                self.owner = owner
                self.schedule = schedule
                self.uid = uid
            }
        }

        public init(monitor: Monitor? = nil) {
            self.monitor = monitor
        }
    }
}

extension Paths {
    /// Update Monitor
    ///
    /// This endpoint allows you to update a monitor using its `uid`. Only the monitor name and its schedule can be updated.
    /// 
    /// Some example `cron` values are:
    /// 
    /// | Frequency                  | Cron Pattern   |
    /// |-----------------------|----------------|
    /// | Every 5 minutes       | `*/5 * * * *`  |
    /// | Every 30 minutes     | `*/30 * * * *` |
    /// | Every Hour         | `0 */1 * * *`  |
    /// | Every 6 Hours      | `0 */6 * * *`  |
    /// | Every day at 5pm    | `0 17 * * *`   |
    /// | Every Monday at 12pm  | `0 12 * * MON` |
    /// | Every weekday (Monday - Friday) at 6am | `0 6 * * MON-FRI` |
    /// 
    /// Note: Currently, you can only create monitors at some limited schedules. You can head to [Postman Monitors](https://monitor.getpostman.com) to see the allowed schedules. 
    /// 
    /// For more information about the format of the `timezone` value, check this [list of time zones.](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func updateMonitor(monitorUid: String, monitor: UpdateMonitorRequest.Monitor? = nil) -> Request<UpdateMonitorResponse> {
        .put("/monitors/\(monitorUid)", body: UpdateMonitorRequest(monitor: monitor))
    }

    public struct UpdateMonitorResponse: Decodable {
        public var monitor: Monitor?

        public struct Monitor: Decodable {
            /// Example: "1e6b6e2a-c2ad-4090-b750-0df4e6624352"
            public var id: String?
            /// Example: "Updated Monitor Name"
            public var name: String?
            /// Example: "5852-1e6b6e2a-c2ad-4090-b750-0df4e6624352"
            public var uid: String?

            public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                self.id = id
                self.name = name
                self.uid = uid
            }
        }

        public init(monitor: Monitor? = nil) {
            self.monitor = monitor
        }
    }

    public struct UpdateMonitorRequest: Encodable {
        public var monitor: Monitor?

        public struct Monitor: Encodable {
            /// Example: "Updated Monitor Name"
            public var name: String?
            public var schedule: Schedule?

            public struct Schedule: Encodable {
                /// Example: "*/5 * * * *"
                public var cron: String?
                /// Example: "America/Chicago"
                public var timezone: String?

                public init(cron: String? = nil, timezone: String? = nil) {
                    self.cron = cron
                    self.timezone = timezone
                }
            }

            public init(name: String? = nil, schedule: Schedule? = nil) {
                self.name = name
                self.schedule = schedule
            }
        }

        public init(monitor: Monitor? = nil) {
            self.monitor = monitor
        }
    }
}

extension Paths {
    /// Delete Monitor
    ///
    /// This endpoint can be used to delete an existing monitor using its `uid`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteMonitor(monitorUid: String) -> Request<DeleteMonitorResponse> {
        .delete("/monitors/\(monitorUid)")
    }

    public struct DeleteMonitorResponse: Decodable {
        public var monitor: Monitor?

        public struct Monitor: Decodable {
            /// Example: "1e6b8957-35f9-42a0-8d2f-f03d7085b3d2"
            public var id: String?
            /// Example: "5852-1e6b8957-35f9-42a0-8d2f-f03d7085b3d2"
            public var uid: String?

            public init(id: String? = nil, uid: String? = nil) {
                self.id = id
                self.uid = uid
            }
        }

        public init(monitor: Monitor? = nil) {
            self.monitor = monitor
        }
    }
}

extension Paths {
    /// Run a Monitor
    ///
    /// This endpoint will run the monitor instantly and wait for the monitor to run completely. It responds with the run results.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func runAMonitor(monitorUid: String) -> Request<RunAMonitorResponse> {
        .post("/monitors/\(monitorUid)/run")
    }

    public struct RunAMonitorResponse: Decodable {
        public var run: Run?

        public struct Run: Decodable {
            public var executions: [Execution]?
            public var failures: [Failure]?
            public var info: Info?
            public var stats: Stats?

            public struct Execution: Decodable {
                public var id: Double?
                public var item: Item?
                public var request: Request?
                public var response: Response?

                public struct Item: Decodable {
                    /// Example: "b5e8d7dd-909c-4ba7-aef4-8609bc50b586"
                    public var id: String?
                    /// Example: "Sample POST Request"
                    public var name: String?

                    public init(id: String? = nil, name: String? = nil) {
                        self.id = id
                        self.name = name
                    }
                }

                public struct Request: Decodable {
                    public var body: Body?
                    public var headers: Headers?
                    /// Example: "POST"
                    public var method: String?
                    /// Example: "2016-12-04T14:30:26.025Z"
                    public var timestamp: String?
                    /// Example: "echo.getpostman.com/post"
                    public var url: String?

                    public struct Body: Decodable {
                        /// Example: 18
                        public var contentLength: Double?
                        /// Example: "raw"
                        public var mode: String?

                        public init(contentLength: Double? = nil, mode: String? = nil) {
                            self.contentLength = contentLength
                            self.mode = mode
                        }
                    }

                    public struct Headers: Decodable {
                        /// Example: "*/*"
                        public var accept: String?
                        /// Example: "gzip, deflate"
                        public var acceptEncoding: String?
                        /// Example: 18
                        public var contentLength: Double?
                        /// Example: "application/json"
                        public var contentType: String?

                        public init(accept: String? = nil, acceptEncoding: String? = nil, contentLength: Double? = nil, contentType: String? = nil) {
                            self.accept = accept
                            self.acceptEncoding = acceptEncoding
                            self.contentLength = contentLength
                            self.contentType = contentType
                        }

                        private enum CodingKeys: String, CodingKey {
                            case accept
                            case acceptEncoding = "accept-encoding"
                            case contentLength = "content-length"
                            case contentType = "content-type"
                        }
                    }

                    public init(body: Body? = nil, headers: Headers? = nil, method: String? = nil, timestamp: String? = nil, url: String? = nil) {
                        self.body = body
                        self.headers = headers
                        self.method = method
                        self.timestamp = timestamp
                        self.url = url
                    }
                }

                public struct Response: Decodable {
                    public var body: Body?
                    /// Example: 200
                    public var code: Double?
                    public var headers: Headers?
                    /// Example: 298
                    public var responseSize: Double?
                    /// Example: 26
                    public var responseTime: Double?

                    public struct Body: Decodable {
                        /// Example: 298
                        public var contentLength: Double?

                        public init(contentLength: Double? = nil) {
                            self.contentLength = contentLength
                        }
                    }

                    public struct Headers: Decodable {
                        /// Example: "keep-alive"
                        public var connection: String?
                        /// Example: "gzip"
                        public var contentEncoding: String?
                        /// Example: "application/json"
                        public var contentType: String?
                        /// Example: "Sun, 04 Dec 2016 14:30:26 GMT"
                        public var date: String?
                        /// Example: "chunked"
                        public var transferEncoding: String?

                        public init(connection: String? = nil, contentEncoding: String? = nil, contentType: String? = nil, date: String? = nil, transferEncoding: String? = nil) {
                            self.connection = connection
                            self.contentEncoding = contentEncoding
                            self.contentType = contentType
                            self.date = date
                            self.transferEncoding = transferEncoding
                        }

                        private enum CodingKeys: String, CodingKey {
                            case connection
                            case contentEncoding = "content-encoding"
                            case contentType = "content-type"
                            case date
                            case transferEncoding = "transfer-encoding"
                        }
                    }

                    public init(body: Body? = nil, code: Double? = nil, headers: Headers? = nil, responseSize: Double? = nil, responseTime: Double? = nil) {
                        self.body = body
                        self.code = code
                        self.headers = headers
                        self.responseSize = responseSize
                        self.responseTime = responseTime
                    }
                }

                public init(id: Double? = nil, item: Item? = nil, request: Request? = nil, response: Response? = nil) {
                    self.id = id
                    self.item = item
                    self.request = request
                    self.response = response
                }
            }

            public struct Failure: Decodable {
                public var assertion: Assertion?
                public var executionID: Double?
                /// Example: "Expected 'Status code is 400' to be truthy"
                public var message: String?
                /// Example: "AssertionError"
                public var name: String?

                public struct Assertion: Decodable {
                    /// Example: false
                    public var isStatusCodeIs400: Bool?

                    public init(isStatusCodeIs400: Bool? = nil) {
                        self.isStatusCodeIs400 = isStatusCodeIs400
                    }

                    private enum CodingKeys: String, CodingKey {
                        case isStatusCodeIs400 = "Status code is 400"
                    }
                }

                public init(assertion: Assertion? = nil, executionID: Double? = nil, message: String? = nil, name: String? = nil) {
                    self.assertion = assertion
                    self.executionID = executionID
                    self.message = message
                    self.name = name
                }

                private enum CodingKeys: String, CodingKey {
                    case assertion
                    case executionID = "executionId"
                    case message
                    case name
                }
            }

            public struct Info: Decodable {
                /// Example: "5852-1d3daef4-2037-4584-ab86-bafd8c8f8a55"
                public var collectionUid: String?
                /// Example: "2016-12-04T14:30:26.000Z"
                public var finishedAt: String?
                /// Example: "1e6ba2e3-1aaf-4c10-bd5f-905943284b2a"
                public var jobID: String?
                /// Example: "1e6b8970-fd13-4480-b011-b3b3e3cd271d"
                public var monitorID: String?
                /// Example: "Sample Collection monitor 1 #56"
                public var name: String?
                /// Example: "2016-12-04T14:30:25.000Z"
                public var startedAt: String?
                /// Example: "failed"
                public var status: String?

                public init(collectionUid: String? = nil, finishedAt: String? = nil, jobID: String? = nil, monitorID: String? = nil, name: String? = nil, startedAt: String? = nil, status: String? = nil) {
                    self.collectionUid = collectionUid
                    self.finishedAt = finishedAt
                    self.jobID = jobID
                    self.monitorID = monitorID
                    self.name = name
                    self.startedAt = startedAt
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case collectionUid
                    case finishedAt
                    case jobID = "jobId"
                    case monitorID = "monitorId"
                    case name
                    case startedAt
                    case status
                }
            }

            public struct Stats: Decodable {
                public var assertions: Assertions?
                public var requests: Requests?

                public struct Assertions: Decodable {
                    public var failed: Double?
                    public var total: Double?

                    public init(failed: Double? = nil, total: Double? = nil) {
                        self.failed = failed
                        self.total = total
                    }
                }

                public struct Requests: Decodable {
                    public var failed: Double?
                    public var total: Double?

                    public init(failed: Double? = nil, total: Double? = nil) {
                        self.failed = failed
                        self.total = total
                    }
                }

                public init(assertions: Assertions? = nil, requests: Requests? = nil) {
                    self.assertions = assertions
                    self.requests = requests
                }
            }

            public init(executions: [Execution]? = nil, failures: [Failure]? = nil, info: Info? = nil, stats: Stats? = nil) {
                self.executions = executions
                self.failures = failures
                self.info = info
                self.stats = stats
            }
        }

        public init(run: Run? = nil) {
            self.run = run
        }
    }
}

extension Paths {
    /// Get ResourceTypes
    ///
    /// Returns all the resource types supported by Postman's SCIM API.
    static public var getResourceTypes: Request<Void> {
        .get("/scim/v2/ResourceTypes")
    }
}

extension Paths {
    /// Service Provider Config
    ///
    /// Returns configuration details for Postman's SCIM API, including the list of operations that are supported.
    static public var serviceProviderConfig: Request<ServiceProviderConfigResponse> {
        .get("/scim/v2/ServiceProviderConfig")
    }

    public struct ServiceProviderConfigResponse: Decodable {
        public var authenticationSchemes: [AuthenticationScheme]?
        public var bulk: Bulk?
        public var changePassword: ChangePassword?
        /// Example: "https://learning.postman.com/docs/administration/managing-your-team/configuring-scim"
        public var documentationUri: String?
        public var etag: Etag?
        public var filter: Filter?
        public var meta: Meta?
        public var patch: Patch?
        public var schemas: [String]?
        public var sort: Sort?

        public struct AuthenticationScheme: Decodable {
            /// Example: "Authentication scheme using the OAuth Bearer Token Standard"
            public var description: String?
            /// Example: "OAuth Bearer Token"
            public var name: String?
            /// Example: "http://www.rfc-editor.org/info/rfc6750"
            public var specUri: String?
            /// Example: "oauthbearertoken"
            public var type: String?

            public init(description: String? = nil, name: String? = nil, specUri: String? = nil, type: String? = nil) {
                self.description = description
                self.name = name
                self.specUri = specUri
                self.type = type
            }
        }

        public struct Bulk: Decodable {
            public var maxOperations: Double?
            public var maxPayloadSize: Double?
            /// Example: false
            public var isSupported: Bool?

            public init(maxOperations: Double? = nil, maxPayloadSize: Double? = nil, isSupported: Bool? = nil) {
                self.maxOperations = maxOperations
                self.maxPayloadSize = maxPayloadSize
                self.isSupported = isSupported
            }

            private enum CodingKeys: String, CodingKey {
                case maxOperations
                case maxPayloadSize
                case isSupported = "supported"
            }
        }

        public struct ChangePassword: Decodable {
            /// Example: false
            public var isSupported: Bool?

            public init(isSupported: Bool? = nil) {
                self.isSupported = isSupported
            }

            private enum CodingKeys: String, CodingKey {
                case isSupported = "supported"
            }
        }

        public struct Etag: Decodable {
            /// Example: false
            public var isSupported: Bool?

            public init(isSupported: Bool? = nil) {
                self.isSupported = isSupported
            }

            private enum CodingKeys: String, CodingKey {
                case isSupported = "supported"
            }
        }

        public struct Filter: Decodable {
            /// Example: 100
            public var maxResults: Double?
            /// Example: true
            public var isSupported: Bool?

            public init(maxResults: Double? = nil, isSupported: Bool? = nil) {
                self.maxResults = maxResults
                self.isSupported = isSupported
            }

            private enum CodingKeys: String, CodingKey {
                case maxResults
                case isSupported = "supported"
            }
        }

        public struct Meta: Decodable {
            /// Example: "{{url}}/scim/v2/ServiceProviderConfig"
            public var location: String?
            /// Example: "ServiceProviderConfig"
            public var resourceType: String?

            public init(location: String? = nil, resourceType: String? = nil) {
                self.location = location
                self.resourceType = resourceType
            }
        }

        public struct Patch: Decodable {
            /// Example: true
            public var isSupported: Bool?

            public init(isSupported: Bool? = nil) {
                self.isSupported = isSupported
            }

            private enum CodingKeys: String, CodingKey {
                case isSupported = "supported"
            }
        }

        public struct Sort: Decodable {
            /// Example: false
            public var isSupported: Bool?

            public init(isSupported: Bool? = nil) {
                self.isSupported = isSupported
            }

            private enum CodingKeys: String, CodingKey {
                case isSupported = "supported"
            }
        }

        public init(authenticationSchemes: [AuthenticationScheme]? = nil, bulk: Bulk? = nil, changePassword: ChangePassword? = nil, documentationUri: String? = nil, etag: Etag? = nil, filter: Filter? = nil, meta: Meta? = nil, patch: Patch? = nil, schemas: [String]? = nil, sort: Sort? = nil) {
            self.authenticationSchemes = authenticationSchemes
            self.bulk = bulk
            self.changePassword = changePassword
            self.documentationUri = documentationUri
            self.etag = etag
            self.filter = filter
            self.meta = meta
            self.patch = patch
            self.schemas = schemas
            self.sort = sort
        }
    }
}

extension Paths {
    /// Fetch All User Resource
    ///
    /// Fetches information on all Postman team members. You can fetch information for a particular user with filters.
    /// 
    /// Note: By default, this endpoint will return a list of hundred users. To overwrite the default setting, update the 'startIndex=1&count=100' value in the request.
    static public func fetchAllUserResource(parameters: FetchAllUserResourceParameters? = nil) -> Request<FetchAllUserResourceResponse> {
        .get("/scim/v2/Users", query: parameters?.asQuery())
    }

    public struct FetchAllUserResourceResponse: Decodable {
        public var resources: [AnyJSON]?
        public var itemsPerPage: Double?
        public var schemas: [String]?
        public var startIndex: Double?
        public var totalResults: Double?

        public init(resources: [AnyJSON]? = nil, itemsPerPage: Double? = nil, schemas: [String]? = nil, startIndex: Double? = nil, totalResults: Double? = nil) {
            self.resources = resources
            self.itemsPerPage = itemsPerPage
            self.schemas = schemas
            self.startIndex = startIndex
            self.totalResults = totalResults
        }

        private enum CodingKeys: String, CodingKey {
            case resources = "Resources"
            case itemsPerPage
            case schemas
            case startIndex
            case totalResults
        }
    }

    public struct FetchAllUserResourceParameters {
        /// Example: "1"
        public var startIndex: String?
        /// Example: "100"
        public var count: String?
        /// Example: "userName eq 'test%40domain.com'"
        public var filter: String?

        public init(startIndex: String? = nil, count: String? = nil, filter: String? = nil) {
            self.startIndex = startIndex
            self.count = count
            self.filter = filter
        }

        public func asQuery() -> [(String, String?)] {
            var query: [(String, String?)] = []
            query.addQueryItem("startIndex", startIndex?.asQueryValue)
            query.addQueryItem("count", count?.asQueryValue)
            query.addQueryItem("filter", filter?.asQueryValue)
            return query
        }
    }
}

extension Paths {
    /// Create User
    ///
    /// Creates a new user account in Postman, adds the user to your organization's Postman team, and activates the user to authenticate into your Postman team, provided an account with the same email ID does not already exist in Postman. The newly added user will have the `developer` role in Postman by default. You can later [update user roles in Postman](/docs/administration/managing-your-team/managing-your-team/#managing-roles).
    /// 
    /// If an account with the same email ID does exist, an [email invite](https://learning.postman.com/docs/administration/managing-your-team/managing-your-team/#invites) to join your Postman team is sent to the user. Once the user accepts the invite, they will be added to your team.
    static public func createUser(_ body: CreateUserRequest? = nil) -> Request<CreateUserResponse> {
        .post("/scim/v2/Users", body: body)
    }

    public struct CreateUserResponse: Decodable {
        /// Example: true
        public var isActive: Bool?
        /// Example: "23123123"
        public var externalID: String?
        /// Example: "405775fe15ed41872a8eea4c8aa2b38cda9749812cc55c99"
        public var id: String?
        public var meta: Meta?
        public var name: Name?
        public var schemas: [String]?
        /// Example: "testUser@postman.local"
        public var userName: String?

        public struct Meta: Decodable {
            /// Example: "2021-02-22T04:24:13.000Z"
            public var created: String?
            /// Example: "2021-02-22T04:24:13.000Z"
            public var lastModified: String?
            /// Example: "User"
            public var resourceType: String?

            public init(created: String? = nil, lastModified: String? = nil, resourceType: String? = nil) {
                self.created = created
                self.lastModified = lastModified
                self.resourceType = resourceType
            }
        }

        public struct Name: Decodable {
            /// Example: "User"
            public var familyName: String?
            /// Example: "Test"
            public var givenName: String?

            public init(familyName: String? = nil, givenName: String? = nil) {
                self.familyName = familyName
                self.givenName = givenName
            }
        }

        public init(isActive: Bool? = nil, externalID: String? = nil, id: String? = nil, meta: Meta? = nil, name: Name? = nil, schemas: [String]? = nil, userName: String? = nil) {
            self.isActive = isActive
            self.externalID = externalID
            self.id = id
            self.meta = meta
            self.name = name
            self.schemas = schemas
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case isActive = "active"
            case externalID = "externalId"
            case id
            case meta
            case name
            case schemas
            case userName
        }
    }

    public struct CreateUserRequest: Encodable {
        /// Example: true
        public var isActive: Bool?
        /// Example: "23123123"
        public var externalID: String?
        public var groups: [AnyJSON]?
        /// Example: "en-US"
        public var locale: String?
        public var name: Name?
        public var schemas: [String]?
        /// Example: "{{userEmail}}"
        public var userName: String?

        public struct Name: Encodable {
            /// Example: "User"
            public var familyName: String?
            /// Example: "Test"
            public var givenName: String?

            public init(familyName: String? = nil, givenName: String? = nil) {
                self.familyName = familyName
                self.givenName = givenName
            }
        }

        public init(isActive: Bool? = nil, externalID: String? = nil, groups: [AnyJSON]? = nil, locale: String? = nil, name: Name? = nil, schemas: [String]? = nil, userName: String? = nil) {
            self.isActive = isActive
            self.externalID = externalID
            self.groups = groups
            self.locale = locale
            self.name = name
            self.schemas = schemas
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case isActive = "active"
            case externalID = "externalId"
            case groups
            case locale
            case name
            case schemas
            case userName
        }
    }
}

extension Paths {
    /// Fetch User Resource
    ///
    /// Fetches an individual Postman team member's information.
    static public func fetchUserResource(id: String) -> Request<Void> {
        .get("/scim/v2/Users/\(id)")
    }
}

extension Paths {
    /// Update User Information
    ///
    /// Updates a users first and last name in Postman. 
    /// 
    /// > Only updates made to the users given and family name via the SCIM API will be pushed to Postman. No other user attributes can be updated in Postman using the SCIM API.
    static public func updateUserInformation(id: String, _ body: UpdateUserInformationRequest? = nil) -> Request<UpdateUserInformationResponse> {
        .put("/scim/v2/Users/\(id)", body: body)
    }

    public struct UpdateUserInformationResponse: Decodable {
        /// Example: true
        public var isActive: Bool?
        /// Example: "23123123"
        public var externalID: String?
        /// Example: "405775fe15ed41872a8eea4c8aa2b38cda9749812cc55c99"
        public var id: String?
        public var meta: Meta?
        public var name: Name?
        public var schemas: [String]?
        /// Example: "test.user@okta.local"
        public var userName: String?

        public struct Meta: Decodable {
            /// Example: "2021-02-22T04:24:13.000Z"
            public var created: String?
            /// Example: "2021-02-22T04:24:13.000Z"
            public var lastModified: String?
            /// Example: "User"
            public var resourceType: String?

            public init(created: String? = nil, lastModified: String? = nil, resourceType: String? = nil) {
                self.created = created
                self.lastModified = lastModified
                self.resourceType = resourceType
            }
        }

        public struct Name: Decodable {
            /// Example: "User"
            public var familyName: String?
            /// Example: "Test"
            public var givenName: String?

            public init(familyName: String? = nil, givenName: String? = nil) {
                self.familyName = familyName
                self.givenName = givenName
            }
        }

        public init(isActive: Bool? = nil, externalID: String? = nil, id: String? = nil, meta: Meta? = nil, name: Name? = nil, schemas: [String]? = nil, userName: String? = nil) {
            self.isActive = isActive
            self.externalID = externalID
            self.id = id
            self.meta = meta
            self.name = name
            self.schemas = schemas
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case isActive = "active"
            case externalID = "externalId"
            case id
            case meta
            case name
            case schemas
            case userName
        }
    }

    public struct UpdateUserInformationRequest: Encodable {
        /// Example: true
        public var isActive: Bool?
        /// Example: "23123123"
        public var externalID: String?
        public var groups: [AnyJSON]?
        /// Example: "en-US"
        public var locale: String?
        public var name: Name?
        public var schemas: [String]?
        /// Example: "{{userEmail}}"
        public var userName: String?

        public struct Name: Encodable {
            /// Example: "User"
            public var familyName: String?
            /// Example: "Test"
            public var givenName: String?

            public init(familyName: String? = nil, givenName: String? = nil) {
                self.familyName = familyName
                self.givenName = givenName
            }
        }

        public init(isActive: Bool? = nil, externalID: String? = nil, groups: [AnyJSON]? = nil, locale: String? = nil, name: Name? = nil, schemas: [String]? = nil, userName: String? = nil) {
            self.isActive = isActive
            self.externalID = externalID
            self.groups = groups
            self.locale = locale
            self.name = name
            self.schemas = schemas
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case isActive = "active"
            case externalID = "externalId"
            case groups
            case locale
            case name
            case schemas
            case userName
        }
    }
}

extension Paths {
    /// Update User Information
    ///
    /// Updates user state in Postman:
    ///   * **Activate User**: Creates a new user on your Postman team, if one does not already exist, and activates the user to authenticate into your Postman team.
    ///   * **Deactivate User**: Removes a user from your Postman team and deactivates their account, blocking the account from authenticating into Postman.
    ///   > The user account and the data corresponding to it will not be deleted. To permanently delete the user account and their data, [contact Postman support](https://www.postman.com/support/).
    ///   * **Reactivate Users**: Reactivates an existing deactivated user by unblocking the account's authentication into Postman and adds the account back on to your Postman team.
    static public func updateUserInformation1(id: String, _ body: UpdateUserInformation1Request? = nil) -> Request<UpdateUserInformation1Response> {
        .patch("/scim/v2/Users/\(id)", body: body)
    }

    public struct UpdateUserInformation1Response: Decodable {
        /// Example: false
        public var isActive: Bool?
        /// Example: "23123123"
        public var externalID: String?
        /// Example: "405775fe15ed41872a8eea4c8aa2b38cda9749812cc55c99"
        public var id: String?
        public var meta: Meta?
        public var name: Name?
        public var schemas: [String]?
        /// Example: "{{userEmail}}"
        public var userName: String?

        public struct Meta: Decodable {
            /// Example: "2021-02-22T04:24:13.000Z"
            public var created: String?
            /// Example: "2021-02-22T04:24:13.000Z"
            public var lastModified: String?
            /// Example: "User"
            public var resourceType: String?

            public init(created: String? = nil, lastModified: String? = nil, resourceType: String? = nil) {
                self.created = created
                self.lastModified = lastModified
                self.resourceType = resourceType
            }
        }

        public struct Name: Decodable {
            /// Example: "User"
            public var familyName: String?
            /// Example: "Test"
            public var givenName: String?

            public init(familyName: String? = nil, givenName: String? = nil) {
                self.familyName = familyName
                self.givenName = givenName
            }
        }

        public init(isActive: Bool? = nil, externalID: String? = nil, id: String? = nil, meta: Meta? = nil, name: Name? = nil, schemas: [String]? = nil, userName: String? = nil) {
            self.isActive = isActive
            self.externalID = externalID
            self.id = id
            self.meta = meta
            self.name = name
            self.schemas = schemas
            self.userName = userName
        }

        private enum CodingKeys: String, CodingKey {
            case isActive = "active"
            case externalID = "externalId"
            case id
            case meta
            case name
            case schemas
            case userName
        }
    }

    public struct UpdateUserInformation1Request: Encodable {
        public var operations: [Operation]?
        public var schemas: [String]?

        public struct Operation: Encodable {
            /// Example: "replace"
            public var op: String?
            public var value: Value?

            public struct Value: Encodable {
                /// Example: false
                public var isActive: Bool?

                public init(isActive: Bool? = nil) {
                    self.isActive = isActive
                }

                private enum CodingKeys: String, CodingKey {
                    case isActive = "active"
                }
            }

            public init(op: String? = nil, value: Value? = nil) {
                self.op = op
                self.value = value
            }
        }

        public init(operations: [Operation]? = nil, schemas: [String]? = nil) {
            self.operations = operations
            self.schemas = schemas
        }

        private enum CodingKeys: String, CodingKey {
            case operations = "Operations"
            case schemas
        }
    }
}

extension Paths {
    /// Schema Security Validation
    ///
    /// This endpoint will perform **static analysis** on the **Schema specification**. It will return the security misses in your schema definition and help you understand their implications and possible ways to patch the warnings. You can introduce this endpoint to your CI/CD process to automate your schema validation.
    /// 
    /// **Request Body**(max size 10MB)</br>
    /// 
    /// | Key | Value Type | Required | Description |
    /// | ---- |----| --- | ---- |
    /// | type | Enum(openapi3, openapi2) | Yes | Type of Schema Specification |
    /// | language | Enum(json, yaml) | Yes | Format of Schema Specification |
    /// | schema | String | Yes | Stringified Schema Body|
    /// 
    /// Visit [Learning Center](https://learning.postman-beta.com/docs/api-security/security-warnings/security-warnings-overview) for more information
    static public func schemaSecurityValidation(schema: SchemaSecurityValidationRequest.Schema? = nil) -> Request<SchemaSecurityValidationResponse> {
        .post("/security/api-validation", body: SchemaSecurityValidationRequest(schema: schema))
    }

    public enum SchemaSecurityValidationResponseHeaders {
        public static let accessControlAllowOrigin = HTTPHeader<String>(field: "Access-Control-Allow-Origin")
        public static let connection = HTTPHeader<String>(field: "Connection")
        public static let contentLength = HTTPHeader<String>(field: "Content-Length")
        public static let date = HTTPHeader<String>(field: "Date")
        public static let eTag = HTTPHeader<String>(field: "ETag")
        public static let server = HTTPHeader<String>(field: "Server")
        public static let vary = HTTPHeader<String>(field: "Vary")
        public static let rateLimitLimit = HTTPHeader<String>(field: "X-RateLimit-Limit")
        public static let rateLimitRemaining = HTTPHeader<String>(field: "X-RateLimit-Remaining")
        public static let rateLimitReset = HTTPHeader<String>(field: "X-RateLimit-Reset")
        public static let frameOptions = HTTPHeader<String>(field: "x-frame-options")
        public static let srvSpan = HTTPHeader<String>(field: "x-srv-span")
        public static let srvTrace = HTTPHeader<String>(field: "x-srv-trace")
    }

    public struct SchemaSecurityValidationResponse: Decodable {
        public var warnings: [AnyJSON]?

        public init(warnings: [AnyJSON]? = nil) {
            self.warnings = warnings
        }
    }

    public struct SchemaSecurityValidationRequest: Encodable {
        public var schema: Schema?

        public struct Schema: Encodable {
            /// Example: "json"
            public var language: String?
            /// Example: "{"openapi":"3.0.0","info":{"version":"1","title":"temp","license":{"name":"MIT"}},"servers":[{"url":"https://petstore.swagger.io/v1"}],"paths":{"/user":{"get":{"summary":"Details about a user","operationId":"listUser","tags":["user"],"parameters":[{"name":"id","in":"query","description":"ID of the user","required":true,"schema":{"type":"integer","format":"int32"}}],"responses":{"200":{"description":"Details about a user","headers":{"x-next":{"description":"A link to the next page of responses","schema":{"type":"string"}}},"content":{"application/json":{"schema":{"$ref":"#/components/schemas/User"}}}},"default":{"description":"unexpected error","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Error"}}}}}}}},"components":{"schemas":{"User":{"type":"object","required":["id","name"],"properties":{"id":{"type":"integer","format":"int64"},"name":{"type":"string"},"tag":{"type":"string"}}},"Error":{"type":"object","required":["code","message"],"properties":{"code":{"type":"integer","format":"int32"},"message":{"type":"string"}}}},"securitySchemes":{"BasicAuth":{"type":"http","scheme":"basic"}}},"security":[{"BasicAuth":[]}]}"
            public var schema: String?
            /// Example: "openapi3"
            public var type: String?

            public init(language: String? = nil, schema: String? = nil, type: String? = nil) {
                self.language = language
                self.schema = schema
                self.type = type
            }
        }

        public init(schema: Schema? = nil) {
            self.schema = schema
        }
    }
}

extension Paths {
    /// Create Webhook
    ///
    /// Create a webhook that triggers a collection with your custom payload.
    /// 
    /// You can specify the webhook name and the collection to trigger by using the following attributes of the `webhook` object on your JSON body:
    /// 
    /// * `name`: the name of the webhook that you're creating.
    /// * `collection`: the UID of the collection that you want to trigger once this webhook is called.
    /// 
    /// Once created, the webhook URL can be retrieved by accessing the `webhookUrl` attribute of the `webhook` object on the response JSON payload.
    static public func createWebhook(workspace: String? = nil, webhook: CreateWebhookRequest.Webhook? = nil) -> Request<Void> {
        .post("/webhooks", query: makeCreateWebhookQuery(workspace), body: CreateWebhookRequest(webhook: webhook))
    }

    private static func makeCreateWebhookQuery(_ workspace: String?) -> [(String, String?)] {
        var query: [(String, String?)] = []
        query.addQueryItem("workspace", workspace?.asQueryValue)
        return query
    }

    public struct CreateWebhookRequest: Encodable {
        public var webhook: Webhook?

        public struct Webhook: Encodable {
            /// Example: "{{collection_uid}}"
            public var collection: String?
            /// Example: "{{webhook_name}}"
            public var name: String?

            public init(collection: String? = nil, name: String? = nil) {
                self.collection = collection
                self.name = name
            }
        }

        public init(webhook: Webhook? = nil) {
            self.webhook = webhook
        }
    }
}

extension Paths {
    /// All workspaces
    ///
    /// The `/workspaces` endpoint returns a list of all [workspaces](https://www.getpostman.com/docs/v6/postman/workspaces/intro_to_workspaces) that is accessible by you. The list includes your own workspaces and the workspaces that you have access to.
    /// 
    /// The response contains an array of collection information containing the `name`, `id`, and `type` of each workspace.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public var allWorkspaces: Request<AllWorkspacesResponse> {
        .get("/workspaces")
    }

    public struct AllWorkspacesResponse: Decodable {
        public var workspaces: [Workspace]?

        public struct Workspace: Decodable {
            /// Example: "4e6d34c2-cfdb-4b33-8868-12a875bebda3"
            public var id: String?
            /// Example: "My Workspace"
            public var name: String?
            /// Example: "personal"
            public var type: String?

            public init(id: String? = nil, name: String? = nil, type: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
            }
        }

        public init(workspaces: [Workspace]? = nil) {
            self.workspaces = workspaces
        }
    }
}

extension Paths {
    /// Create Workspace
    ///
    /// This endpoint allows you to create a workspace and populate it with entities like `collections`, `environments`, `mocks` and `monitors` using their `uid`.
    /// 
    /// On successful creation of the workspace, the response returns the workspcae `name` and `id`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func createWorkspace(workspace: CreateWorkspaceRequest.Workspace? = nil) -> Request<CreateWorkspaceResponse> {
        .post("/workspaces", body: CreateWorkspaceRequest(workspace: workspace))
    }

    public struct CreateWorkspaceResponse: Decodable {
        public var workspace: Workspace?

        public struct Workspace: Decodable {
            /// Example: "cfbcd9bf-cc8b-4d6f-b8ef-440a3e49e29f"
            public var id: String?
            /// Example: "New Workspace"
            public var name: String?

            public init(id: String? = nil, name: String? = nil) {
                self.id = id
                self.name = name
            }
        }

        public init(workspace: Workspace? = nil) {
            self.workspace = workspace
        }
    }

    public struct CreateWorkspaceRequest: Encodable {
        public var workspace: Workspace?

        public struct Workspace: Encodable {
            public var collections: [Collection]?
            /// Example: "Some description"
            public var description: String?
            public var environments: [Environment]?
            public var mocks: [Mock]?
            public var monitors: [Monitor]?
            /// Example: "New Workspace"
            public var name: String?
            /// Example: "personal"
            public var type: String?

            public struct Collection: Encodable {
                /// Example: "e1fc3c38-a0b8-44a3-bd44-d753a96b2e9d"
                public var id: String?
                /// Example: "Straw hats"
                public var name: String?
                /// Example: "8154-e1fc3c38-a0b8-44a3-bd44-d753a96b2e9d"
                public var uid: String?

                public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                    self.id = id
                    self.name = name
                    self.uid = uid
                }
            }

            public struct Environment: Encodable {
                /// Example: "83a1aaa2-a204-4bd8-9b92-4d486918906b"
                public var id: String?
                /// Example: "env"
                public var name: String?
                /// Example: "8154-83a1aaa2-a204-4bd8-9b92-4d486918906b"
                public var uid: String?

                public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                    self.id = id
                    self.name = name
                    self.uid = uid
                }
            }

            public struct Mock: Encodable {
                /// Example: "cda672ef-1375-40e9-baee-e20ece8d7b65"
                public var id: String?

                public init(id: String? = nil) {
                    self.id = id
                }
            }

            public struct Monitor: Encodable {
                /// Example: "1e889bd2-3862-4be0-b2c2-9b1fe9673aec"
                public var id: String?

                public init(id: String? = nil) {
                    self.id = id
                }
            }

            public init(collections: [Collection]? = nil, description: String? = nil, environments: [Environment]? = nil, mocks: [Mock]? = nil, monitors: [Monitor]? = nil, name: String? = nil, type: String? = nil) {
                self.collections = collections
                self.description = description
                self.environments = environments
                self.mocks = mocks
                self.monitors = monitors
                self.name = name
                self.type = type
            }
        }

        public init(workspace: Workspace? = nil) {
            self.workspace = workspace
        }
    }
}

extension Paths {
    /// Single workspace
    ///
    /// Access the contents of a workspace that is accessible to you using its id (`id`). Includes the collections, environments, mocks and monitors of that workspace.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func singleWorkspace(workspaceID: String) -> Request<SingleWorkspaceResponse> {
        .get("/workspaces/\(workspaceID)")
    }

    public struct SingleWorkspaceResponse: Decodable {
        public var workspace: Workspace?

        public struct Workspace: Decodable {
            public var collections: [Collection]?
            /// Example: "Demos."
            public var description: String?
            public var environments: [Environment]?
            /// Example: "f8801e9e-03a4-4c7b-b31e-5db5cd771696"
            public var id: String?
            /// Example: "Demo workspace"
            public var name: String?
            /// Example: "personal"
            public var type: String?

            public struct Collection: Decodable {
                /// Example: "7c31b469-bd43-4411-9283-6d397855ee0e"
                public var id: String?
                /// Example: "Mock demo - collection"
                public var name: String?
                /// Example: "1234-7c31b469-bd43-4411-9283-6d397855ee0e"
                public var uid: String?

                public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                    self.id = id
                    self.name = name
                    self.uid = uid
                }
            }

            public struct Environment: Decodable {
                /// Example: "423fd955-a9c8-47cd-9ab0-09a6a575c4be"
                public var id: String?
                /// Example: "Mock demo - CNX"
                public var name: String?
                /// Example: "1234-423fd955-a9c8-47cd-9ab0-09a6a575c4be"
                public var uid: String?

                public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                    self.id = id
                    self.name = name
                    self.uid = uid
                }
            }

            public init(collections: [Collection]? = nil, description: String? = nil, environments: [Environment]? = nil, id: String? = nil, name: String? = nil, type: String? = nil) {
                self.collections = collections
                self.description = description
                self.environments = environments
                self.id = id
                self.name = name
                self.type = type
            }
        }

        public init(workspace: Workspace? = nil) {
            self.workspace = workspace
        }
    }
}

extension Paths {
    /// Update Workspace
    ///
    /// This endpoint allows you to update a workspace and update it's association to entities like `collections`, `environments`, `mocks` and `monitors` using their `uid`.
    /// 
    /// On successful updation of the workspace, the response returns the workspcae `name` and `id`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    /// 
    /// **Note** : The endpoint expects you to send the desired state of the workspace in terms of the associated entities so be careful when trying to update these entities.
    /// 
    /// For eg. if your workspace has collections A and B, and in the update call, you send C's uid in the collections array, then A and B would be removed from the workspace and C would be added.
    static public func updateWorkspace(workspaceID: String, workspace: UpdateWorkspaceRequest.Workspace? = nil) -> Request<UpdateWorkspaceResponse> {
        .put("/workspaces/\(workspaceID)", body: UpdateWorkspaceRequest(workspace: workspace))
    }

    public struct UpdateWorkspaceResponse: Decodable {
        public var workspace: Workspace?

        public struct Workspace: Decodable {
            /// Example: "cfbcd9bf-cc8b-4d6f-b8ef-440a3e49e29f"
            public var id: String?
            /// Example: "New Workspace"
            public var name: String?

            public init(id: String? = nil, name: String? = nil) {
                self.id = id
                self.name = name
            }
        }

        public init(workspace: Workspace? = nil) {
            self.workspace = workspace
        }
    }

    public struct UpdateWorkspaceRequest: Encodable {
        public var workspace: Workspace?

        public struct Workspace: Encodable {
            public var collections: [Collection]?
            /// Example: "Some description"
            public var description: String?
            public var environments: [Environment]?
            public var mocks: [Mock]?
            public var monitors: [Monitor]?
            /// Example: "New Workspace updated"
            public var name: String?

            public struct Collection: Encodable {
                /// Example: "e1fc3c38-a0b8-44a3-bd44-d753a96b2e9d"
                public var id: String?
                /// Example: "Straw hats"
                public var name: String?
                /// Example: "8154-e1fc3c38-a0b8-44a3-bd44-d753a96b2e9d"
                public var uid: String?

                public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                    self.id = id
                    self.name = name
                    self.uid = uid
                }
            }

            public struct Environment: Encodable {
                /// Example: "83a1aaa2-a204-4bd8-9b92-4d486918906b"
                public var id: String?
                /// Example: "env"
                public var name: String?
                /// Example: "8154-83a1aaa2-a204-4bd8-9b92-4d486918906b"
                public var uid: String?

                public init(id: String? = nil, name: String? = nil, uid: String? = nil) {
                    self.id = id
                    self.name = name
                    self.uid = uid
                }
            }

            public struct Mock: Encodable {
                /// Example: "cda672ef-1375-40e9-baee-e20ece8d7b65"
                public var id: String?

                public init(id: String? = nil) {
                    self.id = id
                }
            }

            public struct Monitor: Encodable {
                /// Example: "1e889bd2-3862-4be0-b2c2-9b1fe9673aec"
                public var id: String?

                public init(id: String? = nil) {
                    self.id = id
                }
            }

            public init(collections: [Collection]? = nil, description: String? = nil, environments: [Environment]? = nil, mocks: [Mock]? = nil, monitors: [Monitor]? = nil, name: String? = nil) {
                self.collections = collections
                self.description = description
                self.environments = environments
                self.mocks = mocks
                self.monitors = monitors
                self.name = name
            }
        }

        public init(workspace: Workspace? = nil) {
            self.workspace = workspace
        }
    }
}

extension Paths {
    /// Delete Workspace
    ///
    /// This endpoint allows you to delete an existing workspace.
    /// 
    /// On successful deletion of the workspace, the response returns the `id`.
    /// 
    /// > Requires <a href="#authentication">API Key</a> as `X-Api-Key` request header or `apikey` URL query parameter.
    static public func deleteWorkspace(workspaceID: String) -> Request<DeleteWorkspaceResponse> {
        .delete("/workspaces/\(workspaceID)")
    }

    public struct DeleteWorkspaceResponse: Decodable {
        public var workspace: Workspace?

        public struct Workspace: Decodable {
            /// Example: "{{workspace_id}}"
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public init(workspace: Workspace? = nil) {
            self.workspace = workspace
        }
    }
}

public enum Paths {}

extension Bool {
    var asQueryValue: String {
        self ? "true" : "false"
    }
}

extension Date {
    var asQueryValue: String {
        ISO8601DateFormatter().string(from: self)
    }
}

extension Double {
    var asQueryValue: String {
        String(self)
    }
}

extension Int {
    var asQueryValue: String {
        String(self)
    }
}

extension Int32 {
    var asQueryValue: String {
        String(self)
    }
}

extension Int64 {
    var asQueryValue: String {
        String(self)
    }
}

extension String {
    var asQueryValue: String {
        self
    }
}

extension URL {
    var asQueryValue: String {
        absoluteString
    }
}

extension RawRepresentable where RawValue == String {
    var asQueryValue: String {
        rawValue
    }
}

extension Array where Element == (String, String?) {
    mutating func addQueryItem(_ name: String, _ value: String?) {
        guard let value = value, !value.isEmpty else { return }
        append((name, value))
    }

    var asPercentEncodedQuery: String {
        var components = URLComponents()
        components.queryItems = self.map(URLQueryItem.init)
        return components.percentEncodedQuery ?? ""
    }
}
