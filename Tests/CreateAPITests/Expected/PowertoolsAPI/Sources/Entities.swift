// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// Example:
///
/// {
///   "ignorecase" : true,
///   "input" : [
///     "the",
///     "brown",
///     "cow "
///   ],
///   "match" : "cow",
///   "trim" : true
/// }
public struct InputCollectionSearch: Codable {
    /// Collection of strings to search
    public var input: [String]
    /// Text to match
    public var match: String
    /// Trim white space from comparison string
    public var trim: Trim?
    /// Ignore case when performing comparison
    public var ignorecase: Ignorecase?

    /// Trim white space from comparison string
    public enum Trim: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    /// Ignore case when performing comparison
    public enum Ignorecase: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(input: [String], match: String, trim: Trim? = nil, ignorecase: Ignorecase? = nil) {
        self.input = input
        self.match = match
        self.trim = trim
        self.ignorecase = ignorecase
    }
}

/// Example:
///
/// {
///   "input" : [
///     1.25,
///     10.5,
///     20.75,
///     51.25,
///     119.59999999999999,
///     301.25
///   ],
///   "match" : "1.25,",
///   "type" : "Decimal"
/// }
public struct InputCollectionSearchNumeric: Codable {
    /// Collection of strings to search
    public var input: [Double]
    /// Number to match
    public var match: Double
    /// Type of number - integer or decimal
    public var type: `Type`?

    /// Type of number - integer or decimal
    public enum `Type`: String, Codable, CaseIterable {
        case integer = "Integer"
        case decimal = "Decimal"
    }

    public init(input: [Double], match: Double, type: `Type`? = nil) {
        self.input = input
        self.match = match
        self.type = type
    }
}

/// Example:
///
/// {
///   "index" : "0",
///   "input" : [
///     "a",
///     "b",
///     "c"
///   ],
///   "item" : "d",
///   "items" : null
/// }
public struct InputCollectionModify: Codable {
    /// Collection of values or objects to modify
    public var input: [String]
    /// Item (for multiple items, leave blank and use Items)
    public var item: String?
    /// Items (Collection, for a single item leave blank and use Item)
    public var items: [String]?
    /// Index position for operation (leave blank to specify end of collection)
    public var index: String?

    public init(input: [String], item: String? = nil, items: [String]? = nil, index: String? = nil) {
        self.input = input
        self.item = item
        self.items = items
        self.index = index
    }
}

/// Example:
///
/// {
///   "input" : [
///     "the cow",
///     "jumped over",
///     "the moon"
///   ],
///   "keywords" : "cow,moon",
///   "match" : "Any"
/// }
public struct InputCollectionFilter: Codable {
    /// Collection of strings to filter
    public var input: [String]
    /// Match type
    public var match: Match
    /// Keywords (separate multiple values with commas)
    public var keywords: String

    /// Match type
    public enum Match: String, Codable, CaseIterable {
        case any = "Any"
        case all = "All"
        case `none` = "None"
    }

    public init(input: [String], match: Match, keywords: String) {
        self.input = input
        self.match = match
        self.keywords = keywords
    }
}

/// Example:
///
/// {
///   "input" : [
///     "a",
///     "d",
///     "c",
///     "b",
///     "e"
///   ],
///   "order" : "Ascending"
/// }
public struct InputCollectionSort: Codable {
    /// Collection of strings to sort
    public var input: [String]
    /// Sort order
    public var order: Order

    /// Sort order
    public enum Order: String, Codable, CaseIterable {
        case ascending = "Ascending"
        case descending = "Descending"
    }

    public init(input: [String], order: Order) {
        self.input = input
        self.order = order
    }
}

/// Example:
///
/// {
///   "input" : [
///     "a",
///     "d",
///     "c",
///     "b",
///     "e"
///   ]
/// }
public struct InputCollectionCount: Codable {
    /// Collection of items to count
    public var input: [String]

    public init(input: [String]) {
        self.input = input
    }
}

/// Example:
///
/// {
///   "index" : null,
///   "input" : [
///     "the cow",
///     "jumped over",
///     "the moon"
///   ],
///   "match" : "jumped over"
/// }
public struct InputCollectionSplit: Codable {
    /// Collection of items to split
    public var input: [String]
    /// String to match (explicit, case-insensitive, leave empty to use Index)
    public var match: String?
    /// Index location to split (leave empty to use Match value)
    public var index: String?

    public init(input: [String], match: String? = nil, index: String? = nil) {
        self.input = input
        self.match = match
        self.index = index
    }
}

/// Example:
///
/// {
///   "ignoreCase" : true,
///   "input" : [
///     "the brown cow",
///     "jumped over",
///     "the brown dog"
///   ],
///   "match" : "Brown",
///   "replacement" : "spotted"
/// }
public struct InputCollectionReplace: Codable {
    /// Collection of strings
    public var input: [String]
    /// Match value
    public var match: String
    /// Replacement value
    public var replacement: String
    /// Ignore case
    public var ignoreCase: IgnoreCase

    /// Ignore case
    public enum IgnoreCase: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(input: [String], match: String, replacement: String, ignoreCase: IgnoreCase) {
        self.input = input
        self.match = match
        self.replacement = replacement
        self.ignoreCase = ignoreCase
    }
}

/// Example:
///
/// {
///   "decimals" : 2,
///   "input" : 0.19592799999999999
/// }
public struct InputCalculateNumber: Codable {
    /// Numeric value to calculate
    public var input: Double
    /// Round to number of decimal places
    public var decimals: Double

    public init(input: Double, decimals: Double) {
        self.input = input
        self.decimals = decimals
    }
}

/// Example:
///
/// {
///   "decimals" : 2,
///   "input" : 4,
///   "value" : 2
/// }
public struct InputCalculateNumbers: Codable {
    /// Numeric value
    public var input: Double
    /// Addend, subtrahend, factor, divisor or radicand
    public var value: Double
    /// Round to number of decimal places
    public var decimals: Double

    public init(input: Double, value: Double, decimals: Double) {
        self.input = input
        self.value = value
        self.decimals = decimals
    }
}

/// Example:
///
/// {
///   "decimals" : 2,
///   "input" : [
///     1,
///     2,
///     3,
///     4,
///     5
///   ]
/// }
public struct InputCalculateSeries: Codable {
    /// Colllection of values to calculate
    public var input: [Double]
    /// Round to number of decimal places
    public var decimals: Double

    public init(input: [Double], decimals: Double) {
        self.input = input
        self.decimals = decimals
    }
}

/// Example:
///
/// {
///   "decimals" : 2,
///   "input" : 5.5300000000000002,
///   "power" : 4
/// }
public struct InputCalculatePower: Codable {
    /// Number to raise
    public var input: Double
    /// Power
    public var power: Double
    /// Round to number of decimal places
    public var decimals: Double

    public init(input: Double, power: Double, decimals: Double) {
        self.input = input
        self.power = power
        self.decimals = decimals
    }
}

/// Example:
///
/// {
///   "input" : [
///     1,
///     2,
///     3,
///     4,
///     5
///   ],
///   "type" : "Minimum"
/// }
public struct InputCalculateMinMax: Codable {
    /// Colllection of values to calculate
    public var input: [Double]
    /// Minimum or Maximum
    public var type: `Type`

    /// Minimum or Maximum
    public enum `Type`: String, Codable, CaseIterable {
        case minimum = "Minimum"
        case maximum = "Maximum"
    }

    public init(input: [Double], type: `Type`) {
        self.input = input
        self.type = type
    }
}

/// Example:
///
/// {
///   "input" : [
///     "a",
///     "b",
///     "c",
///     "d",
///     "e"
///   ],
///   "name" : "Items"
/// }
public struct InputCollectionConversion: Codable {
    /// Collection containing strings to convert
    public var input: [String]
    /// Collection name
    public var name: String

    public init(input: [String], name: String) {
        self.input = input
        self.name = name
    }
}

/// Example:
///
/// {
///   "child" : "Item",
///   "input" : [
///     "a",
///     "b",
///     "c",
///     "d",
///     "e"
///   ],
///   "root" : "Items"
/// }
public struct InputCollectionConversionXML: Codable {
    /// Collection containing strings to convert
    public var input: [String]
    /// Name of root XML node
    public var root: String
    /// Name of child XML node(s)
    public var child: String

    public init(input: [String], root: String, child: String) {
        self.input = input
        self.root = root
        self.child = child
    }
}

/// Example:
///
/// {
///   "alphacase" : "Upper",
///   "input" : "the brown cow"
/// }
public struct InputCaseConversion: Codable {
    /// String containing the text to convert
    public var input: String
    /// Case of conversion result
    public var alphacase: Alphacase

    /// Case of conversion result
    public enum Alphacase: String, Codable, CaseIterable {
        case upper = "Upper"
        case lower = "Lower"
        case title = "Title"
    }

    public init(input: String, alphacase: Alphacase) {
        self.input = input
        self.alphacase = alphacase
    }
}

/// Example:
///
/// {
///   "input" : 16.036843999999999,
///   "source" : "Arcminute",
///   "target" : "Arcsecond"
/// }
public struct InputConvertAngle: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case arcminute = "Arcminute"
        case arcsecond = "Arcsecond"
        case centiradian = "Centiradian"
        case deciradian = "Deciradian"
        case degree = "Degree"
        case gradian = "Gradian"
        case microdegree = "Microdegree"
        case microradian = "Microradian"
        case millidegree = "Millidegree"
        case milliradian = "Milliradian"
        case nanodegree = "Nanodegree"
        case nanoradian = "Nanoradian"
        case radian = "Radian"
        case revolution = "Revolution"
    }

    public enum Target: String, Codable, CaseIterable {
        case arcminute = "Arcminute"
        case arcsecond = "Arcsecond"
        case centiradian = "Centiradian"
        case deciradian = "Deciradian"
        case degree = "Degree"
        case gradian = "Gradian"
        case microdegree = "Microdegree"
        case microradian = "Microradian"
        case millidegree = "Millidegree"
        case milliradian = "Milliradian"
        case nanodegree = "Nanodegree"
        case nanoradian = "Nanoradian"
        case radian = "Radian"
        case revolution = "Revolution"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 0.66374999999999995,
///   "source" : "Day",
///   "target" : "Hour"
/// }
public struct InputConvertDuration: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case day = "Day"
        case hour = "Hour"
        case microsecond = "Microsecond"
        case millisecond = "Millisecond"
        case minute = "Minute"
        case month = "Month"
        case nanosecond = "Nanosecond"
        case second = "Second"
        case week = "Week"
        case year = "Year"
    }

    public enum Target: String, Codable, CaseIterable {
        case day = "Day"
        case hour = "Hour"
        case microsecond = "Microsecond"
        case millisecond = "Millisecond"
        case minute = "Minute"
        case month = "Month"
        case nanosecond = "Nanosecond"
        case second = "Second"
        case week = "Week"
        case year = "Year"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 0.525505,
///   "source" : "Meter",
///   "target" : "Foot"
/// }
public struct InputConvertDistance: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case centimeter = "Centimeter"
        case decimeter = "Decimeter"
        case fathom = "Fathom"
        case foot = "Foot"
        case hectometer = "Hectometer"
        case inch = "Inch"
        case kilometer = "Kilometer"
        case lightYear = "LightYear"
        case meter = "Meter"
        case micrometer = "Micrometer"
        case mile = "Mile"
        case millimeter = "Millimeter"
        case nanometer = "Nanometer"
        case nauticalMile = "NauticalMile"
        case yard = "Yard"
    }

    public enum Target: String, Codable, CaseIterable {
        case centimeter = "Centimeter"
        case decimeter = "Decimeter"
        case fathom = "Fathom"
        case foot = "Foot"
        case hectometer = "Hectometer"
        case inch = "Inch"
        case kilometer = "Kilometer"
        case lightYear = "LightYear"
        case meter = "Meter"
        case micrometer = "Micrometer"
        case mile = "Mile"
        case millimeter = "Millimeter"
        case nanometer = "Nanometer"
        case nauticalMile = "NauticalMile"
        case yard = "Yard"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 0.41671399999999997,
///   "source" : "Acre",
///   "target" : "SquareFoot"
/// }
public struct InputConvertArea: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case acre = "Acre"
        case hectare = "Hectare"
        case squareCentimeter = "SquareCentimeter"
        case squareDecimeter = "SquareDecimeter"
        case squareFoot = "SquareFoot"
        case squareInch = "SquareInch"
        case squareKilometer = "SquareKilometer"
        case squareMeter = "SquareMeter"
        case squareMicrometer = "SquareMicrometer"
        case squareMile = "SquareMile"
        case squareMillimeter = "SquareMillimeter"
        case squareYard = "SquareYard"
    }

    public enum Target: String, Codable, CaseIterable {
        case acre = "Acre"
        case hectare = "Hectare"
        case squareCentimeter = "SquareCentimeter"
        case squareDecimeter = "SquareDecimeter"
        case squareFoot = "SquareFoot"
        case squareInch = "SquareInch"
        case squareKilometer = "SquareKilometer"
        case squareMeter = "SquareMeter"
        case squareMicrometer = "SquareMicrometer"
        case squareMile = "SquareMile"
        case squareMillimeter = "SquareMillimeter"
        case squareYard = "SquareYard"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 0.39715499999999998,
///   "source" : "Calorie",
///   "target" : "Joule"
/// }
public struct InputConvertEnergy: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case britishThermalUnit = "BritishThermalUnit"
        case calorie = "Calorie"
        case electronVolt = "ElectronVolt"
        case footPound = "FootPound"
        case gigawattHour = "GigawattHour"
        case joule = "Joule"
        case kilocalorie = "Kilocalorie"
        case kilojoule = "Kilojoule"
        case kilowattHour = "KilowattHour"
        case megajoule = "Megajoule"
        case megawattHour = "MegawattHour"
        case terawattHour = "TerawattHour"
        case thermEU = "Therm (EU)"
        case thermUK = "Therm (UK)"
        case thermUS = "Therm (US)"
        case wattHour = "WattHour"
    }

    public enum Target: String, Codable, CaseIterable {
        case britishThermalUnit = "BritishThermalUnit"
        case calorie = "Calorie"
        case electronVolt = "ElectronVolt"
        case footPound = "FootPound"
        case gigawattHour = "GigawattHour"
        case joule = "Joule"
        case kilocalorie = "Kilocalorie"
        case kilojoule = "Kilojoule"
        case kilowattHour = "KilowattHour"
        case megajoule = "Megajoule"
        case megawattHour = "MegawattHour"
        case terawattHour = "TerawattHour"
        case thermEU = "Therm (EU)"
        case thermUK = "Therm (UK)"
        case thermUS = "Therm (US)"
        case wattHour = "WattHour"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 0.86610699999999996,
///   "source" : "Gigawatt",
///   "target" : "Kilowatt"
/// }
public struct InputConvertPower: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case britishThermalUnitPerHour = "BritishThermalUnitPerHour"
        case decawatt = "Decawatt"
        case deciwatt = "Deciwatt"
        case electricalHorsepower = "ElectricalHorsepower"
        case femtowatt = "Femtowatt"
        case gigawatt = "Gigawatt"
        case hydraulicHorsepower = "HydraulicHorsepower"
        case kilowatt = "Kilowatt"
        case mechanicalHorsepower = "MechanicalHorsepower"
        case megawatt = "Megawatt"
        case microwatt = "Microwatt"
        case milliwatt = "Milliwatt"
        case nanowatt = "Nanowatt"
        case petawatt = "Petawatt"
        case picowatt = "Picowatt"
        case terawatt = "Terawatt"
        case watt = "Watt"
    }

    public enum Target: String, Codable, CaseIterable {
        case britishThermalUnitPerHour = "BritishThermalUnitPerHour"
        case decawatt = "Decawatt"
        case deciwatt = "Deciwatt"
        case electricalHorsepower = "ElectricalHorsepower"
        case femtowatt = "Femtowatt"
        case gigawatt = "Gigawatt"
        case hydraulicHorsepower = "HydraulicHorsepower"
        case kilowatt = "Kilowatt"
        case mechanicalHorsepower = "MechanicalHorsepower"
        case megawatt = "Megawatt"
        case microwatt = "Microwatt"
        case milliwatt = "Milliwatt"
        case nanowatt = "Nanowatt"
        case petawatt = "Petawatt"
        case picowatt = "Picowatt"
        case terawatt = "Terawatt"
        case watt = "Watt"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 0.27805400000000002,
///   "source" : "Knot",
///   "target" : "MilePerHour"
/// }
public struct InputConvertSpeed: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case centimeterPerHour = "CentimeterPerHour"
        case centimeterPerMinute = "CentimeterPerMinute"
        case centimeterPerSecond = "CentimeterPerSecond"
        case decimeterPerMinute = "DecimeterPerMinute"
        case decimeterPerSecond = "DecimeterPerSecond"
        case footPerHour = "FootPerHour"
        case footPerMinute = "FootPerMinute"
        case footPerSecond = "FootPerSecond"
        case inchPerHour = "InchPerHour"
        case inchPerMinute = "InchPerMinute"
        case inchPerSecond = "InchPerSecond"
        case kilometerPerHour = "KilometerPerHour"
        case kilometerPerMinute = "KilometerPerMinute"
        case kilometerPerSecond = "KilometerPerSecond"
        case knot = "Knot"
        case meterPerHour = "MeterPerHour"
        case meterPerMinute = "MeterPerMinute"
        case meterPerSecond = "MeterPerSecond"
        case micrometerPerMinute = "MicrometerPerMinute"
        case micrometerPerSecond = "MicrometerPerSecond"
        case milePerHour = "MilePerHour"
        case millimeterPerHour = "MillimeterPerHour"
        case millimeterPerMinute = "MillimeterPerMinute"
        case millimeterPerSecond = "MillimeterPerSecond"
        case nanometerPerMinute = "NanometerPerMinute"
        case nanometerPerSecond = "NanometerPerSecond"
        case yardPerHour = "YardPerHour"
        case yardPerMinute = "YardPerMinute"
        case yardPerSecond = "YardPerSecond"
    }

    public enum Target: String, Codable, CaseIterable {
        case centimeterPerHour = "CentimeterPerHour"
        case centimeterPerMinute = "CentimeterPerMinute"
        case centimeterPerSecond = "CentimeterPerSecond"
        case decimeterPerMinute = "DecimeterPerMinute"
        case decimeterPerSecond = "DecimeterPerSecond"
        case footPerHour = "FootPerHour"
        case footPerMinute = "FootPerMinute"
        case footPerSecond = "FootPerSecond"
        case inchPerHour = "InchPerHour"
        case inchPerMinute = "InchPerMinute"
        case inchPerSecond = "InchPerSecond"
        case kilometerPerHour = "KilometerPerHour"
        case kilometerPerMinute = "KilometerPerMinute"
        case kilometerPerSecond = "KilometerPerSecond"
        case knot = "Knot"
        case meterPerHour = "MeterPerHour"
        case meterPerMinute = "MeterPerMinute"
        case meterPerSecond = "MeterPerSecond"
        case micrometerPerMinute = "MicrometerPerMinute"
        case micrometerPerSecond = "MicrometerPerSecond"
        case milePerHour = "MilePerHour"
        case millimeterPerHour = "MillimeterPerHour"
        case millimeterPerMinute = "MillimeterPerMinute"
        case millimeterPerSecond = "MillimeterPerSecond"
        case nanometerPerMinute = "NanometerPerMinute"
        case nanometerPerSecond = "NanometerPerSecond"
        case yardPerHour = "YardPerHour"
        case yardPerMinute = "YardPerMinute"
        case yardPerSecond = "YardPerSecond"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 10,
///   "source" : "Celsius",
///   "target" : "Fahrenheit"
/// }
public struct InputConvertTemperature: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case celsius = "Celsius"
        case fahrenheit = "Fahrenheit"
        case newton = "Newton"
        case kelvin = "Kelvin"
    }

    public enum Target: String, Codable, CaseIterable {
        case celsius = "Celsius"
        case fahrenheit = "Fahrenheit"
        case newton = "Newton"
        case kelvin = "Kelvin"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 1.5,
///   "source" : "CubicFoot",
///   "target" : "CubicMeter"
/// }
public struct InputConvertVolume: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case centiliter = "Centiliter"
        case cubicCentimeter = "CubicCentimeter"
        case cubicDecimeter = "CubicDecimeter"
        case cubicFoot = "CubicFoot"
        case cubicHectometer = "CubicHectometer"
        case cubicInch = "CubicInch"
        case cubicKilometer = "CubicKilometer"
        case cubicMeter = "CubicMeter"
        case cubicMillimeter = "CubicMillimeter"
        case cubicYard = "CubicYard"
        case deciliter = "Deciliter"
        case imperialBeerBarrel = "ImperialBeerBarrel"
        case imperialGallon = "ImperialGallon"
        case imperialOunce = "ImperialOunce"
        case imperialPint = "ImperialPint"
        case kiloliter = "Kiloliter"
        case liter = "Liter"
        case microliter = "Microliter"
        case milliliter = "Milliliter"
        case gallon = "Gallon"
        case cup = "Cup"
        case ounce = "Ounce"
        case pint = "Pint"
        case quart = "Quart"
        case tablespoon = "Tablespoon"
        case teaspoon = "Teaspoon"
    }

    public enum Target: String, Codable, CaseIterable {
        case centiliter = "Centiliter"
        case cubicCentimeter = "CubicCentimeter"
        case cubicDecimeter = "CubicDecimeter"
        case cubicFoot = "CubicFoot"
        case cubicHectometer = "CubicHectometer"
        case cubicInch = "CubicInch"
        case cubicKilometer = "CubicKilometer"
        case cubicMeter = "CubicMeter"
        case cubicMillimeter = "CubicMillimeter"
        case cubicYard = "CubicYard"
        case deciliter = "Deciliter"
        case imperialBeerBarrel = "ImperialBeerBarrel"
        case imperialGallon = "ImperialGallon"
        case imperialOunce = "ImperialOunce"
        case imperialPint = "ImperialPint"
        case kiloliter = "Kiloliter"
        case liter = "Liter"
        case microliter = "Microliter"
        case milliliter = "Milliliter"
        case gallon = "Gallon"
        case cup = "Cup"
        case ounce = "Ounce"
        case pint = "Pint"
        case quart = "Quart"
        case tablespoon = "Tablespoon"
        case teaspoon = "Teaspoon"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 5.7000000000000002,
///   "source" : "Gram",
///   "target" : "Ounce"
/// }
public struct InputConvertWeight: Codable {
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case centigram = "Centigram"
        case decagram = "Decagram"
        case decigram = "Decigram"
        case grain = "Grain"
        case gram = "Gram"
        case hectogram = "Hectogram"
        case kilogram = "Kilogram"
        case microgram = "Microgram"
        case milligram = "Milligram"
        case nanogram = "Nanogram"
        case ounce = "Ounce"
        case pound = "Pound"
        case stone = "Stone"
        case solarMass = "Solar Mass"
        case earthMass = "Earth Mass"
        case slug = "Slug"
        case shortTon = "Short Ton"
        case longTon = "Long Ton"
        case ton = "Ton"
        case megaton = "Megaton"
        case shortHundredweight = "Short Hundredweight"
        case longHundredweight = "Long Hundredweight"
    }

    public enum Target: String, Codable, CaseIterable {
        case centigram = "Centigram"
        case decagram = "Decagram"
        case decigram = "Decigram"
        case grain = "Grain"
        case gram = "Gram"
        case hectogram = "Hectogram"
        case kilogram = "Kilogram"
        case microgram = "Microgram"
        case milligram = "Milligram"
        case nanogram = "Nanogram"
        case ounce = "Ounce"
        case pound = "Pound"
        case stone = "Stone"
        case ton = "Ton"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "header" : true,
///   "input" : "Property1,Property2,Property3\r\nvalue,value,value\r\nvalue,value,value"
/// }
public struct InputCsvConversionJSON: Codable {
    /// CSV string
    public var input: String
    /// Include header row
    public var isHeader: Bool

    public init(input: String, isHeader: Bool) {
        self.input = input
        self.isHeader = isHeader
    }

    private enum CodingKeys: String, CodingKey {
        case input
        case isHeader = "header"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.input = try values.decode(String.self, forKey: .input)
        self.isHeader = try values.decode(Bool.self, forKey: .isHeader)
    }
}

/// Example:
///
/// {
///   "input" : 100.25,
///   "source" : "USD",
///   "target" : "CAD"
/// }
public struct InputCurrencyConversion: Codable {
    /// Amount to convert
    public var input: Double
    public var source: Source
    public var target: Target

    public enum Source: String, Codable, CaseIterable {
        case usd = "USD"
        case aud = "AUD"
        case bgn = "BGN"
        case brl = "BRL"
        case cad = "CAD"
        case chf = "CHF"
        case cny = "CNY"
        case czk = "CZK"
        case dkk = "DKK"
        case eur = "EUR"
        case gbp = "GBP"
        case hkd = "HKD"
        case hrk = "HRK"
        case huf = "HUF"
        case idr = "IDR"
        case ils = "ILS"
        case inr = "INR"
        case isk = "ISK"
        case jpy = "JPY"
        case krw = "KRW"
        case mxn = "MXN"
        case myr = "MYR"
        case nok = "NOK"
        case nzd = "NZD"
        case php = "PHP"
        case pln = "PLN"
        case ron = "RON"
        case rub = "RUB"
        case sgd = "SGD"
        case sek = "SEK"
        case thb = "THB"
        case `try` = "TRY"
        case zar = "ZAR"
    }

    public enum Target: String, Codable, CaseIterable {
        case usd = "USD"
        case aud = "AUD"
        case bgn = "BGN"
        case brl = "BRL"
        case cad = "CAD"
        case chf = "CHF"
        case cny = "CNY"
        case czk = "CZK"
        case dkk = "DKK"
        case eur = "EUR"
        case gbp = "GBP"
        case hkd = "HKD"
        case hrk = "HRK"
        case huf = "HUF"
        case idr = "IDR"
        case ils = "ILS"
        case inr = "INR"
        case isk = "ISK"
        case jpy = "JPY"
        case krw = "KRW"
        case mxn = "MXN"
        case myr = "MYR"
        case nok = "NOK"
        case nzd = "NZD"
        case php = "PHP"
        case pln = "PLN"
        case ron = "RON"
        case rub = "RUB"
        case sgd = "SGD"
        case sek = "SEK"
        case thb = "THB"
        case `try` = "TRY"
        case zar = "ZAR"
    }

    public init(input: Double, source: Source, target: Target) {
        self.input = input
        self.source = source
        self.target = target
    }
}

/// Example:
///
/// {
///   "input" : 10980.790000000001,
///   "target" : "GBP"
/// }
public struct InputCurrencyFormat: Codable {
    /// Amount to format
    public var input: Double
    public var target: Target

    public enum Target: String, Codable, CaseIterable {
        case usd = "USD"
        case aud = "AUD"
        case bgn = "BGN"
        case brl = "BRL"
        case cad = "CAD"
        case chf = "CHF"
        case cny = "CNY"
        case czk = "CZK"
        case dkk = "DKK"
        case eur = "EUR"
        case gbp = "GBP"
        case hkd = "HKD"
        case hrk = "HRK"
        case huf = "HUF"
        case idr = "IDR"
        case ils = "ILS"
        case inr = "INR"
        case isk = "ISK"
        case jpy = "JPY"
        case krw = "KRW"
        case mxn = "MXN"
        case myr = "MYR"
        case nok = "NOK"
        case nzd = "NZD"
        case php = "PHP"
        case pln = "PLN"
        case ron = "RON"
        case rub = "RUB"
        case sgd = "SGD"
        case sek = "SEK"
        case thb = "THB"
        case `try` = "TRY"
        case zar = "ZAR"
    }

    public init(input: Double, target: Target) {
        self.input = input
        self.target = target
    }
}

/// Example:
///
/// {
///   "format" : "yyyy-MM-dd HH:mm:ss",
///   "input" : "03\/10\/2010 09:00:00",
///   "source" : "GMT Standard Time - (GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London",
///   "target" : "Central Standard Time - (GMT-06:00) Central Time (US & Canada)"
/// }
public struct InputDateTimeConversion: Codable {
    /// Source date and time
    public var input: String
    public var source: Source
    public var target: Target
    /// Display format (defaults to 'yyyy-MM-dd HH:mm:ss')
    public var format: String?

    public enum Source: String, Codable, CaseIterable {
        case gMTStandardTimeGMTGreenwichMeanTimeDublinEdinburghLisbonLondon = "GMT Standard Time - (GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London"
        case greenwichStandardTimeGMTMonroviaReykjavik = "Greenwich Standard Time - (GMT) Monrovia, Reykjavik"
        case wEuropeStandardTimeGMT0100AmsterdamBerlinBernRomeStockholmVienna = "W. Europe Standard Time - (GMT+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna"
        case centralEuropeStandardTimeGMT0100BelgradeBratislavaBudapestLjubljanaPrague = "Central Europe Standard Time - (GMT+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague"
        case centralEuropeanStandardTimeGMT0100SarajevoSkopjeWarsawZagreb = "Central European Standard Time - (GMT+01:00) Sarajevo, Skopje, Warsaw, Zagreb"
        case wCentralAfricaStandardTimeGMT0100WestCentralAfrica = "W. Central Africa Standard Time - (GMT+01:00) West Central Africa"
        case gTBStandardTimeGMT0200AthensBucharestIstanbul = "GTB Standard Time - (GMT+02:00) Athens, Bucharest, Istanbul"
        case middleEastStandardTimeGMT0200Beirut = "Middle East Standard Time - (GMT+02:00) Beirut"
        case egyptStandardTimeGMT0200Cairo = "Egypt Standard Time - (GMT+02:00) Cairo"
        case southAfricaStandardTimeGMT0200HararePretoria = "South Africa Standard Time - (GMT+02:00) Harare, Pretoria"
        case fLEStandardTimeGMT0200HelsinkiKyivRigaSofiaTallinnVilnius = "FLE Standard Time - (GMT+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius"
        case israelStandardTimeGMT0200Jerusalem = "Israel Standard Time - (GMT+02:00) Jerusalem"
        case eEuropeStandardTimeGMT0200Minsk = "E. Europe Standard Time - (GMT+02:00) Minsk"
        case namibiaStandardTimeGMT0200Windhoek = "Namibia Standard Time - (GMT+02:00) Windhoek"
        case arabicStandardTimeGMT0300Baghdad = "Arabic Standard Time - (GMT+03:00) Baghdad"
        case arabStandardTimeGMT0300KuwaitRiyadh = "Arab Standard Time - (GMT+03:00) Kuwait, Riyadh"
        case russianStandardTimeGMT0300MoscowStPetersburgVolgograd = "Russian Standard Time - (GMT+03:00) Moscow, St. Petersburg, Volgograd"
        case eAfricaStandardTimeGMT0300Nairobi = "E. Africa Standard Time - (GMT+03:00) Nairobi"
        case georgianStandardTimeGMT0300Tbilisi = "Georgian Standard Time - (GMT+03:00) Tbilisi"
        case iranStandardTimeGMT0330Tehran = "Iran Standard Time - (GMT+03:30) Tehran"
        case arabianStandardTimeGMT0400AbuDhabiMuscat = "Arabian Standard Time - (GMT+04:00) Abu Dhabi, Muscat"
        case azerbaijanStandardTimeGMT0400Baku = "Azerbaijan Standard Time - (GMT+04:00) Baku"
        case mauritiusStandardTimeGMT0400PortLouis = "Mauritius Standard Time - (GMT+04:00) Port Louis"
        case caucasusStandardTimeGMT0400Yerevan = "Caucasus Standard Time - (GMT+04:00) Yerevan"
        case afghanistanStandardTimeGMT0430Kabul = "Afghanistan Standard Time - (GMT+04:30) Kabul"
        case ekaterinburgStandardTimeGMT0500Ekaterinburg = "Ekaterinburg Standard Time - (GMT+05:00) Ekaterinburg"
        case pakistanStandardTimeGMT0500IslamabadKarachi = "Pakistan Standard Time - (GMT+05:00) Islamabad, Karachi"
        case westAsiaStandardTimeGMT0500Tashkent = "West Asia Standard Time - (GMT+05:00) Tashkent"
        case indiaStandardTimeGMT0530ChennaiKolkataMumbaiNewDelhi = "India Standard Time - (GMT+05:30) Chennai, Kolkata, Mumbai, New Delhi"
        case sriLankaStandardTimeGMT0530SriJayawardenepura = "Sri Lanka Standard Time - (GMT+05:30) Sri Jayawardenepura"
        case nepalStandardTimeGMT0545Kathmandu = "Nepal Standard Time - (GMT+05:45) Kathmandu"
        case nCentralAsiaStandardTimeGMT0600AlmatyNovosibirsk = "N. Central Asia Standard Time - (GMT+06:00) Almaty, Novosibirsk"
        case centralAsiaStandardTimeGMT0600AstanaDhaka = "Central Asia Standard Time - (GMT+06:00) Astana, Dhaka"
        case myanmarStandardTimeGMT0630YangonRangoon = "Myanmar Standard Time - (GMT+06:30) Yangon (Rangoon)"
        case sEAsiaStandardTimeGMT0700BangkokHanoiJakarta = "SE Asia Standard Time - (GMT+07:00) Bangkok, Hanoi, Jakarta"
        case northAsiaStandardTimeGMT0700Krasnoyarsk = "North Asia Standard Time - (GMT+07:00) Krasnoyarsk"
        case chinaStandardTimeGMT0800BeijingChongqingHongKongUrumqi = "China Standard Time - (GMT+08:00) Beijing, Chongqing, Hong Kong, Urumqi"
        case northAsiaEastStandardTimeGMT0800IrkutskUlaanBataar = "North Asia East Standard Time - (GMT+08:00) Irkutsk, Ulaan Bataar"
        case singaporeStandardTimeGMT0800KualaLumpurSingapore = "Singapore Standard Time - (GMT+08:00) Kuala Lumpur, Singapore"
        case wAustraliaStandardTimeGMT0800Perth = "W. Australia Standard Time - (GMT+08:00) Perth"
        case taipeiStandardTimeGMT0800Taipei = "Taipei Standard Time - (GMT+08:00) Taipei"
        case tokyoStandardTimeGMT0900OsakaSapporoTokyo = "Tokyo Standard Time - (GMT+09:00) Osaka, Sapporo, Tokyo"
        case koreaStandardTimeGMT0900Seoul = "Korea Standard Time - (GMT+09:00) Seoul"
        case yakutskStandardTimeGMT0900Yakutsk = "Yakutsk Standard Time - (GMT+09:00) Yakutsk"
        case cenAustraliaStandardTimeGMT0930Adelaide = "Cen. Australia Standard Time - (GMT+09:30) Adelaide"
        case aUSCentralStandardTimeGMT0930Darwin = "AUS Central Standard Time - (GMT+09:30) Darwin"
        case eAustraliaStandardTimeGMT1000Brisbane = "E. Australia Standard Time - (GMT+10:00) Brisbane"
        case aUSEasternStandardTimeGMT1000CanberraMelbourneSydney = "AUS Eastern Standard Time - (GMT+10:00) Canberra, Melbourne, Sydney"
        case westPacificStandardTimeGMT1000GuamPortMoresby = "West Pacific Standard Time - (GMT+10:00) Guam, Port Moresby"
        case tasmaniaStandardTimeGMT1000Hobart = "Tasmania Standard Time - (GMT+10:00) Hobart"
        case vladivostokStandardTimeGMT1000Vladivostok = "Vladivostok Standard Time - (GMT+10:00) Vladivostok"
        case centralPacificStandardTimeGMT1100MagadanSolomonIsNewCaledonia = "Central Pacific Standard Time - (GMT+11:00) Magadan, Solomon Is., New Caledonia"
        case newZealandStandardTimeGMT1200AucklandWellington = "New Zealand Standard Time - (GMT+12:00) Auckland, Wellington"
        case fijiStandardTimeGMT1200FijiKamchatkaMarshallIs = "Fiji Standard Time - (GMT+12:00) Fiji, Kamchatka, Marshall Is."
        case tongaStandardTimeGMT1300Nukualofa = "Tonga Standard Time - (GMT+13:00) Nuku'alofa"
        case azoresStandardTimeGMT0100Azores = "Azores Standard Time - (GMT-01:00) Azores"
        case capeVerdeStandardTimeGMT0100CapeVerdeIs = "Cape Verde Standard Time - (GMT-01:00) Cape Verde Is."
        case midAtlanticStandardTimeGMT0200MidAtlantic = "Mid-Atlantic Standard Time - (GMT-02:00) Mid-Atlantic"
        case eSouthAmericaStandardTimeGMT0300Brasilia = "E. South America Standard Time - (GMT-03:00) Brasilia"
        case argentinaStandardTimeGMT0300BuenosAires = "Argentina Standard Time - (GMT-03:00) Buenos Aires"
        case sAEasternStandardTimeGMT0300Georgetown = "SA Eastern Standard Time - (GMT-03:00) Georgetown"
        case greenlandStandardTimeGMT0300Greenland = "Greenland Standard Time - (GMT-03:00) Greenland"
        case montevideoStandardTimeGMT0300Montevideo = "Montevideo Standard Time - (GMT-03:00) Montevideo"
        case newfoundlandStandardTimeGMT0330Newfoundland = "Newfoundland Standard Time - (GMT-03:30) Newfoundland"
        case atlanticStandardTimeGMT0400AtlanticTimeCanada = "Atlantic Standard Time - (GMT-04:00) Atlantic Time (Canada)"
        case sAWesternStandardTimeGMT0400LaPaz = "SA Western Standard Time - (GMT-04:00) La Paz"
        case centralBrazilianStandardTimeGMT0400Manaus = "Central Brazilian Standard Time - (GMT-04:00) Manaus"
        case pacificSAStandardTimeGMT0400Santiago = "Pacific SA Standard Time - (GMT-04:00) Santiago"
        case venezuelaStandardTimeGMT0430Caracas = "Venezuela Standard Time - (GMT-04:30) Caracas"
        case sAPacificStandardTimeGMT0500BogotaLimaQuitoRioBranco = "SA Pacific Standard Time - (GMT-05:00) Bogota, Lima, Quito, Rio Branco"
        case easternStandardTimeGMT0500EasternTimeUSCanada = "Eastern Standard Time - (GMT-05:00) Eastern Time (US & Canada)"
        case uSEasternStandardTimeGMT0500IndianaEast = "US Eastern Standard Time - (GMT-05:00) Indiana (East)"
        case centralAmericaStandardTimeGMT0600CentralAmerica = "Central America Standard Time - (GMT-06:00) Central America"
        case centralStandardTimeGMT0600CentralTimeUSCanada = "Central Standard Time - (GMT-06:00) Central Time (US & Canada)"
        case centralStandardTimeMexicoGMT0600GuadalajaraMexicoCityMonterrey = "Central Standard Time (Mexico) - (GMT-06:00) Guadalajara, Mexico City, Monterrey"
        case canadaCentralStandardTimeGMT0600Saskatchewan = "Canada Central Standard Time - (GMT-06:00) Saskatchewan"
        case uSMountainStandardTimeGMT0700Arizona = "US Mountain Standard Time - (GMT-07:00) Arizona"
        case mountainStandardTimeMexicoGMT0700ChihuahuaLaPazMazatlan = "Mountain Standard Time (Mexico) - (GMT-07:00) Chihuahua, La Paz, Mazatlan"
        case mountainStandardTimeGMT0700MountainTimeUSCanada = "Mountain Standard Time - (GMT-07:00) Mountain Time (US & Canada)"
        case pacificStandardTimeGMT0800PacificTimeUSCanada = "Pacific Standard Time - (GMT-08:00) Pacific Time (US & Canada)"
        case pacificStandardTimeMexicoGMT0800TijuanaBajaCalifornia = "Pacific Standard Time (Mexico) - (GMT-08:00) Tijuana, Baja California"
        case alaskanStandardTimeGMT0900Alaska = "Alaskan Standard Time - (GMT-09:00) Alaska"
        case hawaiianStandardTimeGMT1000Hawaii = "Hawaiian Standard Time - (GMT-10:00) Hawaii"
        case samoaStandardTimeGMT1100MidwayIslandSamoa = "Samoa Standard Time - (GMT-11:00) Midway Island, Samoa"
        case datelineStandardTimeGMT1200InternationalDateLineWest = "Dateline Standard Time - (GMT-12:00) International Date Line West"
    }

    public enum Target: String, Codable, CaseIterable {
        case gMTStandardTimeGMTGreenwichMeanTimeDublinEdinburghLisbonLondon = "GMT Standard Time - (GMT) Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London"
        case greenwichStandardTimeGMTMonroviaReykjavik = "Greenwich Standard Time - (GMT) Monrovia, Reykjavik"
        case wEuropeStandardTimeGMT0100AmsterdamBerlinBernRomeStockholmVienna = "W. Europe Standard Time - (GMT+01:00) Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna"
        case centralEuropeStandardTimeGMT0100BelgradeBratislavaBudapestLjubljanaPrague = "Central Europe Standard Time - (GMT+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague"
        case centralEuropeanStandardTimeGMT0100SarajevoSkopjeWarsawZagreb = "Central European Standard Time - (GMT+01:00) Sarajevo, Skopje, Warsaw, Zagreb"
        case wCentralAfricaStandardTimeGMT0100WestCentralAfrica = "W. Central Africa Standard Time - (GMT+01:00) West Central Africa"
        case gTBStandardTimeGMT0200AthensBucharestIstanbul = "GTB Standard Time - (GMT+02:00) Athens, Bucharest, Istanbul"
        case middleEastStandardTimeGMT0200Beirut = "Middle East Standard Time - (GMT+02:00) Beirut"
        case egyptStandardTimeGMT0200Cairo = "Egypt Standard Time - (GMT+02:00) Cairo"
        case southAfricaStandardTimeGMT0200HararePretoria = "South Africa Standard Time - (GMT+02:00) Harare, Pretoria"
        case fLEStandardTimeGMT0200HelsinkiKyivRigaSofiaTallinnVilnius = "FLE Standard Time - (GMT+02:00) Helsinki, Kyiv, Riga, Sofia, Tallinn, Vilnius"
        case israelStandardTimeGMT0200Jerusalem = "Israel Standard Time - (GMT+02:00) Jerusalem"
        case eEuropeStandardTimeGMT0200Minsk = "E. Europe Standard Time - (GMT+02:00) Minsk"
        case namibiaStandardTimeGMT0200Windhoek = "Namibia Standard Time - (GMT+02:00) Windhoek"
        case arabicStandardTimeGMT0300Baghdad = "Arabic Standard Time - (GMT+03:00) Baghdad"
        case arabStandardTimeGMT0300KuwaitRiyadh = "Arab Standard Time - (GMT+03:00) Kuwait, Riyadh"
        case russianStandardTimeGMT0300MoscowStPetersburgVolgograd = "Russian Standard Time - (GMT+03:00) Moscow, St. Petersburg, Volgograd"
        case eAfricaStandardTimeGMT0300Nairobi = "E. Africa Standard Time - (GMT+03:00) Nairobi"
        case georgianStandardTimeGMT0300Tbilisi = "Georgian Standard Time - (GMT+03:00) Tbilisi"
        case iranStandardTimeGMT0330Tehran = "Iran Standard Time - (GMT+03:30) Tehran"
        case arabianStandardTimeGMT0400AbuDhabiMuscat = "Arabian Standard Time - (GMT+04:00) Abu Dhabi, Muscat"
        case azerbaijanStandardTimeGMT0400Baku = "Azerbaijan Standard Time - (GMT+04:00) Baku"
        case mauritiusStandardTimeGMT0400PortLouis = "Mauritius Standard Time - (GMT+04:00) Port Louis"
        case caucasusStandardTimeGMT0400Yerevan = "Caucasus Standard Time - (GMT+04:00) Yerevan"
        case afghanistanStandardTimeGMT0430Kabul = "Afghanistan Standard Time - (GMT+04:30) Kabul"
        case ekaterinburgStandardTimeGMT0500Ekaterinburg = "Ekaterinburg Standard Time - (GMT+05:00) Ekaterinburg"
        case pakistanStandardTimeGMT0500IslamabadKarachi = "Pakistan Standard Time - (GMT+05:00) Islamabad, Karachi"
        case westAsiaStandardTimeGMT0500Tashkent = "West Asia Standard Time - (GMT+05:00) Tashkent"
        case indiaStandardTimeGMT0530ChennaiKolkataMumbaiNewDelhi = "India Standard Time - (GMT+05:30) Chennai, Kolkata, Mumbai, New Delhi"
        case sriLankaStandardTimeGMT0530SriJayawardenepura = "Sri Lanka Standard Time - (GMT+05:30) Sri Jayawardenepura"
        case nepalStandardTimeGMT0545Kathmandu = "Nepal Standard Time - (GMT+05:45) Kathmandu"
        case nCentralAsiaStandardTimeGMT0600AlmatyNovosibirsk = "N. Central Asia Standard Time - (GMT+06:00) Almaty, Novosibirsk"
        case centralAsiaStandardTimeGMT0600AstanaDhaka = "Central Asia Standard Time - (GMT+06:00) Astana, Dhaka"
        case myanmarStandardTimeGMT0630YangonRangoon = "Myanmar Standard Time - (GMT+06:30) Yangon (Rangoon)"
        case sEAsiaStandardTimeGMT0700BangkokHanoiJakarta = "SE Asia Standard Time - (GMT+07:00) Bangkok, Hanoi, Jakarta"
        case northAsiaStandardTimeGMT0700Krasnoyarsk = "North Asia Standard Time - (GMT+07:00) Krasnoyarsk"
        case chinaStandardTimeGMT0800BeijingChongqingHongKongUrumqi = "China Standard Time - (GMT+08:00) Beijing, Chongqing, Hong Kong, Urumqi"
        case northAsiaEastStandardTimeGMT0800IrkutskUlaanBataar = "North Asia East Standard Time - (GMT+08:00) Irkutsk, Ulaan Bataar"
        case singaporeStandardTimeGMT0800KualaLumpurSingapore = "Singapore Standard Time - (GMT+08:00) Kuala Lumpur, Singapore"
        case wAustraliaStandardTimeGMT0800Perth = "W. Australia Standard Time - (GMT+08:00) Perth"
        case taipeiStandardTimeGMT0800Taipei = "Taipei Standard Time - (GMT+08:00) Taipei"
        case tokyoStandardTimeGMT0900OsakaSapporoTokyo = "Tokyo Standard Time - (GMT+09:00) Osaka, Sapporo, Tokyo"
        case koreaStandardTimeGMT0900Seoul = "Korea Standard Time - (GMT+09:00) Seoul"
        case yakutskStandardTimeGMT0900Yakutsk = "Yakutsk Standard Time - (GMT+09:00) Yakutsk"
        case cenAustraliaStandardTimeGMT0930Adelaide = "Cen. Australia Standard Time - (GMT+09:30) Adelaide"
        case aUSCentralStandardTimeGMT0930Darwin = "AUS Central Standard Time - (GMT+09:30) Darwin"
        case eAustraliaStandardTimeGMT1000Brisbane = "E. Australia Standard Time - (GMT+10:00) Brisbane"
        case aUSEasternStandardTimeGMT1000CanberraMelbourneSydney = "AUS Eastern Standard Time - (GMT+10:00) Canberra, Melbourne, Sydney"
        case westPacificStandardTimeGMT1000GuamPortMoresby = "West Pacific Standard Time - (GMT+10:00) Guam, Port Moresby"
        case tasmaniaStandardTimeGMT1000Hobart = "Tasmania Standard Time - (GMT+10:00) Hobart"
        case vladivostokStandardTimeGMT1000Vladivostok = "Vladivostok Standard Time - (GMT+10:00) Vladivostok"
        case centralPacificStandardTimeGMT1100MagadanSolomonIsNewCaledonia = "Central Pacific Standard Time - (GMT+11:00) Magadan, Solomon Is., New Caledonia"
        case newZealandStandardTimeGMT1200AucklandWellington = "New Zealand Standard Time - (GMT+12:00) Auckland, Wellington"
        case fijiStandardTimeGMT1200FijiKamchatkaMarshallIs = "Fiji Standard Time - (GMT+12:00) Fiji, Kamchatka, Marshall Is."
        case tongaStandardTimeGMT1300Nukualofa = "Tonga Standard Time - (GMT+13:00) Nuku'alofa"
        case azoresStandardTimeGMT0100Azores = "Azores Standard Time - (GMT-01:00) Azores"
        case capeVerdeStandardTimeGMT0100CapeVerdeIs = "Cape Verde Standard Time - (GMT-01:00) Cape Verde Is."
        case midAtlanticStandardTimeGMT0200MidAtlantic = "Mid-Atlantic Standard Time - (GMT-02:00) Mid-Atlantic"
        case eSouthAmericaStandardTimeGMT0300Brasilia = "E. South America Standard Time - (GMT-03:00) Brasilia"
        case argentinaStandardTimeGMT0300BuenosAires = "Argentina Standard Time - (GMT-03:00) Buenos Aires"
        case sAEasternStandardTimeGMT0300Georgetown = "SA Eastern Standard Time - (GMT-03:00) Georgetown"
        case greenlandStandardTimeGMT0300Greenland = "Greenland Standard Time - (GMT-03:00) Greenland"
        case montevideoStandardTimeGMT0300Montevideo = "Montevideo Standard Time - (GMT-03:00) Montevideo"
        case newfoundlandStandardTimeGMT0330Newfoundland = "Newfoundland Standard Time - (GMT-03:30) Newfoundland"
        case atlanticStandardTimeGMT0400AtlanticTimeCanada = "Atlantic Standard Time - (GMT-04:00) Atlantic Time (Canada)"
        case sAWesternStandardTimeGMT0400LaPaz = "SA Western Standard Time - (GMT-04:00) La Paz"
        case centralBrazilianStandardTimeGMT0400Manaus = "Central Brazilian Standard Time - (GMT-04:00) Manaus"
        case pacificSAStandardTimeGMT0400Santiago = "Pacific SA Standard Time - (GMT-04:00) Santiago"
        case venezuelaStandardTimeGMT0430Caracas = "Venezuela Standard Time - (GMT-04:30) Caracas"
        case sAPacificStandardTimeGMT0500BogotaLimaQuitoRioBranco = "SA Pacific Standard Time - (GMT-05:00) Bogota, Lima, Quito, Rio Branco"
        case easternStandardTimeGMT0500EasternTimeUSCanada = "Eastern Standard Time - (GMT-05:00) Eastern Time (US & Canada)"
        case uSEasternStandardTimeGMT0500IndianaEast = "US Eastern Standard Time - (GMT-05:00) Indiana (East)"
        case centralAmericaStandardTimeGMT0600CentralAmerica = "Central America Standard Time - (GMT-06:00) Central America"
        case centralStandardTimeGMT0600CentralTimeUSCanada = "Central Standard Time - (GMT-06:00) Central Time (US & Canada)"
        case centralStandardTimeMexicoGMT0600GuadalajaraMexicoCityMonterrey = "Central Standard Time (Mexico) - (GMT-06:00) Guadalajara, Mexico City, Monterrey"
        case canadaCentralStandardTimeGMT0600Saskatchewan = "Canada Central Standard Time - (GMT-06:00) Saskatchewan"
        case uSMountainStandardTimeGMT0700Arizona = "US Mountain Standard Time - (GMT-07:00) Arizona"
        case mountainStandardTimeMexicoGMT0700ChihuahuaLaPazMazatlan = "Mountain Standard Time (Mexico) - (GMT-07:00) Chihuahua, La Paz, Mazatlan"
        case mountainStandardTimeGMT0700MountainTimeUSCanada = "Mountain Standard Time - (GMT-07:00) Mountain Time (US & Canada)"
        case pacificStandardTimeGMT0800PacificTimeUSCanada = "Pacific Standard Time - (GMT-08:00) Pacific Time (US & Canada)"
        case pacificStandardTimeMexicoGMT0800TijuanaBajaCalifornia = "Pacific Standard Time (Mexico) - (GMT-08:00) Tijuana, Baja California"
        case alaskanStandardTimeGMT0900Alaska = "Alaskan Standard Time - (GMT-09:00) Alaska"
        case hawaiianStandardTimeGMT1000Hawaii = "Hawaiian Standard Time - (GMT-10:00) Hawaii"
        case samoaStandardTimeGMT1100MidwayIslandSamoa = "Samoa Standard Time - (GMT-11:00) Midway Island, Samoa"
        case datelineStandardTimeGMT1200InternationalDateLineWest = "Dateline Standard Time - (GMT-12:00) International Date Line West"
    }

    public init(input: String, source: Source, target: Target, format: String? = nil) {
        self.input = input
        self.source = source
        self.target = target
        self.format = format
    }
}

/// Example:
///
/// {
///   "culture" : "en-GB",
///   "format" : "ddd",
///   "input" : "03\/10\/2010 00:00:00"
/// }
public struct InputDateTimeFormat: Codable {
    /// Source date and time
    public var input: String
    /// Language culture
    public var culture: Culture
    /// Output format
    public var format: String

    /// Language culture
    public enum Culture: String, Codable, CaseIterable {
        case enUS = "en-US"
        case afZA = "af-ZA"
        case arAE = "ar-AE"
        case arBH = "ar-BH"
        case arDZ = "ar-DZ"
        case arEG = "ar-EG"
        case arIQ = "ar-IQ"
        case arJO = "ar-JO"
        case arKW = "ar-KW"
        case arLB = "ar-LB"
        case arLY = "ar-LY"
        case arMA = "ar-MA"
        case arOM = "ar-OM"
        case arQA = "ar-QA"
        case arSA = "ar-SA"
        case arSY = "ar-SY"
        case arTN = "ar-TN"
        case arYE = "ar-YE"
        case azAZ = "az-AZ"
        case beBY = "be-BY"
        case bgBG = "bg-BG"
        case bsBA = "bs-BA"
        case caES = "ca-ES"
        case csCZ = "cs-CZ"
        case cyGB = "cy-GB"
        case daDK = "da-DK"
        case deAT = "de-AT"
        case deCH = "de-CH"
        case deDE = "de-DE"
        case deLI = "de-LI"
        case deLU = "de-LU"
        case elGR = "el-GR"
        case enAU = "en-AU"
        case enBZ = "en-BZ"
        case enCA = "en-CA"
        case enCB = "en-CB"
        case enGB = "en-GB"
        case enIE = "en-IE"
        case enJM = "en-JM"
        case enNZ = "en-NZ"
        case enPH = "en-PH"
        case enTT = "en-TT"
        case enZA = "en-ZA"
        case enZW = "en-ZW"
        case esAR = "es-AR"
        case esBO = "es-BO"
        case esCL = "es-CL"
        case esCO = "es-CO"
        case esCR = "es-CR"
        case esDO = "es-DO"
        case esEC = "es-EC"
        case esES = "es-ES"
        case esGT = "es-GT"
        case esHN = "es-HN"
        case esMX = "es-MX"
        case esNI = "es-NI"
        case esPA = "es-PA"
        case esPE = "es-PE"
        case esPR = "es-PR"
        case esPY = "es-PY"
        case esSV = "es-SV"
        case esUY = "es-UY"
        case esVE = "es-VE"
        case etEE = "et-EE"
        case euES = "eu-ES"
        case faIR = "fa-IR"
        case fiFI = "fi-FI"
        case foFO = "fo-FO"
        case frBE = "fr-BE"
        case frCA = "fr-CA"
        case frCH = "fr-CH"
        case frFR = "fr-FR"
        case frLU = "fr-LU"
        case frMC = "fr-MC"
        case glES = "gl-ES"
        case guIN = "gu-IN"
        case heIL = "he-IL"
        case hiIN = "hi-IN"
        case hrBA = "hr-BA"
        case hrHR = "hr-HR"
        case huHU = "hu-HU"
        case hyAM = "hy-AM"
        case idID = "id-ID"
        case isIS = "is-IS"
        case itCH = "it-CH"
        case itIT = "it-IT"
        case jaJP = "ja-JP"
        case kaGE = "ka-GE"
        case kkKZ = "kk-KZ"
        case knIN = "kn-IN"
        case koKR = "ko-KR"
        case kyKG = "ky-KG"
        case ltLT = "lt-LT"
        case lvLV = "lv-LV"
        case miNZ = "mi-NZ"
        case mnMN = "mn-MN"
        case mrIN = "mr-IN"
        case msBN = "ms-BN"
        case msMY = "ms-MY"
        case mtMT = "mt-MT"
        case nlBE = "nl-BE"
        case nlNL = "nl-NL"
        case nnNO = "nn-NO"
        case nsZA = "ns-ZA"
        case paIN = "pa-IN"
        case plPL = "pl-PL"
        case psAR = "ps-AR"
        case ptBR = "pt-BR"
        case ptPT = "pt-PT"
        case roRO = "ro-RO"
        case ruRU = "ru-RU"
        case saIN = "sa-IN"
        case skSK = "sk-SK"
        case slSI = "sl-SI"
        case sqAL = "sq-AL"
        case srBA = "sr-BA"
        case srSP = "sr-SP"
        case svFI = "sv-FI"
        case svSE = "sv-SE"
        case swKE = "sw-KE"
        case taIN = "ta-IN"
        case teIN = "te-IN"
        case thTH = "th-TH"
        case tlPH = "tl-PH"
        case tnZA = "tn-ZA"
        case trTR = "tr-TR"
        case ukUA = "uk-UA"
        case urPK = "ur-PK"
        case uzUZ = "uz-UZ"
        case viVN = "vi-VN"
        case zhCN = "zh-CN"
        case zhHK = "zh-HK"
        case zhMO = "zh-MO"
        case zhSG = "zh-SG"
        case zhTW = "zh-TW"
        case zuZA = "zu-ZA"
    }

    public init(input: String, culture: Culture, format: String) {
        self.input = input
        self.culture = culture
        self.format = format
    }
}

/// Example:
///
/// {
///   "culture" : "en-GB",
///   "input" : "03\/10\/2010 09:00:00"
/// }
public struct InputDateTimeInfo: Codable {
    /// Source date and time
    public var input: String
    /// Language culture
    public var culture: Culture

    /// Language culture
    public enum Culture: String, Codable, CaseIterable {
        case enUS = "en-US"
        case afZA = "af-ZA"
        case arAE = "ar-AE"
        case arBH = "ar-BH"
        case arDZ = "ar-DZ"
        case arEG = "ar-EG"
        case arIQ = "ar-IQ"
        case arJO = "ar-JO"
        case arKW = "ar-KW"
        case arLB = "ar-LB"
        case arLY = "ar-LY"
        case arMA = "ar-MA"
        case arOM = "ar-OM"
        case arQA = "ar-QA"
        case arSA = "ar-SA"
        case arSY = "ar-SY"
        case arTN = "ar-TN"
        case arYE = "ar-YE"
        case azAZ = "az-AZ"
        case beBY = "be-BY"
        case bgBG = "bg-BG"
        case bsBA = "bs-BA"
        case caES = "ca-ES"
        case csCZ = "cs-CZ"
        case cyGB = "cy-GB"
        case daDK = "da-DK"
        case deAT = "de-AT"
        case deCH = "de-CH"
        case deDE = "de-DE"
        case deLI = "de-LI"
        case deLU = "de-LU"
        case elGR = "el-GR"
        case enAU = "en-AU"
        case enBZ = "en-BZ"
        case enCA = "en-CA"
        case enCB = "en-CB"
        case enGB = "en-GB"
        case enIE = "en-IE"
        case enJM = "en-JM"
        case enNZ = "en-NZ"
        case enPH = "en-PH"
        case enTT = "en-TT"
        case enZA = "en-ZA"
        case enZW = "en-ZW"
        case esAR = "es-AR"
        case esBO = "es-BO"
        case esCL = "es-CL"
        case esCO = "es-CO"
        case esCR = "es-CR"
        case esDO = "es-DO"
        case esEC = "es-EC"
        case esES = "es-ES"
        case esGT = "es-GT"
        case esHN = "es-HN"
        case esMX = "es-MX"
        case esNI = "es-NI"
        case esPA = "es-PA"
        case esPE = "es-PE"
        case esPR = "es-PR"
        case esPY = "es-PY"
        case esSV = "es-SV"
        case esUY = "es-UY"
        case esVE = "es-VE"
        case etEE = "et-EE"
        case euES = "eu-ES"
        case faIR = "fa-IR"
        case fiFI = "fi-FI"
        case foFO = "fo-FO"
        case frBE = "fr-BE"
        case frCA = "fr-CA"
        case frCH = "fr-CH"
        case frFR = "fr-FR"
        case frLU = "fr-LU"
        case frMC = "fr-MC"
        case glES = "gl-ES"
        case guIN = "gu-IN"
        case heIL = "he-IL"
        case hiIN = "hi-IN"
        case hrBA = "hr-BA"
        case hrHR = "hr-HR"
        case huHU = "hu-HU"
        case hyAM = "hy-AM"
        case idID = "id-ID"
        case isIS = "is-IS"
        case itCH = "it-CH"
        case itIT = "it-IT"
        case jaJP = "ja-JP"
        case kaGE = "ka-GE"
        case kkKZ = "kk-KZ"
        case knIN = "kn-IN"
        case koKR = "ko-KR"
        case kyKG = "ky-KG"
        case ltLT = "lt-LT"
        case lvLV = "lv-LV"
        case miNZ = "mi-NZ"
        case mnMN = "mn-MN"
        case mrIN = "mr-IN"
        case msBN = "ms-BN"
        case msMY = "ms-MY"
        case mtMT = "mt-MT"
        case nlBE = "nl-BE"
        case nlNL = "nl-NL"
        case nnNO = "nn-NO"
        case nsZA = "ns-ZA"
        case paIN = "pa-IN"
        case plPL = "pl-PL"
        case psAR = "ps-AR"
        case ptBR = "pt-BR"
        case ptPT = "pt-PT"
        case roRO = "ro-RO"
        case ruRU = "ru-RU"
        case saIN = "sa-IN"
        case skSK = "sk-SK"
        case slSI = "sl-SI"
        case sqAL = "sq-AL"
        case srBA = "sr-BA"
        case srSP = "sr-SP"
        case svFI = "sv-FI"
        case svSE = "sv-SE"
        case swKE = "sw-KE"
        case taIN = "ta-IN"
        case teIN = "te-IN"
        case thTH = "th-TH"
        case tlPH = "tl-PH"
        case tnZA = "tn-ZA"
        case trTR = "tr-TR"
        case ukUA = "uk-UA"
        case urPK = "ur-PK"
        case uzUZ = "uz-UZ"
        case viVN = "vi-VN"
        case zhCN = "zh-CN"
        case zhHK = "zh-HK"
        case zhMO = "zh-MO"
        case zhSG = "zh-SG"
        case zhTW = "zh-TW"
        case zuZA = "zu-ZA"
    }

    public init(input: String, culture: Culture) {
        self.input = input
        self.culture = culture
    }
}

/// Example:
///
/// {
///   "dateTime1" : "1\/1\/2010 12:37:19",
///   "dateTime2" : "3\/15\/2011 14:27:49"
/// }
public struct InputDateTimeDifference: Codable {
    /// First date/time value
    public var dateTime1: String
    /// Second date/time value
    public var dateTime2: String

    public init(dateTime1: String, dateTime2: String) {
        self.dateTime1 = dateTime1
        self.dateTime2 = dateTime2
    }
}

/// Example:
///
/// {
///   "uppercase" : true
/// }
public struct InputGenerateUniqueID: Codable {
    /// All uppercase alpha characters
    public var uppercase: Uppercase

    /// All uppercase alpha characters
    public enum Uppercase: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(uppercase: Uppercase) {
        self.uppercase = uppercase
    }
}

/// Example:
///
/// {
///   "input" : [
///     "The",
///     "brown",
///     "cow"
///   ],
///   "lower" : true,
///   "separator" : ";",
///   "trim" : true
/// }
public struct InputJoinStrings: Codable {
    /// Collection of strings to be joined
    public var input: [String]
    /// Separator character
    public var separator: String
    /// Convert strings in collection to lowercase
    public var lower: Lower
    /// Trim strings in collection
    public var trim: Trim

    /// Convert strings in collection to lowercase
    public enum Lower: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    /// Trim strings in collection
    public enum Trim: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(input: [String], separator: String, lower: Lower, trim: Trim) {
        self.input = input
        self.separator = separator
        self.lower = lower
        self.trim = trim
    }
}

/// Example:
///
/// {
///   "header" : true,
///   "input" : [
///     {
///       "property1" : "value"
///     },
///     {
///       "property2" : "value"
///     },
///     {
///       "property3" : "value"
///     }
///   ],
///   "omit" : "property1",
///   "order" : "property3,property2"
/// }
public struct InputJSONConversionCSV: Codable {
    /// JSON array object
    public var input: String
    /// Include header row
    public var isHeader: Bool
    /// Columns to omit (comma separated)
    public var omit: String?
    /// Column order (comma separated)
    public var order: String?

    public init(input: String, isHeader: Bool, omit: String? = nil, order: String? = nil) {
        self.input = input
        self.isHeader = isHeader
        self.omit = omit
        self.order = order
    }

    private enum CodingKeys: String, CodingKey {
        case input
        case isHeader = "header"
        case omit
        case order
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.input = try values.decode(String.self, forKey: .input)
        self.isHeader = try values.decode(Bool.self, forKey: .isHeader)
        self.omit = try values.decodeIfPresent(String.self, forKey: .omit)
        self.order = try values.decodeIfPresent(String.self, forKey: .order)
    }
}

/// Example:
///
/// {
///   "alternate" : "<tr><th>Property 3<\/th><th>Property 2<\/th><\/tr>",
///   "attributes" : "style='width:100%;text-align:center;'",
///   "header" : false,
///   "input" : [
///     {
///       "property1" : "value"
///     },
///     {
///       "property2" : "value"
///     },
///     {
///       "property3" : "value"
///     }
///   ],
///   "omit" : "property1",
///   "order" : "property3,property2"
/// }
public struct InputJSONConversionHTML: Codable {
    /// JSON array object
    public var input: String
    /// Include header row
    public var isHeader: Bool
    /// Alternate header row markup
    public var alternate: String?
    /// Optional table attributes (single quoted values)
    public var attributes: String?
    /// Columns to omit (comma separated)
    public var omit: String?
    /// Column order (comma separated)
    public var order: String?

    public init(input: String, isHeader: Bool, alternate: String? = nil, attributes: String? = nil, omit: String? = nil, order: String? = nil) {
        self.input = input
        self.isHeader = isHeader
        self.alternate = alternate
        self.attributes = attributes
        self.omit = omit
        self.order = order
    }

    private enum CodingKeys: String, CodingKey {
        case input
        case isHeader = "header"
        case alternate
        case attributes
        case omit
        case order
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.input = try values.decode(String.self, forKey: .input)
        self.isHeader = try values.decode(Bool.self, forKey: .isHeader)
        self.alternate = try values.decodeIfPresent(String.self, forKey: .alternate)
        self.attributes = try values.decodeIfPresent(String.self, forKey: .attributes)
        self.omit = try values.decodeIfPresent(String.self, forKey: .omit)
        self.order = try values.decodeIfPresent(String.self, forKey: .order)
    }
}

/// Example:
///
/// {
///   "input" : "{\"property1\":\"value\",\"property2\":\"value\",\"property3\":\"value\"}",
///   "root" : "Properties"
/// }
public struct InputJSONConversionXML: Codable {
    /// JSON array object
    public var input: String
    /// Name of root node
    public var root: String

    public init(input: String, root: String) {
        self.input = input
        self.root = root
    }
}

/// Example:
///
/// {
///   "end" : 1000000,
///   "start" : 1
/// }
public struct InputNumberRange: Codable {
    /// Start of range
    public var start: Double
    /// End of range
    public var end: Double

    public init(start: Double, end: Double) {
        self.start = start
        self.end = end
    }
}

/// Example:
///
/// {
///   "regex" : "[A-Za-z]{5}",
///   "source" : "The brown cow",
///   "value" : "brown",
///   "values" : [
///     "The",
///     "brown",
///     "cow"
///   ]
/// }
public struct InputRedactString: Codable {
    /// String containing the complete text
    public var source: String
    /// Individual string to redact
    public var value: String?
    /// Collection of strings to redact
    public var values: [String]?
    /// Regular expression pattern for matching strings
    public var regex: String?

    public init(source: String, value: String? = nil, values: [String]? = nil, regex: String? = nil) {
        self.source = source
        self.value = value
        self.values = values
        self.regex = regex
    }
}

/// Example:
///
/// {
///   "replacement" : "dog",
///   "source" : "The brown cow",
///   "value" : "cow"
/// }
public struct InputReplaceString: Codable {
    /// String containing the text to be replaced
    public var source: String
    /// Text to replace
    public var value: String
    /// Replacement text
    public var replacement: String

    public init(source: String, value: String, replacement: String) {
        self.source = source
        self.value = value
        self.replacement = replacement
    }
}

/// Example:
///
/// {
///   "characters" : ",",
///   "input" : "The,brown,cow"
/// }
public struct InputSplitString: Codable {
    /// Text to split
    public var input: String
    /// One or more characters that will be used to split the text
    public var characters: String

    public init(input: String, characters: String) {
        self.input = input
        self.characters = characters
    }
}

/// Example:
///
/// {
///   "compare" : "dog",
///   "input" : "Cow",
///   "lower" : true,
///   "trim" : true
/// }
public struct InputStringComparison: Codable {
    /// Original string
    public var input: String
    /// Comparison string
    public var compare: String
    /// Convert strings to lowercase before comparison
    public var lower: Lower
    /// Trim strings before comparison
    public var trim: Trim

    /// Convert strings to lowercase before comparison
    public enum Lower: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    /// Trim strings before comparison
    public enum Trim: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(input: String, compare: String, lower: Lower, trim: Trim) {
        self.input = input
        self.compare = compare
        self.lower = lower
        self.trim = trim
    }
}

/// Example:
///
/// {
///   "find" : "cow",
///   "input" : "The brown cow",
///   "lower" : true
/// }
public struct InputStringContains: Codable {
    /// Text to match
    public var find: String
    /// Text to search
    public var input: String
    /// Convert strings to lowercase
    public var lower: Lower

    /// Convert strings to lowercase
    public enum Lower: String, Codable, CaseIterable {
        case `true`
        case `false`
    }

    public init(find: String, input: String, lower: Lower) {
        self.find = find
        self.input = input
        self.lower = lower
    }
}

/// Example:
///
/// {
///   "source" : "The brown cow"
/// }
public struct InputString: Codable {
    /// String variable or text value
    public var source: String

    public init(source: String) {
        self.source = source
    }
}

/// Example:
///
/// {
///   "input" : "The brown cow",
///   "language" : "German"
/// }
public struct InputTranslateString: Codable {
    /// String containing the text to be translated
    public var input: String
    /// Translation language
    public var language: Language

    /// Translation language
    public enum Language: String, Codable, CaseIterable {
        case arabic = "Arabic"
        case chineseSimplified = "Chinese (Simplified)"
        case czech = "Czech"
        case danish = "Danish"
        case dutch = "Dutch"
        case english = "English"
        case finnish = "Finnish"
        case french = "French"
        case german = "German"
        case greek = "Greek"
        case hindi = "Hindi"
        case hungarian = "Hungarian"
        case italian = "Italian"
        case japanese = "Japanese"
        case klingon = "Klingon"
        case korean = "Korean"
        case norweigan = "Norweigan"
        case polish = "Polish"
        case portuguese = "Portuguese"
        case russian = "Russian"
        case spanish = "Spanish"
        case swedish = "Swedish"
        case turkish = "Turkish"
        case vietnamese = "Vietnamese"
        case welsh = "Welsh"
    }

    public init(input: String, language: Language) {
        self.input = input
        self.language = language
    }
}

/// Example:
///
/// {
///   "source" : "  The brown cow  ",
///   "type" : "Both"
/// }
public struct InputTrimString: Codable {
    /// String containing the text to be trimmed
    public var source: String
    /// Type of white space to remove
    public var type: `Type`

    /// Type of white space to remove
    public enum `Type`: String, Codable, CaseIterable {
        case start = "Start"
        case end = "End"
        case both = "Both"
    }

    public init(source: String, type: `Type`) {
        self.source = source
        self.type = type
    }
}

/// Example:
///
/// {
///   "input" : "<properties><property1>value<\/property1><\/properties>"
/// }
public struct InputXmlConversionJSON: Codable {
    /// XML string
    public var input: String

    public init(input: String) {
        self.input = input
    }
}

/// Example:
///
/// {
///   "text" : "This is sample text.",
///   "type" : "PlainText",
///   "voice" : "en-US, Aria (Female)"
/// }
public struct InputTextToSpeech: Codable {
    /// Text to convert (10,000 characters max)
    public var text: String
    /// Text or file type
    public var type: `Type`
    /// Voice locale (must match language of input text)
    public var voice: Voice

    /// Text or file type
    public enum `Type`: String, Codable, CaseIterable {
        case plainText = "PlainText"
        case ssml = "SSML"
    }

    /// Voice locale (must match language of input text)
    public enum Voice: String, Codable, CaseIterable {
        case arEGHodaFemale = "ar-EG, Hoda (Female)"
        case arSANaayfMale = "ar-SA, Naayf (Male)"
        case bgBGIvanMale = "bg-BG, Ivan (Male)"
        case caESHerenaFemale = "ca-ES, Herena (Female)"
        case csCZJakubMale = "cs-CZ, Jakub (Male)"
        case daDKHelleFemale = "da-DK, Helle (Female)"
        case deATMichaelMale = "de-AT, Michael (Male)"
        case deCHKarstenMale = "de-CH, Karsten (Male)"
        case deDEHeddaFemale = "de-DE, Hedda (Female)"
        case deDEStefanMale = "de-DE, Stefan (Male)"
        case elGRStefanosMale = "el-GR, Stefanos (Male)"
        case enAUCatherineFemale = "en-AU, Catherine (Female)"
        case enAUHayleyFemale = "en-AU, Hayley (Female)"
        case enCAHeatherFemale = "en-CA, Heather (Female)"
        case enCALindaFemale = "en-CA, Linda (Female)"
        case enGBGeorgeMale = "en-GB, George (Male)"
        case enGBHazelFemale = "en-GB, Hazel (Female)"
        case enGBSusanFemale = "en-GB, Susan (Female)"
        case enIESeanMale = "en-IE, Sean (Male)"
        case enINHeeraFemale = "en-IN, Heera (Female)"
        case enINPriyaFemale = "en-IN, Priya (Female)"
        case enINRaviMale = "en-IN, Ravi (Male)"
        case enUSAriaFemale = "en-US, Aria (Female)"
        case enUSBenjaminMale = "en-US, Benjamin (Male)"
        case enUSGuyMale = "en-US, Guy (Male)"
        case enUSZiraFemale = "en-US, Zira (Female)"
        case esESHelenaFemale = "es-ES, Helena (Female)"
        case esESLauraFemale = "es-ES, Laura (Female)"
        case esESPabloMale = "es-ES, Pablo (Male)"
        case esMXHildaFemale = "es-MX, Hilda (Female)"
        case esMXRaulMale = "es-MX, Raul (Male)"
        case fiFIHeidiFemale = "fi-FI, Heidi (Female)"
        case frCACarolineFemale = "fr-CA, Caroline (Female)"
        case frCAHarmonieFemale = "fr-CA, Harmonie (Female)"
        case frCHGuillaumeMale = "fr-CH, Guillaume (Male)"
        case frFRHortenseFemale = "fr-FR, Hortense (Female)"
        case frFRJulieFemale = "fr-FR, Julie (Female)"
        case frFRPaulMale = "fr-FR, Paul (Male)"
        case heILAsafMale = "he-IL, Asaf (Male)"
        case hiINHemantMale = "hi-IN, Hemant (Male)"
        case hiINKalpanaFemale = "hi-IN, Kalpana (Female)"
        case hrHRMatejMale = "hr-HR, Matej (Male)"
        case huHUSzabolcsMale = "hu-HU, Szabolcs (Male)"
        case idIDAndikaMale = "id-ID, Andika (Male)"
        case itITCosimoMale = "it-IT, Cosimo (Male)"
        case itITLuciaFemale = "it-IT, Lucia (Female)"
        case jaJPAyumiFemale = "ja-JP, Ayumi (Female)"
        case jaJPHarukaFemale = "ja-JP, Haruka (Female)"
        case jaJPIchiroMale = "ja-JP, Ichiro (Male)"
        case koKRHeamiFemale = "ko-KR, Heami (Female)"
        case msMYRizwanMale = "ms-MY, Rizwan (Male)"
        case nbNOHuldaFemale = "nb-NO, Hulda (Female)"
        case nlNLHannaFemale = "nl-NL, Hanna (Female)"
        case plPLPaulinaFemale = "pl-PL, Paulina (Female)"
        case ptBRDanielMale = "pt-BR, Daniel (Male)"
        case ptBRHeloisaFemale = "pt-BR, Heloisa (Female)"
        case ptPTHeliaFemale = "pt-PT, Helia (Female)"
        case roROAndreiMale = "ro-RO, Andrei (Male)"
        case ruRUEkaterinaFemale = "ru-RU, Ekaterina (Female)"
        case ruRUIrinaFemale = "ru-RU, Irina (Female)"
        case ruRUPavelMale = "ru-RU, Pavel (Male)"
        case skSKFilipMale = "sk-SK, Filip (Male)"
        case slSILadoMale = "sl-SI, Lado (Male)"
        case svSEHedvigFemale = "sv-SE, Hedvig (Female)"
        case taINValluvarMale = "ta-IN, Valluvar (Male)"
        case teINChitraFemale = "te-IN, Chitra (Female)"
        case thTHPattaraMale = "th-TH, Pattara (Male)"
        case trTRSedaFemale = "tr-TR, Seda (Female)"
        case viVNAnMale = "vi-VN, An (Male)"
        case zhCNHuihuiFemale = "zh-CN, Huihui (Female)"
        case zhCNKangkangMale = "zh-CN, Kangkang (Male)"
        case zhCNYaoyaoFemale = "zh-CN, Yaoyao (Female)"
        case zhHKDannyMale = "zh-HK, Danny (Male)"
        case zhHKTracyFemale = "zh-HK, Tracy (Female)"
        case zhTWHanHanFemale = "zh-TW, HanHan (Female)"
        case zhTWYatingFemale = "zh-TW, Yating (Female)"
        case zhTWZhiweiMale = "zh-TW, Zhiwei (Male)"
    }

    public init(text: String, type: `Type`, voice: Voice) {
        self.text = text
        self.type = type
        self.voice = voice
    }
}

/// Example:
///
/// {
///   "input" : "{\"properties\": [{\"name\":\"ID\",\"value\":\"1234\"},{\"name\":\"Title\",\"value\":\"Some Title\"}]}",
///   "query" : "$.properties[?(@.name == \"ID\")].value"
/// }
public struct InputDataQuery: Codable {
    /// XML or JSON string
    public var input: String
    /// XPath or JSONPath query
    public var query: String

    public init(input: String, query: String) {
        self.input = input
        self.query = query
    }
}

/// Example:
///
/// {
///   "algorithm" : "SHA256",
///   "source" : "text to hash"
/// }
public struct InputGenerateHash: Codable {
    /// Hash source string
    public var input: String
    /// Hash algorithm
    public var algorithm: Algorithm

    /// Hash algorithm
    public enum Algorithm: String, Codable, CaseIterable {
        case md5 = "MD5"
        case sha1 = "SHA1"
        case sha256 = "SHA256"
        case sha384 = "SHA384"
        case sha512 = "SHA512"
    }

    public init(input: String, algorithm: Algorithm) {
        self.input = input
        self.algorithm = algorithm
    }
}

/// Example:
///
/// {
///   "algorithm" : "SHA256",
///   "hash" : "a52b8248f023cebd33aeeddda695f60d2561c0c9",
///   "source" : "this is a really good test"
/// }
public struct InputVerifyHash: Codable {
    /// Original source string
    public var input: String
    /// Hash algorithm
    public var algorithm: Algorithm
    /// Hashed result
    public var hash: String

    /// Hash algorithm
    public enum Algorithm: String, Codable, CaseIterable {
        case md5 = "MD5"
        case sha1 = "SHA1"
        case sha256 = "SHA256"
        case sha384 = "SHA384"
        case sha512 = "SHA512"
    }

    public init(input: String, algorithm: Algorithm, hash: String) {
        self.input = input
        self.algorithm = algorithm
        self.hash = hash
    }
}

/// Example:
///
/// {
///   "date" : "2020-10-07T00:00:00.000Z",
///   "exchange" : "XNYS (New York Stock Exchange)",
///   "symbols" : "MMM,CVX"
/// }
public struct InputStockPrices: Codable {
    /// Stock ticker symbols (comma-separated, max 20)
    public var symbols: String
    /// Date (yyyy-MM-dd, leave empty for latest)
    public var date: String?
    /// Stock exchange
    public var exchange: Exchange?

    /// Stock exchange
    public enum Exchange: String, Codable, CaseIterable {
        case xNYSNewYorkStockExchange = "XNYS (New York Stock Exchange)"
        case xNASNASDAQStockExchange = "XNAS (NASDAQ Stock Exchange)"
        case xBRUEuronextBrussels = "XBRU (Euronext Brussels)"
        case xTSETorontoStockExchange = "XTSE (Toronto Stock Exchange)"
        case xCNQCandadianSecuritiesExchange = "XCNQ (Candadian Securities Exchange)"
        case xSHGShanghaiStockExchange = "XSHG (Shanghai Stock Exchange)"
        case xCSECopenhagenStockExchange = "XCSE (Copenhagen Stock Exchange)"
        case xPAREuronextParis = "XPAR (Euronext Paris)"
        case xFRADeutscheBorse = "XFRA (Deutsche Borse)"
        case xHKGHongKongStockExchange = "XHKG (Hong Kong Stock Exchange)"
        case xNSENationalStockExchangeIndia = "XNSE (National Stock Exchange India)"
        case xTAETelAvivStockExchange = "XTAE (Tel Aviv Stock Exchange)"
        case xNGONagoyaStockExchange = "XNGO (Nagoya Stock Exchange)"
        case xFKAFukuokaStockExchange = "XFKA (Fukuoka Stock Exchange)"
        case xSAPSapporoStockExchange = "XSAP (Sapporo Stock Exchange)"
        case xMEXMexicanStockExchange = "XMEX (Mexican Stock Exchange)"
        case xNZENewZealandStockExchange = "XNZE (New Zealand Stock Exchange)"
        case xLISEuronextLisbon = "XLIS (Euronext Lisbon)"
        case mISXMoscowStockExchange = "MISX (Moscow Stock Exchange)"
        case xSESSingaporeStockExchange = "XSES (Singapore Stock Exchange)"
        case xLONLondonStockExchange = "XLON (London Stock Exchange)"
        case xASEAmericanStockExchange = "XASE (American Stock Exchange)"
        case xASXAustraliaStockExchange = "XASX (Australia Stock Exchange)"
        case xDFMDubaiFinancialMarket = "XDFM (Dubai Financial Market)"
        case xBKKStockExchangeOfThailand = "XBKK (Stock Exchange of Thailand)"
        case xSWXSIXSwissExchange = "XSWX (SIX Swiss Exchange)"
        case xSTOStockholmStockExchange = "XSTO (Stockholm Stock Exchange)"
        case bMEXBolsasYMercadosEspaOles = "BMEX (Bolsas y Mercados Espaoles)"
        case xJSEJohannesburgStockExchange = "XJSE (Johannesburg Stock Exchange)"
    }

    public init(symbols: String, date: String? = nil, exchange: Exchange? = nil) {
        self.symbols = symbols
        self.date = date
        self.exchange = exchange
    }
}

/// Example:
///
/// {
///   "date" : "2020-10-07T00:00:00.000Z",
///   "symbol" : "DJI.INDX"
/// }
public struct InputMarketIndex: Codable {
    /// Market index
    public var symbol: Symbol
    /// Date (yyyy-MM-dd, leave empty for last trading day)
    public var date: String?

    /// Market index
    public enum Symbol: String, Codable, CaseIterable {
        case dJAINDXDowJonesCompositeAverage = "DJA.INDX (Dow Jones Composite Average)"
        case dJIINDXDowJonesIndustrialAverage = "DJI.INDX (Dow Jones Industrial Average)"
        case dJTINDXDowJonesTransportation = "DJT.INDX (Dow Jones Transportation)"
        case dJUSINDXDowJonesUS = "DJUS.INDX (Dow Jones US)"
        case dXYINDXUSDollarIndex = "DXY.INDX (US Dollar Index)"
        case gDOWINDXGlobalDowUSD = "GDOW.INDX (Global Dow USD)"
        case nYINDXNYSEUS100Index = "NY.INDX (NYSE US 100 Index)"
        case nYAINDXNYSEComposite = "NYA.INDX (NYSE Composite)"
        case iXICINDXNASDAQComposite = "IXIC.INDX (NASDAQ Composite)"
        case ndxIndxNasdaq100 = "NDX.INDX (NASDAQ 100)"
        case gspcIndxSP500 = "GSPC.INDX (S&P 500)"
        case eSINDXSP500Futures = "ES.INDX (S&P 500 Futures)"
        case mIDINDXSPMidcap400 = "MID.INDX (S&P Midcap 400)"
        case gPTSEINDXSPTSXCompositeIndexCanada = "GPTSE.INDX (S&P TSX Composite Index [Canada])"
        case fTSEINDXFTSE100IndexUK = "FTSE.INDX (FTSE 100 Index [UK])"
        case cDAXXINDXDAXCompositeIndexGermany = "CDAXX.INDX (DAX Composite Index [Germany])"
        case gDAXIINDXDAXIndexGermany = "GDAXI.INDX (DAX Index [Germany])"
        case hSCEINDXHangSengChinaEnterpriseCEI = "HSCE.INDX (Hang Seng China Enterprise (CEI))"
        case hSIINDXHangSengIndexHongKong = "HSI.INDX (Hang Seng Index [Hong Kong])"
        case n100INDXEuroNext100 = "N100.INDX (EuroNext 100)"
        case n225INDXNikkei225Index = "N225.INDX (Nikkei 225 Index)"
        case rTSIINDXRTSIIndexRussia = "RTSI.INDX (RTSI Index [Russia])"
        case sSECINDXShanghaiComposite = "SSEC.INDX (Shanghai Composite)"
        case sSMIINDXSwissMarketIndex = "SSMI.INDX (Swiss Market Index)"
    }

    public init(symbol: Symbol, date: String? = nil) {
        self.symbol = symbol
        self.date = date
    }
}

/// Example:
///
/// {
///   "input" : "someone@example.com|Test message|This is a test.",
///   "payload" : "Mail"
/// }
public struct InputQRCode: Codable {
    /// Text value(s) (vertical bar delimited by type)
    public var input: String
    /// Payload type
    public var payload: Payload

    /// Payload type
    public enum Payload: String, Codable, CaseIterable {
        case plainTextString = "Plain Text (string)"
        case bitcoinPaymentAddressAmountLabelMessage = "Bitcoin Payment (address|amount|label|message)"
        case bookmarkURLTitle = "Bookmark (url|title)"
        case calendarEventSubjectDescriptionLocationStartEndAllDayEventTrueOrFalseFormatUniversalOrICal = "Calendar Event (subject|description|location|start|end|allDayEvent['true' or 'false']|format ['universal' or 'iCal'])"
        case geolocationLatitudeLongitude = "Geolocation (latitude|longitude)"
        case mailRecipientSubjectMessage = "Mail (recipient|subject|message)"
        case phoneNumberString = "Phone Number (string)"
        case sMSNumberMessage = "SMS (number|message)"
        case urlString = "URL (string)"
        case wiFiSsidPasswordAuthenticationModeWEPWPAOrWPA2 = "WiFi (ssid|password|authenticationMode ['WEP', 'WPA' or 'WPA2'])"
    }

    public init(input: String, payload: Payload) {
        self.input = input
        self.payload = payload
    }
}

/// Example:
///
/// {
///   "extension" : "TXT",
///   "filename" : "Test",
///   "input" : "This is a test."
/// }
public struct InputStringToFile: Codable {
    /// Text string (body of file)
    public var input: String
    /// File extension
    public var `extension`: Extension
    /// Name of file (without extension)
    public var filename: String

    /// File extension
    public enum Extension: String, Codable, CaseIterable {
        case txt = "TXT"
        case csv = "CSV"
        case html = "HTML"
        case xml = "XML"
        case css = "CSS"
        case json = "JSON"
        case js = "JS"
    }

    public init(input: String, `extension`: Extension, filename: String) {
        self.input = input
        self.extension = `extension`
        self.filename = filename
    }

    private enum CodingKeys: String, CodingKey {
        case input
        case `extension` = "extension"
        case filename
    }
}

/// Example:
///
/// {
///   "data" : [
///     "string"
///   ]
/// }
public struct OutputStringArray: Codable {
    /// Data
    public var data: [String]?

    public init(data: [String]? = nil) {
        self.data = data
    }
}

/// Example:
///
/// {
///   "DayOfWeek" : 2,
///   "DayOfYear" : 25,
///   "MinutesInDay" : 359,
///   "SecondsInDay" : 1234,
///   "Ticks" : 1234567890,
///   "WeekOfYear" : 10
/// }
public struct OutputDateInfo: Codable {
    /// DayOfYear
    public var dayOfYear: Double?
    /// DayOfWeek
    public var dayOfWeek: Double?
    /// WeekOfYear
    public var weekOfYear: Double?
    /// SecondsInDay
    public var secondsInDay: Double?
    /// MinutesInDay
    public var minutesInDay: Double?
    /// Ticks
    public var ticks: Double?

    public init(dayOfYear: Double? = nil, dayOfWeek: Double? = nil, weekOfYear: Double? = nil, secondsInDay: Double? = nil, minutesInDay: Double? = nil, ticks: Double? = nil) {
        self.dayOfYear = dayOfYear
        self.dayOfWeek = dayOfWeek
        self.weekOfYear = weekOfYear
        self.secondsInDay = secondsInDay
        self.minutesInDay = minutesInDay
        self.ticks = ticks
    }

    private enum CodingKeys: String, CodingKey {
        case dayOfYear = "DayOfYear"
        case dayOfWeek = "DayOfWeek"
        case weekOfYear = "WeekOfYear"
        case secondsInDay = "SecondsInDay"
        case minutesInDay = "MinutesInDay"
        case ticks = "Ticks"
    }
}

/// Example:
///
/// {
///   "days" : 14,
///   "hours" : 1,
///   "milliseconds" : 0,
///   "minutes" : 50,
///   "months" : 2,
///   "seconds" : 30,
///   "ticks" : 378498300000000,
///   "totalDays" : 438.07999999999998,
///   "totalHours" : 10513.84,
///   "totalMilliseconds" : 37849830000,
///   "totalMinutes" : 630830.5,
///   "totalMonths" : 14.390000000000001,
///   "totalSeconds" : 37849830,
///   "totalYears" : 1.2,
///   "years" : 1
/// }
public struct OutputDateDifference: Codable {
    /// Years
    public var years: Double?
    /// Months
    public var months: Double?
    /// Days
    public var days: Double?
    /// Hours
    public var hours: Double?
    /// Minutes
    public var minutes: Double?
    /// Milliseconds
    public var milliseconds: Double?
    /// Total Years
    public var totalYears: Double?
    /// Total Months
    public var totalMonths: Double?
    /// Total Days
    public var totalDays: Double?
    /// Total Hours
    public var totalHours: Double?
    /// Total Minutes
    public var totalMinutes: Double?
    /// Total Seconds
    public var totalSeconds: Double?
    /// Total Milliseconds
    public var totalMilliseconds: Double?
    /// Ticks
    public var ticks: Double?

    public init(years: Double? = nil, months: Double? = nil, days: Double? = nil, hours: Double? = nil, minutes: Double? = nil, milliseconds: Double? = nil, totalYears: Double? = nil, totalMonths: Double? = nil, totalDays: Double? = nil, totalHours: Double? = nil, totalMinutes: Double? = nil, totalSeconds: Double? = nil, totalMilliseconds: Double? = nil, ticks: Double? = nil) {
        self.years = years
        self.months = months
        self.days = days
        self.hours = hours
        self.minutes = minutes
        self.milliseconds = milliseconds
        self.totalYears = totalYears
        self.totalMonths = totalMonths
        self.totalDays = totalDays
        self.totalHours = totalHours
        self.totalMinutes = totalMinutes
        self.totalSeconds = totalSeconds
        self.totalMilliseconds = totalMilliseconds
        self.ticks = ticks
    }
}

/// Example:
///
/// {
///   "item" : 1.25,
///   "items" : [
///     1.25,
///     2.5,
///     3.75
///   ],
///   "status" : false
/// }
public struct OutputCollectionNumber: Codable {
    /// Success
    public var isStatus: Bool?
    /// First Value
    public var item: Double?
    /// All Values
    public var items: [Double]?

    public init(isStatus: Bool? = nil, item: Double? = nil, items: [Double]? = nil) {
        self.isStatus = isStatus
        self.item = item
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case isStatus = "status"
        case item
        case items
    }
}

/// Example:
///
/// {
///   "result" : [
///     "a",
///     "b",
///     "c"
///   ]
/// }
public struct OutputCollectionResult: Codable {
    /// Modified collection result
    public var result: [String]?

    public init(result: [String]? = nil) {
        self.result = result
    }
}

/// Example:
///
/// {
///   "item" : "string",
///   "items" : [
///     "string"
///   ],
///   "status" : false
/// }
public struct OutputCollectionString: Codable {
    /// Success
    public var isStatus: Bool?
    /// First Value
    public var item: String?
    /// All Values
    public var items: [String]?

    public init(isStatus: Bool? = nil, item: String? = nil, items: [String]? = nil) {
        self.isStatus = isStatus
        self.item = item
        self.items = items
    }

    private enum CodingKeys: String, CodingKey {
        case isStatus = "status"
        case item
        case items
    }
}

/// Example:
///
/// {
///   "result1" : [
///     "a",
///     "b",
///     "c"
///   ],
///   "result2" : [
///     "d",
///     "e",
///     "f"
///   ]
/// }
public struct OutputMultiCollection: Codable {
    /// First collection result
    public var result1: [String]?
    /// Second collection result
    public var result2: [String]?

    public init(result1: [String]? = nil, result2: [String]? = nil) {
        self.result1 = result1
        self.result2 = result2
    }
}

/// Example:
///
/// {
///   "result" : "string"
/// }
public struct OutputString: Codable {
    /// Result
    public var result: String?

    public init(result: String? = nil) {
        self.result = result
    }
}

/// Example:
///
/// {
///   "result" : 1
/// }
public struct OutputNumber: Codable {
    /// Result
    public var result: Double?

    public init(result: Double? = nil) {
        self.result = result
    }
}

/// Example:
///
/// {
///   "result" : true
/// }
public struct OutputBoolean: Codable {
    /// Result
    public var isResult: Bool?

    public init(isResult: Bool? = nil) {
        self.isResult = isResult
    }

    private enum CodingKeys: String, CodingKey {
        case isResult = "result"
    }
}

/// Example:
///
/// {
///   "result" : "Base64 encoded string (byte array)"
/// }
public struct OutputFileByte: Codable {
    /// Result
    public var result: String?

    public init(result: String? = nil) {
        self.result = result
    }
}

/// Example:
///
/// {
///   "result" : [
///     {
///       "close" : 72.700000000000003,
///       "date" : "2020-10-07T00:00:00+0000",
///       "exchange" : "XNYS",
///       "high" : 74.319999999999993,
///       "last" : 72.299999999999997,
///       "low" : 72.245000000000005,
///       "open" : 73.840000000000003,
///       "symbol" : "CVX",
///       "volume" : 15151304
///     }
///   ]
/// }
public struct OutputStockPrice: Codable {
    /// Stock price information
    public var result: [ResultItem]?

    public struct ResultItem: Codable {
        /// Date
        public var date: String?
        /// Ticker symbol
        public var symbol: String?
        /// Stock exchange
        public var exchange: String?
        /// Open
        public var `open`: Double?
        /// High
        public var high: Double?
        /// Low
        public var low: Double?
        /// Close
        public var close: Double?
        /// Volume
        public var volume: Double?

        public init(date: String? = nil, symbol: String? = nil, exchange: String? = nil, `open`: Double? = nil, high: Double? = nil, low: Double? = nil, close: Double? = nil, volume: Double? = nil) {
            self.date = date
            self.symbol = symbol
            self.exchange = exchange
            self.open = `open`
            self.high = high
            self.low = low
            self.close = close
            self.volume = volume
        }

        private enum CodingKeys: String, CodingKey {
            case date
            case symbol
            case exchange
            case `open` = "open"
            case high
            case low
            case close
            case volume
        }
    }

    public init(result: [ResultItem]? = nil) {
        self.result = result
    }
}

/// Example:
///
/// {
///   "adj_close" : 72.700000000000003,
///   "adj_high" : 74.319999999999993,
///   "adj_low" : 72.245000000000005,
///   "adj_open" : 73.840000000000003,
///   "adj_volume" : 15151304,
///   "close" : 72.700000000000003,
///   "date" : "2020-10-07T00:00:00+0000",
///   "exchange" : "INDX",
///   "high" : 74.319999999999993,
///   "low" : 72.245000000000005,
///   "open" : 73.840000000000003,
///   "symbol" : "DJI.INDX",
///   "volume" : 15151304
/// }
public struct OutputMarketIndex: Codable {
    /// Date
    public var date: String?
    /// Index symbol
    public var symbol: String?
    /// Market exchange
    public var exchange: String?
    /// Open value
    public var `open`: Double?
    /// High value
    public var high: Double?
    /// Low value
    public var low: Double?
    /// Close value
    public var close: Double?
    /// Trading volume
    public var volume: Double?
    /// Adjusted open value
    public var adjOpen: Double?
    /// Adjusted high value
    public var adjHigh: Double?
    /// Adjusted low value
    public var adjLow: Double?
    /// Adjusted close value
    public var adjClose: Double?
    /// Adjusted trading volume
    public var adjVolume: Double?

    public init(date: String? = nil, symbol: String? = nil, exchange: String? = nil, `open`: Double? = nil, high: Double? = nil, low: Double? = nil, close: Double? = nil, volume: Double? = nil, adjOpen: Double? = nil, adjHigh: Double? = nil, adjLow: Double? = nil, adjClose: Double? = nil, adjVolume: Double? = nil) {
        self.date = date
        self.symbol = symbol
        self.exchange = exchange
        self.open = `open`
        self.high = high
        self.low = low
        self.close = close
        self.volume = volume
        self.adjOpen = adjOpen
        self.adjHigh = adjHigh
        self.adjLow = adjLow
        self.adjClose = adjClose
        self.adjVolume = adjVolume
    }

    private enum CodingKeys: String, CodingKey {
        case date
        case symbol
        case exchange
        case `open` = "open"
        case high
        case low
        case close
        case volume
        case adjOpen = "adj_open"
        case adjHigh = "adj_high"
        case adjLow = "adj_low"
        case adjClose = "adj_close"
        case adjVolume = "adj_volume"
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
