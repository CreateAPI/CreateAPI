// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate
import Get
import HTTPHeaders
import URLQueryEncoder

extension Paths {
    public static var accounts: Accounts {
        Accounts(path: "/accounts")
    }

    public struct Accounts {
        /// Path: `/accounts`
        public let path: String

        /// List sub accounts
        ///
        /// List all the sub accounts that have been created by a master account.<br><br>Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage sub accounts. Email the partner programs team at **partner-success@zoom.us** for more details.
        /// 
        /// <br>**Prerequisites:**<br>
        /// * Pro or a higher paid account with master account option enabled. <br>
        /// 
        /// **Scope**: `account:read:admin`
        /// <br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Account List
        ///
        /// List of Accounts.
        public struct GetResponse: Decodable {
            /// List of Account objects.
            public var accounts: [Account]?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public struct Account: Decodable {
                /// Account ID.
                public var id: String?
                /// Account name.
                public var accountName: String?
                /// Account owner email.
                ///
                /// Example: "john.doe@zoom.us"
                public var ownerEmail: String?
                /// Account type.
                public var accountType: String?
                /// Account seats.
                public var seats: Int?
                /// Account subscription start date and time.
                public var subscriptionStartTime: Date?
                /// Account subscription end date and time.
                public var subscriptionEndTime: Date?
                /// Account creation date and time.
                public var createdAt: Date?
                /// Account Number of the account.
                public var accountNumber: String?

                public init(id: String? = nil, accountName: String? = nil, ownerEmail: String? = nil, accountType: String? = nil, seats: Int? = nil, subscriptionStartTime: Date? = nil, subscriptionEndTime: Date? = nil, createdAt: Date? = nil, accountNumber: String? = nil) {
                    self.id = id
                    self.accountName = accountName
                    self.ownerEmail = ownerEmail
                    self.accountType = accountType
                    self.seats = seats
                    self.subscriptionStartTime = subscriptionStartTime
                    self.subscriptionEndTime = subscriptionEndTime
                    self.createdAt = createdAt
                    self.accountNumber = accountNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case accountName = "account_name"
                    case ownerEmail = "owner_email"
                    case accountType = "account_type"
                    case seats
                    case subscriptionStartTime = "subscription_start_time"
                    case subscriptionEndTime = "subscription_end_time"
                    case createdAt = "created_at"
                    case accountNumber = "account_number"
                }
            }

            public init(accounts: [Account]? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.accounts = accounts
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case accounts
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?
            public var subResellerID: String?

            public init(pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil, subResellerID: String? = nil) {
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
                self.subResellerID = subResellerID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(subResellerID, forKey: "sub_reseller_id")
                return encoder.items
            }
        }

        /// Create a sub account
        ///
        /// Create a sub account under a master account. Your account must be a master account in order to create sub accounts. 
        /// <br><br>Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage sub accounts. Email the partner programs team at partner-success@zoom.us. for more details. Please note that the created account user will receive a confirmation email.<br><br>
        /// <br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher paid account with master account option enabled. <br>
        /// 
        /// **Scope**: `account:write:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of the created account.
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// Account ID.
            public var id: String?
            /// Account owner ID.
            public var ownerID: String?
            /// Account owner email.
            public var ownerEmail: String?
            /// Account created date time.
            public var createdAt: String?

            public init(id: String? = nil, ownerID: String? = nil, ownerEmail: String? = nil, createdAt: String? = nil) {
                self.id = id
                self.ownerID = ownerID
                self.ownerEmail = ownerEmail
                self.createdAt = createdAt
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case ownerID = "owner_id"
                case ownerEmail = "owner_email"
                case createdAt = "created_at"
            }
        }

        /// The account object represents an account on Zoom. The account owner is the user who created the account or had an account created for them. You can read more about the Zoom account structure <a href='https://medium.com/zoom-developer-blog/a-brief-look-at-zoom-account-structures-1d19c745bf8a' target='_blank'>here</a>.
        public struct PostRequest: Encodable {
            /// User's first name.
            public var firstName: String
            /// User's last name.
            public var lastName: String
            /// User's email address.
            public var email: String
            /// User's password.
            /// 
            /// **Note:** If the account owner or admin has enabled [enhanced password requirements](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_fa9186e4-6818-4f7a-915c-2e25c19f0acd), the value provided in this field must meet those requirements. These requirements can be retrieved by calling the [Get Account Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) and referring to the `password_requirement` field present in the `security` object.
            public var password: String
            /// Account options object.
            public var options: Options?
            /// Name of the account. If you do not provide a value for this field, by default, the value will be set as a concatenation of "first_name" and "last_name".
            public var accountName: String?
            /// The sub-reseller's ID.
            /// 
            /// If you do not provide this field in the payload, a new subaccount will be created for the requested account.
            public var subResellerID: String?

            /// Account options object.
            public struct Options: Encodable {
                /// Enable/disable the option for a sub account to use shared [Virtual Room Connector(s)](https://support.zoom.us/hc/en-us/articles/202134758-Getting-Started-With-Virtual-Room-Connector) that are set up by the master account. Virtual Room Connectors can only be used by On-prem users.
                public var isShareRc: Bool
                /// Specify the IP addresses of the Room Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Room Connectors of a master account will be shared with the sub account.
                /// 
                /// 
                /// **Note:** This option can only be used if the value of `share_rc` is set to `true`.
                public var roomConnectorList: [String]?
                /// Enable/disable the option for a sub account to use shared [Meeting Connector(s)](https://support.zoom.us/hc/en-us/articles/201363093-Getting-Started-with-the-Meeting-Connector) that are set up by the master account. Meeting Connectors can only be used by On-prem users.
                public var isShareMc: Bool
                /// Specify the IP addresses of the Meeting Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Meeting Connectors of a master account will be shared with the sub account.
                /// 
                /// 
                /// **Note:** This option can only be used if the value of `share_mc` is set to `true`.
                public var meetingConnectorList: [String]?
                /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
                public var payMode: PayMode?
                /// Toggle whether automatic billing renewal is on or off.
                public var isBillingAutoRenew: Bool?

                /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
                public enum PayMode: String, Codable, CaseIterable {
                    case master
                    case sub
                }

                public init(isShareRc: Bool? = nil, roomConnectorList: [String]? = nil, isShareMc: Bool? = nil, meetingConnectorList: [String]? = nil, payMode: PayMode? = nil, isBillingAutoRenew: Bool? = nil) {
                    self.isShareRc = isShareRc ?? false
                    self.roomConnectorList = roomConnectorList
                    self.isShareMc = isShareMc ?? false
                    self.meetingConnectorList = meetingConnectorList
                    self.payMode = payMode
                    self.isBillingAutoRenew = isBillingAutoRenew
                }

                private enum CodingKeys: String, CodingKey {
                    case isShareRc = "share_rc"
                    case roomConnectorList = "room_connector_list"
                    case isShareMc = "share_mc"
                    case meetingConnectorList = "meeting_connector_list"
                    case payMode = "pay_mode"
                    case isBillingAutoRenew = "billing_auto_renew"
                }
            }

            public init(firstName: String, lastName: String, email: String, password: String, options: Options? = nil, accountName: String? = nil, subResellerID: String? = nil) {
                self.firstName = firstName
                self.lastName = lastName
                self.email = email
                self.password = password
                self.options = options
                self.accountName = accountName
                self.subResellerID = subResellerID
            }

            private enum CodingKeys: String, CodingKey {
                case firstName = "first_name"
                case lastName = "last_name"
                case email
                case password
                case options
                case accountName = "account_name"
                case subResellerID = "sub_reseller_id"
            }
        }
    }
}

extension Paths.Accounts {
    public func accountID(_ accountID: String) -> WithAccountID {
        WithAccountID(path: "\(path)/\(accountID)")
    }

    public struct WithAccountID {
        /// Path: `/accounts/{accountId}`
        public let path: String

        /// Get sub account details
        ///
        /// Use this API to get information about Master account's sub account. 
        /// 
        ///  Your account must be a Master account in order to return sub account information. Zoom allows only approved partners to use [Master account APIs](https://marketplace.zoom.us/docs/api-reference/master-account-apis) and create sub accounts. For information about partner programs, email the partners team at [partner-success@zoom.us](mailto:partner-success@zoom.us). 
        /// 
        /// **Scopes:** `account:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or a higher paid account with the Master account option enabled.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Account ID.
            public var id: String?
            /// Account owner ID.
            public var ownerID: String?
            /// Account owner email.
            public var ownerEmail: String?
            /// Account creation date and time.
            public var createdAt: Date?
            /// Account options object.
            public var options: Options?
            /// Account Vanity URL
            public var vanityURL: String?
            /// The account's name.
            public var accountName: String?
            /// The account type.
            public var accountType: String?
            /// The account's maximum number of paid seats.
            public var seats: Int?
            /// The account's subscription start date and time.
            public var subscriptionStartTime: Date?

            /// Account options object.
            public struct Options: Decodable {
                /// Enable/disable the option for a sub account to use shared [Virtual Room Connector(s)](https://support.zoom.us/hc/en-us/articles/202134758-Getting-Started-With-Virtual-Room-Connector) that are set up by the master account. Virtual Room Connectors can only be used by On-prem users.
                public var isShareRc: Bool
                /// Specify the IP addresses of the Room Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Room Connectors of a master account will be shared with the sub account.
                /// 
                /// 
                /// **Note:** This option can only be used if the value of `share_rc` is set to `true`.
                public var roomConnectorList: [String]?
                /// Enable/disable the option for a sub account to use shared [Meeting Connector(s)](https://support.zoom.us/hc/en-us/articles/201363093-Getting-Started-with-the-Meeting-Connector) that are set up by the master account. Meeting Connectors can only be used by On-prem users.
                public var isShareMc: Bool
                /// Specify the IP addresses of the Meeting Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Meeting Connectors of a master account will be shared with the sub account.
                /// 
                /// 
                /// **Note:** This option can only be used if the value of `share_mc` is set to `true`.
                public var meetingConnectorList: [String]?
                /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
                public var payMode: PayMode?
                /// Toggle whether automatic billing renewal is on or off.
                public var isBillingAutoRenew: Bool?

                /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
                public enum PayMode: String, Codable, CaseIterable {
                    case master
                    case sub
                }

                public init(isShareRc: Bool? = nil, roomConnectorList: [String]? = nil, isShareMc: Bool? = nil, meetingConnectorList: [String]? = nil, payMode: PayMode? = nil, isBillingAutoRenew: Bool? = nil) {
                    self.isShareRc = isShareRc ?? false
                    self.roomConnectorList = roomConnectorList
                    self.isShareMc = isShareMc ?? false
                    self.meetingConnectorList = meetingConnectorList
                    self.payMode = payMode
                    self.isBillingAutoRenew = isBillingAutoRenew
                }

                private enum CodingKeys: String, CodingKey {
                    case isShareRc = "share_rc"
                    case roomConnectorList = "room_connector_list"
                    case isShareMc = "share_mc"
                    case meetingConnectorList = "meeting_connector_list"
                    case payMode = "pay_mode"
                    case isBillingAutoRenew = "billing_auto_renew"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isShareRc = try values.decodeIfPresent(Bool.self, forKey: .isShareRc) ?? false
                    self.roomConnectorList = try values.decodeIfPresent([String].self, forKey: .roomConnectorList)
                    self.isShareMc = try values.decodeIfPresent(Bool.self, forKey: .isShareMc) ?? false
                    self.meetingConnectorList = try values.decodeIfPresent([String].self, forKey: .meetingConnectorList)
                    self.payMode = try values.decodeIfPresent(PayMode.self, forKey: .payMode)
                    self.isBillingAutoRenew = try values.decodeIfPresent(Bool.self, forKey: .isBillingAutoRenew)
                }
            }

            public init(id: String? = nil, ownerID: String? = nil, ownerEmail: String? = nil, createdAt: Date? = nil, options: Options? = nil, vanityURL: String? = nil, accountName: String? = nil, accountType: String? = nil, seats: Int? = nil, subscriptionStartTime: Date? = nil) {
                self.id = id
                self.ownerID = ownerID
                self.ownerEmail = ownerEmail
                self.createdAt = createdAt
                self.options = options
                self.vanityURL = vanityURL
                self.accountName = accountName
                self.accountType = accountType
                self.seats = seats
                self.subscriptionStartTime = subscriptionStartTime
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case ownerID = "owner_id"
                case ownerEmail = "owner_email"
                case createdAt = "created_at"
                case options
                case vanityURL = "vanity_url"
                case accountName = "account_name"
                case accountType = "account_type"
                case seats
                case subscriptionStartTime = "subscription_start_time"
            }
        }

        /// Disassociate a sub account
        ///
        /// Disassociate a sub account from its master account. This will leave the sub account intact but it will no longer be associated with the master account.<br>  
        /// 
        /// **Prerequisites:**
        /// * Pro or a higher paid account with master account option enabled. <br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis).<br><br>
        /// 
        /// 
        /// **Scope**: `account:write:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var options: Options {
        Options(path: path + "/options")
    }

    public struct Options {
        /// Path: `/accounts/{accountId}/options`
        public let path: String

        /// Update options
        ///
        /// Update a sub account's options under the master account.<br> <aside>Your account must be a master account in order to update the options for sub accounts. Zoom only assigns this privilege to trusted partners. </aside>
        /// 
        /// **Prerequisites:**
        /// * Pro or a higher paid account with master account option enabled.
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis).<br><br>
        /// 
        /// **Scope**: `account:write:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Account options object.
        public struct PatchRequest: Encodable {
            /// Enable/disable the option for a sub account to use shared [Virtual Room Connector(s)](https://support.zoom.us/hc/en-us/articles/202134758-Getting-Started-With-Virtual-Room-Connector) that are set up by the master account. Virtual Room Connectors can only be used by On-prem users.
            public var isShareRc: Bool
            /// Specify the IP addresses of the Room Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Room Connectors of a master account will be shared with the sub account.
            /// 
            /// 
            /// **Note:** This option can only be used if the value of `share_rc` is set to `true`.
            public var roomConnectorList: [String]?
            /// Enable/disable the option for a sub account to use shared [Meeting Connector(s)](https://support.zoom.us/hc/en-us/articles/201363093-Getting-Started-with-the-Meeting-Connector) that are set up by the master account. Meeting Connectors can only be used by On-prem users.
            public var isShareMc: Bool
            /// Specify the IP addresses of the Meeting Connectors that you would like to share with the sub account. Multiple values can be separated by comma. If no value is provided in this field, all the Meeting Connectors of a master account will be shared with the sub account.
            /// 
            /// 
            /// **Note:** This option can only be used if the value of `share_mc` is set to `true`.
            public var meetingConnectorList: [String]?
            /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
            public var payMode: PayMode?
            /// Toggle whether automatic billing renewal is on or off.
            public var isBillingAutoRenew: Bool?

            /// Payee:<br>`master` - master account holder pays.<br>`sub` - Sub account holder pays.
            public enum PayMode: String, Codable, CaseIterable {
                case master
                case sub
            }

            public init(isShareRc: Bool? = nil, roomConnectorList: [String]? = nil, isShareMc: Bool? = nil, meetingConnectorList: [String]? = nil, payMode: PayMode? = nil, isBillingAutoRenew: Bool? = nil) {
                self.isShareRc = isShareRc ?? false
                self.roomConnectorList = roomConnectorList
                self.isShareMc = isShareMc ?? false
                self.meetingConnectorList = meetingConnectorList
                self.payMode = payMode
                self.isBillingAutoRenew = isBillingAutoRenew
            }

            private enum CodingKeys: String, CodingKey {
                case isShareRc = "share_rc"
                case roomConnectorList = "room_connector_list"
                case isShareMc = "share_mc"
                case meetingConnectorList = "meeting_connector_list"
                case payMode = "pay_mode"
                case isBillingAutoRenew = "billing_auto_renew"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/accounts/{accountId}/settings`
        public let path: String

        /// Get settings
        ///
        /// Use this API to get an account's settings information.
        /// 
        /// To get the settings of a master account, use `me` as the value for the `accountId` path parameter.
        /// 
        /// **Scopes:** `account:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites**: 
        /// * The account must be a paid account
        public func get(option: Option? = nil, customQueryFields: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(option, customQueryFields))
        }

        private func makeGetQuery(_ option: Option?, _ customQueryFields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            encoder.encode(customQueryFields, forKey: "custom_query_fields")
            return encoder.items
        }

        public enum Option: String, Codable, CaseIterable {
            case meetingAuthentication = "meeting_authentication"
            case recordingAuthentication = "recording_authentication"
            case meetingSecurity = "meeting_security"
            case security
        }

        /// Update settings
        ///
        /// Update the settings of a sub account that is under a master account.<br> To update the settings of the master account, use `me` as the value of the `accountId` path parameter.<br><br>
        /// **Prerequisites**:
        ///  * The sub account must be a paid account.<br>
        /// **Scopes**: `account:write:admin`
        /// <br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(option: Option? = nil, _ body: [String: AnyJSON]) -> Request<Void> {
            .patch(path, query: makePatchQuery(option), body: body)
        }

        private func makePatchQuery(_ option: Option?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            return encoder.items
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var managedDomains: ManagedDomains {
        ManagedDomains(path: path + "/managed_domains")
    }

    public struct ManagedDomains {
        /// Path: `/accounts/{accountId}/managed_domains`
        public let path: String

        /// Get managed domains
        ///
        /// Get a sub account's [managed domains](https://support.zoom.us/hc/en-us/articles/203395207-What-is-Managed-Domain-).<br><br>
        /// 
        /// **Note:** This API can be used by Zoom Accounts that are on a Pro or a higher plan as well accounts that have master and sub accounts options enabled. <br><br>
        /// To get managed domains of the master account, provide `me` as the value for accountId in the path parameter. Provide the sub account's Account ID as the value of accountId path parameter to get managed domains of the sub account.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher paid account with master account option enabled. <br>
        /// 
        /// **Scope:** `account:read:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// List of managed domains.
        public struct GetResponse: Decodable {
            /// Total records.
            public var totalRecords: Int?
            /// List of managed domain objects.
            public var domains: [Domain]?

            public struct Domain: Decodable {
                /// Domain name.
                public var domain: String?
                /// Domain status.
                public var status: String?

                public init(domain: String? = nil, status: String? = nil) {
                    self.domain = domain
                    self.status = status
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.domain = try values.decodeIfPresent(String.self, forKey: "domain")
                    self.status = try values.decodeIfPresent(String.self, forKey: "status")
                }
            }

            public init(totalRecords: Int? = nil, domains: [Domain]? = nil) {
                self.totalRecords = totalRecords
                self.domains = domains
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case domains
            }
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var trustedDomains: TrustedDomains {
        TrustedDomains(path: path + "/trusted_domains")
    }

    public struct TrustedDomains {
        /// Path: `/accounts/{accountId}/trusted_domains`
        public let path: String

        /// Get trusted domains
        ///
        /// Get trusted domains of a sub account. To get the trusted domains of a master account, use `me` as the value for the `accountId` path parameter.
        /// 
        /// **Prerequisites:**<br>
        /// * The sub account must be a paid account.<br>
        /// **Scope:** `account:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var lockSettings: LockSettings {
        LockSettings(path: path + "/lock_settings")
    }

    public struct LockSettings {
        /// Path: `/accounts/{accountId}/lock_settings`
        public let path: String

        /// Get locked settings
        ///
        /// [Account Locked Settings](https://support.zoom.us/hc/en-us/articles/115005269866) allow you turn settings on or off for all users in your account. No user except the account admin or account owner can change these settings. With lock settings, you force the settings on for all users.
        /// Use this API to retrieve an account's locked settings. 
        /// 
        /// **Note:** This API can be used by Zoom Accounts that are on a Pro or a higher plan as well accounts that have master and sub accounts options enabled. <br><br>
        /// **Prerequisites:**
        /// * Pro or a higher paid account. <br>
        /// 
        /// **Scope**: `account:read:admin`.
        /// <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// 
        /// 
        /// 
        /// 
        /// 
        /// **Scope:** account:read:admin
        public func get(option: String? = nil, customQueryFields: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(option, customQueryFields))
        }

        private func makeGetQuery(_ option: String?, _ customQueryFields: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            encoder.encode(customQueryFields, forKey: "custom_query_fields")
            return encoder.items
        }

        /// Update locked settings
        ///
        /// [Account Locked Settings](https://support.zoom.us/hc/en-us/articles/115005269866) allow you turn settings on or off for all users in your account. No user except the account admin or account owner can change these settings. With lock settings, you force the settings on for all users. Use this API to update an account's locked settings.
        /// 
        /// **Note:** This API can be used by Zoom Accounts that are on a Pro or a higher plan as well accounts that have master and sub accounts options enabled.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher paid account. <br>
        /// 
        /// **Scope:** `account:write:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func patch(_ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var owner: Owner {
        Owner(path: path + "/owner")
    }

    public struct Owner {
        /// Path: `/accounts/{accountId}/owner`
        public let path: String

        /// Update the account owner
        ///
        /// Use this API to change an account's owner.
        /// 
        /// An account's current owner can [change the account's owner](https://support.zoom.us/hc/en-us/articles/115005686983-Change-Account-Owner) to another user on the same account.
        /// 
        /// **Scopes:** `account:write:admin` or `account:master`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        /// 
        /// **Prerequisites:** 
        /// * An account owner or admin permissions of an account 
        /// * The account making this API request must be on a Pro or a higher account plan with [Master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) privileges
        public func put(email: String) -> Request<[String: AnyJSON]> {
            .put(path, body: ["email": email])
        }
    }
}

extension Paths.Accounts.WithAccountID.Settings {
    public var virtualBackgrounds: VirtualBackgrounds {
        VirtualBackgrounds(path: path + "/virtual_backgrounds")
    }

    public struct VirtualBackgrounds {
        /// Path: `/accounts/{accountId}/settings/virtual_backgrounds`
        public let path: String

        /// Upload virtual background files
        ///
        /// Use this API to [upload virtual background files](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_01EJF3YFEWGT8YA0ZJ079JEDQE) for all users on the account to use. 
        /// 
        /// 
        /// **Prerequisites:**<br>
        /// * Virtual background feature must be [enabled](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) on the account.
        /// <br> **Scope:** `account:write:admin`<br><br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Unique identifier of the file.
            public var id: String?
            /// File name.
            public var name: String?
            /// File type.
            public var type: String?
            /// Indicates whether or not this file is the default virtual background file.
            public var isDefault: Bool?
            /// File size.
            public var size: String?

            public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.isDefault = isDefault
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case isDefault = "is_default"
                case size
            }
        }

        /// Delete virtual background files
        ///
        /// Delete existing virtual background file(s) from an account. 
        /// 
        /// **Prerequisites:**<br>
        /// * Virtual background feature must be [enabled](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) on the account.
        /// <br> **Scope:** `account:write:admin`<br> <br> 
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func delete(fileIDs: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(fileIDs))
        }

        private func makeDeleteQuery(_ fileIDs: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fileIDs, forKey: "file_ids")
            return encoder.items
        }
    }
}

extension Paths {
    public static var roles: Roles {
        Roles(path: "/roles")
    }

    public struct Roles {
        /// Path: `/roles`
        public let path: String

        /// List roles
        ///
        /// List [roles](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) on your account
        /// 
        /// **Scopes:** `role:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// **Prerequisites** :
        /// *  Pro or higher plan. 
        /// *  For setting the initial role, you must be the Account Owner. 
        /// *  For subsequent role management, you must be the Account Owner or user with role management permissions.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Create a role
        ///
        /// Each Zoom user automatically has a role which can either be owner, administrator, or a member. 
        /// 
        /// **Pre-requisite:**<br>
        /// * Pro or higher plan.
        /// * For setting the initial role, you must be the Account Owner.<br>
        /// * For subsequent role management, you must be the Account Owner or user with role management permissions.<br>
        /// **Scopes:** `role:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Name of the role.
            public var name: String?
            /// Description of the role.
            public var description: String?
            /// Privileges assigned to the role. Can be one or a combination of [these permissions](https://marketplace.zoom.us/docs/api-reference/other-references/privileges).
            public var privileges: [String]?

            public init(name: String? = nil, description: String? = nil, privileges: [String]? = nil) {
                self.name = name
                self.description = description
                self.privileges = privileges
            }
        }
    }
}

extension Paths.Roles.WithRoleID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/roles/{roleId}/members`
        public let path: String

        /// List members in a role
        ///
        /// User [roles](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) can have a set of permissions that allows access only to the pages a user needs to view or edit. Use this API to list all the members that are assigned a specific role.
        /// 
        /// **Scope:** `role:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>**Prerequisites:**<br>
        /// * A Pro or a higher plan.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Role Members List
        ///
        /// List of a Role Members
        public struct GetResponse: Decodable {
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The page number of the current results.
            public var pageNumber: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?
            /// List of a Role Members
            public var members: [Member]?

            public struct Member: Decodable {
                /// Member ID
                public var id: String?
                /// Member Email
                public var email: String?
                /// Member First Name
                public var firstName: String?
                /// Member Last Name
                public var lastName: String?
                /// Member Type
                public var type: Int?
                /// Member Department
                public var department: String?

                public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, type: Int? = nil, department: String? = nil) {
                    self.id = id
                    self.email = email
                    self.firstName = firstName
                    self.lastName = lastName
                    self.type = type
                    self.department = department
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decodeIfPresent(String.self, forKey: "id")
                    self.email = try values.decodeIfPresent(String.self, forKey: "email")
                    self.firstName = try values.decodeIfPresent(String.self, forKey: "first_name")
                    self.lastName = try values.decodeIfPresent(String.self, forKey: "last_name")
                    self.type = try values.decodeIfPresent(Int.self, forKey: "type")
                    self.department = try values.decodeIfPresent(String.self, forKey: "department")
                }
            }

            public init(pageCount: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, members: [Member]? = nil) {
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.members = members
            }

            private enum CodingKeys: String, CodingKey {
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case members
            }
        }

        public struct GetParameters {
            public var pageCount: String?
            public var pageNumber: Int?
            public var nextPageToken: String?
            public var pageSize: Int?

            public init(pageCount: String? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil, pageSize: Int? = nil) {
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageCount, forKey: "page_count")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(pageSize, forKey: "page_size")
                return encoder.items
            }
        }

        /// Assign a role
        ///
        /// User [roles](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) can have a set of permissions that allows access only to the pages a user needs to view or edit. Use this API to [assign a role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control#h_748b6fd8-5057-4cf4-bbfd-787909c09db0) to members.
        /// 
        /// **Scopes:** `role:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// **Prerequisites:**<br>
        /// * A Pro or a higher plan.
        public func post(members: [PostRequest.Member]? = nil) -> Request<PostResponse> {
            .post(path, body: PostRequest(members: members))
        }

        public enum PostResponseHeaders {
            /// Location of created members
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// User ID
            public var ids: String?
            /// Date and time at which the members are assigned to the role.
            public var addAt: Date?

            public init(ids: String? = nil, addAt: Date? = nil) {
                self.ids = ids
                self.addAt = addAt
            }

            private enum CodingKeys: String, CodingKey {
                case ids
                case addAt = "add_at"
            }
        }

        public struct PostRequest: Encodable {
            /// Array of userId/user email of users to whom you would like to assign this role. Upto 30 users can be assigned a role at once.
            public var members: [Member]?

            public struct Member: Encodable {
                /// User ID of the user to whom you would like to assign the role.
                public var id: String?
                /// Email address of the user to whom you would like to assign the role. Provide either the userId in the ID field or the email address in the email field. If both fields are provided, only userId is used.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(members: [Member]? = nil) {
                self.members = members
            }
        }
    }
}

extension Paths.Roles.WithRoleID.Members {
    public func memberID(_ memberID: String) -> WithMemberID {
        WithMemberID(path: "\(path)/\(memberID)")
    }

    public struct WithMemberID {
        /// Path: `/roles/{roleId}/members/{memberId}`
        public let path: String

        /// Unassign a role
        ///
        /// User [roles](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) can have a set of permissions that allows access only to the pages a user needs to view or edit. Use this API to unassign a user's role.
        /// 
        /// **Scope:** `role:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites:**<br>
        /// * A Pro or a higher plan.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Roles {
    public func roleID(_ roleID: String) -> WithRoleID {
        WithRoleID(path: "\(path)/\(roleID)")
    }

    public struct WithRoleID {
        /// Path: `/roles/{roleId}`
        public let path: String

        /// Get role information
        ///
        /// Each Zoom user automatically has a role which can either be owner, administrator, or a member. Account Owners and users with edit privileges for Role management can add customized roles with a list of privileges.
        /// 
        /// Use this API to get information including specific privileges assigned to a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control).<br>
        /// **Pre-requisite:**<br>
        /// * A Pro or higher plan.<br>
        /// * For role management and updates, you must be the Account Owner or user with role management permissions.
        /// 
        /// **Scopes:** `role:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Role Id.
            public var id: String?
            /// Name of the role.
            public var name: String?
            /// Description of the role.
            public var description: String?
            /// Total members assigned to that role.
            public var totalMembers: Int?
            /// Privileges assigned to the role. Can be one or a combination of [these permissions](https://marketplace.zoom.us/docs/api-reference/other-references/privileges).
            public var privileges: [String]?
            /// This field will only be displayed to accounts that are enrolled in a partner plan and follow the master accounts and sub accounts structure.
            public var subAccountPrivileges: SubAccountPrivileges?

            /// This field will only be displayed to accounts that are enrolled in a partner plan and follow the master accounts and sub accounts structure.
            public struct SubAccountPrivileges: Decodable {
                /// Indicates how the account can manage sub accounts. The value can be one of the following:<br>
                /// `1`: Manage the sub account as an owner of the account.<br>
                /// `2`: Manage the sub account with the same privileges as the current account.<br>
                /// `3`: Manage the sub account with specified privileges.
                public var secondLevel: Int?

                public init(secondLevel: Int? = nil) {
                    self.secondLevel = secondLevel
                }

                private enum CodingKeys: String, CodingKey {
                    case secondLevel = "second_level"
                }
            }

            public init(id: String? = nil, name: String? = nil, description: String? = nil, totalMembers: Int? = nil, privileges: [String]? = nil, subAccountPrivileges: SubAccountPrivileges? = nil) {
                self.id = id
                self.name = name
                self.description = description
                self.totalMembers = totalMembers
                self.privileges = privileges
                self.subAccountPrivileges = subAccountPrivileges
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case description
                case totalMembers = "total_members"
                case privileges
                case subAccountPrivileges = "sub_account_privileges"
            }
        }

        /// Update role information
        ///
        /// Each Zoom user automatically has a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) which can either be owner, administrator, or a member. Account Owners and users with edit privileges for Role management can add customized roles with a list.
        /// 
        /// Use this API to change the privileges, name and description of a specific role.<br>
        /// **Pre-requisite:**<br>
        /// * A Pro or higher plan.<br>
        /// * For role management and updates, you must be the Account Owner or user with role management permissions.<br>**Scopes:** `role:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// Role Id.
            public var id: String?
            /// Name of the role.
            public var name: String?
            /// Description of the role.
            public var description: String?
            /// Total members assigned to that role.
            public var totalMembers: Int?
            /// Privileges assigned to the role. Can be one or a combination of [these permissions](https://marketplace.zoom.us/docs/api-reference/other-references/privileges).
            public var privileges: [String]?
            /// This field will only be displayed to accounts that are enrolled in the partner plan and follow master accounts and sub accounts structure.
            public var subAccountPrivileges: SubAccountPrivileges?

            /// This field will only be displayed to accounts that are enrolled in the partner plan and follow master accounts and sub accounts structure.
            public struct SubAccountPrivileges: Encodable {
                /// Indicates how the account can manage sub accounts. The value can be one of the following:<br>
                /// `1`: Manage the sub account as an owner of the account.<br>
                /// `2`: Manage the sub account with the same privileges as the current account.<br>
                /// `3`: Manage the sub account with specified privileges.
                public var secondLevel: Int?

                public init(secondLevel: Int? = nil) {
                    self.secondLevel = secondLevel
                }

                private enum CodingKeys: String, CodingKey {
                    case secondLevel = "second_level"
                }
            }

            public init(id: String? = nil, name: String? = nil, description: String? = nil, totalMembers: Int? = nil, privileges: [String]? = nil, subAccountPrivileges: SubAccountPrivileges? = nil) {
                self.id = id
                self.name = name
                self.description = description
                self.totalMembers = totalMembers
                self.privileges = privileges
                self.subAccountPrivileges = subAccountPrivileges
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case description
                case totalMembers = "total_members"
                case privileges
                case subAccountPrivileges = "sub_account_privileges"
            }
        }

        /// Delete a role
        ///
        /// Each Zoom user automatically has a role which can either be owner, administrator, or a member. Account Owners and users with edit privileges for Role management can add customized roles with a list.
        /// 
        /// Use this API to delete a role.<br>
        /// **Pre-requisite:**<br>
        /// * A Pro or higher plan.<br>
        /// * For role management and updates, you must be the Account Owner or user with role management permissions.
        /// 
        /// **Scopes:** `role:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var pastMeetings: PastMeetings {
        PastMeetings(path: "/past_meetings")
    }

    public struct PastMeetings {
        /// Path: `/past_meetings`
        public let path: String
    }
}

extension Paths.PastMeetings {
    public func meetingID(_ meetingID: Int) -> WithMeetingID {
        WithMeetingID(path: "\(path)/\(meetingID)")
    }

    public struct WithMeetingID {
        /// Path: `/past_meetings/{meetingId}`
        public let path: String
    }
}

extension Paths.PastMeetings.WithMeetingID {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/past_meetings/{meetingId}/files`
        public let path: String

        /// List past meeting's files
        ///
        /// **Note: This API has been deprecated and is no longer supported due to GCM encryption updates for security purposes.** To learn about saving the in-meeting chat files via Zoom Client, refer to the [Saving in-meeting chat](https://support.zoom.us/hc/en-us/articles/115004792763-Saving-in-meeting-chat) guide.
        /// 
        /// List files sent via in-meeting chat during a meeting. The in-meeting files are deleted after 24 hours of the meeting completion time. 
        /// <br><br>
        /// **Scope:** `meeting:read`, `meeting:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The total number of files found.
            public var totalRecords: Int?
            public var inMeetingFiles: [InMeetingFile]?

            public struct InMeetingFile: Decodable {
                /// Name of the file.
                public var fileName: String?
                /// URL to download the file.
                public var downloadURL: String?
                /// Size of the file in bytes.
                public var fileSize: Int?

                public init(fileName: String? = nil, downloadURL: String? = nil, fileSize: Int? = nil) {
                    self.fileName = fileName
                    self.downloadURL = downloadURL
                    self.fileSize = fileSize
                }

                private enum CodingKeys: String, CodingKey {
                    case fileName = "file_name"
                    case downloadURL = "download_url"
                    case fileSize = "file_size"
                }
            }

            public init(totalRecords: Int? = nil, inMeetingFiles: [InMeetingFile]? = nil) {
                self.totalRecords = totalRecords
                self.inMeetingFiles = inMeetingFiles
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case inMeetingFiles = "in_meeting_files"
            }
        }
    }
}

extension Paths {
    public static var pastWebinars: PastWebinars {
        PastWebinars(path: "/past_webinars")
    }

    public struct PastWebinars {
        /// Path: `/past_webinars`
        public let path: String
    }
}

extension Paths.PastWebinars {
    public func webinarID(_ webinarID: String) -> WithWebinarID {
        WithWebinarID(path: "\(path)/\(webinarID)")
    }

    public struct WithWebinarID {
        /// Path: `/past_webinars/{webinarId}`
        public let path: String
    }
}

extension Paths.PastWebinars.WithWebinarID {
    public var files: Files {
        Files(path: path + "/files")
    }

    public struct Files {
        /// Path: `/past_webinars/{webinarId}/files`
        public let path: String

        /// List past webinar files
        ///
        /// **Note: This API has been deprecated and is no longer supported due to GCM encryption updates for security purposes.**
        /// 
        /// List files sent via in-meeting chat during a meeting. The in-meeting files are deleted after 24 hours of the meeting completion time. 
        /// <br><br>
        /// **Scope:** `webinar:read`, `webinar:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The total number of files found.
            public var totalRecords: Int?
            public var inMeetingFiles: [InMeetingFile]?

            public struct InMeetingFile: Decodable {
                /// Name of the file.
                public var fileName: String?
                /// URL to download the file.
                public var downloadURL: String?
                /// Size of the file in bytes.
                public var fileSize: Int?

                public init(fileName: String? = nil, downloadURL: String? = nil, fileSize: Int? = nil) {
                    self.fileName = fileName
                    self.downloadURL = downloadURL
                    self.fileSize = fileSize
                }

                private enum CodingKeys: String, CodingKey {
                    case fileName = "file_name"
                    case downloadURL = "download_url"
                    case fileSize = "file_size"
                }
            }

            public init(totalRecords: Int? = nil, inMeetingFiles: [InMeetingFile]? = nil) {
                self.totalRecords = totalRecords
                self.inMeetingFiles = inMeetingFiles
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case inMeetingFiles = "in_meeting_files"
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var recordings: Recordings {
        Recordings(path: path + "/recordings")
    }

    public struct Recordings {
        /// Path: `/users/{userId}/recordings`
        public let path: String

        /// List all recordings
        ///
        /// Use this API to list all [cloud recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> To access a user's password protected cloud recording, add an <code>access_token</code> parameter to the download URL and provide either the <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app">JWT</a> or the user's OAuth access token as the value of the <code>access_token</code> parameter.</p>
        /// 
        /// When a user records a meeting or a webinar by choosing the **Record to the Cloud** option, the video, audio, and chat text are recorded in the Zoom cloud.
        /// 
        /// **Scopes:** `recording:read:admin`, `recording:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * Pro or a higher plan.
        /// * Cloud Recording must be enabled on the user's account.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Recording List
        ///
        /// List of recordings.
        public struct GetResponse: Decodable {
            /// Start Date.
            public var from: NaiveDate?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// End Date.
            public var to: NaiveDate?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public init(from: NaiveDate? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil) {
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.to = to
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case to
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var nextPageToken: String?
            public var mc: String?
            public var isTrash: Bool?
            public var from: NaiveDate?
            public var to: NaiveDate?
            public var trashType: String?
            public var meetingID: Int?

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, mc: String? = nil, isTrash: Bool? = nil, from: NaiveDate? = nil, to: NaiveDate? = nil, trashType: String? = nil, meetingID: Int? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.mc = mc
                self.isTrash = isTrash
                self.from = from
                self.to = to
                self.trashType = trashType
                self.meetingID = meetingID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(mc, forKey: "mc")
                encoder.encode(isTrash, forKey: "trash")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(trashType, forKey: "trash_type")
                encoder.encode(meetingID, forKey: "meeting_id")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var meetings: Meetings {
        Meetings(path: "/meetings")
    }

    public struct Meetings {
        /// Path: `/meetings`
        public let path: String
    }
}

extension Paths.Meetings.WithMeetingID {
    public var recordings: Recordings {
        Recordings(path: path + "/recordings")
    }

    public struct Recordings {
        /// Path: `/meetings/{meetingId}/recordings`
        public let path: String

        /// Get meeting recordings
        ///
        /// Get all the [recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording#h_7420acb5-1897-4061-87b4-5b76e99c03b4) from a meeting or Webinar instance. The recording files can be downloaded via the `download_url` property listed in the response.
        /// 
        /// > To access a password-protected cloud recording, add an `access_token` parameter to the download URL and provide OAuth access token or [JWT](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-jwt-app) as the `access_token` value.
        /// 
        /// **Scopes:** `recording:read:admin`, `recording:read`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func get(includeFields: String? = nil, ttl: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(includeFields, ttl))
        }

        public struct GetResponse: Decodable {
            /// JWT token for downloading the meeting recording.
            ///  This is only returned if the `include_fields` query parameter contains `download_access_token`.
            public var downloadAccessToken: String?
            /// The password of the sharing recording file.
            public var password: String?

            public init(downloadAccessToken: String? = nil, password: String? = nil) {
                self.downloadAccessToken = downloadAccessToken
                self.password = password
            }

            private enum CodingKeys: String, CodingKey {
                case downloadAccessToken = "download_access_token"
                case password
            }
        }

        private func makeGetQuery(_ includeFields: String?, _ ttl: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(includeFields, forKey: "include_fields")
            encoder.encode(ttl, forKey: "ttl")
            return encoder.items
        }

        /// Delete meeting recordings
        ///
        /// Delete all recording files of a meeting.<br><br>
        /// 
        /// **Scopes:** `recording:write:admin` `recording:write`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites**:
        /// * Cloud Recording should be enabled on the user's account.<br>
        public func delete(action: Action? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(action))
        }

        private func makeDeleteQuery(_ action: Action?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(action, forKey: "action")
            return encoder.items
        }

        public enum Action: String, Codable, CaseIterable {
            case trash
            case delete
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings {
    public func recordingID(_ recordingID: String) -> WithRecordingID {
        WithRecordingID(path: "\(path)/\(recordingID)")
    }

    public struct WithRecordingID {
        /// Path: `/meetings/{meetingId}/recordings/{recordingId}`
        public let path: String

        /// Delete a meeting recording file
        ///
        /// Delete a specific recording file from a meeting.<p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> To use this API, you must enable the <b>The host can delete cloud recordings</b> setting. You can find this setting in the <b>Recording</b> tab of the <b>Settings</b> interface in the [Zoom web portal](https://zoom.us/).</p>
        /// 
        /// **Scopes**: `recording:write:admin`, `recording:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func delete(action: Action? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(action))
        }

        private func makeDeleteQuery(_ action: Action?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(action, forKey: "action")
            return encoder.items
        }

        public enum Action: String, Codable, CaseIterable {
            case trash
            case delete
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/meetings/{meetingId}/recordings/status`
        public let path: String

        /// Recover meeting recordings
        ///
        /// Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover all deleted [Cloud Recordings](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording) of a specific meeting.<br><br>
        /// **Scopes**: `recording:write:admin` `recording:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites**:<br>
        /// * A Pro user with Cloud Recording enabled.
        public func put(action: PutRequest.Action? = nil) -> Request<Void> {
            .put(path, body: PutRequest(action: action))
        }

        public struct PutRequest: Encodable {
            public var action: Action?

            public enum Action: String, Codable, CaseIterable {
                case recover
            }

            public init(action: Action? = nil) {
                self.action = action
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings.WithRecordingID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/meetings/{meetingId}/recordings/{recordingId}/status`
        public let path: String

        /// Recover a single recording
        ///
        /// Zoom allows users to recover recordings from trash for up to 30 days from the deletion date. Use this API to recover a single recording file from the meeting.<br>
        /// **Scopes:** `recording:write:admin` `recording:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func put(action: PutRequest.Action? = nil) -> Request<Void> {
            .put(path, body: PutRequest(action: action))
        }

        public struct PutRequest: Encodable {
            public var action: Action?

            public enum Action: String, Codable, CaseIterable {
                case recover
            }

            public init(action: Action? = nil) {
                self.action = action
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/meetings/{meetingId}/recordings/settings`
        public let path: String

        /// Get meeting recording settings
        ///
        /// Retrieve settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording).<br><br>
        /// **Scopes**: `recording:read:admin` `recording:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Recording settings
        public struct GetResponse: Decodable {
            /// Determine how the meeting recording is shared.
            public var shareRecording: ShareRecording?
            /// Only authenticated users can view.
            public var isRecordingAuthentication: Bool?
            /// Authentication Options.
            public var authenticationOption: String?
            /// Authentication domains.
            public var authenticationDomains: String?
            /// Determine whether a viewer can download the recording file or not.
            public var isViewerDownload: Bool?
            /// Enable password protection for the recording by setting a password. The password must have a minimum of **eight** characters with a mix of numbers, letters and special characters.<br><br>
            /// **Note:** If the account owner or the admin has set minimum password strength requirements for recordings via Account Settings, the password value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
            public var password: String?
            /// Determine whether registration  isrequired to view the recording.
            public var isOnDemand: Bool?
            /// Approval type for the registration.<br>
            /// `0`- Automatically approve the registration when a user registers.<br>
            /// `1` - Manually approve or deny the registration of a user.<br>
            /// `2` - No registration required to view the recording.
            public var approvalType: Int?
            /// Send an email to host when someone registers to view the recording. This applies for On-demand recordings only.
            public var isSendEmailToHost: Bool?
            /// Show social share buttons on registration page. This applies for On-demand recordings only.
            public var isShowSocialShareButtons: Bool?
            /// Name of the recording.
            public var topic: String?

            /// Determine how the meeting recording is shared.
            public enum ShareRecording: String, Codable, CaseIterable {
                case publicly
                case internally
                case `none`
            }

            public init(shareRecording: ShareRecording? = nil, isRecordingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, isViewerDownload: Bool? = nil, password: String? = nil, isOnDemand: Bool? = nil, approvalType: Int? = nil, isSendEmailToHost: Bool? = nil, isShowSocialShareButtons: Bool? = nil, topic: String? = nil) {
                self.shareRecording = shareRecording
                self.isRecordingAuthentication = isRecordingAuthentication
                self.authenticationOption = authenticationOption
                self.authenticationDomains = authenticationDomains
                self.isViewerDownload = isViewerDownload
                self.password = password
                self.isOnDemand = isOnDemand
                self.approvalType = approvalType
                self.isSendEmailToHost = isSendEmailToHost
                self.isShowSocialShareButtons = isShowSocialShareButtons
                self.topic = topic
            }

            private enum CodingKeys: String, CodingKey {
                case shareRecording = "share_recording"
                case isRecordingAuthentication = "recording_authentication"
                case authenticationOption = "authentication_option"
                case authenticationDomains = "authentication_domains"
                case isViewerDownload = "viewer_download"
                case password
                case isOnDemand = "on_demand"
                case approvalType = "approval_type"
                case isSendEmailToHost = "send_email_to_host"
                case isShowSocialShareButtons = "show_social_share_buttons"
                case topic
            }
        }

        /// Update meeting recording settings
        ///
        /// Update settings applied to a meeting's [Cloud Recording](https://support.zoom.us/hc/en-us/articles/203741855-Cloud-Recording)<br><br>
        /// **Scopes**: `recording:write:admin` `recording:write`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Recording settings
        public struct PatchRequest: Encodable {
            /// Determine how the meeting recording is shared.
            public var shareRecording: ShareRecording?
            /// Only authenticated users can view.
            public var isRecordingAuthentication: Bool?
            /// Authentication Options.
            public var authenticationOption: String?
            /// Authentication domains.
            public var authenticationDomains: String?
            /// Determine whether a viewer can download the recording file or not.
            public var isViewerDownload: Bool?
            /// Enable password protection for the recording by setting a password. The password must have a minimum of **eight** characters with a mix of numbers, letters and special characters.<br><br>
            /// **Note:** If the account owner or the admin has set minimum password strength requirements for recordings via Account Settings, the password value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
            public var password: String?
            /// Determine whether registration  isrequired to view the recording.
            public var isOnDemand: Bool?
            /// Approval type for the registration.<br>
            /// `0`- Automatically approve the registration when a user registers.<br>
            /// `1` - Manually approve or deny the registration of a user.<br>
            /// `2` - No registration required to view the recording.
            public var approvalType: Int?
            /// Send an email to host when someone registers to view the recording. This applies for On-demand recordings only.
            public var isSendEmailToHost: Bool?
            /// Show social share buttons on registration page. This applies for On-demand recordings only.
            public var isShowSocialShareButtons: Bool?
            /// Name of the recording.
            public var topic: String?

            /// Determine how the meeting recording is shared.
            public enum ShareRecording: String, Codable, CaseIterable {
                case publicly
                case internally
                case `none`
            }

            public init(shareRecording: ShareRecording? = nil, isRecordingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, isViewerDownload: Bool? = nil, password: String? = nil, isOnDemand: Bool? = nil, approvalType: Int? = nil, isSendEmailToHost: Bool? = nil, isShowSocialShareButtons: Bool? = nil, topic: String? = nil) {
                self.shareRecording = shareRecording
                self.isRecordingAuthentication = isRecordingAuthentication
                self.authenticationOption = authenticationOption
                self.authenticationDomains = authenticationDomains
                self.isViewerDownload = isViewerDownload
                self.password = password
                self.isOnDemand = isOnDemand
                self.approvalType = approvalType
                self.isSendEmailToHost = isSendEmailToHost
                self.isShowSocialShareButtons = isShowSocialShareButtons
                self.topic = topic
            }

            private enum CodingKeys: String, CodingKey {
                case shareRecording = "share_recording"
                case isRecordingAuthentication = "recording_authentication"
                case authenticationOption = "authentication_option"
                case authenticationDomains = "authentication_domains"
                case isViewerDownload = "viewer_download"
                case password
                case isOnDemand = "on_demand"
                case approvalType = "approval_type"
                case isSendEmailToHost = "send_email_to_host"
                case isShowSocialShareButtons = "show_social_share_buttons"
                case topic
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings {
    public var registrants: Registrants {
        Registrants(path: path + "/registrants")
    }

    public struct Registrants {
        /// Path: `/meetings/{meetingId}/recordings/registrants`
        public let path: String

        /// List recording registrants
        ///
        /// Use this API to list registrants of a past meeting's [on-demand cloud recordings](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-recordings). Users must [register](https://marketplace.zoom.us/docs/api-reference/zoom-api/cloud-recording/meetingrecordingregistrantcreate) to view the recordings. 
        /// 
        ///  **Scopes:** `recording:read:admin`, `recording:read` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Meeting Cloud Recording Registration
        ///
        /// Information about the meeting cloud recording registrant.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var status: Status?
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public enum Status: String, Codable, CaseIterable {
                case pending
                case approved
                case denied
            }

            public init(status: Status? = nil, pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.status = status
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Create a recording registrant
        ///
        /// Cloud Recordings of past Zoom Meetings can be made [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings). Users should be [registered](https://marketplace.zoom.us/docs/api-reference/zoom-api/cloud-recording/meetingrecordingregistrantcreate) to view these recordings.
        /// 
        /// Use this API to register a user to gain access to **On-demand Cloud Recordings** of a past meeting.<br>
        /// **Scopes:** `recording:write:admin`, `recording:write`.<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Registrant ID
            public var registrantID: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Meeting Topic
            public var topic: String?
            /// Share URL for the on-demand recording. This includes the tk token for the registrant. This is similar to the token that Zoom returns in the URL response to join a registered meeting, for example: `url?tk=xxxx`. Except while the meeting registration token can be used to join the meeting, this token can only be used to watch the recording.
            public var shareURL: String?

            public init(registrantID: String? = nil, id: Int? = nil, topic: String? = nil, shareURL: String? = nil) {
                self.registrantID = registrantID
                self.id = id
                self.topic = topic
                self.shareURL = shareURL
            }

            private enum CodingKeys: String, CodingKey {
                case registrantID = "registrant_id"
                case id
                case topic
                case shareURL = "share_url"
            }
        }

        /// Registrant.
        public struct PostRequest: Encodable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Encodable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings.Registrants {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/meetings/{meetingId}/recordings/registrants/status`
        public let path: String

        /// Update registrant's status
        ///
        /// A registrant can either be approved or denied from viewing the [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) recording. 
        /// Use this API to update a registrant's status.
        /// 
        /// **Scopes:** `recording:write:admin`, `recording:write`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: body)
        }

        /// Registrant Status
        public struct PutRequest: Encodable {
            public var action: Action
            /// List of registrants
            public var registrants: [Registrant]?

            public enum Action: String, Codable, CaseIterable {
                case approve
                case deny
            }

            public struct Registrant: Encodable {
                public var id: String?

                public init(id: String? = nil) {
                    self.id = id
                }
            }

            public init(action: Action, registrants: [Registrant]? = nil) {
                self.action = action
                self.registrants = registrants
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Recordings.Registrants {
    public var questions: Questions {
        Questions(path: path + "/questions")
    }

    public struct Questions {
        /// Path: `/meetings/{meetingId}/recordings/registrants/questions`
        public let path: String

        /// Get registration questions
        ///
        /// For [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) meeting recordings, you can include fields with questions that will be shown to registrants when they register to view the recording.
        /// 
        /// Use this API to retrieve a list of questions that are displayed for users to complete when registering to view the recording of a specific meeting.<br>
        /// **Scopes:** `recording:read:admin`, `recording:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Recording Registrant Questions
        public struct GetResponse: Decodable {
            /// Array of Registrant Questions
            public var questions: [Question]?
            /// Array of Registrant Custom Questions
            public var customQuestions: [CustomQuestion]?

            public struct Question: Decodable {
                /// Field name.
                public var fieldName: FieldName?
                /// State whether the field is required to be answered by the registrant or not.
                public var isRequired: Bool?

                /// Field name.
                public enum FieldName: String, Codable, CaseIterable {
                    case lastName = "last_name"
                    case address
                    case city
                    case country
                    case zip
                    case state
                    case phone
                    case industry
                    case org
                    case jobTitle = "job_title"
                    case purchasingTimeFrame = "purchasing_time_frame"
                    case roleInPurchaseProcess = "role_in_purchase_process"
                    case noOfEmployees = "no_of_employees"
                    case comments
                }

                public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
                    self.fieldName = fieldName
                    self.isRequired = isRequired
                }

                private enum CodingKeys: String, CodingKey {
                    case fieldName = "field_name"
                    case isRequired = "required"
                }
            }

            public struct CustomQuestion: Decodable {
                /// Title of the question.
                public var title: String?
                /// The type of registration question and answers.
                public var type: `Type`?
                /// State whether registrants are required to answer custom questions or not.
                public var isRequired: Bool?
                /// Answer choices for the question. Can not be used with Short answer type.
                public var answers: [String]?

                /// The type of registration question and answers.
                public enum `Type`: String, Codable, CaseIterable {
                    case short
                    case single
                    case multiple
                }

                public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
                    self.title = title
                    self.type = type
                    self.isRequired = isRequired
                    self.answers = answers
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case type
                    case isRequired = "required"
                    case answers
                }
            }

            public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.questions = questions
                self.customQuestions = customQuestions
            }

            private enum CodingKeys: String, CodingKey {
                case questions
                case customQuestions = "custom_questions"
            }
        }

        /// Update registration questions
        ///
        /// For [on-demand](https://support.zoom.us/hc/en-us/articles/360000488283-On-demand-Recordings) meeting recordings, you can include fields with questions that will be shown to registrants when they register to view the recording.
        /// 
        /// Use this API to update registration questions that are to be answered by users while registering to view a recording.<br>
        /// **Scopes:** `recording:write:admin`, `recording:write`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// Array of Registrant Questions
            public var questions: [Question]?
            /// Array of Registrant Custom Questions
            public var customQuestions: [CustomQuestion]?

            public struct Question: Encodable {
                /// Field name.
                public var fieldName: FieldName?
                /// State whether the field is required to be answered by the registrant or not.
                public var isRequired: Bool?

                /// Field name.
                public enum FieldName: String, Codable, CaseIterable {
                    case lastName = "last_name"
                    case address
                    case city
                    case country
                    case zip
                    case state
                    case phone
                    case industry
                    case org
                    case jobTitle = "job_title"
                    case purchasingTimeFrame = "purchasing_time_frame"
                    case roleInPurchaseProcess = "role_in_purchase_process"
                    case noOfEmployees = "no_of_employees"
                    case comments
                }

                public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
                    self.fieldName = fieldName
                    self.isRequired = isRequired
                }

                private enum CodingKeys: String, CodingKey {
                    case fieldName = "field_name"
                    case isRequired = "required"
                }
            }

            public struct CustomQuestion: Encodable {
                /// Title of the question.
                public var title: String?
                /// The type of registration question and answers.
                public var type: `Type`?
                /// State whether registrants are required to answer custom questions or not.
                public var isRequired: Bool?
                /// Answer choices for the question. Can not be used with Short answer type.
                public var answers: [String]?

                /// The type of registration question and answers.
                public enum `Type`: String, Codable, CaseIterable {
                    case short
                    case single
                    case multiple
                }

                public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
                    self.title = title
                    self.type = type
                    self.isRequired = isRequired
                    self.answers = answers
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case type
                    case isRequired = "required"
                    case answers
                }
            }

            public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.questions = questions
                self.customQuestions = customQuestions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(questions, forKey: "questions")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }
    }
}

extension Paths {
    public static var archiveFiles: ArchiveFiles {
        ArchiveFiles(path: "/archive_files")
    }

    public struct ArchiveFiles {
        /// Path: `/archive_files`
        public let path: String

        /// List archived files
        ///
        /// Use this API to retrieve archived meeting or webinar files of an account. 
        /// 
        ///  Zooms [archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) allows account administrators to set up an automated mechanism to record, collect, and archive meeting data to a 3rd-party platform of their choice to satisfy FINRA and/or other compliance requirements. 
        /// 
        /// **Scopes:** `recording:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` 
        /// 
        /// **Prerequisites:** 
        /// * Follow the [enablement process](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data#h_01ENPBD3WR68D7FAKTBY92SG45) to access the archiving feature.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The query start date, in `yyyy-MM-dd'T'HH:mm:ss'Z'` format. The duration for the query defined in the `from` and `to` parameters should **not** exceed 7 days because this API **only** provides one week's data.
            public var from: String?
            /// The query end date, `yyyy-MM-dd'T'HH:mm:ss'Z'` format.
            public var to: String?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var meetings: [Meeting]?

            public struct Meeting: Decodable {
                /// The meeting's universally unique ID (UUID). Each meeting instance generates its own meeting UUID.
                public var uuid: String
                /// The meeting's ID, in long (int64) format. This is also known as the meeting number.
                public var id: Int
                /// The ID of the user who was set as the meeting's host.
                public var hostID: String
                /// The meeting's topic.
                public var topic: String
                /// The type of archived meeting or the webinar:
                /// 
                /// Meeting types:
                /// * `1`  Instant meeting.
                /// * `2`  Scheduled meeting.
                /// * `3`  Recurring meeting with no fixed time.
                /// * `4`  Meeting created using a Personal Meeting ID.
                /// * `7`  Personal Audio Conference ([PAC](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference)).
                /// * `8`  Recurring meeting with a fixed time.
                /// 
                /// Webinar types:
                /// * `5`  Webinar
                /// * `6`  Recurring webinar without a fixed time.
                /// * `9`  Recurring webinar with a fixed time.
                /// 
                /// If the recording is **not** from a meeting or webinar:
                /// 
                /// * `99`  A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
                /// * `100`  A [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).
                public var type: Int
                /// The meeting's start time.
                public var startTime: Date
                /// The meeting's timezone.
                public var timezone: String
                /// The meeting's duration.
                public var duration: Int
                /// The total size of the archive file.
                public var totalSize: Int
                /// The number of recording files returned in the API call response.
                public var recordingCount: Int
                /// Whether the meeting or webinar is internal or external: 
                /// * `internal`  An internal meeting or webinar. 
                /// * `external`  An external meeting or webinar. 
                /// 
                ///  The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.
                public var meetingType: MeetingType
                /// The user's account name.
                public var accountName: String
                /// The meeting or webinar's archive completion time.
                public var completeTime: Date
                /// Whether the meeting room is a [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).
                public var isBreakoutRoom: Bool
                /// The parent meeting's universally unique ID (UUID). Each meeting instance generates its own meeting UUID. If the `is_breakout_room` value is `true`, the API returns this value.
                public var parentMeetingID: String?
                /// Information about the archive files.
                public var archiveFiles: [[String: AnyJSON]]

                /// Whether the meeting or webinar is internal or external: 
                /// * `internal`  An internal meeting or webinar. 
                /// * `external`  An external meeting or webinar. 
                /// 
                ///  The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.
                public enum MeetingType: String, Codable, CaseIterable {
                    case `internal`
                    case external
                }

                public init(uuid: String, id: Int, hostID: String, topic: String, type: Int, startTime: Date, timezone: String, duration: Int, totalSize: Int, recordingCount: Int, meetingType: MeetingType, accountName: String, completeTime: Date, isBreakoutRoom: Bool, parentMeetingID: String? = nil, archiveFiles: [[String: AnyJSON]]) {
                    self.uuid = uuid
                    self.id = id
                    self.hostID = hostID
                    self.topic = topic
                    self.type = type
                    self.startTime = startTime
                    self.timezone = timezone
                    self.duration = duration
                    self.totalSize = totalSize
                    self.recordingCount = recordingCount
                    self.meetingType = meetingType
                    self.accountName = accountName
                    self.completeTime = completeTime
                    self.isBreakoutRoom = isBreakoutRoom
                    self.parentMeetingID = parentMeetingID
                    self.archiveFiles = archiveFiles
                }

                private enum CodingKeys: String, CodingKey {
                    case uuid
                    case id
                    case hostID = "host_id"
                    case topic
                    case type
                    case startTime = "start_time"
                    case timezone
                    case duration
                    case totalSize = "total_size"
                    case recordingCount = "recording_count"
                    case meetingType = "meeting_type"
                    case accountName = "account_name"
                    case completeTime = "complete_time"
                    case isBreakoutRoom = "is_breakout_room"
                    case parentMeetingID = "parent_meeting_id"
                    case archiveFiles = "archive_files"
                }
            }

            public init(from: String? = nil, to: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, meetings: [Meeting]? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.meetings = meetings
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case meetings
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var nextPageToken: String?
            public var from: String?
            public var to: String?
            public var queryDateType: QueryDateType?

            public enum QueryDateType: String, Codable, CaseIterable {
                case meetingStartTime = "meeting_start_time"
                case archiveCompleteTime = "archive_complete_time"
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, from: String? = nil, to: String? = nil, queryDateType: QueryDateType? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.from = from
                self.to = to
                self.queryDateType = queryDateType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(queryDateType, forKey: "query_date_type")
                return encoder.items
            }
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var archiveFiles: ArchiveFiles {
        ArchiveFiles(path: path + "/archive_files")
    }

    public struct ArchiveFiles {
        /// Path: `/accounts/{accountId}/archive_files`
        public let path: String

        /// List account's archived files
        ///
        /// Use this API to retrieve archived meeting or webinar files of an account. 
        /// 
        ///  Zooms [archiving solution](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) allows account administrators to set up an automated mechanism to record, collect, and archive meeting data to a 3rd-party platform of their choice to satisfy FINRA and/or other compliance requirements. 
        /// 
        /// **Scopes:** `recording:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` 
        /// 
        /// **Prerequisites:** 
        /// * Follow the [enablement process](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data#h_01ENPBD3WR68D7FAKTBY92SG45) to access the archiving feature.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The query start date, in `yyyy-MM-dd'T'HH:mm:ss'Z'` format. The duration for the query defined in the `from` and `to` parameters should **not** exceed 7 days because this API **only** provides one week's data.
            public var from: String?
            /// The query end date, `yyyy-MM-dd'T'HH:mm:ss'Z'` format.
            public var to: String?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var meetings: [Meeting]?

            public struct Meeting: Decodable {
                /// The meeting's universally unique ID (UUID). Each meeting instance generates its own meeting UUID.
                public var uuid: String
                /// The meeting's ID, in long (int64) format. This is also known as the meeting number.
                public var id: Int
                /// The ID of the user who was set as the meeting's host.
                public var hostID: String
                /// The meeting's topic.
                public var topic: String
                /// The type of archived meeting or the webinar:
                /// 
                /// Meeting types:
                /// * `1`  Instant meeting.
                /// * `2`  Scheduled meeting.
                /// * `3`  Recurring meeting with no fixed time.
                /// * `4`  Meeting created using a Personal Meeting ID.
                /// * `7`  Personal Audio Conference ([PAC](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference)).
                /// * `8`  Recurring meeting with a fixed time.
                /// 
                /// Webinar types:
                /// * `5`  Webinar
                /// * `6`  Recurring webinar without a fixed time.
                /// * `9`  Recurring webinar with a fixed time.
                /// 
                /// If the recording is **not** from a meeting or webinar:
                /// 
                /// * `99`  A recording uploaded via the [**Recordings**](https://zoom.us/recording) interface on the Zoom Web Portal.
                /// * `100`  A [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).
                public var type: Int
                /// The meeting's start time.
                public var startTime: Date
                /// The meeting's timezone.
                public var timezone: String
                /// The meeting's duration.
                public var duration: Int
                /// The total size of the archive file.
                public var totalSize: Int
                /// The number of recording files returned in the API call response.
                public var recordingCount: Int
                /// Whether the meeting or webinar is internal or external: 
                /// * `internal`  An internal meeting or webinar. 
                /// * `external`  An external meeting or webinar. 
                /// 
                ///  The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.
                public var meetingType: MeetingType
                /// The user's account name.
                public var accountName: String
                /// The meeting or webinar's archive completion time.
                public var completeTime: Date
                /// Whether the meeting room is a [breakout room](https://support.zoom.us/hc/en-us/articles/115005769646-Participating-in-breakout-rooms).
                public var isBreakoutRoom: Bool
                /// The parent meeting's universally unique ID (UUID). Each meeting instance generates its own meeting UUID. If the `is_breakout_room` value is `true`, the API returns this value.
                public var parentMeetingID: String?
                /// Information about the archive files.
                public var archiveFiles: [[String: AnyJSON]]

                /// Whether the meeting or webinar is internal or external: 
                /// * `internal`  An internal meeting or webinar. 
                /// * `external`  An external meeting or webinar. 
                /// 
                ///  The `id`, `host_id`, and `topic` PII (Personal Identifiable Information) values in this response are removed when this value is `external`.
                public enum MeetingType: String, Codable, CaseIterable {
                    case `internal`
                    case external
                }

                public init(uuid: String, id: Int, hostID: String, topic: String, type: Int, startTime: Date, timezone: String, duration: Int, totalSize: Int, recordingCount: Int, meetingType: MeetingType, accountName: String, completeTime: Date, isBreakoutRoom: Bool, parentMeetingID: String? = nil, archiveFiles: [[String: AnyJSON]]) {
                    self.uuid = uuid
                    self.id = id
                    self.hostID = hostID
                    self.topic = topic
                    self.type = type
                    self.startTime = startTime
                    self.timezone = timezone
                    self.duration = duration
                    self.totalSize = totalSize
                    self.recordingCount = recordingCount
                    self.meetingType = meetingType
                    self.accountName = accountName
                    self.completeTime = completeTime
                    self.isBreakoutRoom = isBreakoutRoom
                    self.parentMeetingID = parentMeetingID
                    self.archiveFiles = archiveFiles
                }

                private enum CodingKeys: String, CodingKey {
                    case uuid
                    case id
                    case hostID = "host_id"
                    case topic
                    case type
                    case startTime = "start_time"
                    case timezone
                    case duration
                    case totalSize = "total_size"
                    case recordingCount = "recording_count"
                    case meetingType = "meeting_type"
                    case accountName = "account_name"
                    case completeTime = "complete_time"
                    case isBreakoutRoom = "is_breakout_room"
                    case parentMeetingID = "parent_meeting_id"
                    case archiveFiles = "archive_files"
                }
            }

            public init(from: String? = nil, to: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, meetings: [Meeting]? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.meetings = meetings
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case meetings
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var nextPageToken: String?
            public var from: String?
            public var to: String?
            public var queryDateType: QueryDateType?

            public enum QueryDateType: String, Codable, CaseIterable {
                case meetingStartTime = "meeting_start_time"
                case archiveCompleteTime = "archive_complete_time"
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, from: String? = nil, to: String? = nil, queryDateType: QueryDateType? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.from = from
                self.to = to
                self.queryDateType = queryDateType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(queryDateType, forKey: "query_date_type")
                return encoder.items
            }
        }
    }
}

extension Paths.PastMeetings.WithMeetingUUID {
    public var archiveFiles: ArchiveFiles {
        ArchiveFiles(path: path + "/archive_files")
    }

    public struct ArchiveFiles {
        /// Path: `/past_meetings/{meetingUUID}/archive_files`
        public let path: String

        /// Get meeting archived files
        ///
        /// List the archived recording files of the specific meeting instance. For more information, read our [Managing archiving of meeting and webinar data](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) documentation.
        /// 
        /// **Scopes:** `recording:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Follow the [enablement process](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data#h_01ENPBD3WR68D7FAKTBY92SG45) to access the archiving feature.
        public var get: Request<[String: [String: AnyJSON]]> {
            .get(path)
        }

        /// Delete archived meeting files
        ///
        /// Use this API to delete a meeting instance's archived recording files. For more information, read our [Managing archiving of meeting and webinar data](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data) documentation.
        /// 
        /// **Scopes:** `recording:write:admin`, `recording:write` <br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Follow the [enablement process](https://support.zoom.us/hc/en-us/articles/360050431572-Archiving-Meeting-and-Webinar-data#h_01ENPBD3WR68D7FAKTBY92SG45) to access the archiving feature.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var rooms: Rooms {
        Rooms(path: "/rooms")
    }

    public struct Rooms {
        /// Path: `/rooms`
        public let path: String

        /// List Zoom Rooms
        ///
        /// Zoom Rooms is a software-based room system that provides an integrated experience for audio conferencing, wireless screen sharing and video conferencing. Use this API to list all the existing [Zoom Rooms](https://support.zoom.us/hc/en-us/articles/207483343-Getting-Started-with-Zoom-Rooms) in a Zoom account.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Zoom Room](https://zoom.us/zoomrooms) license.<br>
        /// **Scopes**: `room:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// List of existing Zoom Rooms.
            public var rooms: [Room]?

            public struct Room: Decodable {
                /// Unique Identifier of the Zoom Room.
                public var id: String?
                /// Name of the Zoom Room.
                public var name: String?
                /// Activation Code is the code that is used to complete the setup of the Zoom Room.
                public var activationCode: String?
                /// Status of the Zoom Room.
                public var status: Status?
                /// Globally unique identifier of the Zoom Room. Use this ID for the **Dashboard Zoom Room APIs**.
                public var roomID: String?
                /// Unique Identifier of the [location](https://marketplace.zoom.us/docs/api-reference/zoom-api/rooms-location/listzrlocations) of the room.
                public var locationID: String?

                /// Status of the Zoom Room.
                public enum Status: String, Codable, CaseIterable {
                    case offline = "Offline"
                    case available = "Available"
                    case inMeeting = "InMeeting"
                    case underConstruction = "UnderConstruction"
                }

                public init(id: String? = nil, name: String? = nil, activationCode: String? = nil, status: Status? = nil, roomID: String? = nil, locationID: String? = nil) {
                    self.id = id
                    self.name = name
                    self.activationCode = activationCode
                    self.status = status
                    self.roomID = roomID
                    self.locationID = locationID
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case activationCode = "activation_code"
                    case status
                    case roomID = "room_id"
                    case locationID = "location_id"
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, rooms: [Room]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.rooms = rooms
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case rooms
            }
        }

        public struct GetParameters {
            public var status: Status?
            public var type: `Type`?
            public var isUnassignedRooms: Bool?
            public var pageSize: Int?
            public var nextPageToken: String?
            public var locationID: String?

            public enum Status: String, Codable, CaseIterable {
                case offline = "Offline"
                case available = "Available"
                case inMeeting = "InMeeting"
                case underConstruction = "UnderConstruction"
            }

            public enum `Type`: String, Codable, CaseIterable {
                case zoomRoom = "ZoomRoom"
                case schedulingDisplayOnly = "SchedulingDisplayOnly"
                case digitalSignageOnly = "DigitalSignageOnly"
            }

            public init(status: Status? = nil, type: `Type`? = nil, isUnassignedRooms: Bool? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, locationID: String? = nil) {
                self.status = status
                self.type = type
                self.isUnassignedRooms = isUnassignedRooms
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.locationID = locationID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(type, forKey: "type")
                encoder.encode(isUnassignedRooms, forKey: "unassigned_rooms")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(locationID, forKey: "location_id")
                return encoder.items
            }
        }

        /// Add a Zoom Room
        ///
        /// Use this API to [add a Zoom Room](https://support.zoom.us/hc/en-us/articles/202822279-Add-Zoom-Rooms-on-Web-Portal) to a Zoom account.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Zoom Room](https://zoom.us/zoomrooms) license.<br>
        /// **Scopes**: `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Unique Identifier of the Zoom Room.
            public var id: String?
            /// Name of the Zoom Room.
            public var name: String?
            /// Type of the Zoom Room.
            public var type: `Type`?
            /// Location ID of the location where the Zoom Room was added.
            public var locationID: String?
            /// Globally unique identifier of the Zoom Room. Use this ID for the **Dashboard Zoom Room APIs**.
            public var roomID: String?

            /// Type of the Zoom Room.
            public enum `Type`: String, Codable, CaseIterable {
                case zoomRoom = "ZoomRoom"
                case schedulingDisplayOnly = "SchedulingDisplayOnly"
                case digitalSignageOnly = "DigitalSignageOnly"
            }

            public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, locationID: String? = nil, roomID: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.locationID = locationID
                self.roomID = roomID
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case locationID = "location_id"
                case roomID = "room_id"
            }
        }

        public struct PostRequest: Encodable {
            /// Name of the Zoom Room.
            public var name: String
            /// Type of the Zoom Room.
            public var type: `Type`
            /// **Optional**<br>Location ID of the lowest level location in the [location hierarchy](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) where the Zoom Room is to be added. For instance if the structure of the location hierarchy is set up as country, states, city, campus, building, floor, a room can only be added under the floor level location. 
            /// 
            /// This ID can be retrieved from the [List Zoom Room Locations](https://marketplace.zoom.us/docs/api-reference/zoom-api/rooms-location/listzrlocations) API.
            public var locationID: String?

            /// Type of the Zoom Room.
            public enum `Type`: String, Codable, CaseIterable {
                case zoomRoom = "ZoomRoom"
                case schedulingDisplayOnly = "SchedulingDisplayOnly"
                case digitalSignageOnly = "DigitalSignageOnly"
            }

            public init(name: String, type: `Type`, locationID: String? = nil) {
                self.name = name
                self.type = type
                self.locationID = locationID
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case type
                case locationID = "location_id"
            }
        }
    }
}

extension Paths.Rooms {
    public var accountProfile: AccountProfile {
        AccountProfile(path: path + "/account_profile")
    }

    public struct AccountProfile {
        /// Path: `/rooms/account_profile`
        public let path: String

        /// Get Zoom Room account profile
        ///
        /// Get details on the account profile of a Zoom Room. This information can only by accessed either by the Zoom Room Account Owner or a user with Zoom Rooms admin permission. To get information on an individual Room Profile, use [Get Zoom Room Profile API](https://marketplace.zoom.us/docs/api-reference/zoom-api/rooms/getzrprofile) instead.
        /// 
        /// **Prerequisites:**<br>
        /// * Zoom account owner or Zoom Rooms admin permissions<br>
        /// 
        /// **Scopes:** `room:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var basic: Basic?

            public struct Basic: Decodable {
                /// The email address used for reporting Zoom Room issues.
                public var supportEmail: String?
                /// The phone number used for reporting Zoom room issues.
                public var supportPhone: String?
                /// 1-16 digit number or characters used to secure your Zoom Rooms application. This code must be entered on your Zoom Room Controller to change settings or to sign out.
                public var roomPasscode: String?
                /// Require code to exit out of the Zoom Rooms application to switch between other apps.
                public var isRequiredCodeToExt: Bool?

                public init(supportEmail: String? = nil, supportPhone: String? = nil, roomPasscode: String? = nil, isRequiredCodeToExt: Bool? = nil) {
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.roomPasscode = roomPasscode
                    self.isRequiredCodeToExt = isRequiredCodeToExt
                }

                private enum CodingKeys: String, CodingKey {
                    case supportEmail = "support_email"
                    case supportPhone = "support_phone"
                    case roomPasscode = "room_passcode"
                    case isRequiredCodeToExt = "required_code_to_ext"
                }
            }

            public init(basic: Basic? = nil) {
                self.basic = basic
            }
        }

        /// Update Zoom Room account profile
        ///
        /// Update information on the account profile of a Zoom Room. This information can only by accessed either by the Zoom Room Account Owner or a user with Zoom Rooms admin permission. To update information on an individual Room Profile, use [Update Zoom Room Profile API](https://marketplace.zoom.us/docs/api-reference/zoom-api/rooms/updatezrprofile) instead.
        /// 
        /// **Prerequisites:**<br>
        /// * Zoom account owner or Zoom Rooms admin permissions<br>
        /// 
        /// **Scopes:** `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(basic: PatchRequest.Basic? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(basic: basic))
        }

        public struct PatchRequest: Encodable {
            public var basic: Basic?

            public struct Basic: Encodable {
                /// The email address used for reporting Zoom Room issues.
                public var supportEmail: String?
                /// The phone number used for reporting Zoom room issues.
                public var supportPhone: String?
                /// 1-16 digit number or characters used to secure your Zoom Rooms application. This code must be entered on your Zoom Room Controller to change settings or to sign out.
                public var roomPasscode: String?
                /// Require code to exit out of the Zoom Rooms application to switch between other apps.
                public var isRequiredCodeToExt: Bool?

                public init(supportEmail: String? = nil, supportPhone: String? = nil, roomPasscode: String? = nil, isRequiredCodeToExt: Bool? = nil) {
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.roomPasscode = roomPasscode
                    self.isRequiredCodeToExt = isRequiredCodeToExt
                }

                private enum CodingKeys: String, CodingKey {
                    case supportEmail = "support_email"
                    case supportPhone = "support_phone"
                    case roomPasscode = "room_passcode"
                    case isRequiredCodeToExt = "required_code_to_ext"
                }
            }

            public init(basic: Basic? = nil) {
                self.basic = basic
            }
        }
    }
}

extension Paths.Rooms {
    public var accountSettings: AccountSettings {
        AccountSettings(path: path + "/account_settings")
    }

    public struct AccountSettings {
        /// Path: `/rooms/account_settings`
        public let path: String

        /// Get Zoom Room account settings
        ///
        /// Get details on Account Settings of a Zoom Room. With this API, you can view either the **Account Meeting Settings** or the **Alert Settings** (Client Alert Settings and Notfication Settings) of the Zoom Rooms account. By default, only **Account Meeting Settings** are returned. To view only **Alert Settings**, specify `alert` as the value of the `setting_type` query parameter.<br><br>
        /// **Prerequisites:**<br>
        /// * Zoom Room licenses
        /// * Owner or Admin privileges on the Zoom Account.<br>
        /// **Scopes:** `room:read:admin`<br><br> 
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(settingType: SettingType) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(settingType))
        }

        private func makeGetQuery(_ settingType: SettingType) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(settingType, forKey: "setting_type")
            return encoder.items
        }

        public enum SettingType: String, Codable, CaseIterable {
            case meeting
            case alert
        }

        /// Update Zoom Room account settings
        ///
        /// Update account settings applied for Zoom Rooms in a Zoom account. With this API, you can update either the **Account Meeting Settings** or the **Alert Settings** (Client Alert Settings and Notfication Settings) of the Zoom Rooms account by specifying the required setting type in the `setting_type` parameter. To update only **Alert Settings**, specify `alert` as the value of the `setting_type` query parameter and to update only **Account Meeting Settings**, specify `meeting` as the value of the `setting_type` query parameter.<br><br>
        /// **Prerequisites:**<br>
        /// * Zoom Room licenses
        /// * Owner or Admin privileges on the Zoom Account.<br>
        /// **Scopes:** `room:write:admin`<br> 
        /// 
        ///   **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(settingType: String, _ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, query: [("setting_type", settingType)], body: body)
        }
    }
}

extension Paths.Rooms {
    public var locations: Locations {
        Locations(path: path + "/locations")
    }

    public struct Locations {
        /// Path: `/rooms/locations`
        public let path: String

        /// List Zoom Room locations
        ///
        /// A Zoom account owner or a Zoom Room administrator can establish a [location hierarchy](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) to help manage Zoom Rooms that are spread among a variety of locations. Use this API to list the different location types used for Zoom Rooms in an account.<br><br>
        /// **Prerequisites:**
        /// * Account owner or admin permissions.
        /// * Zoom Rooms Version 4.0 or higher<br><br>
        /// **Scopes:** `room:read:admin`<br> 
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var locations: [Location]?

            public struct Location: Decodable {
                /// Unique Identifier of the location.
                public var id: String?
                /// Name of the location.
                public var name: String?
                /// ID (Unique Identifier) of the parent location. For instance, if a Zoom Room is located in Floor 1 of Building A, the location of Building A will be the parent location of Floor 1 and the parent_location_id of Floor 1 will be the ID of Building A.<br>
                /// The value of parent_location_id of the top-level location (country) is the Account ID of the Zoom account.
                public var parentLocationID: String?
                /// The type of location. The value can be one of the following:
                /// `country`, `states`, `city`, `campus`, `building`, `floor`.
                public var type: `Type`?

                /// The type of location. The value can be one of the following:
                /// `country`, `states`, `city`, `campus`, `building`, `floor`.
                public enum `Type`: String, Codable, CaseIterable {
                    case country
                    case states
                    case city
                    case campus
                    case building
                    case floor
                }

                public init(id: String? = nil, name: String? = nil, parentLocationID: String? = nil, type: `Type`? = nil) {
                    self.id = id
                    self.name = name
                    self.parentLocationID = parentLocationID
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case parentLocationID = "parent_location_id"
                    case type
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, locations: [Location]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.locations = locations
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case locations
            }
        }

        public struct GetParameters {
            public var parentLocationID: String?
            public var type: String?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(parentLocationID: String? = nil, type: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.parentLocationID = parentLocationID
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(parentLocationID, forKey: "parent_location_id")
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Add a location
        ///
        /// Add a location to the [location hierarchial structure(s)](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) of Zoom Rooms in an account.
        /// 
        /// **Prerequisites:**
        /// * Account owner or admin permissions.
        /// * Zoom Rooms Version 4.0 or higher<br><br>
        /// **Scopes:** `room:write:admin`<br> 
        /// 
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Location ID: Unique Identifier of the location that was added.
            public var id: String?
            /// Name of the location.
            public var name: String?
            /// Type of location. The value should be one of the following:<br>
            /// `country`, `states`, `city`, `campus`, `building`, `floor`.
            public var type: `Type`?
            /// Unique Identifier of the parent location.
            public var parentLocationID: String?

            /// Type of location. The value should be one of the following:<br>
            /// `country`, `states`, `city`, `campus`, `building`, `floor`.
            public enum `Type`: String, Codable, CaseIterable {
                case country
                case states
                case city
                case campus
                case building
                case floor
            }

            public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, parentLocationID: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.parentLocationID = parentLocationID
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case parentLocationID = "parent_location_id"
            }
        }

        public struct PostRequest: Encodable {
            /// Name of the location. The name must be unique and shouldn't have already been used in the same account.
            public var name: String?
            /// The location ID of the location that is a level higher from the location that is being added.<br><br> For example, to add a City named "City 1" as the child location under a State named "State 1", you must provide the location ID of "State 1". This can be retrieved using the [List Zoom Room Locations](https://marketplace.zoom.us/docs/api-reference/zoom-api/rooms-location/listzrlocations) API.
            public var parentLocationID: String?

            public init(name: String? = nil, parentLocationID: String? = nil) {
                self.name = name
                self.parentLocationID = parentLocationID
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case parentLocationID = "parent_location_id"
            }
        }
    }
}

extension Paths.Rooms.Locations {
    public func locationID(_ locationID: String) -> WithLocationID {
        WithLocationID(path: "\(path)/\(locationID)")
    }

    public struct WithLocationID {
        /// Path: `/rooms/locations/{locationId}`
        public let path: String

        /// Get Zoom Room location profile
        ///
        /// Each location type of the [Zoom Rooms location hierarchy](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) has a profile page that includes information such as name of the location, address, support email, etc. Use this API to retrieve information about a specific Zoom Rooms location type such as information about the city where the Zoom Rooms is located.
        /// 
        /// **Prerequisite:**<br>
        /// * Account owner or admin permission
        /// * Zoom Rooms version 4.0 or higher<br>
        /// **Scopes:** `room:read:admin`<br> 
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var basic: Basic?

            public struct Basic: Decodable {
                /// Name of the location type.
                public var name: String?
                /// Description about the location.
                public var description: String?
                /// Timezone (only returned for location type - city).
                public var timezone: String?
                /// Address
                public var address: String?
                /// The email address to be used for reporting Zoom Room issues.
                public var supportEmail: String?
                /// The phone number to be used for reporting Zoom Room issues.
                public var supportPhone: String?
                /// 1-16 digit number or characters that is used to secure your Zoom Rooms application.
                public var roomPasscode: String?
                /// Require code to exit out of your Zoom Rooms application to switch between other apps.
                public var isRequiredCodeToExt: Bool?

                public init(name: String? = nil, description: String? = nil, timezone: String? = nil, address: String? = nil, supportEmail: String? = nil, supportPhone: String? = nil, roomPasscode: String? = nil, isRequiredCodeToExt: Bool? = nil) {
                    self.name = name
                    self.description = description
                    self.timezone = timezone
                    self.address = address
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.roomPasscode = roomPasscode
                    self.isRequiredCodeToExt = isRequiredCodeToExt
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case description = "description "
                    case timezone
                    case address
                    case supportEmail = "support_email"
                    case supportPhone = "support_phone"
                    case roomPasscode = "room_passcode"
                    case isRequiredCodeToExt = "required_code_to_ext"
                }
            }

            public init(basic: Basic? = nil) {
                self.basic = basic
            }
        }

        /// Update Zoom Room location profile
        ///
        /// Each location type of the [Zoom Rooms location hierarchy](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) has a profile page that includes information such as name of the location, address, support email, etc. Use this API to update information about a specific Zoom Rooms location type such as information about the city where the Zoom Rooms is located.
        /// 
        /// **Prerequisite:**<br>
        /// * Account owner or admin permission
        /// * Zoom Rooms version 4.0 or higher<br>
        /// **Scopes:** `room:write:admin`<br> 
        /// 
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(basic: PatchRequest.Basic? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(basic: basic))
        }

        public struct PatchRequest: Encodable {
            public var basic: Basic?

            public struct Basic: Encodable {
                /// Name of the location type.
                public var name: String?
                /// Description about the location.
                public var description: String?
                /// Timezone (can only be updated for location type - city).
                public var timezone: String?
                /// Address. Can only be updated for Campus and Building.
                public var address: String?
                /// The email address to be used for reporting Zoom Room issues.
                public var supportEmail: String?
                /// The phone number to be used for reporting Zoom Room issues.
                public var supportPhone: String?
                /// 1-16 digit number or characters that is used to secure your Zoom Rooms application.
                public var roomPasscode: String?
                /// Require code to exit out of your Zoom Rooms application to switch between other apps.
                public var isRequiredCodeToExt: Bool?

                public init(name: String? = nil, description: String? = nil, timezone: String? = nil, address: String? = nil, supportEmail: String? = nil, supportPhone: String? = nil, roomPasscode: String? = nil, isRequiredCodeToExt: Bool? = nil) {
                    self.name = name
                    self.description = description
                    self.timezone = timezone
                    self.address = address
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.roomPasscode = roomPasscode
                    self.isRequiredCodeToExt = isRequiredCodeToExt
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case description = "description "
                    case timezone
                    case address
                    case supportEmail = "support_email"
                    case supportPhone = "support_phone"
                    case roomPasscode = "room_passcode"
                    case isRequiredCodeToExt = "required_code_to_ext"
                }
            }

            public init(basic: Basic? = nil) {
                self.basic = basic
            }
        }
    }
}

extension Paths.Rooms.Locations.WithLocationID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/rooms/locations/{locationId}/settings`
        public let path: String

        /// Get location settings
        ///
        /// Get information on meeting or alert settings applied to Zoom Rooms located in a specific location. By default, only **Meeting Settings** are returned. To view only **Alert Settings**, specify `alert` as the value of the `setting_type` query parameter.<br><br>
        /// **Prerequisites:**<br>
        /// * Zoom Room licenses
        /// * Owner or Admin privileges on the Zoom Account.<br>
        /// **Scopes:** `room:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(settingType: String) -> Request<[String: AnyJSON]> {
            .get(path, query: [("setting_type", settingType)])
        }

        /// Update location settings
        ///
        /// Update information on either meeting or alert settings applied to Zoom Rooms located in a specific location. To update **Alert Settings**, specify `alert` as the value of the `setting_type` query parameter. Similarly, to update **Meeting Settings**, specify `meeting` as the value of the `setting_type` query parameter.<br><br>
        /// **Prerequisites:**<br>
        /// * Zoom Room licenses
        /// * Owner or Admin privileges on the Zoom Account.<br>
        /// **Scopes:** `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(settingType: String, _ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, query: [("setting_type", settingType)], body: body)
        }
    }
}

extension Paths.Rooms.Locations {
    public var structure: Structure {
        Structure(path: path + "/structure")
    }

    public struct Structure {
        /// Path: `/rooms/locations/structure`
        public let path: String

        /// Get Zoom Room location structure
        ///
        /// Get the [location hierarchial structure(s)](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) applied on the Zoom Rooms in an account.<br><br>
        /// **Prerequisites:**<br>
        /// * Zoom Rooms version 4.0 or higher
        /// * Account owner or admin permissions<br>
        /// **Scopes:** `room:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Hierarchial structure array of the Zoom Rooms location.
            public var structures: [String]?

            public init(structures: [String]? = nil) {
                self.structures = structures
            }
        }

        /// Update Zoom Rooms location structure
        ///
        /// Update the [location hierarchial structure(s)](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) applied on the Zoom Rooms in an account.<br><br>
        /// **Prerequisites:**<br>
        /// * Zoom Rooms version 4.0 or higher
        /// * Account owner or admin permissions<br>
        /// **Scopes:** `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(structures: [String]? = nil) -> Request<[String: AnyJSON]> {
            .put(path, body: ["structures": structures])
        }
    }
}

extension Paths.Rooms {
    public func roomID(_ roomID: String) -> WithRoomID {
        WithRoomID(path: "\(path)/\(roomID)")
    }

    public struct WithRoomID {
        /// Path: `/rooms/{roomId}`
        public let path: String

        /// Get Zoom Room profile
        ///
        /// Zoom Rooms is a software-based room system that provides an integrated experience for audio conferencing, wireless screen sharing and video conferencing. Use this API to get detailed information on a specific Zoom Room in a Zoom account.
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Zoom Room](https://zoom.us/zoomrooms) license.<br>
        /// **Scopes**: `room:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(isRegenerateActivationCode: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(isRegenerateActivationCode))
        }

        public struct GetResponse: Decodable {
            public var basic: Basic?

            public struct Basic: Decodable {
                /// Name of the Zoom Room.
                public var name: String?
                /// Activation Code is the code that is used to complete the setup of the Zoom Room.
                public var activationCode: String?
                /// The email address to be used for reporting Zoom Room issues.
                public var supportEmail: String?
                /// The phone number to be used for reporting Zoom Room issues.
                public var supportPhone: String?
                /// 1-16 digit number or characters that is used to secure your Zoom Rooms application. This code must be entered on your Zoom Room Controller to change settings or sign out.
                public var roomPasscode: String?
                /// Require code to exit out of Zoom Rooms application to switch between other apps.
                public var isRequiredCodeToExt: Bool?
                /// Hide this Zoom Room from your Contact List.
                public var isHideRoomInContacts: Bool?

                public init(name: String? = nil, activationCode: String? = nil, supportEmail: String? = nil, supportPhone: String? = nil, roomPasscode: String? = nil, isRequiredCodeToExt: Bool? = nil, isHideRoomInContacts: Bool? = nil) {
                    self.name = name
                    self.activationCode = activationCode
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.roomPasscode = roomPasscode
                    self.isRequiredCodeToExt = isRequiredCodeToExt
                    self.isHideRoomInContacts = isHideRoomInContacts
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case activationCode = "activation_code"
                    case supportEmail = "support_email"
                    case supportPhone = "support_phone"
                    case roomPasscode = "room_passcode"
                    case isRequiredCodeToExt = "required_code_to_ext"
                    case isHideRoomInContacts = "hide_room_in_contacts"
                }
            }

            public init(basic: Basic? = nil) {
                self.basic = basic
            }
        }

        private func makeGetQuery(_ isRegenerateActivationCode: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isRegenerateActivationCode, forKey: "regenerate_activation_code")
            return encoder.items
        }

        /// Update a Zoom Room profile
        ///
        /// Update basic information on a specific Zoom Room in a Zoom account.<br>
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Zoom Room](https://zoom.us/zoomrooms) license.<br>
        /// **Scopes**: `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(basic: PatchRequest.Basic? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: PatchRequest(basic: basic))
        }

        public struct PatchRequest: Encodable {
            public var basic: Basic?

            public struct Basic: Encodable {
                /// Name of the Zoom Room.
                public var name: String?
                /// The email address to be used for reporting Zoom Room issues.
                public var supportEmail: String?
                /// The phone number to be used for reporting Zoom Room issues.
                public var supportPhone: String?
                /// 1-16 digit number or characters that is used to secure your Zoom Rooms application. This code must be entered on your Zoom Room Controller to change settings or sign out.
                public var roomPasscode: String?
                /// Require code to exit out of Zoom Rooms application to switch between other apps.
                public var isRequiredCodeToExt: Bool?
                /// Hide this Zoom Room from your Contact List.
                public var isHideRoomInContacts: Bool?

                public init(name: String? = nil, supportEmail: String? = nil, supportPhone: String? = nil, roomPasscode: String? = nil, isRequiredCodeToExt: Bool? = nil, isHideRoomInContacts: Bool? = nil) {
                    self.name = name
                    self.supportEmail = supportEmail
                    self.supportPhone = supportPhone
                    self.roomPasscode = roomPasscode
                    self.isRequiredCodeToExt = isRequiredCodeToExt
                    self.isHideRoomInContacts = isHideRoomInContacts
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case supportEmail = "support_email"
                    case supportPhone = "support_phone"
                    case roomPasscode = "room_passcode"
                    case isRequiredCodeToExt = "required_code_to_ext"
                    case isHideRoomInContacts = "hide_room_in_contacts"
                }
            }

            public init(basic: Basic? = nil) {
                self.basic = basic
            }
        }

        /// Delete a Zoom Room
        ///
        /// [Remove](https://support.zoom.us/hc/en-us/articles/360033432032-Zoom-Room-Device-Profiles#h_e55b2092-c418-4b02-819f-44de51448900) a specific Zoom Room profile from a Zoom account.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Zoom Room](https://zoom.us/zoomrooms) license.<br>
        /// **Scopes**: `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Rooms.WithRoomID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/rooms/{roomId}/settings`
        public let path: String

        /// Get Zoom Room settings
        ///
        /// Get information on meeting or alert settings applied to a specific Zoom Room. By default, only **Meeting Settings** are returned. To view only **Alert Settings**, specify `alert` as the value of the `setting_type` query parameter.<br>
        /// **Prerequisites:**<br>
        /// * Zoom Room licenses
        /// * Owner or Admin privileges on the Zoom Account.<br>
        /// **Scopes:** `room:read:admin`
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func get(settingType: String) -> Request<[String: AnyJSON]> {
            .get(path, query: [("setting_type", settingType)])
        }

        /// Update Zoom Room settings
        ///
        /// Update either meeting or alert settings applied to a specific Zoom Room. To update **Alert Settings**, specify `alert` as the value of the `setting_type` query parameter. To update **Meeting Settings**, specify `meeting` as the value of the `setting_type` query parameter.<br>
        /// **Prerequisites:**<br>
        /// * Zoom Room licenses
        /// * Owner or Admin privileges on the Zoom Account.<br>
        /// **Scopes:** `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(settingType: String? = nil, _ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, query: makePatchQuery(settingType), body: body)
        }

        private func makePatchQuery(_ settingType: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(settingType, forKey: "setting_type")
            return encoder.items
        }
    }
}

extension Paths.Rooms.WithRoomID {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/rooms/{roomId}/devices`
        public let path: String

        /// List Zoom Room devices
        ///
        /// List information about the devices that are being used for a specific [Zoom Room](https://support.zoom.us/hc/en-us/articles/207483343-Getting-Started-with-Zoom-Rooms) in an account.
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Zoom Room](https://zoom.us/zoomrooms) license.<br>
        /// * Account owner or admin permissions.
        /// **Scopes**: `room:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var devices: [Device]?

            public struct Device: Decodable {
                /// Unique identifier of the device.
                public var id: String?
                /// Name of the Zoom Room.
                public var roomName: String?
                /// Type of the device. The value of this field can be one of the following:<br>`Zoom Rooms Computer`,<br> `Controller`, `Scheduling Display`, `Zoom Rooms Control System`, `Companion Whiteboard`
                public var deviceType: DeviceType?
                /// App version of Zoom Rooms.
                public var appVersion: String?
                /// Operating system of the device.
                public var deviceSystem: String?
                /// Status of the device. The value can be either `Online` or `Offline`.
                public var status: Status?

                /// Type of the device. The value of this field can be one of the following:<br>`Zoom Rooms Computer`,<br> `Controller`, `Scheduling Display`, `Zoom Rooms Control System`, `Companion Whiteboard`
                public enum DeviceType: String, Codable, CaseIterable {
                    case zoomRoomsComputer = "Zoom Rooms Computer"
                    case controller = "Controller"
                    case schedulingDisplay = "Scheduling Display"
                    case zoomRoomsControlSystem = "Zoom Rooms Control System"
                    case companionWhiteboard = "Companion Whiteboard"
                }

                /// Status of the device. The value can be either `Online` or `Offline`.
                public enum Status: String, Codable, CaseIterable {
                    case online = "Online"
                    case offline = "Offline"
                }

                public init(id: String? = nil, roomName: String? = nil, deviceType: DeviceType? = nil, appVersion: String? = nil, deviceSystem: String? = nil, status: Status? = nil) {
                    self.id = id
                    self.roomName = roomName
                    self.deviceType = deviceType
                    self.appVersion = appVersion
                    self.deviceSystem = deviceSystem
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case roomName = "room_name"
                    case deviceType = "device_type"
                    case appVersion = "app_version"
                    case deviceSystem = "device_system"
                    case status
                }
            }

            public init(devices: [Device]? = nil) {
                self.devices = devices
            }
        }
    }
}

extension Paths.Rooms.WithRoomID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/rooms/{roomId}/location`
        public let path: String

        /// Change a Zoom Room's location
        ///
        /// An account owner of a Zoom account can establish a [Zoom Rooms Location Hierarchy](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) to better organize Zoom Rooms spread accress various location. The location can be structured in a hierarchy with Country being the top-level location, followed by city, campus, building, and floor. Use this API to assign a new location for a Zoom Room. Note that the Zoom Room can be assigned only to the lowest level location available in the hierarchy.
        /// **Prerequisite:**<br>
        /// * Account owner or admin permission
        /// * Zoom Rooms version 4.0 or higher<br>
        /// **Scopes:** `room:write:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func put(locationID: String? = nil) -> Request<[String: AnyJSON]> {
            .put(path, body: ["location_id": locationID])
        }
    }
}

extension Paths.Rooms.Locations.WithLocationID {
    public var location: Location {
        Location(path: path + "/location")
    }

    public struct Location {
        /// Path: `/rooms/locations/{locationId}/location`
        public let path: String

        /// Change the assigned parent location
        ///
        /// An account owner of a Zoom account can establish a [Zoom Rooms Location Hierarchy](https://support.zoom.us/hc/en-us/articles/115000342983-Zoom-Rooms-Location-Hierarchy) to better organize Zoom Rooms spread accross various location. The location can be structured in a hierarchy with Country being the top-level location, followed by city, campus, building, and floor. The location in the lower level in the hierarchy is considered as a child of the location that is a level above in the hierarchy. Use this API to change the parent location of a child location. <br><br> For instance, if the location hierarchy is structured in a way where there are two campuses (Campus 1, and Campus 2) in a City and Campus 1 consists of a building named Building 1 with a floor where Zoom Rooms are located, and you would like to rearrange the structure so that Building 1 along with its child locations (floor and Zoom Rooms) are relocated directly under Campus 2 instead of Campus 1, you must provide the location ID of Building 1 in the path parameter of this request and the location ID of Campus 2 as the value of `parent_location_id` in the  request body.<br><br>
        /// **Prerequisite:**<br>
        /// * Account owner or admin permission
        /// * Zoom Rooms version 4.0 or higher<br>
        /// **Scopes:** `room:write:admin`<br><br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(parentLocationID: String? = nil) -> Request<[String: AnyJSON]> {
            .put(path, body: ["parent_location_id": parentLocationID])
        }
    }
}

extension Paths.Rooms {
    public func id(_ id: String) -> WithID {
        WithID(path: "\(path)/\(id)")
    }

    public struct WithID {
        /// Path: `/rooms/{id}`
        public let path: String
    }
}

extension Paths.Rooms.WithID {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/rooms/{id}/events`
        public let path: String

        /// Check-in or check-out of a Zoom Room
        ///
        /// The Zoom Rooms check-in feature helps maximize your room utilization. Use this API to either **check in** and confirm that you are utilizing the room reservation or to **check out** of the room so that the room gets released from the scheduled meeting and will be made available for others to use. Learn more from the [Using the Zoom Rooms check-in feature](https://support.zoom.us/hc/en-us/articles/360001147163-Using-the-Zoom-Rooms-check-in-feature) guide. 
        /// 
        /// **Prerequisites:**
        /// * [Zoom Rooms](https://support.zoom.us/hc/en-us/articles/207483343-Getting-started-with-Zoom-Rooms#:~:text=Zoom%20Rooms%20is%20a%20software,or%20from%20their%20mobile%20device) must have been set up for use for the account and must be online. 
        /// * You must have access to the Calendar Integration APIs (either Microsoft Exchange or Google Calendar APIs) to get calendar information associated with the Room.
        /// 
        /// **Scope:** `room:write:admin`
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The value of this field can be one of the following:<br>
            /// * zoomroom.check_in
            /// * zoomroom.check_out
            public var method: String?
            public var params: Params?

            public struct Params: Encodable {
                /// Unique Identifier of the calendar event associated with the Zoom Room.<br><br>If the calendar integration being used is Microsoft Exchange, the value for this field can be retrieved by using Microsoft's [FindItem Operation](https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditem-operation) and referring to the Id field of the ItemId Element included in the operation response.<br><br>If the Google calendar integration was used for this event, the event_id can be retrieved by calling Google's [Events:list API](https://developers.google.com/calendar/v3/reference/events/list) and referring to the "id" field included in the [events resource](https://developers.google.com/calendar/v3/reference/events#resource).
                public var eventID: String
                /// This field is required only for Microsoft Exchange or Office 365  calendar. The change key represents the specific version of the calendar item and can be retrieved by using Microsoft's [FindItem Operation](https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditem-operation) and referring to the ChangeKey field of the ItemId Element included in the operation response.<br>
                public var changeKey: String?
                /// This field is only required if Google Calendar is being used for the event associated with the Zoom Room. The value for this field can be retrieved by calling Google's [CalendarList:list API](https://developers.google.com/calendar/v3/reference/events/list) and referring to the "id" field included in the [calendarList resource](https://developers.google.com/calendar/v3/reference/calendarList#resource).
                public var calendarID: String?
                /// This field is only required for Microsoft Exchange / Office 365 Calendar. It is the [resource mailbox](https://support.microsoft.com/en-us/help/10063/creating-and-managing-resource-mailboxes-in-office-365) associated with the calendar.
                public var resourceEmail: String?

                public init(eventID: String, changeKey: String? = nil, calendarID: String? = nil, resourceEmail: String? = nil) {
                    self.eventID = eventID
                    self.changeKey = changeKey
                    self.calendarID = calendarID
                    self.resourceEmail = resourceEmail
                }

                private enum CodingKeys: String, CodingKey {
                    case eventID = "event_id"
                    case changeKey = "change_key"
                    case calendarID = "calendar_id"
                    case resourceEmail = "resource_email"
                }
            }

            public init(method: String? = nil, params: Params? = nil) {
                self.method = method
                self.params = params
            }
        }
    }
}

extension Paths.Rooms.WithRoomID.Devices {
    public func deviceID(_ deviceID: String) -> WithDeviceID {
        WithDeviceID(path: "\(path)/\(deviceID)")
    }

    public struct WithDeviceID {
        /// Path: `/rooms/{roomId}/devices/{deviceId}`
        public let path: String
    }
}

extension Paths.Rooms.WithRoomID.Devices.WithDeviceID {
    public var appVersion: AppVersion {
        AppVersion(path: path + "/app_version")
    }

    public struct AppVersion {
        /// Path: `/rooms/{roomId}/devices/{deviceId}/app_version`
        public let path: String

        /// Change Zoom Rooms app version
        ///
        /// Use this API to [upgrade or downgrade](https://support.zoom.us/hc/en-us/articles/204675449-Upgrade-or-Downgrade-Zoom-Rooms-Software) the version of your installed Zoom Rooms app on your Mac or Windows device. 
        /// 
        /// **Scopes:** `room:write:admin` 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or a higher account with Zoom Rooms. 
        /// * The Zoom Rooms software must be installed on a Mac or a Windows device. This API does not support other devices.
        public func put(action: PutRequest.Action? = nil) -> Request<[String: AnyJSON]> {
            .put(path, body: PutRequest(action: action))
        }

        public struct PutRequest: Encodable {
            /// Specify one of the following values for this field:
            /// 
            /// `upgrade`: Upgrade to the latest Zoom Rooms App Version.<br>
            /// `downgrade`: Downgrade the Zoom Rooms App Version.<br>
            /// `cancel`: Cancel an ongoing upgrade or downgrade process.
            public var action: Action?

            /// Specify one of the following values for this field:
            /// 
            /// `upgrade`: Upgrade to the latest Zoom Rooms App Version.<br>
            /// `downgrade`: Downgrade the Zoom Rooms App Version.<br>
            /// `cancel`: Cancel an ongoing upgrade or downgrade process.
            public enum Action: String, Codable, CaseIterable {
                case upgrade
                case downgrade
                case cancel
            }

            public init(action: Action? = nil) {
                self.action = action
            }
        }
    }
}

extension Paths.Rooms {
    public var digitalSignage: DigitalSignage {
        DigitalSignage(path: path + "/digital_signage")
    }

    public struct DigitalSignage {
        /// Path: `/rooms/digital_signage`
        public let path: String

        /// List digital signage contents
        ///
        /// Use this API to return information about a Zoom account's [Zoom Rooms digital signage content](https://support.zoom.us/hc/en-us/articles/360000030683-Zoom-Rooms-digital-signage). You can also view this content in the **Room Management** section's [**Digital Signage Content**](https://zoom.us/digitalsignage#/) tab in the Zoom web portal. 
        /// 
        /// **Scopes:** `room:read:admin` 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or a higher account with Zoom Rooms. 
        /// * Existing content in the **Digital Signage Content** tab.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var contents: [Content]?

            public struct Content: Decodable {
                /// Unique identifier of the content or the folder.
                public var id: String?
                /// Name of the content file or the folder.
                public var name: String?

                public init(id: String? = nil, name: String? = nil) {
                    self.id = id
                    self.name = name
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, contents: [Content]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.contents = contents
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case contents
            }
        }

        public struct GetParameters {
            public var type: String?
            public var folderID: String?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(type: String? = nil, folderID: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.folderID = folderID
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(folderID, forKey: "folder_id")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Rooms {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/rooms/events`
        public let path: String

        /// Update E911 digital signage
        ///
        /// Display or hide E911 emergency alert text content from [Zoom Rooms digital signage](https://support.zoom.us/hc/en-us/articles/360000030683-Zoom-Rooms-digital-signage).
        /// 
        /// **Scope:** `room:write:admin`
        /// 
        /// **Prerequisites:**<br>
        /// * [Zoom Rooms](https://zoom.us/zoomrooms/software) 5.3.0 or higher
        /// * Zoom Rooms digital signage must be [enabled](https://support.zoom.us/hc/en-us/articles/360000030683-Zoom-Rooms-Digital-Signage#h_767fbb33-82a8-45a8-8392-a1bfa9687edd)
        public func patch(_ body: [String: AnyJSON]? = nil) -> Request<PatchResponse> {
            .patch(path, body: body)
        }

        public struct PatchResponse: Decodable {
            /// Unique identifier of the event related to the content being displayed. This field is only returned if you provided `zoomroom.emergency_alert_displayed` as the value of the `method` parameter.
            /// 
            /// Save this response value and provide it as the value of the `event_id` request parameter when you need to remove the alert content using `zoomroom.emergency_alert_removed` method.
            public var eventID: String?

            public init(eventID: String? = nil) {
                self.eventID = eventID
            }

            private enum CodingKeys: String, CodingKey {
                case eventID = "event_id"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/accounts/{accountId}/billing`
        public let path: String

        /// Get billing information
        ///
        /// Get [billing information](https://support.zoom.us/hc/en-us/articles/201363263-About-Billing) of a sub account.<br><br>Only master accounts can use this API. Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage sub accounts' billing information. Email the partner programs team at **partner-success@zoom.us** for more details.<br>
        /// 
        /// **Prerequisites:**
        /// * Pro or a higher paid account with master account option enabled. <br>
        /// 
        /// **Scope**:`billing:master`, `billing_plan:read:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// The account's billing contact information.
        public struct GetResponse: Decodable {
            /// The billing contact's first name.
            public var firstName: String
            /// The billing contact's last name.
            public var lastName: String
            /// The billing contact's email address.
            public var email: String
            /// The billing contact's phone number.
            public var phoneNumber: String
            /// The billing contact's address.
            public var address: String
            /// The billing contact's apartment or suite number.
            public var apt: String?
            /// The billing contact's city.
            public var city: String
            /// The billing contact's state.
            public var state: String
            /// The billing contact's zip or postal code.
            public var zip: String
            /// The billing contact's [country ID abbreviation](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String

            public init(firstName: String, lastName: String, email: String, phoneNumber: String, address: String, apt: String? = nil, city: String, state: String, zip: String, country: String) {
                self.firstName = firstName
                self.lastName = lastName
                self.email = email
                self.phoneNumber = phoneNumber
                self.address = address
                self.apt = apt
                self.city = city
                self.state = state
                self.zip = zip
                self.country = country
            }

            private enum CodingKeys: String, CodingKey {
                case firstName = "first_name"
                case lastName = "last_name"
                case email
                case phoneNumber = "phone_number"
                case address
                case apt
                case city
                case state
                case zip
                case country
            }
        }

        /// Update billing information
        ///
        /// Update [billing information](https://support.zoom.us/hc/en-us/articles/201363263-About-Billing) of a sub account.<br><br>
        /// This API can only be used by master accounts that pay all billing charges of their associated sub accounts. Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage sub accounts' billing information. Email the partner programs team at **partner-success@zoom.us** for more details.<br><br>
        /// 
        /// **Prerequisites:**
        /// * Pro or a higher paid account with master account option enabled. <br>
        /// 
        /// **Scope**:`billing:master`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Billing Contact object.
        public struct PatchRequest: Encodable {
            /// Billing Contact's first name.
            public var firstName: String?
            /// Billing Contact's last name.
            public var lastName: String?
            /// Billing Contact's email address.
            public var email: String?
            /// Billing Contact's phone number.
            public var phoneNumber: String?
            /// Billing Contact's address.
            public var address: String?
            /// Billing Contact's apartment/suite.
            public var apt: String?
            /// Billing Contact's city.
            public var city: String?
            /// Billing Contact's state.
            public var state: String?
            /// Billing Contact's zip/postal code.
            public var zip: String?
            /// Billing Contact's country.
            public var country: String?

            public init(firstName: String? = nil, lastName: String? = nil, email: String? = nil, phoneNumber: String? = nil, address: String? = nil, apt: String? = nil, city: String? = nil, state: String? = nil, zip: String? = nil, country: String? = nil) {
                self.firstName = firstName
                self.lastName = lastName
                self.email = email
                self.phoneNumber = phoneNumber
                self.address = address
                self.apt = apt
                self.city = city
                self.state = state
                self.zip = zip
                self.country = country
            }

            private enum CodingKeys: String, CodingKey {
                case firstName = "first_name"
                case lastName = "last_name"
                case email
                case phoneNumber = "phone_number"
                case address
                case apt
                case city
                case state
                case zip
                case country
            }
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var plans: Plans {
        Plans(path: path + "/plans")
    }

    public struct Plans {
        /// Path: `/accounts/{accountId}/plans`
        public let path: String

        /// Get account plan information
        ///
        /// Use this API to return plan information of a subaccount that is managed by a Master account. 
        /// 
        ///  This API can only be used by Master accounts that pay all billing charges of their associated Pro or higher subaccounts. Zoom only allows approved partners to use [Master APIs](https://marketplace.zoom.us/docs/api-reference/master-account-apis) and manage subaccounts' billing information. Email the partner programs team at [**partner-success@zoom.us**](mailto:partner-success@zoom.us) for more details. 
        /// 
        ///  **Scopes:** `billing:master`, `billing:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Information about the account's Base plan.
            public var planBase: PlanBase?
            /// Information about the account's Zoom Rooms plan.
            public var planZoomRooms: PlanZoomRooms?
            /// Information about the account's H.323/SIP Device Room Connector plan.
            public var planRoomConnector: PlanRoomConnector?
            /// Information about the account's Large Meeting plan.
            public var planLargeMeeting: [PlanLargeMeetingItem]?
            /// Information about the account's Webinar plan.
            public var planWebinar: [PlanWebinarItem]?
            /// Information about the account's Zoom Events plan.
            public var planZoomEvents: [PlanZoomEvent]?
            /// The account's [Cloud Recording plan](https://marketplace.zoom.us/docs/api-reference/other-references/plans#cloud-recording-plans).
            public var planRecording: String?
            /// The date at which the Cloud Recording plan became effective on the account.
            public var planRecordingServiceEffectiveDate: String?
            /// The next invoice date for the account's Cloud Recording plan.
            public var planRecordingNextInvoiceDate: String?
            /// The account's Cloud Recording plan status: 
            /// * `active`  Active. 
            /// * `cancel`  Canceled. 
            /// * `expired`  Expired.
            public var planRecordingStatus: PlanRecordingStatus?
            /// Information about the account's Audio Conferencing plan.
            public var planAudio: PlanAudio?
            /// Information about the account's Zoom Phone plan.
            public var planPhone: PlanPhone?

            /// Information about the account's Base plan.
            public struct PlanBase: Decodable {
                /// The account's [Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#base-plans).
                public var type: String?
                /// The account plan's number of hosts: 
                /// * For a Pro plan, provide a value between `1` and `9`. 
                /// * For a Business Plan, provide a value between `10` and `49`. 
                /// * For a Education Plan, provide a value between `20` and `149`. 
                /// * For a Free Trial Plan, provide a value between `1` and `9999`.
                public var hosts: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?
                /// The Video SDK plan's included minutes.
                public var includedMinutes: Int?
                /// The Video SDK plan's overage price.
                public var overagePrice: Int?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil, includedMinutes: Int? = nil, overagePrice: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                    self.includedMinutes = includedMinutes
                    self.overagePrice = overagePrice
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                    case includedMinutes = "included_minutes"
                    case overagePrice = "overage_price"
                }
            }

            /// Information about the account's Zoom Rooms plan.
            public struct PlanZoomRooms: Decodable {
                /// The [Zoom Rooms plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#zoom-room-plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The account plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                }
            }

            /// Information about the account's H.323/SIP Device Room Connector plan.
            public struct PlanRoomConnector: Decodable {
                /// The [H.323/SIP Device Room Connector plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#h323sip-device-room-connector-plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The account plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                }
            }

            public struct PlanLargeMeetingItem: Decodable {
                /// The [Large Meeting plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#large-meeting-plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The account plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                }
            }

            public struct PlanWebinarItem: Decodable {
                /// The [Webinar plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#webinar-plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The account plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                }
            }

            public struct PlanZoomEvent: Decodable {
                /// The [Zoom Events plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The account plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                }
            }

            /// The account's Cloud Recording plan status: 
            /// * `active`  Active. 
            /// * `cancel`  Canceled. 
            /// * `expired`  Expired.
            public enum PlanRecordingStatus: String, Codable, CaseIterable {
                case active
                case cancel
                case expired
            }

            /// Information about the account's Audio Conferencing plan.
            public struct PlanAudio: Decodable {
                /// The [Audio Conferencing plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#audio-conferencing-plans).
                public var type: String?
                /// A comma-separated list of the account's toll-free countries 
                /// 
                ///  For a list of values, refer to the `ID` field in the [Toll-free countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#toll-free) table.
                public var tollfreeCountries: String?
                /// A comma-separated list of the account's premium countries. 
                /// 
                ///  For a list of values, refer to the `ID` field in the [Premium countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#premium) table.
                public var premiumCountries: String?
                /// A comma-separated list of the account's call-out countries. 
                /// 
                ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
                public var calloutCountries: String?
                /// The account's dedicated dial-in (DDI) numbers.
                public var ddiNumbers: Int?
                /// The date at which the plan became effective on the account.
                public var serviceEffectiveDate: String?
                /// The account plan's next invoice date.
                public var nextInvoiceDate: String?
                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public var status: Status?

                /// The account plan's status: 
                /// * `active`  Active. 
                /// * `cancel`  Canceled. 
                /// * `expired`  Expired.
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case cancel
                    case expired
                }

                public init(type: String? = nil, tollfreeCountries: String? = nil, premiumCountries: String? = nil, calloutCountries: String? = nil, ddiNumbers: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                    self.type = type
                    self.tollfreeCountries = tollfreeCountries
                    self.premiumCountries = premiumCountries
                    self.calloutCountries = calloutCountries
                    self.ddiNumbers = ddiNumbers
                    self.serviceEffectiveDate = serviceEffectiveDate
                    self.nextInvoiceDate = nextInvoiceDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case tollfreeCountries = "tollfree_countries"
                    case premiumCountries = "premium_countries"
                    case calloutCountries = "callout_countries"
                    case ddiNumbers = "ddi_numbers"
                    case serviceEffectiveDate = "service_effective_date"
                    case nextInvoiceDate = "next_invoice_date"
                    case status
                }
            }

            /// Information about the account's Zoom Phone plan.
            public struct PlanPhone: Decodable {
                /// Information about the account's Zoom Phone Base plan.
                public var planBase: PlanBase?
                /// Information about the account's additional Zoom Phone calling plans.
                public var planCalling: [PlanCallingItem]?
                /// Information about the account's additional Zoom Phone number plans.
                public var planNumber: [PlanNumberItem]?

                /// Information about the account's Zoom Phone Base plan.
                public struct PlanBase: Decodable {
                    /// The [Zoom Phone Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// A comma-separated list of the account's call-out countries. 
                    /// 
                    ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
                    public var calloutCountries: String?
                    /// The date at which the plan became effective on the account.
                    public var serviceEffectiveDate: String?
                    /// The account plan's next invoice date.
                    public var nextInvoiceDate: String?
                    /// The account plan's status: 
                    /// * `active`  Active. 
                    /// * `cancel`  Canceled. 
                    /// * `expired`  Expired.
                    public var status: Status?

                    /// The account plan's status: 
                    /// * `active`  Active. 
                    /// * `cancel`  Canceled. 
                    /// * `expired`  Expired.
                    public enum Status: String, Codable, CaseIterable {
                        case active
                        case cancel
                        case expired
                    }

                    public init(type: String? = nil, calloutCountries: String? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                        self.type = type
                        self.calloutCountries = calloutCountries
                        self.serviceEffectiveDate = serviceEffectiveDate
                        self.nextInvoiceDate = nextInvoiceDate
                        self.status = status
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case calloutCountries = "callout_countries"
                        case serviceEffectiveDate = "service_effective_date"
                        case nextInvoiceDate = "next_invoice_date"
                        case status
                    }
                }

                public struct PlanCallingItem: Decodable {
                    /// The additional [Zoom Phone calling plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// The account plan's number of hosts.
                    public var hosts: Int?
                    /// The date at which the plan became effective on the account.
                    public var serviceEffectiveDate: String?
                    /// The account plan's next invoice date.
                    public var nextInvoiceDate: String?
                    /// The account plan's status: 
                    /// * `active`  Active. 
                    /// * `cancel`  Canceled. 
                    /// * `expired`  Expired.
                    public var status: Status?

                    /// The account plan's status: 
                    /// * `active`  Active. 
                    /// * `cancel`  Canceled. 
                    /// * `expired`  Expired.
                    public enum Status: String, Codable, CaseIterable {
                        case active
                        case cancel
                        case expired
                    }

                    public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                        self.type = type
                        self.hosts = hosts
                        self.serviceEffectiveDate = serviceEffectiveDate
                        self.nextInvoiceDate = nextInvoiceDate
                        self.status = status
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case hosts
                        case serviceEffectiveDate = "service_effective_date"
                        case nextInvoiceDate = "next_invoice_date"
                        case status
                    }
                }

                public struct PlanNumberItem: Decodable {
                    /// The additional [Zoom Phone number plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// The account plan's number of hosts.
                    public var hosts: Int?
                    /// The date at which the plan became effective on the account.
                    public var serviceEffectiveDate: String?
                    /// The account plan's next invoice date.
                    public var nextInvoiceDate: String?
                    /// The account plan's status: 
                    /// * `active`  Active. 
                    /// * `cancel`  Canceled. 
                    /// * `expired`  Expired.
                    public var status: Status?

                    /// The account plan's status: 
                    /// * `active`  Active. 
                    /// * `cancel`  Canceled. 
                    /// * `expired`  Expired.
                    public enum Status: String, Codable, CaseIterable {
                        case active
                        case cancel
                        case expired
                    }

                    public init(type: String? = nil, hosts: Int? = nil, serviceEffectiveDate: String? = nil, nextInvoiceDate: String? = nil, status: Status? = nil) {
                        self.type = type
                        self.hosts = hosts
                        self.serviceEffectiveDate = serviceEffectiveDate
                        self.nextInvoiceDate = nextInvoiceDate
                        self.status = status
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case hosts
                        case serviceEffectiveDate = "service_effective_date"
                        case nextInvoiceDate = "next_invoice_date"
                        case status
                    }
                }

                public init(planBase: PlanBase? = nil, planCalling: [PlanCallingItem]? = nil, planNumber: [PlanNumberItem]? = nil) {
                    self.planBase = planBase
                    self.planCalling = planCalling
                    self.planNumber = planNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case planBase = "plan_base"
                    case planCalling = "plan_calling"
                    case planNumber = "plan_number"
                }
            }

            public init(planBase: PlanBase? = nil, planZoomRooms: PlanZoomRooms? = nil, planRoomConnector: PlanRoomConnector? = nil, planLargeMeeting: [PlanLargeMeetingItem]? = nil, planWebinar: [PlanWebinarItem]? = nil, planZoomEvents: [PlanZoomEvent]? = nil, planRecording: String? = nil, planRecordingServiceEffectiveDate: String? = nil, planRecordingNextInvoiceDate: String? = nil, planRecordingStatus: PlanRecordingStatus? = nil, planAudio: PlanAudio? = nil, planPhone: PlanPhone? = nil) {
                self.planBase = planBase
                self.planZoomRooms = planZoomRooms
                self.planRoomConnector = planRoomConnector
                self.planLargeMeeting = planLargeMeeting
                self.planWebinar = planWebinar
                self.planZoomEvents = planZoomEvents
                self.planRecording = planRecording
                self.planRecordingServiceEffectiveDate = planRecordingServiceEffectiveDate
                self.planRecordingNextInvoiceDate = planRecordingNextInvoiceDate
                self.planRecordingStatus = planRecordingStatus
                self.planAudio = planAudio
                self.planPhone = planPhone
            }

            private enum CodingKeys: String, CodingKey {
                case planBase = "plan_base"
                case planZoomRooms = "plan_zoom_rooms"
                case planRoomConnector = "plan_room_connector"
                case planLargeMeeting = "plan_large_meeting"
                case planWebinar = "plan_webinar"
                case planZoomEvents = "plan_zoom_events"
                case planRecording = "plan_recording"
                case planRecordingServiceEffectiveDate = "plan_recording_service_effective_date"
                case planRecordingNextInvoiceDate = "plan_recording_next_invoice_date"
                case planRecordingStatus = "plan_recording_status"
                case planAudio = "plan_audio"
                case planPhone = "plan_phone"
            }
        }

        /// Subscribe account to a plan
        ///
        /// Use this API to subscribe a subaccount to a Zoom plan using your Master account. 
        /// 
        ///  This API can only be used by Master accounts that pay all billing charges of their associated Pro or higher subaccounts. Zoom only allows [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use Master APIs and manage subaccounts' billing information. Email the partner programs team at [**partner-success@zoom.us**](mailto:partner-success@zoom.us) for more details. 
        /// 
        ///  **Note:** To subscribe to an addon plan **after** subscribing to a base plan, you **must** use the [**Subscribe additional plan**](https://marketplace.zoom.us/docs/api-reference/zoom-api/billing/accountplanaddoncreate) API.
        /// 
        /// **Scopes:** `billing:master`
        public func post(_ body: PostRequest) -> Request<[String: AnyJSON]> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The account's billing contact information.
            public var contact: Contact?
            /// Information about the account's Base plan.
            public var planBase: PlanBase
            /// Information about the account's plan.
            public var planZoomRooms: PlanZoomRooms?
            /// Information about the account's plan.
            public var planRoomConnector: PlanRoomConnector?
            /// Information about the account's Large Meeting plan.
            public var planLargeMeeting: [PlanLargeMeetingItem]?
            /// Information about the account's Webinar plan.
            public var planWebinar: [PlanWebinarItem]?
            /// Information about the account's Zoom Events plan.
            public var planZoomEvents: [PlanZoomEvent]?
            /// The account's [Cloud Recording plan](https://marketplace.zoom.us/docs/api-reference/other-references/plans#cloud-recording-plans).
            public var planRecording: String?
            /// Information about the account's Audio Conferencing plan.
            public var planAudio: PlanAudio?
            /// Information about the account's Zoom Phone plan.
            public var planPhone: PlanPhone?

            /// The account's billing contact information.
            public struct Contact: Encodable {
                /// The billing contact's first name.
                public var firstName: String
                /// The billing contact's last name.
                public var lastName: String
                /// The billing contact's email address.
                public var email: String
                /// The billing contact's phone number.
                public var phoneNumber: String
                /// The billing contact's address.
                public var address: String
                /// The billing contact's apartment or suite number.
                public var apt: String?
                /// The billing contact's city.
                public var city: String
                /// The billing contact's state.
                public var state: String
                /// The billing contact's zip or postal code.
                public var zip: String
                /// The billing contact's [country ID abbreviation](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
                public var country: String

                public init(firstName: String, lastName: String, email: String, phoneNumber: String, address: String, apt: String? = nil, city: String, state: String, zip: String, country: String) {
                    self.firstName = firstName
                    self.lastName = lastName
                    self.email = email
                    self.phoneNumber = phoneNumber
                    self.address = address
                    self.apt = apt
                    self.city = city
                    self.state = state
                    self.zip = zip
                    self.country = country
                }

                private enum CodingKeys: String, CodingKey {
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case email
                    case phoneNumber = "phone_number"
                    case address
                    case apt
                    case city
                    case state
                    case zip
                    case country
                }
            }

            /// Information about the account's Base plan.
            public struct PlanBase: Encodable {
                /// The account's [Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#base-plans).
                public var type: String
                /// The account plan's number of hosts: 
                /// * For a Pro plan, provide a value between `1` and `9`. 
                /// * For a Business Plan, provide a value between `10` and `49`. 
                /// * For a Education Plan, provide a value between `20` and `149`. 
                /// * For a Free Trial Plan, provide a value between `1` and `9999`. 
                /// 
                /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
                public var hosts: Int
                /// An optional number of additional hosts to add to the account's Base plan. 
                /// 
                /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
                public var increasingHosts: Int?

                public init(type: String, hosts: Int, increasingHosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.increasingHosts = increasingHosts
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case increasingHosts = "increasing_hosts"
                }
            }

            /// Information about the account's plan.
            public struct PlanZoomRooms: Encodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanRoomConnector: Encodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanLargeMeetingItem: Encodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanWebinarItem: Encodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanZoomEvent: Encodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's Audio Conferencing plan.
            public struct PlanAudio: Encodable {
                /// The [Audio Conferencing plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#audio-conferencing-plans).
                public var type: String?
                /// A comma-separated list of the account's toll-free countries 
                /// 
                ///  For a list of values, refer to the `ID` field in the [Toll-free countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#toll-free) table.
                public var tollfreeCountries: String?
                /// A comma-separated list of the account's premium countries. 
                /// 
                ///  For a list of values, refer to the `ID` field in the [Premium countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#premium) table.
                public var premiumCountries: String?
                /// A comma-separated list of the account's call-out countries. 
                /// 
                ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
                public var calloutCountries: String?
                /// The account's dedicated dial-in (DDI) numbers.
                public var ddiNumbers: Int?

                public init(type: String? = nil, tollfreeCountries: String? = nil, premiumCountries: String? = nil, calloutCountries: String? = nil, ddiNumbers: Int? = nil) {
                    self.type = type
                    self.tollfreeCountries = tollfreeCountries
                    self.premiumCountries = premiumCountries
                    self.calloutCountries = calloutCountries
                    self.ddiNumbers = ddiNumbers
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case tollfreeCountries = "tollfree_countries"
                    case premiumCountries = "premium_countries"
                    case calloutCountries = "callout_countries"
                    case ddiNumbers = "ddi_numbers"
                }
            }

            /// Information about the account's Zoom Phone plan.
            public struct PlanPhone: Encodable {
                /// Information about the account's Zoom Phone Base plan.
                public var planBase: PlanBase?
                /// Information about the account's additional Zoom Phone calling plans.
                public var planCalling: [PlanCallingItem]?
                /// Information about the account's additional Zoom Phone number plans.
                public var planNumber: [PlanNumberItem]?

                /// Information about the account's Zoom Phone Base plan.
                public struct PlanBase: Encodable {
                    /// The [Zoom Phone Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// A comma-separated list of the account's call-out countries. 
                    /// 
                    ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
                    public var calloutCountries: String?

                    public init(type: String? = nil, calloutCountries: String? = nil) {
                        self.type = type
                        self.calloutCountries = calloutCountries
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case calloutCountries = "callout_countries"
                    }
                }

                public struct PlanCallingItem: Encodable {
                    /// The additional [Zoom Phone calling plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// The account plan's number of hosts.
                    public var hosts: Int?

                    public init(type: String? = nil, hosts: Int? = nil) {
                        self.type = type
                        self.hosts = hosts
                    }
                }

                public struct PlanNumberItem: Encodable {
                    /// The additional [Zoom Phone number plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// The account plan's number of hosts.
                    public var hosts: Int?

                    public init(type: String? = nil, hosts: Int? = nil) {
                        self.type = type
                        self.hosts = hosts
                    }
                }

                public init(planBase: PlanBase? = nil, planCalling: [PlanCallingItem]? = nil, planNumber: [PlanNumberItem]? = nil) {
                    self.planBase = planBase
                    self.planCalling = planCalling
                    self.planNumber = planNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case planBase = "plan_base"
                    case planCalling = "plan_calling"
                    case planNumber = "plan_number"
                }
            }

            public init(contact: Contact? = nil, planBase: PlanBase, planZoomRooms: PlanZoomRooms? = nil, planRoomConnector: PlanRoomConnector? = nil, planLargeMeeting: [PlanLargeMeetingItem]? = nil, planWebinar: [PlanWebinarItem]? = nil, planZoomEvents: [PlanZoomEvent]? = nil, planRecording: String? = nil, planAudio: PlanAudio? = nil, planPhone: PlanPhone? = nil) {
                self.contact = contact
                self.planBase = planBase
                self.planZoomRooms = planZoomRooms
                self.planRoomConnector = planRoomConnector
                self.planLargeMeeting = planLargeMeeting
                self.planWebinar = planWebinar
                self.planZoomEvents = planZoomEvents
                self.planRecording = planRecording
                self.planAudio = planAudio
                self.planPhone = planPhone
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(contact, forKey: "contact")
                try values.encode(planBase, forKey: "plan_base")
                try values.encodeIfPresent(planZoomRooms, forKey: "plan_zoom_rooms")
                try values.encodeIfPresent(planRoomConnector, forKey: "plan_room_connector")
                try values.encodeIfPresent(planLargeMeeting, forKey: "plan_large_meeting")
                try values.encodeIfPresent(planWebinar, forKey: "plan_webinar")
                try values.encodeIfPresent(planZoomEvents, forKey: "plan_zoom_events")
                try values.encodeIfPresent(planRecording, forKey: "plan_recording")
                try values.encodeIfPresent(planAudio, forKey: "plan_audio")
                try values.encodeIfPresent(planPhone, forKey: "plan_phone")
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.Plans {
    public var base: Base {
        Base(path: path + "/base")
    }

    public struct Base {
        /// Path: `/accounts/{accountId}/plans/base`
        public let path: String

        /// Update a base plan
        ///
        /// Update a base plan of a sub account. 
        /// 
        /// This API can only be used by master accounts that pay all billing charges of their associated Pro or higher subaccounts. Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage subaccounts' subscriptions. Email the partner programs team at **partner-success@zoom.us** for more details.
        /// 
        /// **Scopes:** `billing:master`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        /// 
        /// **Prerequisites:**<br>
        /// * The subaccount must have a Pro or a higher plan.
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: body)
        }

        /// Information about the account's Base plan.
        public struct PutRequest: Encodable {
            /// The account's [Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#base-plans).
            public var type: String
            /// The account plan's number of hosts: 
            /// * For a Pro plan, provide a value between `1` and `9`. 
            /// * For a Business Plan, provide a value between `10` and `49`. 
            /// * For a Education Plan, provide a value between `20` and `149`. 
            /// * For a Free Trial Plan, provide a value between `1` and `9999`. 
            /// 
            /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
            public var hosts: Int
            /// An optional number of additional hosts to add to the account's Base plan. 
            /// 
            /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
            public var increasingHosts: Int?

            public init(type: String, hosts: Int, increasingHosts: Int? = nil) {
                self.type = type
                self.hosts = hosts
                self.increasingHosts = increasingHosts
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case hosts
                case increasingHosts = "increasing_hosts"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.Plans {
    public var addons: Addons {
        Addons(path: path + "/addons")
    }

    public struct Addons {
        /// Path: `/accounts/{accountId}/plans/addons`
        public let path: String

        /// Subscribe account to an additional plan
        ///
        /// Use this API to subscribe a subaccount to a Zoom addon plan. 
        /// 
        ///  This API can only be used by Master accounts that pay all billing charges of their associated Pro or higher subaccounts. Zoom only allows approved partners to use [Master APIs](https://marketplace.zoom.us/docs/api-reference/master-account-apis) and manage subaccounts' billing information. Email the partner programs team at [**partner-success@zoom.us**](mailto:partner-success@zoom.us) for more details. 
        /// 
        ///  **Scopes**: `billing:master` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        ///  **Prerequisites:** 
        /// * A Pro or a higher plan with the **Master account** option enabled. 
        /// * The subaccount **must** be a paid account whose billing charges are paid by its Master account.
        public func post(_ body: [String: AnyJSON]) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// Information about the account's plan.
        public struct PostResponse: Decodable {
            /// Information about the account's Base plan.
            public var planBase: PlanBase
            /// Information about the account's plan.
            public var planZoomRooms: PlanZoomRooms?
            /// Information about the account's plan.
            public var planRoomConnector: PlanRoomConnector?
            /// Information about the account's Large Meeting plan.
            public var planLargeMeeting: [PlanLargeMeetingItem]?
            /// Information about the account's Webinar plan.
            public var planWebinar: [PlanWebinarItem]?
            /// Information about the account's Zoom Events plan.
            public var planZoomEvents: [PlanZoomEvent]?
            /// The account's [Cloud Recording plan](https://marketplace.zoom.us/docs/api-reference/other-references/plans#cloud-recording-plans).
            public var planRecording: String?
            /// Information about the account's Audio Conferencing plan.
            public var planAudio: PlanAudio?
            /// Information about the account's Zoom Phone plan.
            public var planPhone: PlanPhone?

            /// Information about the account's Base plan.
            public struct PlanBase: Decodable {
                /// The account's [Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#base-plans).
                public var type: String
                /// The account plan's number of hosts: 
                /// * For a Pro plan, provide a value between `1` and `9`. 
                /// * For a Business Plan, provide a value between `10` and `49`. 
                /// * For a Education Plan, provide a value between `20` and `149`. 
                /// * For a Free Trial Plan, provide a value between `1` and `9999`. 
                /// 
                /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
                public var hosts: Int
                /// An optional number of additional hosts to add to the account's Base plan. 
                /// 
                /// You **must** provide at least one positive integer value for the `hosts` or the `increasing_hosts` field.
                public var increasingHosts: Int?

                public init(type: String, hosts: Int, increasingHosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.increasingHosts = increasingHosts
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case hosts
                    case increasingHosts = "increasing_hosts"
                }
            }

            /// Information about the account's plan.
            public struct PlanZoomRooms: Decodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanRoomConnector: Decodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanLargeMeetingItem: Decodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanWebinarItem: Decodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's plan.
            public struct PlanZoomEvent: Decodable {
                /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The account plan's number of hosts.
                public var hosts: Int?

                public init(type: String? = nil, hosts: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                }
            }

            /// Information about the account's Audio Conferencing plan.
            public struct PlanAudio: Decodable {
                /// The [Audio Conferencing plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#audio-conferencing-plans).
                public var type: String?
                /// A comma-separated list of the account's toll-free countries 
                /// 
                ///  For a list of values, refer to the `ID` field in the [Toll-free countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#toll-free) table.
                public var tollfreeCountries: String?
                /// A comma-separated list of the account's premium countries. 
                /// 
                ///  For a list of values, refer to the `ID` field in the [Premium countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#premium) table.
                public var premiumCountries: String?
                /// A comma-separated list of the account's call-out countries. 
                /// 
                ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
                public var calloutCountries: String?
                /// The account's dedicated dial-in (DDI) numbers.
                public var ddiNumbers: Int?

                public init(type: String? = nil, tollfreeCountries: String? = nil, premiumCountries: String? = nil, calloutCountries: String? = nil, ddiNumbers: Int? = nil) {
                    self.type = type
                    self.tollfreeCountries = tollfreeCountries
                    self.premiumCountries = premiumCountries
                    self.calloutCountries = calloutCountries
                    self.ddiNumbers = ddiNumbers
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case tollfreeCountries = "tollfree_countries"
                    case premiumCountries = "premium_countries"
                    case calloutCountries = "callout_countries"
                    case ddiNumbers = "ddi_numbers"
                }
            }

            /// Information about the account's Zoom Phone plan.
            public struct PlanPhone: Decodable {
                /// Information about the account's Zoom Phone Base plan.
                public var planBase: PlanBase?
                /// Information about the account's additional Zoom Phone calling plans.
                public var planCalling: [PlanCallingItem]?
                /// Information about the account's additional Zoom Phone number plans.
                public var planNumber: [PlanNumberItem]?

                /// Information about the account's Zoom Phone Base plan.
                public struct PlanBase: Decodable {
                    /// The [Zoom Phone Base plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// A comma-separated list of the account's call-out countries. 
                    /// 
                    ///  For a list of values, refer to the `ID` field in the [TSP callout countries](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#tsp-countries) table.
                    public var calloutCountries: String?

                    public init(type: String? = nil, calloutCountries: String? = nil) {
                        self.type = type
                        self.calloutCountries = calloutCountries
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case calloutCountries = "callout_countries"
                    }
                }

                public struct PlanCallingItem: Decodable {
                    /// The additional [Zoom Phone calling plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// The account plan's number of hosts.
                    public var hosts: Int?

                    public init(type: String? = nil, hosts: Int? = nil) {
                        self.type = type
                        self.hosts = hosts
                    }
                }

                public struct PlanNumberItem: Decodable {
                    /// The additional [Zoom Phone number plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#additional-zoom-phone-plans).
                    public var type: String?
                    /// The account plan's number of hosts.
                    public var hosts: Int?

                    public init(type: String? = nil, hosts: Int? = nil) {
                        self.type = type
                        self.hosts = hosts
                    }
                }

                public init(planBase: PlanBase? = nil, planCalling: [PlanCallingItem]? = nil, planNumber: [PlanNumberItem]? = nil) {
                    self.planBase = planBase
                    self.planCalling = planCalling
                    self.planNumber = planNumber
                }

                private enum CodingKeys: String, CodingKey {
                    case planBase = "plan_base"
                    case planCalling = "plan_calling"
                    case planNumber = "plan_number"
                }
            }

            public init(planBase: PlanBase, planZoomRooms: PlanZoomRooms? = nil, planRoomConnector: PlanRoomConnector? = nil, planLargeMeeting: [PlanLargeMeetingItem]? = nil, planWebinar: [PlanWebinarItem]? = nil, planZoomEvents: [PlanZoomEvent]? = nil, planRecording: String? = nil, planAudio: PlanAudio? = nil, planPhone: PlanPhone? = nil) {
                self.planBase = planBase
                self.planZoomRooms = planZoomRooms
                self.planRoomConnector = planRoomConnector
                self.planLargeMeeting = planLargeMeeting
                self.planWebinar = planWebinar
                self.planZoomEvents = planZoomEvents
                self.planRecording = planRecording
                self.planAudio = planAudio
                self.planPhone = planPhone
            }

            private enum CodingKeys: String, CodingKey {
                case planBase = "plan_base"
                case planZoomRooms = "plan_zoom_rooms"
                case planRoomConnector = "plan_room_connector"
                case planLargeMeeting = "plan_large_meeting"
                case planWebinar = "plan_webinar"
                case planZoomEvents = "plan_zoom_events"
                case planRecording = "plan_recording"
                case planAudio = "plan_audio"
                case planPhone = "plan_phone"
            }
        }

        /// Update an account's additional plan
        ///
        /// Use this API to update a subaccount's additional plan. 
        /// 
        ///  This API can only be used by Master accounts that pay all billing charges of their associated Pro or higher subaccounts. Zoom only allows approved partners to use [Master APIs](https://marketplace.zoom.us/docs/api-reference/master-account-apis) and manage subaccounts' billing information. Email the partner programs team at [**partner-success@zoom.us**](mailto:partner-success@zoom.us) for more details. 
        /// 
        ///  **Scopes:** `billing:master` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        ///  **Prerequisites:** 
        /// * A Pro or a higher plan with the **Master account** option enabled. 
        /// * The subaccount **must** be a paid account whose billing charges are paid by its Master account.
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: body)
        }

        /// Information about the account's plan.
        public struct PutRequest: Encodable {
            /// The account's [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
            public var type: String
            /// The account plan's number of hosts.
            public var hosts: Int

            public init(type: String, hosts: Int) {
                self.type = type
                self.hosts = hosts
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.Plans.Base {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/accounts/{accountId}/plans/base/status`
        public let path: String

        /// Cancel a base plan
        ///
        /// [Cancel a base plan](https://support.zoom.us/hc/en-us/articles/203634215-How-Do-I-Cancel-My-Subscription-) for a sub account.
        /// 
        /// This API can only be used by master accounts that pay all billing charges of their associated Pro or higher sub accounts. Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage sub accounts' subscriptions. Email the partner programs team at **partner-success@zoom.us** for more details.<br><br>
        /// 
        /// **Scopes**: `billing:master`<br> 
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * The sub account must have a Pro or a higher plan.
        public func patch(_ body: PatchRequest? = nil) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The action that needs to be taken for this sub account. Value must be set to "cancel".
            public var action: String
            /// The reason for the cancellation of plan. Reason options:<br>`1` - I am no longer working remote.<br>`2` - I had challenges getting the support I needed.<br>`3` - Features in the Basic Free Plan are sufficient.<br>`4` - The expense is too high.<br>`5` - I purchased the wrong product.<br> `6` - Paid purchase not needed right now, will repurchase in the future.
            public var reason: Int?
            /// Additional comments about the cancellation decision.
            public var comment: String?

            public init(action: String, reason: Int? = nil, comment: String? = nil) {
                self.action = action
                self.reason = reason
                self.comment = comment
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.Plans.Addons {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/accounts/{accountId}/plans/addons/status`
        public let path: String

        /// Cancel additional plans
        ///
        /// [Cancel additional plan](https://support.zoom.us/hc/en-us/articles/203634215-How-Do-I-Cancel-My-Subscription-) of a sub account. The cancellation does not provide refund for the current subscription. The service remains active for the current session.
        /// 
        /// This API can only be used by master accounts that pay all billing charges of their associated Pro or higher sub accounts. Zoom allows only [approved partners](https://marketplace.zoom.us/docs/api-reference/master-account-apis) to use master APIs and manage sub accounts' subscriptions. Email the partner programs team at **partner-success@zoom.us** for more details.<br><br>
        /// 
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with master account option enabled.
        /// * The sub account must be a paid account.<br>
        /// **Scope:** `billing:master`<br>
        public func patch(_ body: PatchRequest? = nil) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Account plan object
        public struct PatchRequest: Encodable {
            /// The action that needs to be taken for this sub account. Value must be set to "cancel".
            public var action: Action?
            /// Plan [type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
            public var type: String?
            /// The reason for the cancellation of plan. Reason options:<br>`1` - I am no longer working remote.<br>`2` - I had challenges getting the support I needed.<br>`3` - Features in the Basic Free Plan are sufficient.<br>`4` - The expense is too high.<br>`5` - I purchased the wrong product.<br> `6` - Paid purchase not needed right now, will repurchase in the future.
            public var reason: Int?
            /// Additional comments about the cancellation decision.
            public var comment: String?

            /// The action that needs to be taken for this sub account. Value must be set to "cancel".
            public enum Action: String, Codable, CaseIterable {
                case cancel
            }

            public init(action: Action? = nil, type: String? = nil, reason: Int? = nil, comment: String? = nil) {
                self.action = action
                self.type = type
                self.reason = reason
                self.comment = comment
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.Plans {
    public var usage: Usage {
        Usage(path: path + "/usage")
    }

    public struct Usage {
        /// Path: `/accounts/{accountId}/plans/usage`
        public let path: String

        /// Get plan usage
        ///
        /// Get information on usage of [plans](https://marketplace.zoom.us/docs/api-reference/other-references/plans) of an account. This API supports regular accounts as well as master and sub accounts. To get plan usage of a regular account, use the `account:read:admin` scope and provide me as the value of the  `accountId` path parameter.To get plan usage of a master account, provide the keyword "me" as the value of the `accountId` path parameter and use the `billing:master` scope. To get plan usage of a sub account, provide the actual account Id of the sub account as the value of the `accountId` path parameter and use the `billing:master` scope. 
        /// 
        /// **Prerequisite**:<br>
        /// Account type: master account on a paid Pro, Business or Enterprise plan.<br>
        /// **Scope:** `billing:master` for master and sub accounts. `account:read:admin` for regular Zoom accounts.<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The base plan subscribed for the sub account.
            public var planBase: PlanBase?
            /// Webinar Plan
            public var planWebinar: [PlanWebinarItem]?
            /// Large Meeting Plan
            public var planLargeMeeting: [PlanLargeMeetingItem]?
            /// Information about the Zoom Events plan.
            public var planZoomEvents: [PlanZoomEvent]?
            /// Zoom Rooms Plan
            public var planZoomRooms: PlanZoomRooms?
            /// Recording Plan
            public var planRecording: PlanRecording?
            /// [Zoom United](https://zoom.us/pricing/zoom-bundles) plan.
            public var planUnited: PlanUnited?

            /// The base plan subscribed for the sub account.
            public struct PlanBase: Decodable {
                /// The type of base plan.
                public var type: String?
                /// The number of hosts in the base plan.
                public var hosts: Int?
                /// The plan's total usage number.
                public var usage: Int?

                public init(type: String? = nil, hosts: Int? = nil, usage: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.usage = usage
                }
            }

            public struct PlanWebinarItem: Decodable {
                /// The type of Webinar plan for the account.
                public var type: String?
                /// The number of hosts in this plan.
                public var hosts: Int?
                /// The total number of plan usage.
                public var usage: Int?

                public init(type: String? = nil, hosts: Int? = nil, usage: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.usage = usage
                }
            }

            public struct PlanLargeMeetingItem: Decodable {
                /// Large meeting Plan Type
                public var type: String?
                /// Number of hosts in this plan.
                public var hosts: Int?
                /// Number of usages for this account plan.
                public var usage: Int?

                public init(type: String? = nil, hosts: Int? = nil, usage: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.usage = usage
                }
            }

            public struct PlanZoomEvent: Decodable {
                /// The Zoom Events [plan type](https://marketplace.zoom.us/docs/api-reference/other-references/plans).
                public var type: String?
                /// The plan's number of hosts.
                public var hosts: Int?
                /// The plan's total usage number.
                public var usage: Int?

                public init(type: String? = nil, hosts: Int? = nil, usage: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.usage = usage
                }
            }

            /// Zoom Rooms Plan
            public struct PlanZoomRooms: Decodable {
                /// The Zoom Room plan's type.
                public var type: String?
                /// The number of hosts in this plan.
                public var hosts: Int?
                /// The plan's total usage number.
                public var usage: Int?

                public init(type: String? = nil, hosts: Int? = nil, usage: Int? = nil) {
                    self.type = type
                    self.hosts = hosts
                    self.usage = usage
                }
            }

            /// Recording Plan
            public struct PlanRecording: Decodable {
                /// Recording plan type.
                public var type: String?
                /// Recording free storage.
                public var freeStorage: String?
                /// Amount of free storage used.
                public var freeStorageUsage: String?
                /// Recording plan storage.
                public var planStorage: String?
                /// Recording storage usage.
                public var planStorageUsage: String?
                public var planStorageExceed: String?

                public init(type: String? = nil, freeStorage: String? = nil, freeStorageUsage: String? = nil, planStorage: String? = nil, planStorageUsage: String? = nil, planStorageExceed: String? = nil) {
                    self.type = type
                    self.freeStorage = freeStorage
                    self.freeStorageUsage = freeStorageUsage
                    self.planStorage = planStorage
                    self.planStorageUsage = planStorageUsage
                    self.planStorageExceed = planStorageExceed
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case freeStorage = "free_storage"
                    case freeStorageUsage = "free_storage_usage"
                    case planStorage = "plan_storage"
                    case planStorageUsage = "plan_storage_usage"
                    case planStorageExceed = "plan_storage_exceed"
                }
            }

            /// [Zoom United](https://zoom.us/pricing/zoom-bundles) plan.
            public struct PlanUnited: Decodable {
                /// Name of the plan.
                public var name: String?
                /// Plan [type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#zoom-united-plans).
                public var type: String?
                /// Number of licenses purchased.
                public var hosts: Int?
                /// Number of licenses that are already being used.
                public var usage: Int?

                public init(name: String? = nil, type: String? = nil, hosts: Int? = nil, usage: Int? = nil) {
                    self.name = name
                    self.type = type
                    self.hosts = hosts
                    self.usage = usage
                }
            }

            public init(planBase: PlanBase? = nil, planWebinar: [PlanWebinarItem]? = nil, planLargeMeeting: [PlanLargeMeetingItem]? = nil, planZoomEvents: [PlanZoomEvent]? = nil, planZoomRooms: PlanZoomRooms? = nil, planRecording: PlanRecording? = nil, planUnited: PlanUnited? = nil) {
                self.planBase = planBase
                self.planWebinar = planWebinar
                self.planLargeMeeting = planLargeMeeting
                self.planZoomEvents = planZoomEvents
                self.planZoomRooms = planZoomRooms
                self.planRecording = planRecording
                self.planUnited = planUnited
            }

            private enum CodingKeys: String, CodingKey {
                case planBase = "plan_base"
                case planWebinar = "plan_webinar"
                case planLargeMeeting = "plan_large_meeting"
                case planZoomEvents = "plan_zoom_events"
                case planZoomRooms = "plan_zoom_rooms"
                case planRecording = "plan_recording"
                case planUnited = "plan_united"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.Billing {
    public var invoices: Invoices {
        Invoices(path: path + "/invoices")
    }

    public struct Invoices {
        /// Path: `/accounts/{accountId}/billing/invoices`
        public let path: String

        /// List billing invoices
        ///
        /// List [invoices](https://support.zoom.us/hc/en-us/articles/207276556-Viewing-your-invoice-history#h_6710542f-23cc-4059-9cc7-ff02bec7314e) of a Zoom account.
        /// 
        /// To list a regular Zoom account's invoices or a master account's invoices, provide `me` as the value of the `accountId` path parameter. To list a sub account's invoices, provide the account ID of the sub account in the `accountId` path parameter. 
        /// 
        /// **Prerequisites:**
        /// * Account must be enrolled in Pro or a higher plan.<br>
        /// 
        /// **Scope**:`billing:master`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Additional Rate Limit:** You can make **one** API request per account(`accountId`) every **five** minutes until the daily limit is reached. This API has a daily limit of **6** requests per account(`accountId`).
        public func get(from: NaiveDate? = nil, to: NaiveDate? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(from, to))
        }

        public struct GetResponse: Decodable {
            public var invoices: [Invoice]?
            /// Currency used in the invoice.
            public var currency: String?

            public struct Invoice: Decodable {
                /// Unique identifier of the invoice.
                public var id: String?
                /// Invoice number.
                public var invoiceNumber: String?
                /// Total invoice amount.
                public var totalAmount: Double?
                /// Tax amount.
                public var taxAmount: Double?
                /// The remaining balance of the invoice after all payments, adjustments, and refunds are applied.
                public var balance: Double?
                /// The date by which the payment for this invoice is due.
                public var dueDate: String?
                /// The date when the invoice was generated.
                public var invoiceDate: String?
                /// This date is used to determine which charges are to be billed. All charges that are to be billed on this date or prior will be included in the invoice.
                public var targetDate: String?
                /// Status of the invoice.
                public var status: String?

                public init(id: String? = nil, invoiceNumber: String? = nil, totalAmount: Double? = nil, taxAmount: Double? = nil, balance: Double? = nil, dueDate: String? = nil, invoiceDate: String? = nil, targetDate: String? = nil, status: String? = nil) {
                    self.id = id
                    self.invoiceNumber = invoiceNumber
                    self.totalAmount = totalAmount
                    self.taxAmount = taxAmount
                    self.balance = balance
                    self.dueDate = dueDate
                    self.invoiceDate = invoiceDate
                    self.targetDate = targetDate
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case invoiceNumber = "invoice_number"
                    case totalAmount = "total_amount"
                    case taxAmount = "tax_amount"
                    case balance
                    case dueDate = "due_date"
                    case invoiceDate = "invoice_date"
                    case targetDate = "target_date"
                    case status
                }
            }

            public init(invoices: [Invoice]? = nil, currency: String? = nil) {
                self.invoices = invoices
                self.currency = currency
            }
        }

        private func makeGetQuery(_ from: NaiveDate?, _ to: NaiveDate?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Accounts.WithAccountID.Billing.Invoices {
    public func invoiceID(_ invoiceID: String) -> WithInvoiceID {
        WithInvoiceID(path: "\(path)/\(invoiceID)")
    }

    public struct WithInvoiceID {
        /// Path: `/accounts/{accountId}/billing/invoices/{invoiceId}`
        public let path: String

        /// Get invoice details
        ///
        /// Get detailed information about a specific [invoice](https://support.zoom.us/hc/en-us/articles/207276556-Viewing-your-invoice-history#h_6710542f-23cc-4059-9cc7-ff02bec7314e). <br>To retrieve a regular Zoom account's invoice details or a master account's invoice details, provide `me` as the value of `accountId` path parameter. To list a sub account's invoice details, provide the account ID of the sub account in the `accountId` path parameter. 
        /// 
        /// **Prerequisites:**
        /// * Account must be enrolled in Pro or a higher plan. <br>
        /// 
        /// **Scope**:`billing:master`<br>
        /// <br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Additional Rate Limit:** You can make **one** API request every **thirty** minutes until the daily limit is reached. This API has a daily limit of **100** requests per **account**.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Unique identifier of the invoice.
            public var id: String?
            /// Invoice number.
            public var invoiceNumber: String?
            /// Total invoice amount.
            public var totalAmount: Double?
            /// Tax amount.
            public var taxAmount: Double?
            /// The remaining balance of the invoice after all payments, adjustments, and refunds are applied.
            public var balance: Double?
            /// The date by which the payment for this invoice is due.
            public var dueDate: String?
            /// The date when the invoice was generated.
            public var invoiceDate: String?
            /// This date is used to determine which charges are to be billed. All charges that are to be billed on this date or prior will be included in the invoice.
            public var targetDate: String?
            /// Status of the invoice.
            public var status: String?
            public var invoiceItems: [InvoiceItem]?
            /// Billing currency.
            public var currency: String?

            public struct InvoiceItem: Decodable {
                /// Description for the charge.
                public var chargeName: String?
                /// Charge type.
                public var chargeType: String?
                /// Identifier for the charge.
                public var chargeNumber: String?
                /// Total amount.
                public var totalAmount: Double?
                /// Tax amount.
                public var taxAmount: Double?
                /// Quantity.
                public var quantity: Int?
                /// Billing start date.
                public var startDate: NaiveDate?
                /// Billing end date.
                public var endDate: NaiveDate?
                /// The purchase order number.
                public var purchaseOrderNumber: String?
                /// The partner SKU.
                public var partnerSku: String?

                public init(chargeName: String? = nil, chargeType: String? = nil, chargeNumber: String? = nil, totalAmount: Double? = nil, taxAmount: Double? = nil, quantity: Int? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, purchaseOrderNumber: String? = nil, partnerSku: String? = nil) {
                    self.chargeName = chargeName
                    self.chargeType = chargeType
                    self.chargeNumber = chargeNumber
                    self.totalAmount = totalAmount
                    self.taxAmount = taxAmount
                    self.quantity = quantity
                    self.startDate = startDate
                    self.endDate = endDate
                    self.purchaseOrderNumber = purchaseOrderNumber
                    self.partnerSku = partnerSku
                }

                private enum CodingKeys: String, CodingKey {
                    case chargeName = "charge_name"
                    case chargeType = "charge_type"
                    case chargeNumber = "charge_number"
                    case totalAmount = "total_amount"
                    case taxAmount = "tax_amount"
                    case quantity
                    case startDate = "start_date"
                    case endDate = "end_date"
                    case purchaseOrderNumber = "purchase_order_number"
                    case partnerSku = "partner_sku"
                }
            }

            public init(id: String? = nil, invoiceNumber: String? = nil, totalAmount: Double? = nil, taxAmount: Double? = nil, balance: Double? = nil, dueDate: String? = nil, invoiceDate: String? = nil, targetDate: String? = nil, status: String? = nil, invoiceItems: [InvoiceItem]? = nil, currency: String? = nil) {
                self.id = id
                self.invoiceNumber = invoiceNumber
                self.totalAmount = totalAmount
                self.taxAmount = taxAmount
                self.balance = balance
                self.dueDate = dueDate
                self.invoiceDate = invoiceDate
                self.targetDate = targetDate
                self.status = status
                self.invoiceItems = invoiceItems
                self.currency = currency
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case invoiceNumber = "invoice_number"
                case totalAmount = "total_amount"
                case taxAmount = "tax_amount"
                case balance
                case dueDate = "due_date"
                case invoiceDate = "invoice_date"
                case targetDate = "target_date"
                case status
                case invoiceItems = "invoice_items"
                case currency
            }
        }
    }
}

extension Paths {
    public static var api: API {
        API(path: "/api")
    }

    public struct API {
        /// Path: `/api`
        public let path: String
    }
}

extension Paths.API {
    public var download: Download {
        Download(path: path + "/download")
    }

    public struct Download {
        /// Path: `/api/download`
        public let path: String
    }
}

extension Paths.API.Download {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/api/download/billing`
        public let path: String
    }
}

extension Paths.API.Download.Billing {
    public var invoices: Invoices {
        Invoices(path: path + "/invoices")
    }

    public struct Invoices {
        /// Path: `/api/download/billing/invoices`
        public let path: String
    }
}

extension Paths.API.Download.Billing.Invoices {
    public func invoiceID(_ invoiceID: String) -> WithInvoiceID {
        WithInvoiceID(path: "\(path)/\(invoiceID)")
    }

    public struct WithInvoiceID {
        /// Path: `/api/download/billing/invoices/{invoiceId}`
        public let path: String

        /// Download an invoice file
        ///
        /// Use this API to download a Zoom accounts [billed](https://support.zoom.us/hc/en-us/articles/201363263-About-Billing) invoice file, in PDF format. To get an accounts invoice ID, use the **[List billing invoices](https://marketplace.zoom.us/docs/api-reference/zoom-api/billing/accountbillinginvoices)** API.
        /// 
        /// **Scopes:** `billing:master`<br>**Rate Limits:**
        /// * You can make **one** request to this API every **30 minutes** until the daily limit is reached.
        /// * This API has a daily limit of **100 requests per account**.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths {
    public static var tsp: Tsp {
        Tsp(path: "/tsp")
    }

    public struct Tsp {
        /// Path: `/tsp`
        public let path: String

        /// Get account's TSP information
        ///
        /// Get information on Telephony Service Provider on an account level.<br><br>
        /// **Scopes:** `tsp:read:admin` <br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:**<br>
        /// * A Pro or a higher plan.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Telephony Service Provider.
            public var tspProvider: String?
            /// Enable Telephony Service Provider for account users.
            public var enable: Bool?
            public var dialInNumbers: [DialInNumber]?
            /// Enable TSP feature for account. This has to be enabled to use any other tsp settings/features.
            public var isTspEnabled: Bool?
            /// For master account, extend its TSP setting to all sub accounts. For sub account, extend TSP setting from master account.
            public var isMasterAccountSettingExtended: Bool?
            /// Control restriction on account users being able to modify their TSP credentials.
            public var isModifyCredentialForbidden: Bool?
            /// Control restriction on account users adding a TSP number outside of account's dial in numbers.
            public var isDialInNumberUnrestricted: Bool?
            /// Telephony bridge zone
            public var tspBridge: TspBridge?

            public struct DialInNumber: Decodable {
                /// Country Code
                public var code: String?
                /// Dial-in number, length is less than 16
                public var number: String?
                /// Dial-in number type.
                public var type: String?

                public init(code: String? = nil, number: String? = nil, type: String? = nil) {
                    self.code = code
                    self.number = number
                    self.type = type
                }
            }

            /// Telephony bridge zone
            public enum TspBridge: String, Codable, CaseIterable {
                case usTspTb = "US_TSP_TB"
                case euTspTb = "EU_TSP_TB"
            }

            public init(tspProvider: String? = nil, enable: Bool? = nil, dialInNumbers: [DialInNumber]? = nil, isTspEnabled: Bool? = nil, isMasterAccountSettingExtended: Bool? = nil, isModifyCredentialForbidden: Bool? = nil, isDialInNumberUnrestricted: Bool? = nil, tspBridge: TspBridge? = nil) {
                self.tspProvider = tspProvider
                self.enable = enable
                self.dialInNumbers = dialInNumbers
                self.isTspEnabled = isTspEnabled
                self.isMasterAccountSettingExtended = isMasterAccountSettingExtended
                self.isModifyCredentialForbidden = isModifyCredentialForbidden
                self.isDialInNumberUnrestricted = isDialInNumberUnrestricted
                self.tspBridge = tspBridge
            }

            private enum CodingKeys: String, CodingKey {
                case tspProvider = "tsp_provider"
                case enable
                case dialInNumbers = "dial_in_numbers"
                case isTspEnabled = "tsp_enabled"
                case isMasterAccountSettingExtended = "master_account_setting_extended"
                case isModifyCredentialForbidden = "modify_credential_forbidden"
                case isDialInNumberUnrestricted = "dial_in_number_unrestricted"
                case tspBridge = "tsp_bridge"
            }
        }

        /// Update account's TSP information
        ///
        /// Update information of the Telephony Service Provider set up on an account.<br>
        /// **Prerequisites**:<br>
        /// TSP account option should be enabled.<br>
        /// **Scopes:** `tsp:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// 3rd party audio conferencing provider
            public var tspProvider: String?
            /// Enable 3rd party audio conferencing for account users
            public var enable: Bool?
            /// Enable TSP feature for account. This has to be enabled to use any other tsp settings/features.
            public var isTspEnabled: Bool?
            /// For master account, extend its TSP setting to all sub accounts. For sub account, extend TSP setting from master account.
            public var isMasterAccountSettingExtended: Bool?
            /// Control restriction on account users being able to modify their TSP credentials.
            public var isModifyCredentialForbidden: Bool?
            /// Control restriction on account users adding a TSP number outside of account's dial in numbers.
            public var isDialInNumberUnrestricted: Bool?
            /// Telephony bridge
            public var tspBridge: TspBridge?

            /// Telephony bridge
            public enum TspBridge: String, Codable, CaseIterable {
                case usTspTb = "US_TSP_TB"
                case euTspTb = "EU_TSP_TB"
            }

            public init(tspProvider: String? = nil, enable: Bool? = nil, isTspEnabled: Bool? = nil, isMasterAccountSettingExtended: Bool? = nil, isModifyCredentialForbidden: Bool? = nil, isDialInNumberUnrestricted: Bool? = nil, tspBridge: TspBridge? = nil) {
                self.tspProvider = tspProvider
                self.enable = enable
                self.isTspEnabled = isTspEnabled
                self.isMasterAccountSettingExtended = isMasterAccountSettingExtended
                self.isModifyCredentialForbidden = isModifyCredentialForbidden
                self.isDialInNumberUnrestricted = isDialInNumberUnrestricted
                self.tspBridge = tspBridge
            }

            private enum CodingKeys: String, CodingKey {
                case tspProvider = "tsp_provider"
                case enable
                case isTspEnabled = "tsp_enabled"
                case isMasterAccountSettingExtended = "master_account_setting_extended"
                case isModifyCredentialForbidden = "modify_credential_forbidden"
                case isDialInNumberUnrestricted = "dial_in_number_unrestricted"
                case tspBridge = "tsp_bridge"
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var tsp: Tsp {
        Tsp(path: path + "/tsp")
    }

    public struct Tsp {
        /// Path: `/users/{userId}/tsp`
        public let path: String

        /// List user's TSP accounts
        ///
        /// A user can have a maximum of two TSP accounts. Use this API to list all TSP accounts of a user.<br><br>
        /// **Scopes:** `tsp:read:admin` `tsp:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var tspAccounts: [TspAccount]?

            /// TSP Accounts List
            ///
            /// List of TSP accounts.
            public struct TspAccount: Decodable {
                /// The ID of the TSP account.
                public var id: Int?
                /// Conference code: numeric value, length is less than 16.
                public var conferenceCode: String
                /// Leader PIN: numeric value, length is less than 16.
                public var leaderPin: String
                /// List of dial in numbers.
                public var dialInNumbers: [DialInNumber]?
                /// Telephony bridge
                public var tspBridge: TspBridge?

                public struct DialInNumber: Decodable {
                    /// Country code.
                    public var code: String?
                    /// Dial-in number: length is less than 16.
                    public var number: String?
                    /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
                    /// `media_link` - Media link
                    public var type: `Type`?
                    /// Country Label, if passed, will display in place of code.
                    public var countryLabel: String?

                    /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
                    /// `media_link` - Media link
                    public enum `Type`: String, Codable, CaseIterable {
                        case toll
                        case tollfree
                        case mediaLink = "media_link"
                    }

                    public init(code: String? = nil, number: String? = nil, type: `Type`? = nil, countryLabel: String? = nil) {
                        self.code = code
                        self.number = number
                        self.type = type
                        self.countryLabel = countryLabel
                    }

                    private enum CodingKeys: String, CodingKey {
                        case code
                        case number
                        case type
                        case countryLabel = "country_label"
                    }
                }

                /// Telephony bridge
                public enum TspBridge: String, Codable, CaseIterable {
                    case usTspTb = "US_TSP_TB"
                    case euTspTb = "EU_TSP_TB"
                }

                public init(id: Int? = nil, conferenceCode: String, leaderPin: String, dialInNumbers: [DialInNumber]? = nil, tspBridge: TspBridge? = nil) {
                    self.id = id
                    self.conferenceCode = conferenceCode
                    self.leaderPin = leaderPin
                    self.dialInNumbers = dialInNumbers
                    self.tspBridge = tspBridge
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case conferenceCode = "conference_code"
                    case leaderPin = "leader_pin"
                    case dialInNumbers = "dial_in_numbers"
                    case tspBridge = "tsp_bridge"
                }
            }

            public init(tspAccounts: [TspAccount]? = nil) {
                self.tspAccounts = tspAccounts
            }

            private enum CodingKeys: String, CodingKey {
                case tspAccounts = "tsp_accounts"
            }
        }

        /// Add a user's TSP account
        ///
        /// Add a user's TSP account.<br><br>
        /// **Scopes:** `tsp:write:admin` `tsp:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        /// TSP Accounts List
        ///
        /// List of TSP accounts.
        public struct PostResponse: Decodable {
            /// Conference code: numeric value, length is less than 16.
            public var conferenceCode: String
            /// Leader PIN: numeric value, length is less than 16.
            public var leaderPin: String
            /// List of dial in numbers.
            public var dialInNumbers: [DialInNumber]?
            /// Telephony bridge
            public var tspBridge: TspBridge?

            public struct DialInNumber: Decodable {
                /// Country code.
                public var code: String?
                /// Dial-in number: length is less than 16.
                public var number: String?
                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
                /// `media_link` - Media link.
                public var type: `Type`?
                /// Country Label, if passed, will display in place of code.
                public var countryLabel: String?

                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
                /// `media_link` - Media link.
                public enum `Type`: String, Codable, CaseIterable {
                    case toll
                    case tollfree
                    case mediaLink = "media_link"
                }

                public init(code: String? = nil, number: String? = nil, type: `Type`? = nil, countryLabel: String? = nil) {
                    self.code = code
                    self.number = number
                    self.type = type
                    self.countryLabel = countryLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case number
                    case type
                    case countryLabel = "country_label"
                }
            }

            /// Telephony bridge
            public enum TspBridge: String, Codable, CaseIterable {
                case usTspTb = "US_TSP_TB"
                case euTspTb = "EU_TSP_TB"
            }

            public init(conferenceCode: String, leaderPin: String, dialInNumbers: [DialInNumber]? = nil, tspBridge: TspBridge? = nil) {
                self.conferenceCode = conferenceCode
                self.leaderPin = leaderPin
                self.dialInNumbers = dialInNumbers
                self.tspBridge = tspBridge
            }

            private enum CodingKeys: String, CodingKey {
                case conferenceCode = "conference_code"
                case leaderPin = "leader_pin"
                case dialInNumbers = "dial_in_numbers"
                case tspBridge = "tsp_bridge"
            }
        }

        /// TSP Accounts List
        ///
        /// List of TSP accounts.
        public struct PostRequest: Encodable {
            /// Conference code: numeric value, length is less than 16.
            public var conferenceCode: String
            /// Leader PIN: numeric value, length is less than 16.
            public var leaderPin: String
            /// List of dial in numbers.
            public var dialInNumbers: [DialInNumber]?
            /// Telephony bridge
            public var tspBridge: TspBridge?

            public struct DialInNumber: Encodable {
                /// Country code.
                public var code: String?
                /// Dial-in number: length is less than 16.
                public var number: String?
                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
                /// `media_link` - Media link.
                public var type: `Type`?
                /// Country Label, if passed, will display in place of code.
                public var countryLabel: String?

                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>
                /// `media_link` - Media link.
                public enum `Type`: String, Codable, CaseIterable {
                    case toll
                    case tollfree
                    case mediaLink = "media_link"
                }

                public init(code: String? = nil, number: String? = nil, type: `Type`? = nil, countryLabel: String? = nil) {
                    self.code = code
                    self.number = number
                    self.type = type
                    self.countryLabel = countryLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case number
                    case type
                    case countryLabel = "country_label"
                }
            }

            /// Telephony bridge
            public enum TspBridge: String, Codable, CaseIterable {
                case usTspTb = "US_TSP_TB"
                case euTspTb = "EU_TSP_TB"
            }

            public init(conferenceCode: String, leaderPin: String, dialInNumbers: [DialInNumber]? = nil, tspBridge: TspBridge? = nil) {
                self.conferenceCode = conferenceCode
                self.leaderPin = leaderPin
                self.dialInNumbers = dialInNumbers
                self.tspBridge = tspBridge
            }

            private enum CodingKeys: String, CodingKey {
                case conferenceCode = "conference_code"
                case leaderPin = "leader_pin"
                case dialInNumbers = "dial_in_numbers"
                case tspBridge = "tsp_bridge"
            }
        }
    }
}

extension Paths.Users.WithUserID.Tsp {
    public func tspID(_ tspID: String) -> WithTspID {
        WithTspID(path: "\(path)/\(tspID)")
    }

    public struct WithTspID {
        /// Path: `/users/{userId}/tsp/{tspId}`
        public let path: String

        /// Get a user's TSP account
        ///
        /// Each user can have a maximum of two TSP accounts. Use this API to retrieve details of a specific TSP account enabled for a specific user.<br><br>
        /// **Scopes:** `tsp:read:admin` `tsp:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// TSP Account
        ///
        /// TSP account of the user.
        public struct GetResponse: Decodable {
            /// The ID of the TSP account.
            public var id: Int?
            /// Conference code: numeric value, length is less than 16.
            public var conferenceCode: String
            /// Leader PIN: numeric value, length is less than 16.
            public var leaderPin: String
            /// List of dial in numbers.
            public var dialInNumbers: [DialInNumber]?
            /// Telephony bridge
            public var tspBridge: TspBridge?

            public struct DialInNumber: Decodable {
                /// Country code.
                public var code: String?
                /// Dial-in number: length is less than 16.
                public var number: String?
                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number. <br> `media_link` - Media link phone number. This is used for PSTN integration instead of a paid bridge number.
                public var type: `Type`?
                /// Country Label, if passed, will display in place of code.
                public var countryLabel: String?

                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number. <br> `media_link` - Media link phone number. This is used for PSTN integration instead of a paid bridge number.
                public enum `Type`: String, Codable, CaseIterable {
                    case toll
                    case tollfree
                    case mediaLink = "media_link"
                }

                public init(code: String? = nil, number: String? = nil, type: `Type`? = nil, countryLabel: String? = nil) {
                    self.code = code
                    self.number = number
                    self.type = type
                    self.countryLabel = countryLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case number
                    case type
                    case countryLabel = "country_label"
                }
            }

            /// Telephony bridge
            public enum TspBridge: String, Codable, CaseIterable {
                case usTspTb = "US_TSP_TB"
                case euTspTb = "EU_TSP_TB"
            }

            public init(id: Int? = nil, conferenceCode: String, leaderPin: String, dialInNumbers: [DialInNumber]? = nil, tspBridge: TspBridge? = nil) {
                self.id = id
                self.conferenceCode = conferenceCode
                self.leaderPin = leaderPin
                self.dialInNumbers = dialInNumbers
                self.tspBridge = tspBridge
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case conferenceCode = "conference_code"
                case leaderPin = "leader_pin"
                case dialInNumbers = "dial_in_numbers"
                case tspBridge = "tsp_bridge"
            }
        }

        /// Update a TSP account
        ///
        /// Update a user's TSP account.<br><br>
        /// **Scopes:** `tsp:write:admin` `tsp:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// TSP Account
        ///
        /// TSP account.
        public struct PatchRequest: Encodable {
            /// Conference code: numeric value, length is less than 16.
            public var conferenceCode: String
            /// Leader PIN: numeric value, length is less than 16.
            public var leaderPin: String
            /// List of dial in numbers.
            public var dialInNumbers: [DialInNumber]?
            /// Telephony bridge
            public var tspBridge: TspBridge?

            public struct DialInNumber: Encodable {
                /// Country code.
                public var code: String?
                /// Dial-in number: length is less than 16.
                public var number: String?
                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>`media_link` - Media Link Phone Number. It is used for PSTN integration instead of paid bridge number.
                public var type: `Type`?
                /// Country Label, if passed, will display in place of code.
                public var countryLabel: String?

                /// Dial-in number types:<br>`toll` - Toll number.<br>`tollfree` -Toll free number.<br>`media_link` - Media Link Phone Number. It is used for PSTN integration instead of paid bridge number.
                public enum `Type`: String, Codable, CaseIterable {
                    case toll
                    case tollfree
                    case mediaLink = "media_link"
                }

                public init(code: String? = nil, number: String? = nil, type: `Type`? = nil, countryLabel: String? = nil) {
                    self.code = code
                    self.number = number
                    self.type = type
                    self.countryLabel = countryLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case code
                    case number
                    case type
                    case countryLabel = "country_label"
                }
            }

            /// Telephony bridge
            public enum TspBridge: String, Codable, CaseIterable {
                case usTspTb = "US_TSP_TB"
                case euTspTb = "EU_TSP_TB"
            }

            public init(conferenceCode: String, leaderPin: String, dialInNumbers: [DialInNumber]? = nil, tspBridge: TspBridge? = nil) {
                self.conferenceCode = conferenceCode
                self.leaderPin = leaderPin
                self.dialInNumbers = dialInNumbers
                self.tspBridge = tspBridge
            }

            private enum CodingKeys: String, CodingKey {
                case conferenceCode = "conference_code"
                case leaderPin = "leader_pin"
                case dialInNumbers = "dial_in_numbers"
                case tspBridge = "tsp_bridge"
            }
        }

        /// Delete a user's TSP account
        ///
        /// Delete a user's TSP account.<br><br>
        /// **Scopes:** `tsp:write:admin` `tsp:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID.Tsp {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/users/{userId}/tsp/settings`
        public let path: String

        /// Set global dial-in URL for a TSP user
        ///
        /// A global dial-in page can provide a list of global access numbers using which audio conferencing can be conducted. By calling this API, you can set the url for the global dial-in page of a user whose Zoom account has TSP and special TSP with third-party audio conferencing options enabled. <p></p>
        /// **Scopes:**`tsp:write:admin` `tsp:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(audioURL: String? = nil) -> Request<Void> {
            .patch(path, body: ["audio_url": audioURL])
        }
    }
}

extension Paths {
    public static var trackingFields: TrackingFields {
        TrackingFields(path: "/tracking_fields")
    }

    public struct TrackingFields {
        /// Path: `/tracking_fields`
        public let path: String

        /// List tracking fields
        ///
        /// Use this API to list all the [tracking fields](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) on your Zoom account. Tracking fields let you analyze usage by various fields within an organization. 
        /// 
        /// **Scopes:** `tracking_fields:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, API or higher plan.
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Create a tracking field
        ///
        /// Use this API to create a new [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields). Tracking fields let you analyze usage by various fields within an organization. When scheduling a meeting, tracking fields will be included in the meeting options. 
        /// 
        /// **Scope:** `tracking_fields:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, API or higher plan.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of created tracking field
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// Label/ Name for the tracking field.
            public var field: String?
            /// Array of recommended values
            public var recommendedValues: [String]?
            /// Tracking Field Required
            public var isRequired: Bool?
            /// Tracking Field Visible
            public var isVisible: Bool?

            public init(field: String? = nil, recommendedValues: [String]? = nil, isRequired: Bool? = nil, isVisible: Bool? = nil) {
                self.field = field
                self.recommendedValues = recommendedValues
                self.isRequired = isRequired
                self.isVisible = isVisible
            }

            private enum CodingKeys: String, CodingKey {
                case field
                case recommendedValues = "recommended_values"
                case isRequired = "required"
                case isVisible = "visible"
            }
        }

        /// Tracking Field
        public struct PostRequest: Encodable {
            /// Label/ Name for the tracking field.
            public var field: String?
            /// Tracking Field Required
            public var isRequired: Bool?
            /// Tracking Field Visible
            public var isVisible: Bool?
            /// Array of recommended values
            public var recommendedValues: [String]?

            public init(field: String? = nil, isRequired: Bool? = nil, isVisible: Bool? = nil, recommendedValues: [String]? = nil) {
                self.field = field
                self.isRequired = isRequired
                self.isVisible = isVisible
                self.recommendedValues = recommendedValues
            }

            private enum CodingKeys: String, CodingKey {
                case field
                case isRequired = "required"
                case isVisible = "visible"
                case recommendedValues = "recommended_values"
            }
        }
    }
}

extension Paths.TrackingFields {
    public func fieldID(_ fieldID: String) -> WithFieldID {
        WithFieldID(path: "\(path)/\(fieldID)")
    }

    public struct WithFieldID {
        /// Path: `/tracking_fields/{fieldId}`
        public let path: String

        /// Get a tracking field
        ///
        /// Use this API to return information about a [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields). 
        /// 
        /// **Scopes:** `tracking_fields:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, API or higher plan.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Label/ Name for the tracking field.
            public var field: String?
            /// Array of recommended values
            public var recommendedValues: [String]?
            /// Tracking Field Required
            public var isRequired: Bool?
            /// Tracking Field Visible
            public var isVisible: Bool?

            public init(field: String? = nil, recommendedValues: [String]? = nil, isRequired: Bool? = nil, isVisible: Bool? = nil) {
                self.field = field
                self.recommendedValues = recommendedValues
                self.isRequired = isRequired
                self.isVisible = isVisible
            }

            private enum CodingKeys: String, CodingKey {
                case field
                case recommendedValues = "recommended_values"
                case isRequired = "required"
                case isVisible = "visible"
            }
        }

        /// Update a tracking field
        ///
        /// Use this API to update a [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields). 
        /// 
        /// **Scope:** `tracking_fields:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, API or higher plan.
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Tracking Field
        public struct PatchRequest: Encodable {
            /// Label/ Name for the tracking field.
            public var field: String?
            /// Tracking Field Required
            public var isRequired: Bool?
            /// Tracking Field Visible
            public var isVisible: Bool?
            /// Array of recommended values
            public var recommendedValues: [String]?

            public init(field: String? = nil, isRequired: Bool? = nil, isVisible: Bool? = nil, recommendedValues: [String]? = nil) {
                self.field = field
                self.isRequired = isRequired
                self.isVisible = isVisible
                self.recommendedValues = recommendedValues
            }

            private enum CodingKeys: String, CodingKey {
                case field
                case isRequired = "required"
                case isVisible = "visible"
                case recommendedValues = "recommended_values"
            }
        }

        /// Delete a tracking field
        ///
        /// Use this API to delete a [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields). 
        /// 
        /// **Scope:** `tracking_fields:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, API or higher plan.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var pac: Pac {
        Pac(path: path + "/pac")
    }

    public struct Pac {
        /// Path: `/users/{userId}/pac`
        public let path: String

        /// List a user's PAC accounts
        ///
        /// Use this API to list a user's [Personal Audio Conference](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) accounts. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// PAC allows Pro or higher account holders to host meetings through PSTN (phone dial-in) only.
        /// 
        /// **Scopes:** `pac:read:admin`, `pac:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan with [Premium Audio Conferencing](https://support.zoom.us/hc/en-us/articles/204517069-Getting-Started-with-Personal-Audio-Conference) add-on.
        /// * Personal Audio Conference must be enabled in the user's profile.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var pacAccounts: [PacAccount]?

            public struct PacAccount: Decodable {
                /// List of dedicated dial-in numbers.
                public var dedicatedDialInNumber: [DedicatedDialInNumberItem]?
                /// List of global dial-in numbers.
                public var globalDialInNumbers: [GlobalDialInNumber]?
                /// Conference ID.
                public var conferenceID: Int?
                /// Participant password: numeric value - length is less than 6.
                public var participantPassword: String?
                /// Listen-Only password: numeric value - length is less than 6.
                public var listenOnlyPassword: String?

                public struct DedicatedDialInNumberItem: Decodable {
                    /// Dial-in number: length is less than 16.
                    public var number: String?
                    /// Country code.
                    public var country: String?

                    public init(number: String? = nil, country: String? = nil) {
                        self.number = number
                        self.country = country
                    }
                }

                public struct GlobalDialInNumber: Decodable {
                    /// Dial-in number: length is less than 16.
                    public var number: String?
                    /// Country code.
                    public var country: String?

                    public init(number: String? = nil, country: String? = nil) {
                        self.number = number
                        self.country = country
                    }
                }

                public init(dedicatedDialInNumber: [DedicatedDialInNumberItem]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, conferenceID: Int? = nil, participantPassword: String? = nil, listenOnlyPassword: String? = nil) {
                    self.dedicatedDialInNumber = dedicatedDialInNumber
                    self.globalDialInNumbers = globalDialInNumbers
                    self.conferenceID = conferenceID
                    self.participantPassword = participantPassword
                    self.listenOnlyPassword = listenOnlyPassword
                }

                private enum CodingKeys: String, CodingKey {
                    case dedicatedDialInNumber = "dedicated_dial_in_number"
                    case globalDialInNumbers = "global_dial_in_numbers"
                    case conferenceID = "conference_id"
                    case participantPassword = "participant_password"
                    case listenOnlyPassword = "listen_only_password"
                }
            }

            public init(pacAccounts: [PacAccount]? = nil) {
                self.pacAccounts = pacAccounts
            }

            private enum CodingKeys: String, CodingKey {
                case pacAccounts = "pac_accounts"
            }
        }
    }
}

extension Paths {
    public static var chat: Chat {
        Chat(path: "/chat")
    }

    public struct Chat {
        /// Path: `/chat`
        public let path: String
    }
}

extension Paths.Chat {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/chat/users`
        public let path: String
    }
}

extension Paths.Chat.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/chat/users/{userId}`
        public let path: String
    }
}

extension Paths.Chat.Users.WithUserID {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/chat/users/{userId}/messages`
        public let path: String

        /// List user's chat messages
        ///
        /// Use this API to search chat messages and/or shared files between a user and an individual contact or a chat channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        ///  <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.">role</a> that has the <b>View</b> or <b>Edit</b> permission for <b>Chat Messages</b>.</p> 
        /// 
        /// **Scopes:** `chat_message:read`, `chat_message:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Chat message object.
        public struct GetResponse: Decodable {
            /// The date provided in the query parameter. If a date is not provided, the default value is the **current date**.
            public var date: NaiveDate?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// Information about the received messages and files.
            public var messages: [Message]?

            public struct Message: Decodable {
                /// Message ID: Unique Identifier of the message.
                public var id: String?
                /// The message content.
                public var message: String?
                /// The email address of the sender of the message.
                public var sender: String?
                /// The date-time at which the message was sent.
                public var dateTime: String?
                /// The timestamp of the message in microseconds.
                public var timestamp: Int?
                /// Unique identifier of a reply. This field will only be returned if the message is a reply message.
                public var replyMainMessageID: String?
                /// Timestamp of when the reply message was sent. This field will only be returned if the message is a reply message.
                /// 
                /// The value of this field will be in **long** format(int64).
                public var replyMainMessageTimestamp: Int?
                /// This field indicates whether a message is an original message(unedited), an edited message or a deleted message.
                /// 
                /// This field is only returned if you set the value of `for include_deleted_and_edited_message` query parameter to `true`.
                public var status: Status?
                /// The Chatbot's message, in JSON format. For more information, read the [Chatbots: Send, Edit, and Delete Messages](https://marketplace.zoom.us/docs/guides/chatbots/send-edit-and-delete-messages) documentation.
                public var botMessage: [String: AnyJSON]?
                /// The file's unique ID.
                public var fileID: String?
                /// The file's name.
                public var fileName: String?
                /// The file's size, in bytes.
                public var fileSize: Int?
                /// The file's download URL.
                public var downloadURL: String?

                /// This field indicates whether a message is an original message(unedited), an edited message or a deleted message.
                /// 
                /// This field is only returned if you set the value of `for include_deleted_and_edited_message` query parameter to `true`.
                public enum Status: String, Codable, CaseIterable {
                    case deleted = "Deleted"
                    case edited = "Edited"
                    case normal = "Normal"
                }

                public init(id: String? = nil, message: String? = nil, sender: String? = nil, dateTime: String? = nil, timestamp: Int? = nil, replyMainMessageID: String? = nil, replyMainMessageTimestamp: Int? = nil, status: Status? = nil, botMessage: [String: AnyJSON]? = nil, fileID: String? = nil, fileName: String? = nil, fileSize: Int? = nil, downloadURL: String? = nil) {
                    self.id = id
                    self.message = message
                    self.sender = sender
                    self.dateTime = dateTime
                    self.timestamp = timestamp
                    self.replyMainMessageID = replyMainMessageID
                    self.replyMainMessageTimestamp = replyMainMessageTimestamp
                    self.status = status
                    self.botMessage = botMessage
                    self.fileID = fileID
                    self.fileName = fileName
                    self.fileSize = fileSize
                    self.downloadURL = downloadURL
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case message
                    case sender
                    case dateTime = "date_time"
                    case timestamp
                    case replyMainMessageID = "reply_main_message_id"
                    case replyMainMessageTimestamp = "reply_main_message_timestamp"
                    case status
                    case botMessage = "bot_message"
                    case fileID = "file_id"
                    case fileName = "file_name"
                    case fileSize = "file_size"
                    case downloadURL = "download_url"
                }
            }

            public init(date: NaiveDate? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, messages: [Message]? = nil) {
                self.date = date
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.messages = messages
            }

            private enum CodingKeys: String, CodingKey {
                case date
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case messages
            }
        }

        public struct GetParameters {
            public var toContact: String?
            public var toChannel: String?
            public var date: NaiveDate?
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeDeletedAndEditedMessage: String?
            public var searchType: SearchType?
            public var searchKey: String?

            public enum SearchType: String, Codable, CaseIterable {
                case message
                case file
            }

            public init(toContact: String? = nil, toChannel: String? = nil, date: NaiveDate? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, includeDeletedAndEditedMessage: String? = nil, searchType: SearchType? = nil, searchKey: String? = nil) {
                self.toContact = toContact
                self.toChannel = toChannel
                self.date = date
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeDeletedAndEditedMessage = includeDeletedAndEditedMessage
                self.searchType = searchType
                self.searchKey = searchKey
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(toContact, forKey: "to_contact")
                encoder.encode(toChannel, forKey: "to_channel")
                encoder.encode(date, forKey: "date")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeDeletedAndEditedMessage, forKey: "include_deleted_and_edited_message")
                encoder.encode(searchType, forKey: "search_type")
                encoder.encode(searchKey, forKey: "search_key")
                return encoder.items
            }
        }

        /// Send a chat message
        ///
        /// Send chat messages on Zoom to either an individual user who is in your contact list or to a [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) of which you are a member. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// To send a message to a contact, provide the contact's email address in the `to_contact` field. To send a message to a channel, provide the channel's ID in `to_channel` parameter
        /// 
        /// **Scopes:** `chat_message:write`, `chat_message:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        ///  <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has the <b>Edit</b> permission for <b>Chat Messages</b>.</p>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Message ID: Unique Identifier of the message.
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        public struct PostRequest: Encodable {
            /// The message to be sent.
            public var message: String
            /// The email address of the contact to whom you would like to send the message.
            public var toContact: String?
            /// The Channel Id of the channel where you would like to send a message.
            public var toChannel: String?
            /// The reply message's ID. This field only returns if the message is a reply message.
            public var replyMainMessageID: String?
            /// [Chat mentions](https://support.zoom.us/hc/en-us/articles/360037567431-Using-chat-mentions-and-slash-commands) object. Use this object to include mentions in the message that will be sent to  a channel.
            public var atItems: [AtItem]?

            public struct AtItem: Encodable {
                /// Start position of the mention("@") in the message string. 
                /// 
                /// For example if you want to include the mention at the beginning of the message, the value for this field will be 0. 
                /// 
                /// Example message: "@Shrijana How are you?"
                public var startPosition: Int?
                /// End position of the mention.
                /// 
                /// Example message: "@Shrijana How are you?"
                /// In this case, the end position of the mention "@Shrijana" is 8. Hence, the value of this field will be 8.
                public var endPosition: Int?
                /// Type of mention. You can use one of the following values:<br>
                /// * `1`: Mention a contact. 
                /// 
                /// * `2`: Mention "all" to notify everyone in the channel.
                public var atType: Int?
                /// This field is required if the value of `at_type` field is set to 1. 
                /// 
                /// Email address of the contact.
                public var atContact: String?

                public init(startPosition: Int? = nil, endPosition: Int? = nil, atType: Int? = nil, atContact: String? = nil) {
                    self.startPosition = startPosition
                    self.endPosition = endPosition
                    self.atType = atType
                    self.atContact = atContact
                }

                private enum CodingKeys: String, CodingKey {
                    case startPosition = "start_position"
                    case endPosition = "end_position"
                    case atType = "at_type"
                    case atContact = "at_contact"
                }
            }

            public init(message: String, toContact: String? = nil, toChannel: String? = nil, replyMainMessageID: String? = nil, atItems: [AtItem]? = nil) {
                self.message = message
                self.toContact = toContact
                self.toChannel = toChannel
                self.replyMainMessageID = replyMainMessageID
                self.atItems = atItems
            }

            private enum CodingKeys: String, CodingKey {
                case message
                case toContact = "to_contact"
                case toChannel = "to_channel"
                case replyMainMessageID = "reply_main_message_id"
                case atItems = "at_items"
            }
        }
    }
}

extension Paths.Chat.Users.WithUserID.Messages.WithMessageID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/chat/users/{userId}/messages/{messageId}/status`
        public let path: String

        /// Mark message read or unread
        ///
        /// Use this API to mark a chat message as read or unread. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        /// **Note:** 
        /// 
        /// For an [account-level OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a [user assigned to a role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management) with the "**Edit**" permission for **Chat Messages**. 
        /// 
        /// **Scopes:** `chat_message:write`, `chat_message:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(_ body: PatchRequest? = nil) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The marking message's timestamp.
            public var timestamp: Int?
            /// The email address of the contact to whom the message was sent.<br>
            /// You must provide either a `to_contact` or `to_channel` parameter in the API request.
            public var toContact: String?
            /// The Channel ID of the channel where you sent the message.<br>You must provide either a `to_contact` or `to_channel` parameter in the API request.
            ///  You can retrieve the Channel ID using the [List User's Channels API](https://marketplace.zoom.us/docs/api-reference/zoom-api/chat-channels/getchannels).
            public var toChannel: String?
            /// Values include <br>`read` or `unread`.
            public var action: String?

            public init(timestamp: Int? = nil, toContact: String? = nil, toChannel: String? = nil, action: String? = nil) {
                self.timestamp = timestamp
                self.toContact = toContact
                self.toChannel = toChannel
                self.action = action
            }

            private enum CodingKeys: String, CodingKey {
                case timestamp
                case toContact = "to_contact"
                case toChannel = "to_channel"
                case action
            }
        }
    }
}

extension Paths.Chat.Users.WithUserID.Messages.WithMessageID {
    public var emojiReactions: EmojiReactions {
        EmojiReactions(path: path + "/emoji_reactions")
    }

    public struct EmojiReactions {
        /// Path: `/chat/users/{userId}/messages/{messageId}/emoji_reactions`
        public let path: String

        /// React to a chat message
        ///
        /// Use this API to react (add or remove) to a chat message with an emoji.
        /// 
        /// For an **account-level** [OAuth app](https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app), this API can only be used on behalf of a user who is assigned with a [role](https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.) that has the **Edit** permission for **Chat Messages**.
        /// 
        /// **Scopes:** `chat_message:write`, `chat_message:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(_ body: PatchRequest? = nil) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The email address of the contact to whom the message was sent. You must provide either the `to_contact` or the `to_channel` parameter in the API request.
            /// 
            /// To get a channel's ID, use the [List User's Channels API](https://marketplace.zoom.us/docs/api-reference/zoom-api/chat-channels/getchannels).
            public var toContact: String?
            /// The channel's ID where you sent the message. You must provide either the `to_contact` or the `to_channel` parameter in the API request.
            /// 
            /// To get a channel's ID, use the [List User's Channels API](https://marketplace.zoom.us/docs/api-reference/zoom-api/chat-channels/getchannels).
            public var toChannel: String?
            /// The action to perform with the message:
            /// * `add`  Add an emoji reaction.
            /// * `remove`  Remove an emoji reaction.
            public var action: Action?
            /// The emoji's unicode value, in `UTF-32` format. For more information, read the [Emojipedia](https://emojipedia.org/emoji-modifier-sequence/) documentation.
            public var emoji: String?

            /// The action to perform with the message:
            /// * `add`  Add an emoji reaction.
            /// * `remove`  Remove an emoji reaction.
            public enum Action: String, Codable, CaseIterable {
                case add
                case remove
            }

            public init(toContact: String? = nil, toChannel: String? = nil, action: Action? = nil, emoji: String? = nil) {
                self.toContact = toContact
                self.toChannel = toChannel
                self.action = action
                self.emoji = emoji
            }

            private enum CodingKeys: String, CodingKey {
                case toContact = "to_contact"
                case toChannel = "to_channel"
                case action
                case emoji
            }
        }
    }
}

extension Paths.Chat.Users.WithUserID.Messages {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/chat/users/{userId}/messages/{messageId}`
        public let path: String

        /// Get a message
        ///
        /// Get a chat message previously sent to a contact or a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// You must provide one of the following query parameters:<br>
        /// * `to_contact`  The email address of the Zoom contact to whom you sent the message.
        /// * `to_channel`  The ID of the Zoom channel where you sent the message.
        /// 
        /// **Scopes:** `chat_message:read`, `chat_message:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, you can only use this API for a user assigned <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.">the <b>Edit</b> permission for the <b>Chat message</b> role setting</a>.</p>
        public func get(toContact: String? = nil, toChannel: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(toContact, toChannel))
        }

        /// A chat message object.
        public struct GetResponse: Decodable {
            /// Message ID: Unique Identifier of the message.
            public var id: String?
            /// The message content.
            public var message: String?
            /// The email address of the sender of the message.
            public var sender: String?
            /// The date and time at which the message was sent.
            public var dateTime: String?
            /// The timestamp of the message in microseconds.
            public var timestamp: Int?
            /// The reply message's unique ID. The API only returns this value if the message is a reply message.
            public var replyMainMessageID: String?
            /// Timestamp of when the reply message was sent. This field will only be returned if the message is a reply message.
            /// 
            /// The value of this field will be in **long** format(int64).
            public var replyMainMessageTimestamp: Int?
            /// A list of emoji reactions.
            public var reactions: [Reaction]?
            /// The Chatbot's message, in JSON format. For more information, read the [Chatbots: Send, Edit, and Delete Messages](https://marketplace.zoom.us/docs/guides/chatbots/send-edit-and-delete-messages) documentation.
            public var botMessage: [String: AnyJSON]?
            /// The file's ID.
            public var fileID: String?
            /// The file's name.
            public var fileName: String?
            /// The file size.
            public var fileSize: Int?
            /// The file's download URL.
            public var downloadURL: String?

            public struct Reaction: Decodable {
                /// The emoji's Unicode value, in `UTF-32` format.
                public var emoji: String?
                /// The emoji's total usage count.
                public var totalCount: Int?

                public init(emoji: String? = nil, totalCount: Int? = nil) {
                    self.emoji = emoji
                    self.totalCount = totalCount
                }

                private enum CodingKeys: String, CodingKey {
                    case emoji
                    case totalCount = "total_count"
                }
            }

            public init(id: String? = nil, message: String? = nil, sender: String? = nil, dateTime: String? = nil, timestamp: Int? = nil, replyMainMessageID: String? = nil, replyMainMessageTimestamp: Int? = nil, reactions: [Reaction]? = nil, botMessage: [String: AnyJSON]? = nil, fileID: String? = nil, fileName: String? = nil, fileSize: Int? = nil, downloadURL: String? = nil) {
                self.id = id
                self.message = message
                self.sender = sender
                self.dateTime = dateTime
                self.timestamp = timestamp
                self.replyMainMessageID = replyMainMessageID
                self.replyMainMessageTimestamp = replyMainMessageTimestamp
                self.reactions = reactions
                self.botMessage = botMessage
                self.fileID = fileID
                self.fileName = fileName
                self.fileSize = fileSize
                self.downloadURL = downloadURL
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case message
                case sender
                case dateTime = "date_time"
                case timestamp
                case replyMainMessageID = "reply_main_message_id"
                case replyMainMessageTimestamp = "reply_main_message_timestamp"
                case reactions
                case botMessage = "bot_message"
                case fileID = "file_id"
                case fileName = "file_name"
                case fileSize = "file_size"
                case downloadURL = "download_url"
            }
        }

        private func makeGetQuery(_ toContact: String?, _ toChannel: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(toContact, forKey: "to_contact")
            encoder.encode(toChannel, forKey: "to_channel")
            return encoder.items
        }

        /// Update a message
        ///
        /// Use this API to edit a chat message that you previously sent to either a contact or a channel in Zoom by providing the ID of the message as the value of the `messageId` parameter. You can get the ID from the **List User's Chat Messages** API. Additionally, as a query parameter, you must provide either the contact's **email address** of the contact or the **Channel ID** of the channel where the message was sent.
        /// 
        /// For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has the <b>Edit</b> permission for <b>Chat Messages</b>.</p>
        /// 
        /// **Scope:** `chat_message:write`,`chat_message:write:admin`	<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(_ body: PutRequest? = nil) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The edited message.
            public var message: String?
            /// The email address of the contact to whom the message was sent.<br>
            /// You must provide either `to_contact` or `to_channel` parameter in the API request.
            public var toContact: String?
            /// The Channel ID of the channel where you sent the message.<br>You must provide either `to_contact` or `to_channel` parameter in the API request.
            ///  Channel ID can be retrieved from List User's Channels API.
            public var toChannel: String?

            public init(message: String? = nil, toContact: String? = nil, toChannel: String? = nil) {
                self.message = message
                self.toContact = toContact
                self.toChannel = toChannel
            }

            private enum CodingKeys: String, CodingKey {
                case message
                case toContact = "to_contact"
                case toChannel = "to_channel"
            }
        }

        /// Delete a message
        ///
        /// Delete a chat message that you previously sent to a contact or a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// In the query parameter, you must provide either of the following:
        /// 
        /// * `to_contact`: The email address of the contact to whom you sent the message. Use this parameter to delete a message sent to an individual contact in Zoom.
        /// * `to_channel`: The channel ID of the channel where you sent the message. Use this parameter to delete a message sent to a channel in Zoom.
        /// 
        /// 
        /// 
        /// **Scopes:** `chat_message:write`, `chat_message:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has the <b>Edit</b> permission for <b>Chat Messages</b>.</p>
        public func delete(toContact: String? = nil, toChannel: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(toContact, toChannel))
        }

        private func makeDeleteQuery(_ toContact: String?, _ toChannel: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(toContact, forKey: "to_contact")
            encoder.encode(toChannel, forKey: "to_channel")
            return encoder.items
        }
    }
}

extension Paths.Chat.Users.WithUserID {
    public var channels: Channels {
        Channels(path: path + "/channels")
    }

    public struct Channels {
        /// Path: `/chat/users/{userId}/channels`
        public let path: String

        /// List user's channels
        ///
        /// Use this API to list a user's chat channels. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Zoom chat [channels](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) allow users to communicate via chat in private or public groups.
        /// 
        /// **Scopes:** `chat_channel:read` or `chat_channel:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> This API supports both user-managed apps and account-level apps. However, in an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, to list channels of another user in the same Zoom account, the user calling this API must have a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.">role</a> that has the <b>View</b> or <b>Edit</b> permission for the <b>Chat channels</b> feature.</p>
        public func get(pageSize: Int? = nil, nextPageToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, nextPageToken))
        }

        public struct GetResponse: Decodable {
            /// The total number of records found.
            public var totalRecords: Int?
            /// The number of records returned with a single API call.
            /// Default value: 30.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// Chat Channel object(s).
            public var channels: [Channel]?

            public struct Channel: Decodable {
                /// Channel ID: Unique identifier of the Channel.
                public var id: String?
                /// Name of the channel.
                public var name: String?
                /// The channel's type:
                /// * `0`  An unknown channel type.
                /// * `1`  A private channel. Members must be invited to join this channel.
                /// * `2`  A private channel with members that belong to a Zoom account. All members of this channel are from the same organization and must be invited to join.
                /// * `3`  A public channel. Anyone can search for and join this channel.
                /// * `4`  An instant channel. This type of channel is created by adding members to a new chat.
                /// * `5`  A public channel. Anyone can join this channel and invite members from other Zoom accounts.
                public var type: Int?
                public var channelsSettings: ChannelsSettings?

                public struct ChannelsSettings: Decodable {
                    public var newMembersCanSeePreviousMessagesFiles: Bool?
                    public var allowToAddExternalUsers: Int?
                    public var postingPermissions: Int?

                    public init(newMembersCanSeePreviousMessagesFiles: Bool? = nil, allowToAddExternalUsers: Int? = nil, postingPermissions: Int? = nil) {
                        self.newMembersCanSeePreviousMessagesFiles = newMembersCanSeePreviousMessagesFiles
                        self.allowToAddExternalUsers = allowToAddExternalUsers
                        self.postingPermissions = postingPermissions
                    }

                    private enum CodingKeys: String, CodingKey {
                        case newMembersCanSeePreviousMessagesFiles = "new_members_can_see_previous_messages_files"
                        case allowToAddExternalUsers = "allow_to_add_external_users"
                        case postingPermissions = "posting_permissions"
                    }
                }

                public init(id: String? = nil, name: String? = nil, type: Int? = nil, channelsSettings: ChannelsSettings? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                    self.channelsSettings = channelsSettings
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case type
                    case channelsSettings = "channels_settings"
                }
            }

            public init(totalRecords: Int? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, channels: [Channel]? = nil) {
                self.totalRecords = totalRecords
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.channels = channels
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case channels
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ nextPageToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(nextPageToken, forKey: "next_page_token")
            return encoder.items
        }

        /// Create a channel
        ///
        /// Use this API to create a channel for a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Zoom chat channels allow users to communicate via chat in private or public groups.
        /// 
        /// **Scopes:** `chat_channel:write` or `chat_channel:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> This API supports both user-managed apps and account-level apps. However, in an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, to create a channel on behalf of another user in the same Zoom account, the user calling this API must have a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit.">role</a> that has the <b>Edit</b> permission for the <b>Chat channels</b> feature.</p>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Channel ID: Unique Identifier of the Channel.
            public var id: String?
            /// Channel name.
            public var name: String?
            /// Channel type.
            public var type: Int?
            /// Channel JID.
            public var jid: String?

            public init(id: String? = nil, name: String? = nil, type: Int? = nil, jid: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.jid = jid
            }
        }

        public struct PostRequest: Encodable {
            /// Name of the channel.
            public var name: String?
            /// Type of the channel. The value can be one of the following:<br>
            /// `1`: Private channel. In this type of channel, members must be invited to join a channel.<br>
            /// `2`: Private channel with members that belong to one Zoom account. Members in this channel should be invited and the members should be from the same organization.<br>
            /// `3`: Public channel. Anyone can search for this channel and join the channel.<br>
            /// `4`: New chat. This is an instant channel which can be created by adding members to a new chat.
            public var type: Int?
            /// Member(s) to include in the channel. A max of 5 members can be added to the channel at once with this API.
            public var members: [Member]?

            public struct Member: Encodable {
                /// Member's email address.
                public var email: String

                public init(email: String) {
                    self.email = email
                }
            }

            public init(name: String? = nil, type: Int? = nil, members: [Member]? = nil) {
                self.name = name
                self.type = type
                self.members = members
            }
        }
    }
}

extension Paths.Chat.Users.WithUserID.Channels {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/chat/users/{userId}/channels/{channelId}`
        public let path: String

        /// Get a channel
        ///
        /// Use this API to get information about a specific channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Zoom chat [channels](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) allow users to communicate via chat in private or public groups.
        /// 
        /// **Scopes:** `chat_channel:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a>  that has the <b>View</b> or <b>Edit</b> permission for <b>Chat Channels</b>.</p>
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// The channel object represents a Zoom chat [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-).
        public struct GetResponse: Decodable {
            public var properties: Properties?

            public struct Properties: Decodable {
                /// The ID of the channel.
                public var id: String?
                /// The [Jabber Identity](https://en.wikipedia.org/wiki/JID_(Jabber)) used to access the account.
                public var jid: String?
                /// The channel name.
                public var name: String?
                /// The channel's type:
                /// * `0`  An unknown channel type.
                /// * `1`  A private channel. Members must be invited to join this channel.
                /// * `2`  A private channel with members that belong to a Zoom account. All members of this channel are from the same organization and must be invited to join.
                /// * `3`  A public channel. Anyone can search for and join this channel.
                /// * `4`  An instant channel. This type of channel is created by adding members to a new chat.
                /// * `5`  A public channel. Anyone can join this channel and invite members from other Zoom accounts.
                public var type: Int?
                public var channelSettings: ChannelSettings?

                public struct ChannelSettings: Decodable {
                    /// New members to the channel can see previous messages and files posted in the channel.
                    public var newMembersCanSeePreviousMessagesFiles: Bool?
                    /// Allow members to add external users to the channel. The value can be one of the following:<br>
                    /// `0`: Disable. Do not allow channel members to add external users to the channel.<br>
                    /// `1`: All channel members. Allow all channel members to add external users to the channel.<br>
                    /// `2`: By members in your organization. Allow only members in your organization to add external users to the channel.
                    public var allowToAddExternalUsers: Int?
                    /// Permissions for members to post to the channel. The value can be one of the following:<br>
                    /// `1`: Everyone. All members can post to the channel.<br>
                    /// `2`: Admin only. Only the admin can post to the channel<br>
                    /// `3`: Admin and specific members. Only the admin and specified members can post to the channel. <br>
                    public var postingPermissions: Int?

                    public init(newMembersCanSeePreviousMessagesFiles: Bool? = nil, allowToAddExternalUsers: Int? = nil, postingPermissions: Int? = nil) {
                        self.newMembersCanSeePreviousMessagesFiles = newMembersCanSeePreviousMessagesFiles
                        self.allowToAddExternalUsers = allowToAddExternalUsers
                        self.postingPermissions = postingPermissions
                    }

                    private enum CodingKeys: String, CodingKey {
                        case newMembersCanSeePreviousMessagesFiles = "new_members_can_see_previous_messages_files"
                        case allowToAddExternalUsers = "allow_to_add_external_users"
                        case postingPermissions = "posting_permissions"
                    }
                }

                public init(id: String? = nil, jid: String? = nil, name: String? = nil, type: Int? = nil, channelSettings: ChannelSettings? = nil) {
                    self.id = id
                    self.jid = jid
                    self.name = name
                    self.type = type
                    self.channelSettings = channelSettings
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case jid
                    case name
                    case type
                    case channelSettings = "channel_settings"
                }
            }

            public init(properties: Properties? = nil) {
                self.properties = properties
            }
        }

        /// Update a channel
        ///
        /// Use this API to update the name of a specific channel created by a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Zoom chat channels allow users to communicate via chat in private or public channels.
        /// 
        /// **Scopes:** `chat_channel:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has the <b>Edit</b> permission for <b>Chat Channel</b>.</p>
        public func patch(name: String) -> Request<[String: AnyJSON]> {
            .patch(path, body: ["name": name])
        }

        /// Delete a channel
        ///
        /// Use this API to delete a specific channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Zoom chat [channels](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) allow users to communicate via chat in private or public groups.
        /// 
        /// **Scopes:** `chat_channel:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> This API only supports a <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p>
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Chat.Users.WithUserID.Channels.WithChannelID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/chat/users/{userId}/channels/{channelId}/members`
        public let path: String

        /// List channel members
        ///
        /// Use this API to list all members of a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `chat_channel:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an<b> account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has the <b>View</b> or <b>Edit</b> permission for <b>Chat Channels</b>.</p>
        public func get(pageSize: Int? = nil, nextPageToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, nextPageToken))
        }

        public struct GetResponse: Decodable {
            /// The total number of records returned.
            public var totalRecords: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// Members in a channel.
            public var members: [Member]?

            public struct Member: Decodable {
                /// Member ID: Unique Identifier of the member.
                public var id: String?
                /// Email address of the member.
                public var email: String?
                /// Member's first name.
                public var firstName: String?
                /// Member's last name.
                public var lastName: String?
                /// The user's display name.
                public var name: String?
                /// The role of the member. The value can be one of these: `owner`, `admin`, `member`.
                public var role: Role?

                /// The role of the member. The value can be one of these: `owner`, `admin`, `member`.
                public enum Role: String, Codable, CaseIterable {
                    case admin
                    case owner
                    case member
                }

                public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, name: String? = nil, role: Role? = nil) {
                    self.id = id
                    self.email = email
                    self.firstName = firstName
                    self.lastName = lastName
                    self.name = name
                    self.role = role
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case email
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case name
                    case role
                }
            }

            public init(totalRecords: Int? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, members: [Member]? = nil) {
                self.totalRecords = totalRecords
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.members = members
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case members
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ nextPageToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(nextPageToken, forKey: "next_page_token")
            return encoder.items
        }

        /// Invite channel members
        ///
        /// Use this API to invite members that are in a user's contact list to a channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `chat_channel:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note:</b> For an <b>account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has the <b>Edit</b> permission for <b>Chat Channels</b>.</p>
        public func post(members: [PostRequest.Member]? = nil) -> Request<PostResponse> {
            .post(path, body: PostRequest(members: members))
        }

        public struct PostResponse: Decodable {
            /// Member Ids of the members.
            public var ids: [String]?
            /// The date and time at which the member(s) are added to the channel.
            public var addedAt: Date?

            public init(ids: [String]? = nil, addedAt: Date? = nil) {
                self.ids = ids
                self.addedAt = addedAt
            }

            private enum CodingKeys: String, CodingKey {
                case ids
                case addedAt = "added_at"
            }
        }

        public struct PostRequest: Encodable {
            /// Members of a channel. You can invite up to a max number of 5 members with a single API call.
            public var members: [Member]?

            public struct Member: Encodable {
                /// Email address of the member.
                public var email: String

                public init(email: String) {
                    self.email = email
                }
            }

            public init(members: [Member]? = nil) {
                self.members = members
            }
        }
    }
}

extension Paths.Chat {
    public var channels: Channels {
        Channels(path: path + "/channels")
    }

    public struct Channels {
        /// Path: `/chat/channels`
        public let path: String
    }
}

extension Paths.Chat.Channels {
    public func channelID(_ channelID: String) -> WithChannelID {
        WithChannelID(path: "\(path)/\(channelID)")
    }

    public struct WithChannelID {
        /// Path: `/chat/channels/{channelId}`
        public let path: String

        /// Get a channel
        ///
        /// Zoom chat [channels](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) allow users to communicate via chat in private or public groups. Use this API to get information about a specific channel. 
        /// 
        /// **Scope:** `chat_channel:read`	<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#000000; padding:8px"> <b>Note: </b> This API supports only <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth apps</a>. If you use an Account-Level OAuth Access token, you can only retrieve the channel information for the authorized user. You can't retrieve the channel information of other account users. Use the <a href="https://marketplace.zoom.us/docs/api-reference/zoom-api/chat-channels-account-level/getchannel">Account-Level Get Channel Info API</a> to retrieve the channel information of other account users.</p><br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// The channel object represents a Zoom chat [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-).
        public struct GetResponse: Decodable {
            public var properties: Properties?

            public struct Properties: Decodable {
                /// The ID of the channel.
                public var id: String?
                /// The [Jabber Identity](https://en.wikipedia.org/wiki/JID_(Jabber)) used to access the account.
                public var jid: String?
                /// The channel name.
                public var name: String?
                /// The channel's type:
                /// * `0`  An unknown channel type.
                /// * `1`  A private channel. Members must be invited to join this channel.
                /// * `2`  A private channel with members that belong to a Zoom account. All members of this channel are from the same organization and must be invited to join.
                /// * `3`  A public channel. Anyone can search for and join this channel.
                /// * `4`  An instant channel. This type of channel is created by adding members to a new chat.
                /// * `5`  A public channel. Anyone can join this channel and invite members from other Zoom accounts.
                public var type: Int?
                public var channelSettings: ChannelSettings?

                public struct ChannelSettings: Decodable {
                    /// New members to the channel can see previous messages and files posted in the channel.
                    public var newMembersCanSeePreviousMessagesFiles: Bool?
                    /// Allow members to add external users to the channel. The value can be one of the following:<br>
                    /// `0`: Disable. Do not allow channel members to add external users to the channel.<br>
                    /// `1`: All channel members. Allow all channel members to add external users to the channel.<br>
                    /// `2`: By members in your organization. Allow only members in your organization to add external users to the channel.
                    public var allowToAddExternalUsers: Int?
                    /// Permissions for members to post to the channel. The value can be one of the following:<br>
                    /// `1`: Everyone. All members can post to the channel.<br>
                    /// `2`: Admin only. Only the admin can post to the channel<br>
                    /// `3`: Admin and specific members. Only the admin and specified members can post to the channel. <br>
                    public var postingPermissions: Int?

                    public init(newMembersCanSeePreviousMessagesFiles: Bool? = nil, allowToAddExternalUsers: Int? = nil, postingPermissions: Int? = nil) {
                        self.newMembersCanSeePreviousMessagesFiles = newMembersCanSeePreviousMessagesFiles
                        self.allowToAddExternalUsers = allowToAddExternalUsers
                        self.postingPermissions = postingPermissions
                    }

                    private enum CodingKeys: String, CodingKey {
                        case newMembersCanSeePreviousMessagesFiles = "new_members_can_see_previous_messages_files"
                        case allowToAddExternalUsers = "allow_to_add_external_users"
                        case postingPermissions = "posting_permissions"
                    }
                }

                public init(id: String? = nil, jid: String? = nil, name: String? = nil, type: Int? = nil, channelSettings: ChannelSettings? = nil) {
                    self.id = id
                    self.jid = jid
                    self.name = name
                    self.type = type
                    self.channelSettings = channelSettings
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case jid
                    case name
                    case type
                    case channelSettings = "channel_settings"
                }
            }

            public init(properties: Properties? = nil) {
                self.properties = properties
            }
        }

        /// Update a channel
        ///
        /// Zoom chat channels allow users to communicate via chat in private or public channels. Use this API to update the name of a specific channel that you created. 
        /// 
        /// **Scope:** `chat_channel:write`	<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b> This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        public func patch(name: String) -> Request<[String: AnyJSON]> {
            .patch(path, body: ["name": name])
        }

        /// Delete a channel
        ///
        /// Zoom chat [channels](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) allow users to communicate via chat in private or public groups. Use this API to delete a specific channel. 
        /// 
        /// **Scope:** `chat_channel:write`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b> This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Chat.Channels.WithChannelID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/chat/channels/{channelId}/members`
        public let path: String
    }
}

extension Paths.Chat.Channels.WithChannelID.Members {
    public func memberID(_ memberID: String) -> WithMemberID {
        WithMemberID(path: "\(path)/\(memberID)")
    }

    public struct WithMemberID {
        /// Path: `/chat/channels/{channelId}/members/{memberId}`
        public let path: String

        /// Remove a member
        ///
        /// A [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) can have one or multiple members. Use this API to remove a member from a chat channel.<br><br>
        ///  **Scopes:** `chat_channel:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        ///  
        ///  <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b> This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Chat.Channels.WithChannelID.Members {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/chat/channels/{channelId}/members/me`
        public let path: String

        /// Join a channel
        ///
        /// A [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) can have one or multiple members. Use this API to join a channel that is open for anyone in the same organization to join. You cannot use this API to join private channels that only allows invited members to be a part of it.
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b>This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        /// 
        /// **Scope:** `chat_channel:write`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var post: Request<PostResponse> {
            .post(path)
        }

        public struct PostResponse: Decodable {
            /// Member Id of the user who joined the public channel.
            public var id: String?
            /// The date and time at which a user joined the channel.
            public var addedAt: Date?

            public init(id: String? = nil, addedAt: Date? = nil) {
                self.id = id
                self.addedAt = addedAt
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case addedAt = "added_at"
            }
        }

        /// Leave a channel
        ///
        /// If you're no longer interested in being a member of an existing channel, you can leave the channel at any time. Use this API to leave a specific channel. After leaving the channel, you can no longer access information from that channel.
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b>This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        /// 
        /// **Scope:** `chat_channel:write`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var im: Im {
        Im(path: "/im")
    }

    public struct Im {
        /// Path: `/im`
        public let path: String
    }
}

extension Paths.Im {
    public var chat: Chat {
        Chat(path: path + "/chat")
    }

    public struct Chat {
        /// Path: `/im/chat`
        public let path: String
    }
}

extension Paths.Im.Chat {
    public var sessions: Sessions {
        Sessions(path: path + "/sessions")
    }

    public struct Sessions {
        /// Path: `/im/chat/sessions`
        public let path: String

        /// Get IM chat sessions
        ///
        /// Retrieve IM Chat sessions for a specified period of time. This API only supports Oauth2.<br>
        /// 	
        /// **Scopes:** `imchat:read, imchat:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        ///  <br><br>
        ///   <p style="background-color:#e1f5fe; color:#000000; padding:8px"><b>Deprecated:</b> By end of 2021, Zoom is deprecating this API in favor of a consolidated set of APIs. The API will still be available for you to use, though Zoom will no longer provide support for it. For further information, see <a href="https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#im-api-notice">Announcements: IM APIs Deprecation</a>.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date.
            public var from: NaiveDate?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
            public var nextPageToken: String?
            /// The amount of records returns within a single API call.
            public var pageSize: Int?
            /// Array of session objects.
            public var sessions: [Session]?
            /// End date.
            public var to: NaiveDate?

            public struct Session: Decodable {
                /// IM chat session ID.
                public var sessionID: String?
                /// IM chat session type.
                public var type: `Type`?
                /// Meeting topic.
                public var name: String?
                /// Last message sent time.
                public var lastMessageSentTime: Date?

                /// IM chat session type.
                public enum `Type`: String, Codable, CaseIterable {
                    case group = "Group"
                    case _11 = "1:1"
                }

                public init(sessionID: String? = nil, type: `Type`? = nil, name: String? = nil, lastMessageSentTime: Date? = nil) {
                    self.sessionID = sessionID
                    self.type = type
                    self.name = name
                    self.lastMessageSentTime = lastMessageSentTime
                }

                private enum CodingKeys: String, CodingKey {
                    case sessionID = "session_id"
                    case type
                    case name
                    case lastMessageSentTime = "last_message_sent_time"
                }
            }

            public init(from: NaiveDate? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, sessions: [Session]? = nil, to: NaiveDate? = nil) {
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.sessions = sessions
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case sessions
                case to
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Im.Chat.Sessions {
    public func sessionID(_ sessionID: String) -> WithSessionID {
        WithSessionID(path: "\(path)/\(sessionID)")
    }

    public struct WithSessionID {
        /// Path: `/im/chat/sessions/{sessionId}`
        public let path: String

        /// Get IM chat messages
        ///
        /// Retrieve IM chat messages for a specified period of time. This API only supports oauth2.<br>
        /// 
        /// **Scopes:** `imchat:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        ///  
        ///  <br>
        ///  
        ///  <p style="background-color:#e1f5fe; color:#000000; padding:8px"><b>Deprecated:</b> By end of 2021, Zoom is deprecating this API in favor of a consolidated set of APIs. The API will still be available for you to use, though Zoom will no longer provide support for it. For further information, see <a href="https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#im-api-notice">Announcements: IM APIs Deprecation</a>.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date.
            public var from: NaiveDate?
            /// Array of session objects.
            public var messages: [Message]?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
            public var nextPageToken: String?
            /// The amount of records returns within a single API call.
            public var pageSize: Int?
            /// IM chat session ID.
            public var sessionID: String?
            /// End date.
            public var to: NaiveDate?

            public struct Message: Decodable {
                /// IM chat message content.
                public var message: String?
                /// IM chat message sender.
                public var sender: String?
                /// IM chat message sent time.
                public var dateTime: Date?
                /// IM chat message action.
                public var action: String?
                /// Action time.
                public var actionTime: Date?

                public init(message: String? = nil, sender: String? = nil, dateTime: Date? = nil, action: String? = nil, actionTime: Date? = nil) {
                    self.message = message
                    self.sender = sender
                    self.dateTime = dateTime
                    self.action = action
                    self.actionTime = actionTime
                }

                private enum CodingKeys: String, CodingKey {
                    case message
                    case sender
                    case dateTime = "date_time"
                    case action
                    case actionTime = "action_time"
                }
            }

            public init(from: NaiveDate? = nil, messages: [Message]? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, sessionID: String? = nil, to: NaiveDate? = nil) {
                self.from = from
                self.messages = messages
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.sessionID = sessionID
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case messages
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case sessionID = "session_id"
                case to
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Im {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/im/users`
        public let path: String
    }
}

extension Paths.Im.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/im/users/{userId}`
        public let path: String
    }
}

extension Paths.Im.Users.WithUserID {
    public var chat: Chat {
        Chat(path: path + "/chat")
    }

    public struct Chat {
        /// Path: `/im/users/{userId}/chat`
        public let path: String
    }
}

extension Paths.Im.Users.WithUserID.Chat {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/im/users/{userId}/chat/messages`
        public let path: String

        /// Get users IM messages
        ///
        /// Get IM Chat messages for a specified period of time. This API only supports Oauth2.<br>
        /// **Scopes:** `imchat:read`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// <br><br>
        ///   <p style="background-color:#e1f5fe; color:#000000; padding:8px"><b>Deprecated:</b> By end of 2021, Zoom is deprecating this API in favor of a consolidated set of APIs. The API will still be available for you to use, though Zoom will no longer provide support for it. For further information, see <a href="https://marketplace.zoom.us/docs/guides/stay-up-to-date/announcements#im-api-notice">Announcements: IM APIs Deprecation</a>.</p>
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Query date time, format as yyyy-mm-dd.
            public var date: Date?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// Array of im messages.
            public var messages: [Message]?

            public struct Message: Decodable {
                /// IM message UUID.
                public var id: String?
                /// IM message content.
                public var message: String?
                /// IM message sender.
                public var sender: String?
                /// IM message send time.
                public var dateTime: Date?
                /// IM message send timestamp.
                public var timstamp: Int?

                public init(id: String? = nil, message: String? = nil, sender: String? = nil, dateTime: Date? = nil, timstamp: Int? = nil) {
                    self.id = id
                    self.message = message
                    self.sender = sender
                    self.dateTime = dateTime
                    self.timstamp = timstamp
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case message
                    case sender
                    case dateTime = "date_time"
                    case timstamp
                }
            }

            public init(date: Date? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, messages: [Message]? = nil) {
                self.date = date
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.messages = messages
            }

            private enum CodingKeys: String, CodingKey {
                case date
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case messages
            }
        }

        public struct GetParameters {
            public var chatUser: String?
            public var channel: String?
            public var date: String?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(chatUser: String? = nil, channel: String? = nil, date: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.chatUser = chatUser
                self.channel = channel
                self.date = date
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(chatUser, forKey: "chat_user")
                encoder.encode(channel, forKey: "channel")
                encoder.encode(date, forKey: "date")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Im.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/im/users/me`
        public let path: String
    }
}

extension Paths.Im.Users.Me {
    public var chat: Chat {
        Chat(path: path + "/chat")
    }

    public struct Chat {
        /// Path: `/im/users/me/chat`
        public let path: String
    }
}

extension Paths.Im.Users.Me.Chat {
    public var messages: Messages {
        Messages(path: path + "/messages")
    }

    public struct Messages {
        /// Path: `/im/users/me/chat/messages`
        public let path: String

        /// Send IM messages
        ///
        /// Send chat message to a user. <aside>Note: This API only supports OAuth 2.0.</aside><br><br>**Scope:** `imchat:write`
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        @available(*, deprecated, message: "Deprecated")
        public func post(chatUser: String? = nil, message: String? = nil) -> Request<PostResponse> {
            .post(path, query: makePostQuery(chatUser), body: ["message": message])
        }

        public struct PostResponse: Decodable {
            /// IM message UUID.
            public var id: String?

            public init(id: String? = nil) {
                self.id = id
            }
        }

        private func makePostQuery(_ chatUser: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(chatUser, forKey: "chat_user")
            return encoder.items
        }
    }
}

extension Paths.Chat.Users.WithUserID.Channels.WithChannelID.Members {
    public func memberID(_ memberID: String) -> WithMemberID {
        WithMemberID(path: "\(path)/\(memberID)")
    }

    public struct WithMemberID {
        /// Path: `/chat/users/{userId}/channels/{channelId}/members/{memberId}`
        public let path: String

        /// Remove a member
        ///
        /// A [channel](https://support.zoom.us/hc/en-us/articles/200912909-Getting-Started-With-Channels-Group-Messaging-) can have one or multiple members. Use this API to remove a member from a chat channel. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `chat_channel:write:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` <br>
        ///  
        ///  
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b> For an<b> account-level</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>, this API can only be used on behalf of a user who is assigned with a <b><a href="https://support.zoom.us/hc/en-us/articles/115001078646-Using-role-management#:~:text=Each%20user%20in%20a%20Zoom,owner%2C%20administrator%2C%20or%20member.&text=Role%2Dbased%20access%20control%20enables,needs%20to%20view%20or%20edit."> role</a> that has Edit permission for Chat Channels</b>.</p>
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var contacts: Contacts {
        Contacts(path: "/contacts")
    }

    public struct Contacts {
        /// Path: `/contacts`
        public let path: String

        /// Search company contacts
        ///
        /// A user under an organization's Zoom account has internal users listed under Company Contacts in the Zoom Client. Use this API to search users that are in the company contacts of a Zoom account. Using the `search_key` query parameter, provide either first name, last name or the email address of the user that you would like to search for. Optionally, set `query_presence_status` to `true` in order to include the presence status of a contact. <br><br>
        /// 
        /// **Scopes:** `contact:read:admin`, `contact:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned with a single API call. Default value is `1`.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var contacts: [Contact]?

            public struct Contact: Decodable {
                /// User ID of the contact.
                public var id: String?
                /// Email address of the contact.
                public var email: String?
                /// First name of the contact.
                public var firstName: String?
                /// Last name of the contact.
                public var lastName: String?
                /// Presence status of the contact in Zoom Client. The value of this field can be one of the following:
                /// `Do_Not_Disturb`<br> `away`<br> `Available`<br> `Offline`
                public var presenceStatus: PresenceStatus?
                /// Phone number of the user.
                public var phoneNumber: String?
                public var phoneNumbers: [PhoneNumber]?
                /// SIP Phone number of the user. Returned only if user has SIP phone enabled.
                public var sipPhoneNumber: String?
                /// Direct Number(s) of a user who has Zoom Phone license assigned.
                public var directNumbers: [String]?
                /// Extension Number of a user who has Zoom Phone license assigned.
                public var extensionNumber: String?
                /// Unique Identifier of the [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) in which the user has been added. An IM Directory group is not the same as a channel. IM Directory allows administrators to assign users in their account to groups that display within the Contacts list on Zoom clients.
                public var imGroupID: String?
                /// Name of the [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) in which the user has been added. An IM Directory group is not the same as a channel. IM Directory allows administrators to assign users in their account to groups that display within the Contacts list on Zoom clients.
                public var imGroupName: String?
                /// Department of the contact as provided in the user's Zoom profile.
                public var dept: String?
                /// Department of the user as provided in the user's Zoom profile.
                public var jobTitle: String?
                /// Location of the user as provided in the user's Zoom profile.
                public var location: String?
                /// The contact's SIP (Session Initiation Protocol) URI.
                public var sipUri: String?
                /// The user's contact type: 
                /// * `1`  A Zoom user. 
                /// * `2`  An auto receptionist. 
                /// * `3`  A common area phone. 
                /// * `4`  A call queue. 
                ///  * `5`  A shared line group. 
                /// * `6`  A shared global directory. 
                /// * `7`  A shared office contact.
                public var contactType: Int?

                /// Presence status of the contact in Zoom Client. The value of this field can be one of the following:
                /// `Do_Not_Disturb`<br> `away`<br> `Available`<br> `Offline`
                public enum PresenceStatus: String, Codable, CaseIterable {
                    case doNotDisturb = "Do_Not_Disturb"
                    case away = "Away"
                    case available = "Available"
                    case offline = "Offline"
                }

                public struct PhoneNumber: Decodable {
                    /// The phone number's [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). For example, if the phone number provided in the `number` field is a Brazil-based number, this will be the `BR` value.
                    public var country: String?
                    /// The phone number's country code. For example, for United States phone numbers, this will be a `+1` value.
                    public var code: String?
                    /// The user's phone number.
                    public var number: String?
                    /// Whether Zoom has verified the phone number.
                    public var isVerified: Bool?
                    /// The phone number's label:
                    /// * `Mobile`
                    /// * `Office`
                    /// * `Home`
                    ///  * `Fax`
                    public var label: Label?

                    /// The phone number's label:
                    /// * `Mobile`
                    /// * `Office`
                    /// * `Home`
                    ///  * `Fax`
                    public enum Label: String, Codable, CaseIterable {
                        case mobile = "Mobile"
                        case office = "Office"
                        case home = "Home"
                        case fax = "Fax"
                    }

                    public init(country: String? = nil, code: String? = nil, number: String? = nil, isVerified: Bool? = nil, label: Label? = nil) {
                        self.country = country
                        self.code = code
                        self.number = number
                        self.isVerified = isVerified
                        self.label = label
                    }

                    private enum CodingKeys: String, CodingKey {
                        case country
                        case code
                        case number
                        case isVerified = "verified"
                        case label
                    }
                }

                public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, presenceStatus: PresenceStatus? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, sipPhoneNumber: String? = nil, directNumbers: [String]? = nil, extensionNumber: String? = nil, imGroupID: String? = nil, imGroupName: String? = nil, dept: String? = nil, jobTitle: String? = nil, location: String? = nil, sipUri: String? = nil, contactType: Int? = nil) {
                    self.id = id
                    self.email = email
                    self.firstName = firstName
                    self.lastName = lastName
                    self.presenceStatus = presenceStatus
                    self.phoneNumber = phoneNumber
                    self.phoneNumbers = phoneNumbers
                    self.sipPhoneNumber = sipPhoneNumber
                    self.directNumbers = directNumbers
                    self.extensionNumber = extensionNumber
                    self.imGroupID = imGroupID
                    self.imGroupName = imGroupName
                    self.dept = dept
                    self.jobTitle = jobTitle
                    self.location = location
                    self.sipUri = sipUri
                    self.contactType = contactType
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case email
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case presenceStatus = "presence_status"
                    case phoneNumber = "phone_number"
                    case phoneNumbers = "phone_numbers"
                    case sipPhoneNumber = "sip_phone_number"
                    case directNumbers = "direct_numbers"
                    case extensionNumber = "extension_number"
                    case imGroupID = "im_group_id"
                    case imGroupName = "im_group_name"
                    case dept
                    case jobTitle = "job_title"
                    case location
                    case sipUri = "sip_uri"
                    case contactType = "contact_type"
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, contacts: [Contact]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.contacts = contacts
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case contacts
            }
        }

        public struct GetParameters {
            public var searchKey: String
            public var queryPresenceStatus: String?
            public var pageSize: Int?
            public var contactTypes: Int?
            public var nextPageToken: String?

            public init(searchKey: String, queryPresenceStatus: String? = nil, pageSize: Int? = nil, contactTypes: Int? = nil, nextPageToken: String? = nil) {
                self.searchKey = searchKey
                self.queryPresenceStatus = queryPresenceStatus
                self.pageSize = pageSize
                self.contactTypes = contactTypes
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(searchKey, forKey: "search_key")
                encoder.encode(queryPresenceStatus, forKey: "query_presence_status")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(contactTypes, forKey: "contact_types")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Chat.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/chat/users/me`
        public let path: String
    }
}

extension Paths.Chat.Users.Me {
    public var contacts: Contacts {
        Contacts(path: path + "/contacts")
    }

    public struct Contacts {
        /// Path: `/chat/users/me/contacts`
        public let path: String

        /// List user's contacts
        ///
        /// A user under an organizations Zoom account has internal users listed under Company Contacts in the Zoom Client. A Zoom user can also add another Zoom user as a [contact](https://support.zoom.us/hc/en-us/articles/115004055706-Managing-Contacts). Call this API to list all the contacts of a Zoom user. Zoom contacts are categorized into "company contacts" and "external contacts". You must specify the contact type in the `type` query parameter. If you do not specify, by default, the type will be set as company contact.
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b> This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        /// 
        /// **Scope**: `chat_contact:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned with a single API call.
            /// Default value: 30.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The contacts object.
            public var contacts: [Contact]?

            public struct Contact: Decodable {
                /// Contact Id.
                public var id: String?
                /// Contact's email address.
                public var email: String?
                /// Contact's first name.
                public var firstName: String?
                /// Contact's last name.
                public var lastName: String?

                public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil) {
                    self.id = id
                    self.email = email
                    self.firstName = firstName
                    self.lastName = lastName
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case email
                    case firstName = "first_name"
                    case lastName = "last_name"
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, contacts: [Contact]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.contacts = contacts
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case contacts
            }
        }

        public struct GetParameters {
            public var type: String?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(type: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Chat.Users.Me.Contacts {
    public func contactID(_ contactID: String) -> WithContactID {
        WithContactID(path: "\(path)/\(contactID)")
    }

    public struct WithContactID {
        /// Path: `/chat/users/me/contacts/{contactId}`
        public let path: String

        /// Get user's contact details
        ///
        /// A user under an organizations Zoom account has internal users listed under Company Contacts in the Zoom Client. A Zoom user can also add another Zoom user as a [contact](https://support.zoom.us/hc/en-us/articles/115004055706-Managing-Contacts). Call this API to get information on a specific contact of the Zoom user.
        /// 
        /// <p style="background-color:#e1f5fe; color:#01579b; padding:8px"> <b>Note: </b>This API only supports <b>user-managed</b> <a href="https://marketplace.zoom.us/docs/guides/getting-started/app-types/create-oauth-app">OAuth app</a>.</p><br>
        /// 
        /// **Scope**: `chat_contact:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(isQueryPresenceStatus: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(isQueryPresenceStatus))
        }

        public struct GetResponse: Decodable {
            /// User ID of the contact.
            public var id: String?
            /// Contact's email address.
            public var email: String?
            /// Contact's first name
            public var firstName: String?
            /// Contact's last name
            public var lastName: String?
            /// Contact's Presence Status in the Zoom Chat Client. The status can be one of the following: <br> `Do_Not_Disturb`<br> `Away`<br> `Available`<br> `Offline`
            public var presenceStatus: PresenceStatus?
            /// Phone number of the contact.
            public var phoneNumber: String?
            public var phoneNumbers: [PhoneNumber]?
            /// Direct number(s) assigned to the contact.
            public var directNumbers: [String]?
            /// Extension number of the contact.
            public var extensionNumber: String?

            /// Contact's Presence Status in the Zoom Chat Client. The status can be one of the following: <br> `Do_Not_Disturb`<br> `Away`<br> `Available`<br> `Offline`
            public enum PresenceStatus: String, Codable, CaseIterable {
                case doNotDisturb = "Do_Not_Disturb"
                case away = "Away"
                case available = "Available"
                case offline = "Offline"
            }

            public struct PhoneNumber: Decodable {
                /// The phone number's [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). For example, if the phone number provided in the `number` field is a Brazil-based number, this will be the `BR` value.
                public var country: String?
                /// The phone number's country code. For example, for United States phone numbers, this will be a `+1` value.
                public var code: String?
                /// The user's phone number.
                public var number: String?
                /// Whether Zoom has verified the phone number.
                public var isVerified: Bool?
                /// The phone number's label:
                /// * `Mobile`
                /// * `Office`
                /// * `Home`
                ///  * `Fax`
                public var label: Label?

                /// The phone number's label:
                /// * `Mobile`
                /// * `Office`
                /// * `Home`
                ///  * `Fax`
                public enum Label: String, Codable, CaseIterable {
                    case mobile = "Mobile"
                    case office = "Office"
                    case home = "Home"
                    case fax = "Fax"
                }

                public init(country: String? = nil, code: String? = nil, number: String? = nil, isVerified: Bool? = nil, label: Label? = nil) {
                    self.country = country
                    self.code = code
                    self.number = number
                    self.isVerified = isVerified
                    self.label = label
                }

                private enum CodingKeys: String, CodingKey {
                    case country
                    case code
                    case number
                    case isVerified = "verified"
                    case label
                }
            }

            public init(id: String? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, presenceStatus: PresenceStatus? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, directNumbers: [String]? = nil, extensionNumber: String? = nil) {
                self.id = id
                self.email = email
                self.firstName = firstName
                self.lastName = lastName
                self.presenceStatus = presenceStatus
                self.phoneNumber = phoneNumber
                self.phoneNumbers = phoneNumbers
                self.directNumbers = directNumbers
                self.extensionNumber = extensionNumber
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case email
                case firstName = "first_name"
                case lastName = "last_name"
                case presenceStatus = "presence_status"
                case phoneNumber = "phone_number"
                case phoneNumbers = "phone_numbers"
                case directNumbers = "direct_numbers"
                case extensionNumber = "extension_number"
            }
        }

        private func makeGetQuery(_ isQueryPresenceStatus: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isQueryPresenceStatus, forKey: "query_presence_status")
            return encoder.items
        }
    }
}

extension Paths {
    public static var report: Report {
        Report(path: "/report")
    }

    public struct Report {
        /// Path: `/report`
        public let path: String
    }
}

extension Paths.Report {
    public var daily: Daily {
        Daily(path: path + "/daily")
    }

    public struct Daily {
        /// Path: `/report/daily`
        public let path: String

        /// Get daily usage report
        ///
        /// Retrieve daily report to access the account-wide usage of Zoom services for each day in a given month. It lists the number of new users, meetings, participants, and meeting minutes.<br>
        /// **Prerequisites**<br>
        /// * Pro or higher plan.<br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(year: Int? = nil, month: Int? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(year, month))
        }

        private func makeGetQuery(_ year: Int?, _ month: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(year, forKey: "year")
            encoder.encode(month, forKey: "month")
            return encoder.items
        }
    }
}

extension Paths.Report {
    public var users: Users {
        Users(path: path + "/users")
    }

    public struct Users {
        /// Path: `/report/users`
        public let path: String

        /// Get active/inactive host reports
        ///
        /// A user is considered to be an active host during the month specified in the "from" and "to" range, if the user has hosted at least one meeting during this period. If the user didn't host any meetings during this period, the user is considered to be inactive.<br>The Active Hosts report displays a list of meetings, participants, and meeting minutes for a specific time range, up to one month. The month should fall within the last six months.<br>The Inactive Hosts report pulls a list of users who were not active during a specific period of time. 
        /// Use this API to retrieve an active or inactive host report for a specified period of time. The time range for the report is limited to a month and the month should fall under the past six months. <br>You can specify the type of report and date range using the query parameters.<br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var type: `Type`?
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case active
                case inactive
            }

            public init(type: `Type`? = nil, from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Report.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/report/users/{userId}`
        public let path: String
    }
}

extension Paths.Report.Users.WithUserID {
    public var meetings: Meetings {
        Meetings(path: path + "/meetings")
    }

    public struct Meetings {
        /// Path: `/report/users/{userId}/meetings`
        public let path: String

        /// Get meeting reports
        ///
        /// Retrieve [report](https://support.zoom.us/hc/en-us/articles/216378603-Meeting-Reporting) on past meetings and webinars for a specified time period. The time range for the report is limited to a month and the month must fall within the past six months.
        /// 
        /// Meetings and webinars are returned only if they have two or more unique participants.  <br><br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date for this report.
            public var from: NaiveDate?
            /// Array of meeting objects.
            public var meetings: [Meeting]?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// End date for this report.
            public var to: NaiveDate?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public struct Meeting: Decodable {
                /// Meeting UUID. Each meeting instance will generate its own UUID(i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). Please double encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.
                public var uuid: String?
                /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-):            Unique identifier of the meeting in "**long**" format(represented as int64
                /// data type in JSON), also known as the meeting number.
                public var id: Int?
                /// Meeting Type:<br> `1` - Instant Meeting<br> `2` - Scheduled Meeting<br> `3` - Recurring Meeting with no fixed time.<br>
                /// `4` - This value is returned if the meeting was started using a Personal Meeting ID. <br>
                /// `8` - Recurring Meeting with a fixed time.
                public var type: Int?
                /// Meeting topic.
                public var topic: String?
                /// User display name.
                public var userName: String?
                /// User email.
                public var userEmail: String?
                /// Meeting start time.
                public var startTime: Date?
                /// Meeting end time.
                public var endTime: Date?
                /// Meeting duration.
                public var duration: Int?
                /// Sum of meeting minutes from all participants in the meeting.
                public var totalMinutes: Int?
                /// Number of meeting participants.
                public var participantsCount: Int?
                /// Custom keys and values assigned to the meeting.
                public var customKeys: [CustomKey]?
                /// Indicates whether the meeting was created directly through Zoom or through an API request.
                public var source: String?

                public struct CustomKey: Decodable {
                    /// Custom key associated with the user.
                    public var key: String?
                    /// Value of the custom key associated with the user.
                    public var value: String?

                    public init(key: String? = nil, value: String? = nil) {
                        self.key = key
                        self.value = value
                    }
                }

                public init(uuid: String? = nil, id: Int? = nil, type: Int? = nil, topic: String? = nil, userName: String? = nil, userEmail: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: Int? = nil, totalMinutes: Int? = nil, participantsCount: Int? = nil, customKeys: [CustomKey]? = nil, source: String? = nil) {
                    self.uuid = uuid
                    self.id = id
                    self.type = type
                    self.topic = topic
                    self.userName = userName
                    self.userEmail = userEmail
                    self.startTime = startTime
                    self.endTime = endTime
                    self.duration = duration
                    self.totalMinutes = totalMinutes
                    self.participantsCount = participantsCount
                    self.customKeys = customKeys
                    self.source = source
                }

                private enum CodingKeys: String, CodingKey {
                    case uuid
                    case id
                    case type
                    case topic
                    case userName = "user_name"
                    case userEmail = "user_email"
                    case startTime = "start_time"
                    case endTime = "end_time"
                    case duration
                    case totalMinutes = "total_minutes"
                    case participantsCount = "participants_count"
                    case customKeys = "custom_keys"
                    case source
                }
            }

            public init(from: NaiveDate? = nil, meetings: [Meeting]? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil) {
                self.from = from
                self.meetings = meetings
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.to = to
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case meetings
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case to
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?
            public var type: `Type`?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case pastOne
            }

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil, type: `Type`? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Report {
    public var meetings: Meetings {
        Meetings(path: path + "/meetings")
    }

    public struct Meetings {
        /// Path: `/report/meetings`
        public let path: String
    }
}

extension Paths.Report.Meetings {
    public func meetingID(_ meetingID: String) -> WithMeetingID {
        WithMeetingID(path: "\(path)/\(meetingID)")
    }

    public struct WithMeetingID {
        /// Path: `/report/meetings/{meetingId}`
        public let path: String

        /// Get meeting detail reports
        ///
        /// Get a detailed report for a past meeting. <br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan.<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Meeting UUID. Each meeting instance will generate its own UUID(i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). Please double encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.
            public var uuid: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Meeting type.
            public var type: Int?
            /// Meeting topic.
            public var topic: String?
            /// User display name.
            public var userName: String?
            /// User email.
            public var userEmail: String?
            /// Meeting start time.
            public var startTime: Date?
            /// Meeting end time.
            public var endTime: Date?
            /// Meeting duration.
            public var duration: Int?
            /// Number of meeting minutes. This represents the total amount of meeting minutes attended by each participant including the host, for meetings hosted by the user. For instance if there were one host(named A) and one participant(named B) in a meeting, the value of total_minutes would be calculated as below:
            /// 
            /// **total_minutes** = Total Meeting Attendance Minutes of A + Total Meeting Attendance Minutes of B
            public var totalMinutes: Int?
            /// Number of meeting participants.
            public var participantsCount: Int?
            /// Tracking fields.
            public var trackingFields: [TrackingField]?
            /// Department of the host.
            public var dept: String?
            /// Custom keys and values assigned to the meeting.
            public var customKeys: [CustomKey]?

            public struct TrackingField: Decodable {
                /// Tracking fields type.
                public var field: String?
                /// Tracking fields value.
                public var value: String?

                public init(field: String? = nil, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            public struct CustomKey: Decodable {
                /// Custom key associated with the user.
                public var key: String?
                /// Value of the custom key associated with the user.
                public var value: String?

                public init(key: String? = nil, value: String? = nil) {
                    self.key = key
                    self.value = value
                }
            }

            public init(uuid: String? = nil, id: Int? = nil, type: Int? = nil, topic: String? = nil, userName: String? = nil, userEmail: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: Int? = nil, totalMinutes: Int? = nil, participantsCount: Int? = nil, trackingFields: [TrackingField]? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
                self.uuid = uuid
                self.id = id
                self.type = type
                self.topic = topic
                self.userName = userName
                self.userEmail = userEmail
                self.startTime = startTime
                self.endTime = endTime
                self.duration = duration
                self.totalMinutes = totalMinutes
                self.participantsCount = participantsCount
                self.trackingFields = trackingFields
                self.dept = dept
                self.customKeys = customKeys
            }

            private enum CodingKeys: String, CodingKey {
                case uuid
                case id
                case type
                case topic
                case userName = "user_name"
                case userEmail = "user_email"
                case startTime = "start_time"
                case endTime = "end_time"
                case duration
                case totalMinutes = "total_minutes"
                case participantsCount = "participants_count"
                case trackingFields = "tracking_fields"
                case dept
                case customKeys = "custom_keys"
            }
        }
    }
}

extension Paths.Report.Meetings.WithMeetingID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/report/meetings/{meetingId}/participants`
        public let path: String

        /// Get meeting participant reports
        ///
        /// Use this API to return a report of a past meeting with two or more participants, including the host. To return a report for past meeting with only **one** participant, use the [**List meeting participants**](https://marketplace.zoom.us/docs/api-reference/zoom-api/dashboards/dashboardmeetingparticipants) API. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `report:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or a higher plan.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Array of meeting participant objects.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// Universally unique identifier of the Participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank..
                public var id: String?
                /// Participant ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.
                public var userID: String?
                /// Participant display name.
                /// 
                /// This returns an empty string value if the account calling the API is a BAA account.
                public var name: String?
                /// Participant email.
                /// 
                /// This returns an empty string value if the account calling the API is a BAA account.
                public var userEmail: String?
                /// Participant join time.
                public var joinTime: Date?
                /// Participant leave time.
                public var leaveTime: Date?
                /// Participant duration.
                public var duration: Int?
                /// Unique identifier of the registrant. This field is only returned if you entered "registrant_id" as the value of `include_fields` query parameter.
                public var registrantID: String?
                /// Another identifier for the participant. Can be a number or characters, maximum length of 15 characters.
                public var customerKey: String?
                /// Indicates if failover happened during the meeting.
                public var isFailover: Bool?

                public init(id: String? = nil, userID: String? = nil, name: String? = nil, userEmail: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, duration: Int? = nil, registrantID: String? = nil, customerKey: String? = nil, isFailover: Bool? = nil) {
                    self.id = id
                    self.userID = userID
                    self.name = name
                    self.userEmail = userEmail
                    self.joinTime = joinTime
                    self.leaveTime = leaveTime
                    self.duration = duration
                    self.registrantID = registrantID
                    self.customerKey = customerKey
                    self.isFailover = isFailover
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userID = "user_id"
                    case name
                    case userEmail = "user_email"
                    case joinTime = "join_time"
                    case leaveTime = "leave_time"
                    case duration
                    case registrantID = "registrant_id"
                    case customerKey = "customer_key"
                    case isFailover = "failover"
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeFields: IncludeFields?

            public enum IncludeFields: String, Codable, CaseIterable {
                case registrantID = "registrant_id"
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, includeFields: IncludeFields? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeFields = includeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeFields, forKey: "include_fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Report.Meetings.WithMeetingID {
    public var polls: Polls {
        Polls(path: path + "/polls")
    }

    public struct Polls {
        /// Path: `/report/meetings/{meetingId}/polls`
        public let path: String

        /// Get meeting poll reports
        ///
        /// Retrieve a report of [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings) results for a past meeting. <br><br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan.<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Meeting UUID. Each meeting instance will generate its own UUID(i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). Please double encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.
            public var uuid: String?
            /// Meeting start time.
            public var startTime: Date?
            /// Array of meeting question objects.
            public var questions: [Question]?

            public struct Question: Decodable {
                /// Participant display name.<br> If "anonymous" option is enabled for a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meet), the participant's polling information will be kept anonymous and the value of `name` field will be "Anonymous Attendee".
                public var name: String?
                /// Participant email.
                public var email: String?
                /// Array of questions from user.
                public var questionDetails: [QuestionDetail]?

                public struct QuestionDetail: Decodable {
                    /// Asked question.
                    public var question: String?
                    /// Given answer.
                    public var answer: String?
                    /// Unique identifier of the poll.
                    public var pollingID: String?
                    /// Date and time at which the answer to the poll was submitted.
                    public var dateTime: Date?

                    public init(question: String? = nil, answer: String? = nil, pollingID: String? = nil, dateTime: Date? = nil) {
                        self.question = question
                        self.answer = answer
                        self.pollingID = pollingID
                        self.dateTime = dateTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case question
                        case answer
                        case pollingID = "polling_id"
                        case dateTime = "date_time"
                    }
                }

                public init(name: String? = nil, email: String? = nil, questionDetails: [QuestionDetail]? = nil) {
                    self.name = name
                    self.email = email
                    self.questionDetails = questionDetails
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case email
                    case questionDetails = "question_details"
                }
            }

            public init(id: Int? = nil, uuid: String? = nil, startTime: Date? = nil, questions: [Question]? = nil) {
                self.id = id
                self.uuid = uuid
                self.startTime = startTime
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case uuid
                case startTime = "start_time"
                case questions
            }
        }
    }
}

extension Paths.Report {
    public var webinars: Webinars {
        Webinars(path: path + "/webinars")
    }

    public struct Webinars {
        /// Path: `/report/webinars`
        public let path: String
    }
}

extension Paths.Report.Webinars {
    public func webinarID(_ webinarID: String) -> WithWebinarID {
        WithWebinarID(path: "\(path)/\(webinarID)")
    }

    public struct WithWebinarID {
        /// Path: `/report/webinars/{webinarId}`
        public let path: String

        /// Get webinar detail reports
        ///
        /// Retrieve a [report](https://support.zoom.us/hc/en-us/articles/201393719-Webinar-Reporting) containing past webinar details.  <br><br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan with Webinar add-on.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Webinar UUID. Each webinar instance will generate its own UUID(i.e., after a meeting ends, a new UUID will be generated when the next instance of the webinar starts). Double encode the UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.
            public var uuid: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Meeting type.
            public var type: Int?
            /// Meeting topic.
            public var topic: String?
            /// User display name.
            public var userName: String?
            /// User email.
            public var userEmail: String?
            /// Meeting start time.
            public var startTime: Date?
            /// Meeting end time.
            public var endTime: Date?
            /// Meeting duration.
            public var duration: Int?
            /// Number of Webinar minutes. This represents the total amount of Webinar minutes attended by each participant including the host, for a Webinar hosted by the user. For instance if there were one host(named A) and one participant(named B) in a Webinar, the value of total_minutes would be calculated as below:
            /// 
            /// **total_minutes** = Total Webinar Attendance Minutes of A + Total Webinar Attendance Minutes of B
            public var totalMinutes: Int?
            /// Number of meeting participants.
            public var participantsCount: Int?
            /// Tracking fields.
            public var trackingFields: [TrackingField]?
            /// Department of the host.
            public var dept: String?
            /// Custom keys and values assigned to the meeting.
            public var customKeys: [CustomKey]?

            public struct TrackingField: Decodable {
                /// Tracking fields type.
                public var field: String?
                /// Tracking fields value.
                public var value: String?

                public init(field: String? = nil, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            public struct CustomKey: Decodable {
                /// Custom key associated with the user.
                public var key: String?
                /// Value of the custom key associated with the user.
                public var value: String?

                public init(key: String? = nil, value: String? = nil) {
                    self.key = key
                    self.value = value
                }
            }

            public init(uuid: String? = nil, id: Int? = nil, type: Int? = nil, topic: String? = nil, userName: String? = nil, userEmail: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: Int? = nil, totalMinutes: Int? = nil, participantsCount: Int? = nil, trackingFields: [TrackingField]? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
                self.uuid = uuid
                self.id = id
                self.type = type
                self.topic = topic
                self.userName = userName
                self.userEmail = userEmail
                self.startTime = startTime
                self.endTime = endTime
                self.duration = duration
                self.totalMinutes = totalMinutes
                self.participantsCount = participantsCount
                self.trackingFields = trackingFields
                self.dept = dept
                self.customKeys = customKeys
            }

            private enum CodingKeys: String, CodingKey {
                case uuid
                case id
                case type
                case topic
                case userName = "user_name"
                case userEmail = "user_email"
                case startTime = "start_time"
                case endTime = "end_time"
                case duration
                case totalMinutes = "total_minutes"
                case participantsCount = "participants_count"
                case trackingFields = "tracking_fields"
                case dept
                case customKeys = "custom_keys"
            }
        }
    }
}

extension Paths.Report.Webinars.WithWebinarID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/report/webinars/{webinarId}/participants`
        public let path: String

        /// Get webinar participant reports
        ///
        /// Get detailed report on each attendee of a webinar.<br><br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with Webinar add-on enabled.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Array of webinar participant objects.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// Universally unique identifier of the Participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.
                public var id: String?
                /// Participant ID. This is a unique ID assigned to the participant joining the webinar and is valid for that webinar only.
                public var userID: String?
                /// Participant display name.
                /// 
                /// This returns an empty string value if the account calling the API is a BAA account.
                public var name: String?
                /// Participant email.
                /// 
                /// This returns an empty string value if the account calling the API is a BAA account.
                public var userEmail: String?
                /// Participant join time.
                public var joinTime: Date?
                /// Participant leave time.
                public var leaveTime: Date?
                /// Participant duration.
                public var duration: Int?
                /// Another identifier for the participant. Can be a number or characters, maximum length of 15 characters.
                public var customerKey: String?
                /// Indicates if failover happened during the webinar.
                public var isFailover: Bool?

                public init(id: String? = nil, userID: String? = nil, name: String? = nil, userEmail: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, duration: Int? = nil, customerKey: String? = nil, isFailover: Bool? = nil) {
                    self.id = id
                    self.userID = userID
                    self.name = name
                    self.userEmail = userEmail
                    self.joinTime = joinTime
                    self.leaveTime = leaveTime
                    self.duration = duration
                    self.customerKey = customerKey
                    self.isFailover = isFailover
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userID = "user_id"
                    case name
                    case userEmail = "user_email"
                    case joinTime = "join_time"
                    case leaveTime = "leave_time"
                    case duration
                    case customerKey = "customer_key"
                    case isFailover = "failover"
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeFields: IncludeFields?

            public enum IncludeFields: String, Codable, CaseIterable {
                case registrantID = "registrant_id"
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, includeFields: IncludeFields? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeFields = includeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeFields, forKey: "include_fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Report.Webinars.WithWebinarID {
    public var polls: Polls {
        Polls(path: path + "/polls")
    }

    public struct Polls {
        /// Path: `/report/webinars/{webinarId}/polls`
        public let path: String

        /// Get webinar poll reports
        ///
        /// Retrieve a report on past [webinar polls](https://support.zoom.us/hc/en-us/articles/203749865-Polling-for-Webinars).<br><br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with Webinar add-on enabled.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// Webinar UUID. Each webinar instance will generate its own UUID(i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.
            public var uuid: String?
            /// Webinar start time.
            public var startTime: Date?
            /// Array of webinar question objects.
            public var questions: [Question]?

            public struct Question: Decodable {
                /// Participant display name.<br><br> If the poll was created as an anonymous poll, participant's information will remain anonymous and the value of the `name` field will be "Anonymous Attendee".
                public var name: String?
                /// Participant email.
                public var email: String?
                /// Array of questions from user.
                public var questionDetails: [QuestionDetail]?

                public struct QuestionDetail: Decodable {
                    /// Asked question.
                    public var question: String?
                    /// Given answer.
                    public var answer: String?
                    /// Unique identifier of the poll.
                    public var pollingID: String?
                    /// Date and time at which the answer to the poll was submitted.
                    public var dateTime: Date?

                    public init(question: String? = nil, answer: String? = nil, pollingID: String? = nil, dateTime: Date? = nil) {
                        self.question = question
                        self.answer = answer
                        self.pollingID = pollingID
                        self.dateTime = dateTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case question
                        case answer
                        case pollingID = "polling_id"
                        case dateTime = "date_time"
                    }
                }

                public init(name: String? = nil, email: String? = nil, questionDetails: [QuestionDetail]? = nil) {
                    self.name = name
                    self.email = email
                    self.questionDetails = questionDetails
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case email
                    case questionDetails = "question_details"
                }
            }

            public init(id: Int? = nil, uuid: String? = nil, startTime: Date? = nil, questions: [Question]? = nil) {
                self.id = id
                self.uuid = uuid
                self.startTime = startTime
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case uuid
                case startTime = "start_time"
                case questions
            }
        }
    }
}

extension Paths.Report.Webinars.WithWebinarID {
    public var qa: Qa {
        Qa(path: path + "/qa")
    }

    public struct Qa {
        /// Path: `/report/webinars/{webinarId}/qa`
        public let path: String

        /// Get webinar Q&A report
        ///
        /// The Question & Answer (Q&A) feature for webinars allows attendees to ask questions during the webinar and for the panelists, co-hosts and host to answer their questions.
        /// 
        /// Use this API to retrieve a report on question and answers from past webinars. <br><br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with Webinar add-on enabled.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// Webinar UUID. Each Webinar instance will generate its own UUID(i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Please double encode your UUID when using it for API calls if the UUID begins with a '/' or contains '//' in it.
            public var uuid: String?
            /// Webinar start time.
            public var startTime: Date?
            /// Array of webinar question objects.
            public var questions: [Question]?

            public struct Question: Decodable {
                /// Participant display name.<br> 
                /// 
                /// If anonymous [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Getting-Started-with-Question-Answer) option is enabled and if a participant submits the Q&A without providing their name, the value of the `name` field will be "Anonymous Attendee".
                public var name: String?
                /// Participant email.
                public var email: String?
                /// Array of questions from user.
                public var questionDetails: [QuestionDetail]?

                public struct QuestionDetail: Decodable {
                    /// Asked question.
                    public var question: String?
                    /// Given answer.
                    public var answer: String?

                    public init(question: String? = nil, answer: String? = nil) {
                        self.question = question
                        self.answer = answer
                    }
                }

                public init(name: String? = nil, email: String? = nil, questionDetails: [QuestionDetail]? = nil) {
                    self.name = name
                    self.email = email
                    self.questionDetails = questionDetails
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case email
                    case questionDetails = "question_details"
                }
            }

            public init(id: Int? = nil, uuid: String? = nil, startTime: Date? = nil, questions: [Question]? = nil) {
                self.id = id
                self.uuid = uuid
                self.startTime = startTime
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case uuid
                case startTime = "start_time"
                case questions
            }
        }
    }
}

extension Paths.Report {
    public var telephone: Telephone {
        Telephone(path: path + "/telephone")
    }

    public struct Telephone {
        /// Path: `/report/telephone`
        public let path: String

        /// Get telephone reports
        ///
        /// The [telephone report](https://support.zoom.us/hc/en-us/articles/206514816-Telephone-reports) allows you to view who dialed into meetings via phone (Audio Conferencing or SIP Connected Audio) and which number they dialed into and other details. Use this API to get telephone report for a specified period of time.
        /// 
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>**Prerequisites:**<br>
        /// * Pro or higher plan.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var type: `Type`?
            public var queryDateType: QueryDateType?
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case _1 = "1"
                case _3 = "3"
            }

            public enum QueryDateType: String, Codable, CaseIterable {
                case startTime = "start_time"
                case endTime = "end_time"
                case meetingStartTime = "meeting_start_time"
                case meetingEndTime = "meeting_end_time"
            }

            public init(type: `Type`? = nil, queryDateType: QueryDateType? = nil, from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.queryDateType = queryDateType
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(queryDateType, forKey: "query_date_type")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Report {
    public var cloudRecording: CloudRecording {
        CloudRecording(path: path + "/cloud_recording")
    }

    public struct CloudRecording {
        /// Path: `/report/cloud_recording`
        public let path: String

        /// Get cloud recording usage report
        ///
        /// Retrieve cloud recording usage report for a specified period. You can only get cloud recording reports that is one day ealier than the current date and for the most recent period of 6 months. The date gap between from and to dates should be smaller or equal to 30 days. <br>
        /// **Prerequisites**<br>
        /// * Pro or higher plan.<br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(from: NaiveDate, to: NaiveDate) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(from, to))
        }

        private func makeGetQuery(_ from: NaiveDate, _ to: NaiveDate) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Report {
    public var operationlogs: Operationlogs {
        Operationlogs(path: path + "/operationlogs")
    }

    public struct Operationlogs {
        /// Path: `/report/operationlogs`
        public let path: String

        /// Get operation logs report
        ///
        /// The [Operations Logs](https://support.zoom.us/hc/en-us/articles/360032748331-Operation-Logs) report allows you to audit admin and user activity, such as adding a new user, changing account settings, and deleting recordings.<br>
        /// Use this API to retrieve operation logs report for a specified period of time.<br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
            public var nextPageToken: String?
            /// Array of operation log objects
            public var operationLogs: [OperationLog]?
            /// The amount of records returns within a single API call.
            public var pageSize: Int?

            public struct OperationLog: Decodable {
                /// The time at which the operation was performed.
                public var time: Date?
                /// The user who performed the operation.
                public var `operator`: String?
                /// Category type
                public var categoryType: String?
                /// Action
                public var action: String?
                /// Operation detail
                public var operationDetail: String?

                public init(time: Date? = nil, `operator`: String? = nil, categoryType: String? = nil, action: String? = nil, operationDetail: String? = nil) {
                    self.time = time
                    self.operator = `operator`
                    self.categoryType = categoryType
                    self.action = action
                    self.operationDetail = operationDetail
                }

                private enum CodingKeys: String, CodingKey {
                    case time
                    case `operator` = "operator"
                    case categoryType = "category_type"
                    case action
                    case operationDetail = "operation_detail"
                }
            }

            public init(nextPageToken: String? = nil, operationLogs: [OperationLog]? = nil, pageSize: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.operationLogs = operationLogs
                self.pageSize = pageSize
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case operationLogs = "operation_logs"
                case pageSize = "page_size"
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?
            public var categoryType: CategoryType?

            public enum CategoryType: String, Codable, CaseIterable {
                case all
                case user
                case userSettings = "user_settings"
                case account
                case billing
                case im
                case recording
                case phoneContacts = "phone_contacts"
                case webinar
                case subAccount = "sub_account"
                case role
                case zoomRooms = "zoom_rooms"
            }

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil, categoryType: CategoryType? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.categoryType = categoryType
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(categoryType, forKey: "category_type")
                return encoder.items
            }
        }
    }
}

extension Paths.Report {
    public var upcomingEvents: UpcomingEvents {
        UpcomingEvents(path: path + "/upcoming_events")
    }

    public struct UpcomingEvents {
        /// Path: `/report/upcoming_events`
        public let path: String

        /// Get upcoming events report
        ///
        /// Use this API to list upcoming meeting and/or webinar events within a specified period of time. The report's time range is limited to one month and must also be within the past six months.
        /// 
        /// **Scopes:** `report:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The report's start date. This value must be within the past six months.
            public var from: NaiveDate?
            /// The next page token is used to paginate through large result sets. A next page token returns when the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of records returned in a single API call.
            public var pageSize: Int?
            /// The report's end date. This value must be within the past six months and cannot exceed a month from the `from` value.
            public var to: NaiveDate?
            /// Information about the upcoming event.
            public var upcomingEvents: [UpcomingEvent]?

            public struct UpcomingEvent: Decodable {
                /// The event's unique ID.
                public var id: Int?
                /// The event's start time.
                public var startTime: String?
                /// The event's topic.
                public var topic: String?
                /// The event host's ID.
                public var hostID: String?
                /// The event host's name.
                public var hostName: String?
                /// The event host's department.
                public var dept: String?

                public init(id: Int? = nil, startTime: String? = nil, topic: String? = nil, hostID: String? = nil, hostName: String? = nil, dept: String? = nil) {
                    self.id = id
                    self.startTime = startTime
                    self.topic = topic
                    self.hostID = hostID
                    self.hostName = hostName
                    self.dept = dept
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case startTime = "start_time"
                    case topic
                    case hostID = "host_id"
                    case hostName = "host_name"
                    case dept
                }
            }

            public init(from: NaiveDate? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, upcomingEvents: [UpcomingEvent]? = nil) {
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.to = to
                self.upcomingEvents = upcomingEvents
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case to
                case upcomingEvents = "upcoming_events"
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?
            public var type: `Type`?

            public enum `Type`: String, Codable, CaseIterable {
                case meeting
                case webinar
                case all
            }

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil, type: `Type`? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Report {
    public var activities: Activities {
        Activities(path: path + "/activities")
    }

    public struct Activities {
        /// Path: `/report/activities`
        public let path: String

        /// Get sign In / sign out activity report
        ///
        /// Retrieve a list of sign in / sign out activity logs [report](https://support.zoom.us/hc/en-us/articles/201363213-Getting-Started-with-Reports) of users under a Zoom account.<br>
        /// **Prerequisites**<br>
        /// * Pro or higher plan.<br>
        /// **Scopes:** `report:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Report object
        public struct GetResponse: Decodable {
            /// Start date from which you want the activity logs report to be generated.
            public var from: String?
            /// End date until which you want the activity logs report to be generated
            public var to: String?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Next page token is used to paginate through large result sets.
            public var nextPageToken: String?
            /// Array of activity logs.
            public var activityLogs: [ActivityLog]?

            public struct ActivityLog: Decodable {
                /// Email address of the user used for the activity.
                public var email: String?
                /// Time during which the activity occurred.
                public var time: Date?
                /// The type of activity: <br>`Sign in`: Sign in activity by user.<br>`Sign out`: Sign out activity by user.
                public var type: String?
                /// The IP address of the user's device.
                public var ipAddress: String?
                /// The client interface type using which the activity was performed.
                public var clientType: String?
                /// Zoom client version of the user.
                public var version: String?

                public init(email: String? = nil, time: Date? = nil, type: String? = nil, ipAddress: String? = nil, clientType: String? = nil, version: String? = nil) {
                    self.email = email
                    self.time = time
                    self.type = type
                    self.ipAddress = ipAddress
                    self.clientType = clientType
                    self.version = version
                }

                private enum CodingKeys: String, CodingKey {
                    case email
                    case time
                    case type
                    case ipAddress = "ip_address"
                    case clientType = "client_type"
                    case version
                }
            }

            public init(from: String? = nil, to: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, activityLogs: [ActivityLog]? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.activityLogs = activityLogs
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case activityLogs = "activity_logs"
            }
        }

        public struct GetParameters {
            public var from: NaiveDate?
            public var to: NaiveDate?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate? = nil, to: NaiveDate? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Report {
    public var billing: Billing {
        Billing(path: path + "/billing")
    }

    public struct Billing {
        /// Path: `/report/billing`
        public let path: String

        /// Get billing reports
        ///
        /// Get department billing reports of a Zoom account.
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher account with Department Billing option enabled. Contact Zoom Support team for details.
        /// 
        /// **Scopes:** `report:read:admin`, `report:master`
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            public var billingReports: [BillingReport]?
            /// Currency of the billed amount.
            public var currency: String?

            public struct BillingReport: Decodable {
                /// Unique Identifier of the report. Use this ID to retrieve billing invoice via the "Get Billing Invoices API". 
                /// 
                /// You can also use this ID to export a CSV file of the billing report from this URL: `https://zoom.us/account/report/billing/export?id={id}`.
                public var id: String?
                /// Start date of the billing period.
                public var startDate: NaiveDate?
                /// End date of the billing period.
                public var endDate: NaiveDate?
                /// Total billing amount for this billing period.
                public var totalAmount: String?
                /// Total tax amount for this billing period.
                public var taxAmount: String?
                /// Type of the billing report. The value should be either of the following:<br>
                /// `0` - Detailed Billing Reports
                /// `1` - Custom Billing Reports
                public var type: Int?

                public init(id: String? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil, totalAmount: String? = nil, taxAmount: String? = nil, type: Int? = nil) {
                    self.id = id
                    self.startDate = startDate
                    self.endDate = endDate
                    self.totalAmount = totalAmount
                    self.taxAmount = taxAmount
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case startDate = "start_date"
                    case endDate = "end_date"
                    case totalAmount = "total_amount"
                    case taxAmount = "tax_amount"
                    case type
                }
            }

            public init(billingReports: [BillingReport]? = nil, currency: String? = nil) {
                self.billingReports = billingReports
                self.currency = currency
            }

            private enum CodingKeys: String, CodingKey {
                case billingReports = "billing_reports"
                case currency
            }
        }
    }
}

extension Paths.Report.Billing {
    public var invoices: Invoices {
        Invoices(path: path + "/invoices")
    }

    public struct Invoices {
        /// Path: `/report/billing/invoices`
        public let path: String

        /// Get billing invoice reports
        ///
        /// Get department billing invoices reports for a specific billing period. Provide the `billing_id` of the billing period for which you would like to retrieve the invoices for. This ID can be retrieved from **Get Billing Reports** API. 
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher account with Department Billing option enabled. Contact the Zoom Support team to enable this feature.
        /// 
        /// **Scopes:** `report:read:admin`, `report:master`
        /// 
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(billingID: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(billingID))
        }

        public struct GetResponse: Decodable {
            public var invoices: [Invoice]?
            /// Currency of the billed amount in the invoice.
            public var currency: String?

            public struct Invoice: Decodable {
                /// Invoice number
                public var invoiceNumber: String?
                /// Name of the invoice.
                public var invoiceChargeName: String?
                /// Number of licenses bought.
                public var quantity: Int?
                /// Total billed amount in the invoice.
                public var totalAmount: String?
                /// Tax amount in the invoice.
                public var taxAmount: String?
                /// Start date of the invoice period.
                public var startDate: NaiveDate?
                /// End date of the invoice period.
                public var endDate: NaiveDate?

                public init(invoiceNumber: String? = nil, invoiceChargeName: String? = nil, quantity: Int? = nil, totalAmount: String? = nil, taxAmount: String? = nil, startDate: NaiveDate? = nil, endDate: NaiveDate? = nil) {
                    self.invoiceNumber = invoiceNumber
                    self.invoiceChargeName = invoiceChargeName
                    self.quantity = quantity
                    self.totalAmount = totalAmount
                    self.taxAmount = taxAmount
                    self.startDate = startDate
                    self.endDate = endDate
                }

                private enum CodingKeys: String, CodingKey {
                    case invoiceNumber = "invoice_number"
                    case invoiceChargeName = "invoice_charge_name"
                    case quantity
                    case totalAmount = "total_amount"
                    case taxAmount = "tax_amount"
                    case startDate = "start_date"
                    case endDate = "end_date"
                }
            }

            public init(invoices: [Invoice]? = nil, currency: String? = nil) {
                self.invoices = invoices
                self.currency = currency
            }
        }

        private func makeGetQuery(_ billingID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(billingID, forKey: "billing_id")
            return encoder.items
        }
    }
}

extension Paths.Report {
    public var chat: Chat {
        Chat(path: path + "/chat")
    }

    public struct Chat {
        /// Path: `/report/chat`
        public let path: String
    }
}

extension Paths.Report.Chat {
    public var sessions: Sessions {
        Sessions(path: path + "/sessions")
    }

    public struct Sessions {
        /// Path: `/report/chat/sessions`
        public let path: String

        /// Get chat sessions reports
        ///
        /// Use this API to get Zoom Chat session reports for a specified period of time. The monthly date range **must** be within the last six months.
        /// 
        /// **Scopes:** `report_chat:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan 
        /// * Report chat permissions.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The query's start date.
            public var from: NaiveDate?
            /// The query's end date.
            public var to: NaiveDate?
            /// The amount of records returns within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
            public var nextPageToken: String?
            /// Information about the chat session.
            public var sessions: [Session]?

            public struct Session: Decodable {
                /// The chat session's ID.
                public var id: String?
                /// The chat session's type:
                /// * `Group`  A group chat.
                /// * `1:1`  A one-on-one chat.
                public var type: `Type`?
                /// The chat session's name.
                public var name: String?
                /// The timestamp of the last message sent.
                public var lastMessageSentTime: Date?

                /// The chat session's type:
                /// * `Group`  A group chat.
                /// * `1:1`  A one-on-one chat.
                public enum `Type`: String, Codable, CaseIterable {
                    case group = "Group"
                    case _11 = "1:1"
                }

                public init(id: String? = nil, type: `Type`? = nil, name: String? = nil, lastMessageSentTime: Date? = nil) {
                    self.id = id
                    self.type = type
                    self.name = name
                    self.lastMessageSentTime = lastMessageSentTime
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case type
                    case name
                    case lastMessageSentTime = "last_message_sent_time"
                }
            }

            public init(from: NaiveDate? = nil, to: NaiveDate? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, sessions: [Session]? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.sessions = sessions
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case sessions
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Report.Chat.Sessions {
    public func sessionID(_ sessionID: String) -> WithSessionID {
        WithSessionID(path: "\(path)/\(sessionID)")
    }

    public struct WithSessionID {
        /// Path: `/report/chat/sessions/{sessionId}`
        public let path: String

        /// Get chat messages reports
        ///
        /// Use this API to get Zoom Chat message reports for a specified period of time. The monthly date range must be within the last six months.
        /// 
        /// **Scopes:** `report_chat:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan 
        /// * Report chat permissions
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The query's start date.
            public var from: NaiveDate?
            /// The query's end date.
            public var to: NaiveDate?
            /// The amount of records returns within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
            public var nextPageToken: String?
            /// An array containing chat message information.
            /// 
            /// **Note:** The `page_size` parameter only works for messages.
            public var messages: [Message]?
            /// An array containing edited chat message information.
            public var editedMessages: [EditedMessage]?
            /// An array containing deleted chat messages information.
            public var deletedMessages: [DeletedMessage]?

            public struct Message: Decodable {
                /// The chat message's ID.
                public var id: String?
                /// The contents of the chat message.
                public var message: String?
                /// The chat message's sender.
                public var sender: String?
                /// The chat message's recipient. This field only returns if the chat session `type` value is `1:1`.
                public var receiver: String?
                /// The timestamp at which the chat message was sent.
                public var dateTime: Date?
                /// The message's timestamp, in milliseconds.
                public var timestamp: Int?
                /// The reply message's unique ID. The API only returns this value if the message is a reply message.
                public var replyMainMessageID: String?
                /// A timestamp of when the reply message was sent. The API only returns this value if the message is a reply message.
                public var replyMainMessageTimestamp: Int?
                /// Information about the chat files.
                public var files: [File]?

                public struct File: Decodable {
                    /// The chat file's unique ID.
                    public var fileID: String?
                    /// The chat file's name and its file extension.
                    public var fileName: String?
                    /// The chat file's size, in bytes.
                    public var fileSize: Int?
                    /// The URL at which to download the chat file.
                    public var downloadURL: String?

                    public init(fileID: String? = nil, fileName: String? = nil, fileSize: Int? = nil, downloadURL: String? = nil) {
                        self.fileID = fileID
                        self.fileName = fileName
                        self.fileSize = fileSize
                        self.downloadURL = downloadURL
                    }

                    private enum CodingKeys: String, CodingKey {
                        case fileID = "file_id"
                        case fileName = "file_name"
                        case fileSize = "file_size"
                        case downloadURL = "download_url"
                    }
                }

                public init(id: String? = nil, message: String? = nil, sender: String? = nil, receiver: String? = nil, dateTime: Date? = nil, timestamp: Int? = nil, replyMainMessageID: String? = nil, replyMainMessageTimestamp: Int? = nil, files: [File]? = nil) {
                    self.id = id
                    self.message = message
                    self.sender = sender
                    self.receiver = receiver
                    self.dateTime = dateTime
                    self.timestamp = timestamp
                    self.replyMainMessageID = replyMainMessageID
                    self.replyMainMessageTimestamp = replyMainMessageTimestamp
                    self.files = files
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case message
                    case sender
                    case receiver
                    case dateTime = "date_time"
                    case timestamp
                    case replyMainMessageID = "reply_main_message_id"
                    case replyMainMessageTimestamp = "reply_main_message_timestamp"
                    case files
                }
            }

            public struct EditedMessage: Decodable {
                /// The chat message's ID.
                public var id: String?
                /// The contents of the chat message.
                public var message: String?
                /// The chat message's sender.
                public var sender: String?
                /// The chat message's recipient. This field only returns if the chat session `type` value is `1:1`.
                public var receiver: String?
                /// The timestamp at which the chat message was sent.
                public var dateTime: Date?
                /// The message's timestamp, in milliseconds.
                public var timestamp: Int?
                /// The reply message's unique ID. The API only returns this value if the message is a reply message.
                public var replyMainMessageID: String?
                /// A timestamp of when the reply message was sent. The API only returns this value if the message is a reply message.
                public var replyMainMessageTimestamp: Int?
                /// Information about the chat files.
                public var files: [File]?

                public struct File: Decodable {
                    /// The chat file's unique ID.
                    public var fileID: String?
                    /// The chat file's name and its file extension.
                    public var fileName: String?
                    /// The chat file's size, in bytes.
                    public var fileSize: Int?
                    /// The URL at which to download the chat file.
                    public var downloadURL: String?

                    public init(fileID: String? = nil, fileName: String? = nil, fileSize: Int? = nil, downloadURL: String? = nil) {
                        self.fileID = fileID
                        self.fileName = fileName
                        self.fileSize = fileSize
                        self.downloadURL = downloadURL
                    }

                    private enum CodingKeys: String, CodingKey {
                        case fileID = "file_id"
                        case fileName = "file_name"
                        case fileSize = "file_size"
                        case downloadURL = "download_url"
                    }
                }

                public init(id: String? = nil, message: String? = nil, sender: String? = nil, receiver: String? = nil, dateTime: Date? = nil, timestamp: Int? = nil, replyMainMessageID: String? = nil, replyMainMessageTimestamp: Int? = nil, files: [File]? = nil) {
                    self.id = id
                    self.message = message
                    self.sender = sender
                    self.receiver = receiver
                    self.dateTime = dateTime
                    self.timestamp = timestamp
                    self.replyMainMessageID = replyMainMessageID
                    self.replyMainMessageTimestamp = replyMainMessageTimestamp
                    self.files = files
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case message
                    case sender
                    case receiver
                    case dateTime = "date_time"
                    case timestamp
                    case replyMainMessageID = "reply_main_message_id"
                    case replyMainMessageTimestamp = "reply_main_message_timestamp"
                    case files
                }
            }

            public struct DeletedMessage: Decodable {
                /// The chat message's ID.
                public var id: String?
                /// The contents of the chat message.
                public var message: String?
                /// The chat message's sender.
                public var sender: String?
                /// The chat message's recipient. This field only returns if the chat session `type` value is `1:1`.
                public var receiver: String?
                /// The timestamp at which the chat message was sent.
                public var dateTime: Date?
                /// The message's timestamp, in milliseconds.
                public var timestamp: Int?
                /// The reply message's unique ID. The API only returns this value if the message is a reply message.
                public var replyMainMessageID: String?
                /// A timestamp of when the reply message was sent. The API only returns this value if the message is a reply message.
                public var replyMainMessageTimestamp: Int?
                /// Information about the chat files.
                public var files: [File]?

                public struct File: Decodable {
                    /// The chat file's unique ID.
                    public var fileID: String?
                    /// The chat file's name and its file extension.
                    public var fileName: String?
                    /// The chat file's size, in bytes.
                    public var fileSize: Int?
                    /// The URL at which to download the chat file.
                    public var downloadURL: String?

                    public init(fileID: String? = nil, fileName: String? = nil, fileSize: Int? = nil, downloadURL: String? = nil) {
                        self.fileID = fileID
                        self.fileName = fileName
                        self.fileSize = fileSize
                        self.downloadURL = downloadURL
                    }

                    private enum CodingKeys: String, CodingKey {
                        case fileID = "file_id"
                        case fileName = "file_name"
                        case fileSize = "file_size"
                        case downloadURL = "download_url"
                    }
                }

                public init(id: String? = nil, message: String? = nil, sender: String? = nil, receiver: String? = nil, dateTime: Date? = nil, timestamp: Int? = nil, replyMainMessageID: String? = nil, replyMainMessageTimestamp: Int? = nil, files: [File]? = nil) {
                    self.id = id
                    self.message = message
                    self.sender = sender
                    self.receiver = receiver
                    self.dateTime = dateTime
                    self.timestamp = timestamp
                    self.replyMainMessageID = replyMainMessageID
                    self.replyMainMessageTimestamp = replyMainMessageTimestamp
                    self.files = files
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case message
                    case sender
                    case receiver
                    case dateTime = "date_time"
                    case timestamp
                    case replyMainMessageID = "reply_main_message_id"
                    case replyMainMessageTimestamp = "reply_main_message_timestamp"
                    case files
                }
            }

            public init(from: NaiveDate? = nil, to: NaiveDate? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, messages: [Message]? = nil, editedMessages: [EditedMessage]? = nil, deletedMessages: [DeletedMessage]? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.messages = messages
                self.editedMessages = editedMessages
                self.deletedMessages = deletedMessages
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case messages
                case editedMessages = "edited_messages"
                case deletedMessages = "deleted_messages"
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeFields: IncludeFields?

            public enum IncludeFields: String, Codable, CaseIterable {
                case editedMessages = "edited_messages"
                case deletedMessages = "deleted_messages"
                case editedMessagesDeletedMessages = "edited_messages,deleted_messages"
            }

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil, includeFields: IncludeFields? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeFields = includeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeFields, forKey: "include_fields")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var sipTrunk: SipTrunk {
        SipTrunk(path: "/sip_trunk")
    }

    public struct SipTrunk {
        /// Path: `/sip_trunk`
        public let path: String
    }
}

extension Paths.SipTrunk {
    public var numbers: Numbers {
        Numbers(path: path + "/numbers")
    }

    public struct Numbers {
        /// Path: `/sip_trunk/numbers`
        public let path: String

        /// List SIP trunk numbers
        ///
        /// With SIP-connected audio, Zoom establishes a SIP trunk (a network connection specifically designed to make and deliver phone calls) over a direct and private connection between the customers network and the Zoom cloud. Meeting participants that dial into a meeting or have the meeting call them, and are On-Net from the perspective of the customers' IP telephony network, will be connected over this trunk rather than over the PSTN. <br><br>Use this API to list all the numbers that are configured for SIP Connected Audio in a Zoom Account.
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher account with SIP Connected Audio plan enabled.
        /// * The account must be a master account<br>
        /// **Scopes:** `sip_trunk:master`
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Total number of records returned.
            public var totalRecords: Int?
            public var phoneNumbers: [PhoneNumber]?

            public struct PhoneNumber: Decodable {
                /// Phone number
                public var number: String?
                /// Country ID (example: US)
                public var country: String?

                public init(number: String? = nil, country: String? = nil) {
                    self.number = number
                    self.country = country
                }
            }

            public init(totalRecords: Int? = nil, phoneNumbers: [PhoneNumber]? = nil) {
                self.totalRecords = totalRecords
                self.phoneNumbers = phoneNumbers
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case phoneNumbers = "phone_numbers"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID {
    public var sipTrunk: SipTrunk {
        SipTrunk(path: path + "/sip_trunk")
    }

    public struct SipTrunk {
        /// Path: `/accounts/{accountId}/sip_trunk`
        public let path: String
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/accounts/{accountId}/sip_trunk/settings`
        public let path: String

        /// Get SIP trunk configuration
        ///
        /// Use this API to get a SIP (Session Initiation Protocol) trunk configuration.
        /// 
        /// **Scopes:** `sip_trunk:master`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * The account making this API request must be a [Master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with the SIP Connected Audio plan. 
        /// * A Pro or a higher paid account with Master account option enabled.
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// SIP trunk configuration
        ///
        /// Information about the SIP trunk configuration.
        public struct GetResponse: Decodable {
            /// Whether to display the call-out country numbers provided by Zoom carrier partners in the account's list of available call-out numbers in the Zoom Web Portal and Zoom Client.
            public var isShowCalloutInternalNumber: Bool?
            /// The account's call-out countries display setting: 
            /// * `0`  [Display](https://support.zoom.us/hc/en-us/articles/200942859-Using-telephone-call-out) the Zoom-provided list of call-out countries in the account's list of available call-out countries. 
            /// * `1`  Do **not** display the Zoom-provided list of call-out countries in the user's account. 
            /// * `2`  Delete all Zoom-provided call-out countries and **only** display internal countries provided by carrier partners.
            public var showZoomProvidedCalloutCountries: Int?
            /// The account's Zoom-provided numbers display setting: 
            /// * `0`  Display the Zoom-provided numbers in the account's list of available call-out and call-in numbers in the Zoom Web Portal and Zoom Client. 
            /// * `1`  Display the Zoom-provided numbers in the Zoom Web Portal but the user must specify whether to use the numbers. 
            /// * `2`  Delete all Zoom-provided numbers and **only** use internal numbers provided by carrier partners.
            public var showZoomProvidedNumbers: Int?

            public init(isShowCalloutInternalNumber: Bool? = nil, showZoomProvidedCalloutCountries: Int? = nil, showZoomProvidedNumbers: Int? = nil) {
                self.isShowCalloutInternalNumber = isShowCalloutInternalNumber
                self.showZoomProvidedCalloutCountries = showZoomProvidedCalloutCountries
                self.showZoomProvidedNumbers = showZoomProvidedNumbers
            }

            private enum CodingKeys: String, CodingKey {
                case isShowCalloutInternalNumber = "show_callout_internal_number"
                case showZoomProvidedCalloutCountries = "show_zoom_provided_callout_countries"
                case showZoomProvidedNumbers = "show_zoom_provided_numbers"
            }
        }

        /// Assign SIP trunk configuration
        ///
        /// Use this API to copy the Session Initiation Protocol (SIP) Connected Audio configurations applied on the Master account and enable or disable those configurations on a subaccount.
        /// 
        /// With SIP-connected audio, Zoom establishes a [SIP trunk](https://en.wikipedia.org/wiki/SIP_trunking) (a network connection specifically designed to make and deliver phone calls) over a direct and private connection between the customers network and the Zoom cloud. Meeting participants that dial into a meeting or have the meeting call them, and are On-Net from the perspective of the customers' IP telephony network, will be connected over this trunk rather than over the PSTN.
        /// 
        /// **Scopes:** `sip_trunk:master`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Pro or a higher account with SIP Connected Audio plan enabled. 
        /// * A Master account owner
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// Assign or delete the SIP configuration:
            /// 
            /// * `true`  Assign the Master account's SIP configuration information to the subaccount.
            /// * `false`  Delete the subaccount's assigned SIP configuration.
            /// 
            /// If you do **not** query this parameter, the API will **not** modify the subaccount's configuration.
            public var enable: Bool?
            /// If the value of this option is set to `true`, the call-out numbers provided by the Zoom carrier partners will be displayed in the account's list of available call-out numbers in the Zoom Web Portal and Zoom Client.
            public var isShowCalloutInternalNumber: Bool?
            /// If the value of this option is set to `0`, the call-out countries list provided by Zoom will be [displayed](https://support.zoom.us/hc/en-us/articles/200942859-Using-telephone-call-out) in the account's list of available call-out countries. 
            /// 
            /// If the value of this option is set to `1`, the Zoom provided call-out countries will be hidden from the user's account.<br> 
            /// 
            /// If the value of this option is set to `2`, all Zoom provided countries will be deleted and only internal countries (provided by carrier partners) will be used.
            public var showZoomProvidedCalloutCountries: Int?
            /// If the value of this option is set to `0`, the numbers provided by Zoom will be displayed in the account's list of available call-out and call-in numbers in the Zoom Web Portal and Zoom Client. 
            /// 
            /// If the value of this option is set to `1`, the Zoom provided numbers will be shown in the Zoom Web Portal but will not be used unless specified by the user.<br> 
            /// 
            /// If the value of this option is set to `2`, all Zoom provided numbers will be deleted and only internal numbers (provided by carrier partners) will be used.
            public var showZoomProvidedNumbers: Int?

            public init(enable: Bool? = nil, isShowCalloutInternalNumber: Bool? = nil, showZoomProvidedCalloutCountries: Int? = nil, showZoomProvidedNumbers: Int? = nil) {
                self.enable = enable
                self.isShowCalloutInternalNumber = isShowCalloutInternalNumber
                self.showZoomProvidedCalloutCountries = showZoomProvidedCalloutCountries
                self.showZoomProvidedNumbers = showZoomProvidedNumbers
            }

            private enum CodingKeys: String, CodingKey {
                case enable
                case isShowCalloutInternalNumber = "show_callout_internal_number"
                case showZoomProvidedCalloutCountries = "show_zoom_provided_callout_countries"
                case showZoomProvidedNumbers = "show_zoom_provided_numbers"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk {
    public var numbers: Numbers {
        Numbers(path: path + "/numbers")
    }

    public struct Numbers {
        /// Path: `/accounts/{accountId}/sip_trunk/numbers`
        public let path: String

        /// Assign numbers
        ///
        /// With SIP-connected audio, Zoom establishes a SIP trunk (a network connection specifically designed to make and deliver phone calls) over a direct and private connection between the customers network and the Zoom cloud. Meeting participants that dial into a meeting or have the meeting call them, and are On-Net from the perspective of the customers' IP telephony network, will be connected over this trunk rather than over the PSTN. <br><br>Use this API to assign internal numbers to a sub account.
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher account with SIP Connected Audio plan enabled.
        /// * The account must be a master account<br>
        /// **Scopes:** `sip_trunk:master`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(phoneNumbers: [String]? = nil) -> Request<[String: AnyJSON]> {
            .post(path, body: ["phone_numbers": phoneNumbers])
        }

        /// Delete all numbers
        ///
        /// With SIP-connected audio, Zoom establishes a SIP trunk (a network connection specifically designed to make and deliver phone calls) over a direct and private connection between the customers network and the Zoom cloud. Meeting participants that dial into a meeting or have the meeting call them, and are On-Net from the perspective of the customers' IP telephony network, will be connected over this trunk rather than over the PSTN. <br><br>Use this API to delete all internal numbers assigned to a sub account.
        /// **Prerequisites:**<br>
        /// 
        /// * Pro or a higher account with SIP Connected Audio plan enabled.
        /// * The account must be a master account<br>
        /// **Scopes:** `sip_trunk:master`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk {
    public var trunks: Trunks {
        Trunks(path: path + "/trunks")
    }

    public struct Trunks {
        /// Path: `/accounts/{accountId}/sip_trunk/trunks`
        public let path: String

        /// List SIP trunks
        ///
        /// With SIP-connected audio, Zoom establishes a SIP trunk (a network connection specifically designed to make and deliver phone calls) over a direct and private connection between the customers network and the Zoom cloud. Meeting participants that dial into a meeting or have the meeting call them, and are On-Net from the perspective of the customers IP telephony network, will be connected over this trunk rather than over the PSTN.<br><br>
        /// Use this API to list all the SIP trunks assigned to a master account or a sub account of the master account. To retrieve SIP trunks assigned to a sub account, provide the account ID of the sub account in the `accountId` path parameter. To retrieve SIP trunks of a master account, provide `me` as the value of the `accountId` path parameter. <br><br> **Scope:** `sip_trunk:read:admin`
        /// <br><b>Prerequisites:</b><br>
        /// * The account must either be a master account or a sub account with [API Partner Plan](https://zoom.us/plan/api) and SIP Connected Audio Plan.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Total number of records returned.
            public var totalRecords: Int?
            public var sipTrunks: [SipTrunk]?

            public struct SipTrunk: Decodable {
                /// Unique identifier of the sip trunk.
                public var id: String?
                /// Name assigned to the SIP trunk.
                public var name: String?
                /// IP address or domain of the SIP trunk.
                public var sipServerAddress: String?
                /// DNIS of the SIP trunk.
                public var dnis: String?
                /// Prefix of the SIP Connected Audio phone number.
                public var numberPrefix: String?
                /// Outbound caller Id assigned to the trunk.
                public var outboundCallerID: String?

                public init(id: String? = nil, name: String? = nil, sipServerAddress: String? = nil, dnis: String? = nil, numberPrefix: String? = nil, outboundCallerID: String? = nil) {
                    self.id = id
                    self.name = name
                    self.sipServerAddress = sipServerAddress
                    self.dnis = dnis
                    self.numberPrefix = numberPrefix
                    self.outboundCallerID = outboundCallerID
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case sipServerAddress = "sip_server_address"
                    case dnis
                    case numberPrefix = "number_prefix"
                    case outboundCallerID = "outbound_caller_id"
                }
            }

            public init(totalRecords: Int? = nil, sipTrunks: [SipTrunk]? = nil) {
                self.totalRecords = totalRecords
                self.sipTrunks = sipTrunks
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case sipTrunks = "sip_trunks"
            }
        }

        /// Assign SIP trunks
        ///
        /// With SIP-connected audio, Zoom establishes a SIP trunk (a network connection specifically designed to make and deliver phone calls) over a direct and private connection between the customers network and the Zoom cloud. Meeting participants that dial into a meeting or have the meeting call them, and are On-Net from the perspective of the customers IP telephony network, will be connected over this trunk rather than over the PSTN.<br><br>Use this API to assign SIP trunk(s) that are available on a master account to a sub account. <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a master account with [API Partner Plan](https://zoom.us/plan/api) and SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public func post(sipTrunks: [PostRequest.SipTrunk]? = nil) -> Request<PostResponse> {
            .post(path, body: PostRequest(sipTrunks: sipTrunks))
        }

        public struct PostResponse: Decodable {
            public var sipTrunks: [SipTrunk]?

            public struct SipTrunk: Decodable {
                /// Unique identifier of the SIP trunk.
                public var id: String?
                /// Name of the SIP trunk.
                public var name: String?
                /// IP Address or domain of the SIP trunk.
                public var sipServerAddress: String?
                /// DNIS - identifier for the SIP trunk enabled account.
                public var dnis: String?
                /// If the value of this field is `"0"`, it means that all the calls will be routed through this special line. All other values indicate the prefix of the phone number.
                public var numberPrefix: String?

                public init(id: String? = nil, name: String? = nil, sipServerAddress: String? = nil, dnis: String? = nil, numberPrefix: String? = nil) {
                    self.id = id
                    self.name = name
                    self.sipServerAddress = sipServerAddress
                    self.dnis = dnis
                    self.numberPrefix = numberPrefix
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case sipServerAddress = "sip_server_address"
                    case dnis
                    case numberPrefix = "number_prefix"
                }
            }

            public init(sipTrunks: [SipTrunk]? = nil) {
                self.sipTrunks = sipTrunks
            }

            private enum CodingKeys: String, CodingKey {
                case sipTrunks = "sip_trunks"
            }
        }

        public struct PostRequest: Encodable {
            /// Array of one or more SIP Trunk objects.
            public var sipTrunks: [SipTrunk]?

            public struct SipTrunk: Encodable {
                /// Unique identifier of the SIP trunk that will be assigned to the sub account. The value of this field can be retrieved by listing the SIP Trunks of a master account using List SIP Trunks API.
                public var id: String?
                /// DNIS of the sub account. The prefix of the DNIS (i.e. the first five digits of the DNIS value) must match the DNIS prefix of the master account. To retrieve the DNIS prefix of a master account's SIP Trunk, use the List SIP Trunks API and refer to the first five digits in the `dnis` value. 
                /// 
                /// For example, if the DNIS of the master account is 1888812345, the DNIS of the sub account must comprise of "18888" + "random_number". The maximum allowed length of the DNIS is 8.
                public var dnis: String?
                /// Assign an outbound caller Id to the trunk.
                public var outboundCallerID: String?

                public init(id: String? = nil, dnis: String? = nil, outboundCallerID: String? = nil) {
                    self.id = id
                    self.dnis = dnis
                    self.outboundCallerID = outboundCallerID
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case dnis
                    case outboundCallerID = "outbound_caller_id"
                }
            }

            public init(sipTrunks: [SipTrunk]? = nil) {
                self.sipTrunks = sipTrunks
            }

            private enum CodingKeys: String, CodingKey {
                case sipTrunks = "sip_trunks"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk.Trunks {
    public func trunkID(_ trunkID: String) -> WithTrunkID {
        WithTrunkID(path: "\(path)/\(trunkID)")
    }

    public struct WithTrunkID {
        /// Path: `/accounts/{accountId}/sip_trunk/trunks/{trunkId}`
        public let path: String

        /// Delete a SIP trunk
        ///
        /// Use this API to remove existing SIP trunk of a sub account.<br>
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a master account with [API Partner Plan](https://zoom.us/plan/api) and SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk {
    public var calloutCountries: CalloutCountries {
        CalloutCountries(path: path + "/callout_countries")
    }

    public struct CalloutCountries {
        /// Path: `/accounts/{accountId}/sip_trunk/callout_countries`
        public let path: String

        /// List internal call-out countries
        ///
        /// Retrieve the list of internal [call-out](https://support.zoom.us/hc/en-us/articles/200942859-How-To-Use-Telephone-Call-Out-) countries of a master account or a sub account. To list call-out enabled countries of a sub account, provide the account ID of the sub account in the `accountId` path parameter. To list call-out enabled countries of a master account, provide `me` as the value of the `accountId` path parameter.
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The total number of records returned.
            public var totalRecords: Int?
            public var calloutCountries: [CalloutCountry]?

            public struct CalloutCountry: Decodable {
                /// Two letter country Id.
                public var id: String?
                /// Name of the country.
                public var name: String?
                /// Country code.
                public var code: String?

                public init(id: String? = nil, name: String? = nil, code: String? = nil) {
                    self.id = id
                    self.name = name
                    self.code = code
                }
            }

            public init(totalRecords: Int? = nil, calloutCountries: [CalloutCountry]? = nil) {
                self.totalRecords = totalRecords
                self.calloutCountries = calloutCountries
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case calloutCountries = "callout_countries"
            }
        }

        /// Add internal call-out countries
        ///
        /// Specify the list of [call-out](https://support.zoom.us/hc/en-us/articles/200942859-How-To-Use-Telephone-Call-Out-) countries for a master account or a sub account. To add call-out enabled countries to a sub account, provide the account ID of the sub account in the `accountId` path parameter. To add call-out enabled countries to a master account, provide `me` as the value of the `accountId` path parameter.
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public func post(calloutCountries: [PostRequest.CalloutCountry]) -> Request<PostResponse> {
            .post(path, body: PostRequest(calloutCountries: calloutCountries))
        }

        public struct PostResponse: Decodable {
            /// List of Call-out countries.
            public var calloutCountries: [CalloutCountry]?

            public struct CalloutCountry: Decodable {
                /// Country ID.
                public var id: String?
                /// Name of the country.
                public var name: String?
                /// Country code for Phone number.
                public var code: String?

                public init(id: String? = nil, name: String? = nil, code: String? = nil) {
                    self.id = id
                    self.name = name
                    self.code = code
                }
            }

            public init(calloutCountries: [CalloutCountry]? = nil) {
                self.calloutCountries = calloutCountries
            }

            private enum CodingKeys: String, CodingKey {
                case calloutCountries = "callout_countries"
            }
        }

        public struct PostRequest: Encodable {
            /// List of callout countries.
            public var calloutCountries: [CalloutCountry]

            public struct CalloutCountry: Encodable {
                /// Two letter country code of the  call-out country.
                public var id: String

                public init(id: String) {
                    self.id = id
                }
            }

            public init(calloutCountries: [CalloutCountry]) {
                self.calloutCountries = calloutCountries
            }

            private enum CodingKeys: String, CodingKey {
                case calloutCountries = "callout_countries"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk.CalloutCountries {
    public func countryID(_ countryID: String) -> WithCountryID {
        WithCountryID(path: "\(path)/\(countryID)")
    }

    public struct WithCountryID {
        /// Path: `/accounts/{accountId}/sip_trunk/callout_countries/{countryId}`
        public let path: String

        /// Delete internal call-out country
        ///
        /// Delete a previously assigned [call-out](https://support.zoom.us/hc/en-us/articles/200942859-How-To-Use-Telephone-Call-Out-) country from a master account or a sub account. To remove call-out country from a sub account, provide the account ID of the sub account in the `accountId` path parameter. To remove call-out country from a master account, provide `me` as the value of the `accountId` path parameter.
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk {
    public var internalNumbers: InternalNumbers {
        InternalNumbers(path: path + "/internal_numbers")
    }

    public struct InternalNumbers {
        /// Path: `/accounts/{accountId}/sip_trunk/internal_numbers`
        public let path: String

        /// List internal numbers
        ///
        /// This API allows a master account with SIP Connected Audio plan to list internal phone numbers (i.e., numbers that are not provided by Zoom but are owned by the organization consuming the API) assigned to a master account or a sub account.<br><br>To list internal numbers of a sub account, provide the account ID of the sub account in the `accountId` path parameter. To list internal numbers of a  master account, provide `me` as the value of the `accountId` path parameter.
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public func get(pageSize: Int? = nil, nextPageToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, nextPageToken))
        }

        public struct GetResponse: Decodable {
            /// The number of records that you specified to get in the response per page.
            public var pageSize: Int?
            /// The total number of records returned.
            public var totalRecords: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var internalNumbers: [InternalNumber]?

            public struct InternalNumber: Decodable {
                /// Phone number in E164 format.
                public var number: String
                /// Phone number with display format. For instance, if the value in the number field is `+1888888000`, the value of this field could be `+1 888 888 000`.
                public var displayNumber: String
                /// Two letter country code of the country.
                public var country: String
                /// Specify whether you want this number to be visible (in Zoom Client and Zoom Portal) to the account users or not. The value could be one of the following:<br>
                /// * `true`: Make the number visible. <br>
                /// * `false`: Hide the number.
                public var isVisible: Bool?
                /// Specify whether this number can be used by users to join a meeting or not. <br>
                /// * `true` : This number can be used to join a meeting. <br>
                /// *  `false`: This number can not be used to join a meeting. 
                /// 
                /// Note that if the value of `visible` field is set to `true`, the value of this field will always be `true`.
                public var allowJoin: Bool?
                /// Type of phone number. <br>
                /// The value can be one of the following:<br>
                /// * `0` : toll <br>
                /// * `1` : tollfree
                public var type: Int
                /// A short description for the phone number.
                public var labels: String
                /// The language in which to display the phone number: 
                /// * `en-GB`  English (UK) 
                /// * `en-US`  English (USA) 
                /// * `ar`  Arabic 
                /// * `da-DK`  Danish (Denmark) 
                /// * `de-DE`  German 
                /// * `es-ES`  Spanish 
                /// * `es-MX`  Spanish (Mexico) 
                /// * `fr-CA`  French (Canada) 
                /// * `fr-FR`  French 
                /// * `it-IT`  Italian 
                /// * `ja`  Japanese 
                /// * `ko-KR`  Korean 
                /// * `nl-NL`  Dutch (Netherlands) 
                /// * `pt-BR`  Portuguese (Brazil) 
                /// * `pt-PT`  Portuguese 
                /// * `ru`  Russian 
                /// * `zh-CN`  Chinese (PRC) 
                /// * `zh-HK`  Chinese (Hong Kong)
                public var languages: Languages
                /// Control whether the number can be used to attend 3rd party meetings.
                public var allowForExternalMeetings: Bool?

                /// The language in which to display the phone number: 
                /// * `en-GB`  English (UK) 
                /// * `en-US`  English (USA) 
                /// * `ar`  Arabic 
                /// * `da-DK`  Danish (Denmark) 
                /// * `de-DE`  German 
                /// * `es-ES`  Spanish 
                /// * `es-MX`  Spanish (Mexico) 
                /// * `fr-CA`  French (Canada) 
                /// * `fr-FR`  French 
                /// * `it-IT`  Italian 
                /// * `ja`  Japanese 
                /// * `ko-KR`  Korean 
                /// * `nl-NL`  Dutch (Netherlands) 
                /// * `pt-BR`  Portuguese (Brazil) 
                /// * `pt-PT`  Portuguese 
                /// * `ru`  Russian 
                /// * `zh-CN`  Chinese (PRC) 
                /// * `zh-HK`  Chinese (Hong Kong)
                public enum Languages: String, Codable, CaseIterable {
                    case enGB = "en-GB"
                    case enUS = "en-US"
                    case ar
                    case daDK = "da-DK"
                    case deDE = "de-DE"
                    case esES = "es-ES"
                    case esMX = "es-MX"
                    case frCA = "fr-CA"
                    case frFR = "fr-FR"
                    case itIT = "it-IT"
                    case ja
                    case koKR = "ko-KR"
                    case nlNL = "nl-NL"
                    case ptBR = "pt-BR"
                    case ptPT = "pt-PT"
                    case ru
                    case zhCN = "zh-CN"
                    case zhHK = "zh-HK"
                }

                public init(number: String, displayNumber: String, country: String, isVisible: Bool? = nil, allowJoin: Bool? = nil, type: Int, labels: String, languages: Languages, allowForExternalMeetings: Bool? = nil) {
                    self.number = number
                    self.displayNumber = displayNumber
                    self.country = country
                    self.isVisible = isVisible
                    self.allowJoin = allowJoin
                    self.type = type
                    self.labels = labels
                    self.languages = languages
                    self.allowForExternalMeetings = allowForExternalMeetings
                }

                private enum CodingKeys: String, CodingKey {
                    case number
                    case displayNumber = "display_number"
                    case country
                    case isVisible = "visible"
                    case allowJoin = "allow_join"
                    case type
                    case labels
                    case languages
                    case allowForExternalMeetings = "allow_for_external_meetings"
                }
            }

            public init(pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, internalNumbers: [InternalNumber]? = nil) {
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.nextPageToken = nextPageToken
                self.internalNumbers = internalNumbers
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case nextPageToken = "next_page_token"
                case internalNumbers = "internal_numbers"
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ nextPageToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(nextPageToken, forKey: "next_page_token")
            return encoder.items
        }

        /// Add internal numbers
        ///
        /// This API allows a master account with SIP Connected Audio plan to assign internal phone numbers (i.e., numbers that are not provided by Zoom but are owned by the organization consuming the API) to a master account or a sub account.<br><br>To add internal numbers to a sub account, provide the account ID of the sub account in the `accountId` path parameter. To add internal numbers to a master account, provide `me` as the value of the `accountId` path parameter.
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public func post(internalNumbers: [PostRequest.InternalNumber]? = nil) -> Request<PostResponse> {
            .post(path, body: PostRequest(internalNumbers: internalNumbers))
        }

        public struct PostResponse: Decodable {
            public var internalNumbers: [InternalNumber]?

            public struct InternalNumber: Decodable {
                /// Phone number in E164 format.
                public var number: String
                /// Phone number with display format. For instance, if the value in the number field is `+1888888000`, the value of this field could be `+1 888 888 000`.
                public var displayNumber: String
                /// Two letter country code of the country.
                public var country: String
                /// Specify whether you want this number to be visible (in Zoom Client and Zoom Portal) to the account users or not. The value could be one of the following:<br>
                /// * `true`: Make the number visible. <br>
                /// * `false`: Hide the number.
                public var isVisible: Bool?
                /// Specify whether this number can be used by users to join a meeting or not. <br>
                /// * `true` : This number can be used to join a meeting. <br>
                /// *  `false`: This number can not be used to join a meeting. 
                /// 
                /// Note that if the value of `visible` field is set to `true`, the value of this field will always be `true`.
                public var allowJoin: Bool?
                /// Type of phone number. <br>
                /// The value can be one of the following:<br>
                /// * `0` : toll <br>
                /// * `1` : tollfree
                public var type: Int
                /// A short description for the phone number.
                public var labels: String
                /// The language in which to display the phone number: 
                /// * `en-GB`  English (UK) 
                /// * `en-US`  English (USA) 
                /// * `ar`  Arabic 
                /// * `da-DK`  Danish (Denmark) 
                /// * `de-DE`  German 
                /// * `es-ES`  Spanish 
                /// * `es-MX`  Spanish (Mexico) 
                /// * `fr-CA`  French (Canada) 
                /// * `fr-FR`  French 
                /// * `it-IT`  Italian 
                /// * `ja`  Japanese 
                /// * `ko-KR`  Korean 
                /// * `nl-NL`  Dutch (Netherlands) 
                /// * `pt-BR`  Portuguese (Brazil) 
                /// * `pt-PT`  Portuguese 
                /// * `ru`  Russian 
                /// * `zh-CN`  Chinese (PRC) 
                /// * `zh-HK`  Chinese (Hong Kong)
                public var languages: Languages
                /// Unique identifier of the internal number.
                public var id: String?
                /// Control whether the number can be used to attend 3rd party meetings.
                public var allowForExternalMeetings: Bool?

                /// The language in which to display the phone number: 
                /// * `en-GB`  English (UK) 
                /// * `en-US`  English (USA) 
                /// * `ar`  Arabic 
                /// * `da-DK`  Danish (Denmark) 
                /// * `de-DE`  German 
                /// * `es-ES`  Spanish 
                /// * `es-MX`  Spanish (Mexico) 
                /// * `fr-CA`  French (Canada) 
                /// * `fr-FR`  French 
                /// * `it-IT`  Italian 
                /// * `ja`  Japanese 
                /// * `ko-KR`  Korean 
                /// * `nl-NL`  Dutch (Netherlands) 
                /// * `pt-BR`  Portuguese (Brazil) 
                /// * `pt-PT`  Portuguese 
                /// * `ru`  Russian 
                /// * `zh-CN`  Chinese (PRC) 
                /// * `zh-HK`  Chinese (Hong Kong)
                public enum Languages: String, Codable, CaseIterable {
                    case enGB = "en-GB"
                    case enUS = "en-US"
                    case ar
                    case daDK = "da-DK"
                    case deDE = "de-DE"
                    case esES = "es-ES"
                    case esMX = "es-MX"
                    case frCA = "fr-CA"
                    case frFR = "fr-FR"
                    case itIT = "it-IT"
                    case ja
                    case koKR = "ko-KR"
                    case nlNL = "nl-NL"
                    case ptBR = "pt-BR"
                    case ptPT = "pt-PT"
                    case ru
                    case zhCN = "zh-CN"
                    case zhHK = "zh-HK"
                }

                public init(number: String, displayNumber: String, country: String, isVisible: Bool? = nil, allowJoin: Bool? = nil, type: Int, labels: String, languages: Languages, id: String? = nil, allowForExternalMeetings: Bool? = nil) {
                    self.number = number
                    self.displayNumber = displayNumber
                    self.country = country
                    self.isVisible = isVisible
                    self.allowJoin = allowJoin
                    self.type = type
                    self.labels = labels
                    self.languages = languages
                    self.id = id
                    self.allowForExternalMeetings = allowForExternalMeetings
                }

                private enum CodingKeys: String, CodingKey {
                    case number
                    case displayNumber = "display_number"
                    case country
                    case isVisible = "visible"
                    case allowJoin = "allow_join"
                    case type
                    case labels
                    case languages
                    case id
                    case allowForExternalMeetings = "allow_for_external_meetings"
                }
            }

            public init(internalNumbers: [InternalNumber]? = nil) {
                self.internalNumbers = internalNumbers
            }

            private enum CodingKeys: String, CodingKey {
                case internalNumbers = "internal_numbers"
            }
        }

        public struct PostRequest: Encodable {
            public var internalNumbers: [InternalNumber]?

            public struct InternalNumber: Encodable {
                /// Phone number in E164 format.
                public var number: String
                /// Phone number with display format. For instance, if the value in the number field is `+1888888000`, the value of this field could be `+1 888 888 000`.
                public var displayNumber: String
                /// Two letter country code of the country.
                public var country: String
                /// Specify whether you want this number to be visible (in Zoom Client and Zoom Portal) to the account users or not. The value could be one of the following:<br>
                /// * `true`: Make the number visible. <br>
                /// * `false`: Hide the number.
                public var isVisible: Bool?
                /// Specify whether this number can be used by users to join a meeting or not. <br>
                /// * `true` : This number can be used to join a meeting. <br>
                /// *  `false`: This number can not be used to join a meeting. 
                /// 
                /// Note that if the value of `visible` field is set to `true`, the value of this field will always be `true`.
                public var allowJoin: Bool?
                /// Control whether the number can be used to attend 3rd party meetings.
                public var allowForExternalMeetings: Bool?
                /// Type of phone number. <br>
                /// The value can be one of the following:<br>
                /// * `0` : toll <br>
                /// * `1` : tollfree
                public var type: Int
                /// A short description for the phone number.
                public var labels: String
                /// The language in which to display the phone number: 
                /// * `en-GB`  English (UK) 
                /// * `en-US`  English (USA) 
                /// * `ar`  Arabic 
                /// * `da-DK`  Danish (Denmark) 
                /// * `de-DE`  German 
                /// * `es-ES`  Spanish 
                /// * `es-MX`  Spanish (Mexico) 
                /// * `fr-CA`  French (Canada) 
                /// * `fr-FR`  French 
                /// * `it-IT`  Italian 
                /// * `ja`  Japanese 
                /// * `ko-KR`  Korean 
                /// * `nl-NL`  Dutch (Netherlands) 
                /// * `pt-BR`  Portuguese (Brazil) 
                /// * `pt-PT`  Portuguese 
                /// * `ru`  Russian 
                /// * `zh-CN`  Chinese (PRC) 
                /// * `zh-HK`  Chinese (Hong Kong)
                public var languages: Languages

                /// The language in which to display the phone number: 
                /// * `en-GB`  English (UK) 
                /// * `en-US`  English (USA) 
                /// * `ar`  Arabic 
                /// * `da-DK`  Danish (Denmark) 
                /// * `de-DE`  German 
                /// * `es-ES`  Spanish 
                /// * `es-MX`  Spanish (Mexico) 
                /// * `fr-CA`  French (Canada) 
                /// * `fr-FR`  French 
                /// * `it-IT`  Italian 
                /// * `ja`  Japanese 
                /// * `ko-KR`  Korean 
                /// * `nl-NL`  Dutch (Netherlands) 
                /// * `pt-BR`  Portuguese (Brazil) 
                /// * `pt-PT`  Portuguese 
                /// * `ru`  Russian 
                /// * `zh-CN`  Chinese (PRC) 
                /// * `zh-HK`  Chinese (Hong Kong)
                public enum Languages: String, Codable, CaseIterable {
                    case enGB = "en-GB"
                    case enUS = "en-US"
                    case ar
                    case daDK = "da-DK"
                    case deDE = "de-DE"
                    case esES = "es-ES"
                    case esMX = "es-MX"
                    case frCA = "fr-CA"
                    case frFR = "fr-FR"
                    case itIT = "it-IT"
                    case ja
                    case koKR = "ko-KR"
                    case nlNL = "nl-NL"
                    case ptBR = "pt-BR"
                    case ptPT = "pt-PT"
                    case ru
                    case zhCN = "zh-CN"
                    case zhHK = "zh-HK"
                }

                public init(number: String, displayNumber: String, country: String, isVisible: Bool? = nil, allowJoin: Bool? = nil, allowForExternalMeetings: Bool? = nil, type: Int, labels: String, languages: Languages) {
                    self.number = number
                    self.displayNumber = displayNumber
                    self.country = country
                    self.isVisible = isVisible
                    self.allowJoin = allowJoin
                    self.allowForExternalMeetings = allowForExternalMeetings
                    self.type = type
                    self.labels = labels
                    self.languages = languages
                }

                private enum CodingKeys: String, CodingKey {
                    case number
                    case displayNumber = "display_number"
                    case country
                    case isVisible = "visible"
                    case allowJoin = "allow_join"
                    case allowForExternalMeetings = "allow_for_external_meetings"
                    case type
                    case labels
                    case languages
                }
            }

            public init(internalNumbers: [InternalNumber]? = nil) {
                self.internalNumbers = internalNumbers
            }

            private enum CodingKeys: String, CodingKey {
                case internalNumbers = "internal_numbers"
            }
        }
    }
}

extension Paths.Accounts.WithAccountID.SipTrunk.InternalNumbers {
    public func numberID(_ numberID: String) -> WithNumberID {
        WithNumberID(path: "\(path)/\(numberID)")
    }

    public struct WithNumberID {
        /// Path: `/accounts/{accountId}/sip_trunk/internal_numbers/{numberId}`
        public let path: String

        /// Delete an internal number
        ///
        /// This API allows a master account with SIP Connected Audio plan to delete a previously assigned internal phone number from a master account or a sub account.<br><br>To delete an internal number from a sub account, provide the account ID of the sub account in the `accountId` path parameter. To delete an internal number from a master account, provide `me` as the value of the `accountId` path parameter.
        /// <br><b>Prerequisites:</b><br>
        /// * The account making this API request must be a [master account](https://marketplace.zoom.us/docs/api-reference/master-account-apis) with SIP Connected Audio Plan.<br><br>
        /// **Scope:** `sip_trunk:master`
        public var delete: Request<[String: AnyJSON]> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var sipPhones: SipPhones {
        SipPhones(path: "/sip_phones")
    }

    public struct SipPhones {
        /// Path: `/sip_phones`
        public let path: String

        /// List SIP phones
        ///
        /// Zooms Phone System Integration (PSI), also referred as SIP phones, enables an organization to leverage the Zoom client to complete a softphone registration to supported premise based PBX system. End users will have the ability to have softphone functionality within a single client while maintaining a comparable interface to Zoom Phone. Use this API to list SIP phones on an account.<br><br>
        /// **Prerequisites**:
        /// * Currently only supported on Cisco and Avaya PBX systems. 
        /// * User must enable SIP Phone Integration by contacting the [Sales](https://zoom.us/contactsales) team.<br> **Scope:** `sip_phone:read:admin`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The page number of the current results.
            public var pageNumber: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?
            /// SIP phones object.
            public var phones: [Phone]?
            public var nextPageToken: String?

            public struct Phone: Decodable {
                /// Unique Identifier of the SIP Phone.
                public var id: String?
                /// The email address of the user to associate with the SIP Phone. Can add `.win`, `.mac`, `.android`, `.ipad`, `.iphone`, `.linux`, `.pc`, `.mobile`, `.pad` at the end of the email (for example, `example@example.com.mac`) to add accounts for different platforms for the same user.
                public var userEmail: String?
                /// The name or IP address of your providers SIP domain.
                public var domain: String?
                /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
                public var registerServer: String?
                /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
                public var transportProtocol: TransportProtocol?
                /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server, or empty.
                public var proxyServer: String?
                /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
                public var registerServer2: String?
                /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
                public var transportProtocol2: TransportProtocol2?
                /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server, or empty.
                public var proxyServer2: String?
                /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
                public var registerServer3: String?
                /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
                public var transportProtocol3: TransportProtocol3?
                /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server, or empty.
                public var proxyServer3: String?
                /// The number of minutes after which the SIP registration of the Zoom client user will expire, and the client will auto register to the SIP server.
                public var registrationExpireTime: Int?
                /// The phone number associated with the user in the SIP account.
                public var userName: String?
                /// The password generated for the user in the SIP account.
                public var password: String?
                /// Authorization name of the user  registered for SIP Phone.
                public var authorizationName: String?
                /// The number to dial for checking voicemail.
                public var voiceMail: String?

                /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
                public enum TransportProtocol: String, Codable, CaseIterable {
                    case udp = "UDP"
                    case tcp = "TCP"
                    case tls = "TLS"
                    case auto = "AUTO"
                }

                /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
                public enum TransportProtocol2: String, Codable, CaseIterable {
                    case udp = "UDP"
                    case tcp = "TCP"
                    case tls = "TLS"
                    case auto = "AUTO"
                }

                /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
                public enum TransportProtocol3: String, Codable, CaseIterable {
                    case udp = "UDP"
                    case tcp = "TCP"
                    case tls = "TLS"
                    case auto = "AUTO"
                }

                public init(id: String? = nil, userEmail: String? = nil, domain: String? = nil, registerServer: String? = nil, transportProtocol: TransportProtocol? = nil, proxyServer: String? = nil, registerServer2: String? = nil, transportProtocol2: TransportProtocol2? = nil, proxyServer2: String? = nil, registerServer3: String? = nil, transportProtocol3: TransportProtocol3? = nil, proxyServer3: String? = nil, registrationExpireTime: Int? = nil, userName: String? = nil, password: String? = nil, authorizationName: String? = nil, voiceMail: String? = nil) {
                    self.id = id
                    self.userEmail = userEmail
                    self.domain = domain
                    self.registerServer = registerServer
                    self.transportProtocol = transportProtocol
                    self.proxyServer = proxyServer
                    self.registerServer2 = registerServer2
                    self.transportProtocol2 = transportProtocol2
                    self.proxyServer2 = proxyServer2
                    self.registerServer3 = registerServer3
                    self.transportProtocol3 = transportProtocol3
                    self.proxyServer3 = proxyServer3
                    self.registrationExpireTime = registrationExpireTime
                    self.userName = userName
                    self.password = password
                    self.authorizationName = authorizationName
                    self.voiceMail = voiceMail
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userEmail = "user_email"
                    case domain
                    case registerServer = "register_server"
                    case transportProtocol = "transport_protocol"
                    case proxyServer = "proxy_server"
                    case registerServer2 = "register_server2"
                    case transportProtocol2 = "transport_protocol2"
                    case proxyServer2 = "proxy_server2"
                    case registerServer3 = "register_server3"
                    case transportProtocol3 = "transport_protocol3"
                    case proxyServer3 = "proxy_server3"
                    case registrationExpireTime = "registration_expire_time"
                    case userName = "user_name"
                    case password
                    case authorizationName = "authorization_name"
                    case voiceMail = "voice_mail"
                }
            }

            public init(pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, phones: [Phone]? = nil, nextPageToken: String? = nil) {
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.phones = phones
                self.nextPageToken = nextPageToken
            }

            private enum CodingKeys: String, CodingKey {
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case phones
                case nextPageToken = "next_page_token"
            }
        }

        public struct GetParameters {
            public var pageNumber: Int?
            public var searchKey: String?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(pageNumber: Int? = nil, searchKey: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.pageNumber = pageNumber
                self.searchKey = searchKey
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(searchKey, forKey: "search_key")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Enable SIP phone
        ///
        /// Zooms Phone System Integration (PSI), also referred as SIP phones, enables an organization to leverage the Zoom client to complete a softphone registration to supported premise based PBX system. End users will have the ability to have softphone functionality within a single client while maintaining a comparable interface to Zoom Phone. Use this API to enable a user to use SIP phone.<br><br>
        /// **Prerequisites**:
        /// * Currently only supported on Cisco and Avaya PBX systems. 
        /// * The account owner or account admin must first enable SIP Phone Integration by contacting the [Sales](https://zoom.us/contactsales) team.<br> **Scope:** `sip_phone:write:admin`
        /// <br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest? = nil) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// The name or IP address of your providers SIP domain. (example: CDC.WEB).
            public var domain: String
            /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
            public var registerServer: String
            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public var transportProtocol: TransportProtocol?
            /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.
            public var proxyServer: String
            /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
            public var registerServer2: String?
            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public var transportProtocol2: TransportProtocol2?
            /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server, or empty.
            public var proxyServer2: String?
            /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
            public var registerServer3: String?
            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public var transportProtocol3: TransportProtocol3?
            /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server, or empty.
            public var proxyServer3: String?
            /// The number of minutes after which the SIP registration of the Zoom client user will expire, and the client will auto register to the SIP server.
            public var registrationExpireTime: Int?
            /// The phone number associated with the user in the SIP account.
            public var userName: String
            /// The password generated for the user in the SIP account.
            public var password: String
            /// Authorization name of the user registered for SIP Phone.
            public var authorizationName: String
            /// The email address of the user to associate with the SIP Phone. Can add `.win`, `.mac`, `.android`, `.ipad`, `.iphone`, `.linux`, `.pc`, `.mobile`, `.pad` at the end of the email (for example, `example@example.com.mac`) to add accounts for different platforms for the same user.
            public var userEmail: String
            /// The number to dial for checking voicemail.
            public var voiceMail: String

            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public enum TransportProtocol: String, Codable, CaseIterable {
                case udp = "UDP"
                case tcp = "TCP"
                case tls = "TLS"
                case auto = "AUTO"
            }

            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public enum TransportProtocol2: String, Codable, CaseIterable {
                case udp = "UDP"
                case tcp = "TCP"
                case tls = "TLS"
                case auto = "AUTO"
            }

            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public enum TransportProtocol3: String, Codable, CaseIterable {
                case udp = "UDP"
                case tcp = "TCP"
                case tls = "TLS"
                case auto = "AUTO"
            }

            public init(domain: String, registerServer: String, transportProtocol: TransportProtocol? = nil, proxyServer: String, registerServer2: String? = nil, transportProtocol2: TransportProtocol2? = nil, proxyServer2: String? = nil, registerServer3: String? = nil, transportProtocol3: TransportProtocol3? = nil, proxyServer3: String? = nil, registrationExpireTime: Int? = nil, userName: String, password: String, authorizationName: String, userEmail: String, voiceMail: String) {
                self.domain = domain
                self.registerServer = registerServer
                self.transportProtocol = transportProtocol
                self.proxyServer = proxyServer
                self.registerServer2 = registerServer2
                self.transportProtocol2 = transportProtocol2
                self.proxyServer2 = proxyServer2
                self.registerServer3 = registerServer3
                self.transportProtocol3 = transportProtocol3
                self.proxyServer3 = proxyServer3
                self.registrationExpireTime = registrationExpireTime
                self.userName = userName
                self.password = password
                self.authorizationName = authorizationName
                self.userEmail = userEmail
                self.voiceMail = voiceMail
            }

            private enum CodingKeys: String, CodingKey {
                case domain
                case registerServer = "register_server"
                case transportProtocol = "transport_protocol"
                case proxyServer = "proxy_server"
                case registerServer2 = "register_server2"
                case transportProtocol2 = "transport_protocol2"
                case proxyServer2 = "proxy_server2"
                case registerServer3 = "register_server3"
                case transportProtocol3 = "transport_protocol3"
                case proxyServer3 = "proxy_server3"
                case registrationExpireTime = "registration_expire_time"
                case userName = "user_name"
                case password
                case authorizationName = "authorization_name"
                case userEmail = "user_email"
                case voiceMail = "voice_mail"
            }
        }
    }
}

extension Paths.SipPhones {
    public func phoneID(_ phoneID: String) -> WithPhoneID {
        WithPhoneID(path: "\(path)/\(phoneID)")
    }

    public struct WithPhoneID {
        /// Path: `/sip_phones/{phoneId}`
        public let path: String

        /// Update SIP phone
        ///
        /// Zooms Phone System Integration (PSI), also referred as SIP phones, enables an organization to leverage the Zoom client to complete a softphone registration to supported premise based PBX system. End users will have the ability to have softphone functionality within a single client while maintaining a comparable interface to Zoom Phone. Use this API to update information of a specific SIP Phone on a Zoom account.<br><br>
        /// **Prerequisites**:
        /// * Currently only supported on Cisco and Avaya PBX systems. 
        /// * The account owner or account admin must first enable SIP Phone Integration by contacting the [Sales](https://zoom.us/contactsales) team.<br> **Scope:** `sip_phone:write:admin`
        /// <br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest? = nil) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The name or IP address of your providers SIP domain. (example: CDC.WEB).
            public var domain: String
            /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
            public var registerServer: String
            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public var transportProtocol: TransportProtocol?
            /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.
            public var proxyServer: String
            /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
            public var registerServer2: String
            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public var transportProtocol2: TransportProtocol2?
            /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.
            public var proxyServer2: String
            /// IP address of the server that accepts REGISTER requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address.
            public var registerServer3: String
            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public var transportProtocol3: TransportProtocol3?
            /// IP address of the proxy server for SIP requests. Note that if you are using the UDP transport protocol, the default port is 5060. If you are using UDP with a different port number, that port number must be included with the IP address. If you are not using a proxy server, this value can be the same as the Register Server.
            public var proxyServer3: String
            /// The number of minutes after which the SIP registration of the Zoom client user will expire, and the client will auto register to the SIP server.
            public var registrationExpireTime: Int?
            /// The phone number associated with the user in the SIP account.
            public var userName: String
            /// The password generated for the user in the SIP account.
            public var password: String
            /// Authorization name of the user  registered for SIP Phone.
            public var authorizationName: String
            /// The number to dial for checking voicemail.
            public var voiceMail: String

            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public enum TransportProtocol: String, Codable, CaseIterable {
                case udp = "UDP"
                case tcp = "TCP"
                case tls = "TLS"
                case auto = "AUTO"
            }

            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public enum TransportProtocol2: String, Codable, CaseIterable {
                case udp = "UDP"
                case tcp = "TCP"
                case tls = "TLS"
                case auto = "AUTO"
            }

            /// Protocols supported by the SIP provider.<br> The value must be either `UDP`, `TCP`, `TLS`, `AUTO`.
            public enum TransportProtocol3: String, Codable, CaseIterable {
                case udp = "UDP"
                case tcp = "TCP"
                case tls = "TLS"
                case auto = "AUTO"
            }

            public init(domain: String, registerServer: String, transportProtocol: TransportProtocol? = nil, proxyServer: String, registerServer2: String, transportProtocol2: TransportProtocol2? = nil, proxyServer2: String, registerServer3: String, transportProtocol3: TransportProtocol3? = nil, proxyServer3: String, registrationExpireTime: Int? = nil, userName: String, password: String, authorizationName: String, voiceMail: String) {
                self.domain = domain
                self.registerServer = registerServer
                self.transportProtocol = transportProtocol
                self.proxyServer = proxyServer
                self.registerServer2 = registerServer2
                self.transportProtocol2 = transportProtocol2
                self.proxyServer2 = proxyServer2
                self.registerServer3 = registerServer3
                self.transportProtocol3 = transportProtocol3
                self.proxyServer3 = proxyServer3
                self.registrationExpireTime = registrationExpireTime
                self.userName = userName
                self.password = password
                self.authorizationName = authorizationName
                self.voiceMail = voiceMail
            }

            private enum CodingKeys: String, CodingKey {
                case domain
                case registerServer = "register_server"
                case transportProtocol = "transport_protocol"
                case proxyServer = "proxy_server"
                case registerServer2 = "register_server2"
                case transportProtocol2 = "transport_protocol2"
                case proxyServer2 = "proxy_server2"
                case registerServer3 = "register_server3"
                case transportProtocol3 = "transport_protocol3"
                case proxyServer3 = "proxy_server3"
                case registrationExpireTime = "registration_expire_time"
                case userName = "user_name"
                case password
                case authorizationName = "authorization_name"
                case voiceMail = "voice_mail"
            }
        }

        /// Delete SIP phone
        ///
        /// Use this API to delete a Zoom account's SIP phone. 
        /// 
        ///  **Scopes:** `sip_phone:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites**: 
        /// * Currently only supported on Cisco and Avaya PBX systems. 
        /// * The user must enable **SIP Phone Integration** by contacting the [Zoom Sales](https://zoom.us/contactsales) team.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var meetings: Meetings {
        Meetings(path: path + "/meetings")
    }

    public struct Meetings {
        /// Path: `/users/{userId}/meetings`
        public let path: String

        /// List meetings
        ///
        /// List all the meetings that were scheduled for a user (meeting host). For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// This API **only** supports scheduled meetings. This API does not return information about instant meetings.
        /// 
        /// **Scopes:** `meeting:read:admin`, `meeting:read`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?
            public var pageNumber: String?

            public enum `Type`: String, Codable, CaseIterable {
                case scheduled
                case live
                case upcoming
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, pageNumber: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.pageNumber = pageNumber
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(pageNumber, forKey: "page_number")
                return encoder.items
            }
        }

        /// Create a meeting
        ///
        /// Use this API to [create a meeting](https://support.zoom.us/hc/en-us/articles/201362413-Scheduling-meetings) for a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// * A meeting's `start_url` value is the URL a host or an alternative host can use to start a meeting. The expiration time for the `start_url` value is **two hours** for all regular users.
        /// * For `custCreate` meeting hosts (users created with the `custCreate` parameter via the **[Create Users](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usercreate)** API), the expiration time of the `start_url` parameter is **90 days** from the generation of the `start_url`.
        /// 
        /// **Note:** 
        /// 
        /// For security reasons, the recommended way to programmatically (after expiry) get the updated `start_url` value is to call the [**Retrieve a Meeting**](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meeting) API. Refer to the `start_url` value in the response. 
        /// 
        ///  **Scopes:** `meeting:write:admin`, `meeting:write`
        /// 
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` <br>
        /// * This API has a daily rate limit of **100 requests per day**. The rate limit is applied against the `userId` of the **meeting host** used to make the request.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of created Meeting
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// Agenda
            public var agenda: String?
            /// The ID of the user who scheduled this meeting on behalf of the host.
            public var assistantID: String?
            /// The date and time at which this meeting was created.
            public var createdAt: Date?
            /// Meeting duration.
            public var duration: Int?
            /// H.323/SIP room system password
            public var h323Password: String?
            /// Email address of the meeting host.
            public var hostEmail: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
            public var joinURL: String?
            /// Array of occurrence objects.
            public var occurrences: [Occurrence]?
            /// Meeting password. Password may only contain the following characters: `[a-z A-Z 0-9 @ - _ * !]`
            /// 
            /// If "Require a password when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the password field will be autogenerated in the response even if it is not provided in the API request.
            public var password: String?
            /// Personal Meeting Id. Only used for scheduled meetings and recurring meetings with no fixed time.
            public var pmi: Int?
            /// Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
            /// * `true`  A GSuite prescheduled meeting. 
            /// * `false`  A regular meeting.
            public var isPreSchedule: Bool
            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public var recurrence: Recurrence?
            /// URL using which registrants can register for a meeting. This field is only returned for meetings that have enabled registration.
            public var registrationURL: String?
            /// Meeting settings.
            public var settings: Settings?
            /// Meeting start date-time in UTC/GMT. Example: "2020-03-31T12:02:00Z"
            public var startTime: Date?
            /// URL to start the meeting. This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
            public var startURL: String?
            /// Timezone to format start_time
            public var timezone: String?
            /// Meeting topic
            public var topic: String?
            /// Tracking fields
            public var trackingFields: [TrackingField]?
            /// Meeting Type
            public var type: Int?

            /// Occurrence object. This object is only returned for Recurring Webinars.
            public struct Occurrence: Decodable {
                /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
                public var occurrenceID: String?
                /// Start time.
                public var startTime: Date?
                /// Duration.
                public var duration: Int?
                /// Occurrence status.
                public var status: String?

                public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
                    self.occurrenceID = occurrenceID
                    self.startTime = startTime
                    self.duration = duration
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case occurrenceID = "occurrence_id"
                    case startTime = "start_time"
                    case duration
                    case status
                }
            }

            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public struct Recurrence: Decodable {
                /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
                public var repeatInterval: Int?
                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: WeeklyDays?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
                /// 
                /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public enum WeeklyDays: String, Codable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                    case _3 = "3"
                    case _4 = "4"
                    case _5 = "5"
                    case _6 = "6"
                    case _7 = "7"
                }

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            /// Meeting settings.
            public struct Settings: Decodable {
                /// Start video when the host joins the meeting.
                public var isHostVideo: Bool?
                /// Start video when participants join the meeting.
                public var isParticipantVideo: Bool?
                /// Host meeting in China.
                public var isCnMeeting: Bool
                /// Host meeting in India.
                public var isInMeeting: Bool
                /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
                public var isJoinBeforeHost: Bool
                /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
                /// 
                /// *  `0`: Allow participant to join anytime.
                /// *  `5`: Allow participant to join 5 minutes before meeting start time.
                ///  * `10`: Allow participant to join 10 minutes before meeting start time.
                public var jbhTime: Int?
                /// Mute participants upon entry.
                public var isMuteUponEntry: Bool
                /// Add watermark when viewing a shared screen.
                public var isWatermark: Bool
                /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
                public var usePmi: Bool
                /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
                /// 
                /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                public var approvalType: Int?
                /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
                public var registrationType: Int?
                /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
                public var audio: Audio?
                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public var autoRecording: AutoRecording?
                /// Only signed in users can join this meeting.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
                public var enforceLogin: Bool?
                /// Only signed in users with specified domains can join meetings.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
                public var enforceLoginDomains: String?
                /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
                public var alternativeHosts: String?
                /// Close registration after event date
                public var isCloseRegistration: Bool
                /// Enable waiting room
                public var isWaitingRoom: Bool
                /// List of global dial-in countries
                public var globalDialInCountries: [String]?
                /// Global Dial-in Countries/Regions
                public var globalDialInNumbers: [GlobalDialInNumber]?
                /// Contact name for registration
                public var contactName: String?
                /// Contact email for registration
                public var contactEmail: String?
                /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
                /// 
                /// * `true`  Send an email notification.
                /// * `false`  Do not send an email notification.
                /// 
                ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
                public var isRegistrantsEmailNotification: Bool?
                /// Whether to send registrants an email confirmation:
                /// * `true`  Send a confirmation email.
                /// * `false`  Do not send a confirmation email.
                public var isRegistrantsConfirmationEmail: Bool?
                /// `true`- Only authenticated users can join meetings.
                public var isMeetingAuthentication: Bool?
                /// Meeting authentication option id.
                public var authenticationOption: String?
                /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
                public var authenticationDomains: String?
                /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
                public var authenticationName: String?
                /// Show social share buttons on the meeting registration page.
                /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
                public var isShowShareButton: Bool?
                /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
                public var allowMultipleDevices: Bool?
                /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
                /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
                /// 
                /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
                public var encryptionType: EncryptionType?
                /// Approve or block users from specific regions/countries from joining this meeting.
                public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
                /// The participants added here will receive unique meeting invite links and bypass authentication.
                public var authenticationException: [AuthenticationExceptionItem]?
                /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
                public var breakoutRoom: BreakoutRoom?
                /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                public var languageInterpretation: LanguageInterpretation?
                /// Custom keys and values assigned to the meeting.
                public var customKeys: [CustomKey]?
                /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
                public var isAlternativeHostsEmailNotification: Bool
                /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
                public var isFocusMode: Bool?
                /// Whether the meeting is set as private.
                public var isPrivateMeeting: Bool?
                /// The calendar type: 
                /// * `1`  Outlook calendar. 
                /// * `2`  Google Calendar.
                public var calendarType: Int?

                /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                public struct GlobalDialInNumber: Decodable {
                    /// Country code. For example, BR.
                    public var country: String?
                    /// Full name of country. For example, Brazil.
                    public var countryName: String?
                    /// City of the number, if any. For example, Chicago.
                    public var city: String?
                    /// Phone number. For example, +1 2332357613.
                    public var number: String?
                    /// Type of number.
                    public var type: `Type`?

                    /// Type of number.
                    public enum `Type`: String, Codable, CaseIterable {
                        case toll
                        case tollfree
                    }

                    public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                        self.country = country
                        self.countryName = countryName
                        self.city = city
                        self.number = number
                        self.type = type
                    }

                    private enum CodingKeys: String, CodingKey {
                        case country
                        case countryName = "country_name"
                        case city
                        case number
                        case type
                    }
                }

                /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
                /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
                /// 
                /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
                public enum EncryptionType: String, Codable, CaseIterable {
                    case enhancedEncryption = "enhanced_encryption"
                    case e2ee
                }

                /// Approve or block users from specific regions/countries from joining this meeting.
                public struct ApprovedOrDeniedCountriesOrRegions: Decodable {
                    /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
                    /// 
                    /// `false`: Setting disabled.
                    public var enable: Bool?
                    /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
                    /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
                    /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
                    public var method: Method?
                    /// List of countries/regions from where participants can join this meeting.
                    public var approvedList: [String]?
                    /// List of countries/regions from where participants can not join this meeting.
                    public var deniedList: [String]?

                    /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
                    /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
                    /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
                    public enum Method: String, Codable, CaseIterable {
                        case approve
                        case deny
                    }

                    public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                        self.enable = enable
                        self.method = method
                        self.approvedList = approvedList
                        self.deniedList = deniedList
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case method
                        case approvedList = "approved_list"
                        case deniedList = "denied_list"
                    }
                }

                public struct AuthenticationExceptionItem: Decodable {
                    /// Name of the participant.
                    public var name: String?
                    /// Email address of the participant.
                    public var email: String?

                    public init(name: String? = nil, email: String? = nil) {
                        self.name = name
                        self.email = email
                    }
                }

                /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
                public struct BreakoutRoom: Decodable {
                    /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
                    public var enable: Bool?
                    /// Create room(s).
                    public var rooms: [Room]?

                    public struct Room: Decodable {
                        /// Name of the breakout room.
                        public var name: String?
                        /// Email addresses of the participants who are to be assigned to the breakout room.
                        public var participants: [String]?

                        public init(name: String? = nil, participants: [String]? = nil) {
                            self.name = name
                            self.participants = participants
                        }
                    }

                    public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                        self.enable = enable
                        self.rooms = rooms
                    }
                }

                /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                public struct LanguageInterpretation: Decodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
                    public var enable: Bool?
                    /// Information about the meeting's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Decodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                public struct CustomKey: Decodable {
                    /// Custom key associated with the user.
                    public var key: String?
                    /// Value of the custom key associated with the user.
                    public var value: String?

                    public init(key: String? = nil, value: String? = nil) {
                        self.key = key
                        self.value = value
                    }
                }

                public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isParticipantVideo = isParticipantVideo
                    self.isCnMeeting = isCnMeeting ?? false
                    self.isInMeeting = isInMeeting ?? false
                    self.isJoinBeforeHost = isJoinBeforeHost ?? false
                    self.jbhTime = jbhTime
                    self.isMuteUponEntry = isMuteUponEntry ?? false
                    self.isWatermark = isWatermark ?? false
                    self.usePmi = usePmi ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.enforceLogin = enforceLogin
                    self.enforceLoginDomains = enforceLoginDomains
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration ?? false
                    self.isWaitingRoom = isWaitingRoom ?? false
                    self.globalDialInCountries = globalDialInCountries
                    self.globalDialInNumbers = globalDialInNumbers
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.authenticationName = authenticationName
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.encryptionType = encryptionType
                    self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
                    self.authenticationException = authenticationException
                    self.breakoutRoom = breakoutRoom
                    self.languageInterpretation = languageInterpretation
                    self.customKeys = customKeys
                    self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
                    self.isFocusMode = isFocusMode
                    self.isPrivateMeeting = isPrivateMeeting
                    self.calendarType = calendarType
                }

                private enum CodingKeys: String, CodingKey {
                    case isHostVideo = "host_video"
                    case isParticipantVideo = "participant_video"
                    case isCnMeeting = "cn_meeting"
                    case isInMeeting = "in_meeting"
                    case isJoinBeforeHost = "join_before_host"
                    case jbhTime = "jbh_time"
                    case isMuteUponEntry = "mute_upon_entry"
                    case isWatermark = "watermark"
                    case usePmi = "use_pmi"
                    case approvalType = "approval_type"
                    case registrationType = "registration_type"
                    case audio
                    case autoRecording = "auto_recording"
                    case enforceLogin = "enforce_login"
                    case enforceLoginDomains = "enforce_login_domains"
                    case alternativeHosts = "alternative_hosts"
                    case isCloseRegistration = "close_registration"
                    case isWaitingRoom = "waiting_room"
                    case globalDialInCountries = "global_dial_in_countries"
                    case globalDialInNumbers = "global_dial_in_numbers"
                    case contactName = "contact_name"
                    case contactEmail = "contact_email"
                    case isRegistrantsEmailNotification = "registrants_email_notification"
                    case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
                    case isMeetingAuthentication = "meeting_authentication"
                    case authenticationOption = "authentication_option"
                    case authenticationDomains = "authentication_domains"
                    case authenticationName = "authentication_name"
                    case isShowShareButton = "show_share_button"
                    case allowMultipleDevices = "allow_multiple_devices"
                    case encryptionType = "encryption_type"
                    case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
                    case authenticationException = "authentication_exception"
                    case breakoutRoom = "breakout_room"
                    case languageInterpretation = "language_interpretation"
                    case customKeys = "custom_keys"
                    case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
                    case isFocusMode = "focus_mode"
                    case isPrivateMeeting = "private_meeting"
                    case calendarType = "calendar_type"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
                    self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: .isParticipantVideo)
                    self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: .isCnMeeting) ?? false
                    self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: .isInMeeting) ?? false
                    self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: .isJoinBeforeHost) ?? false
                    self.jbhTime = try values.decodeIfPresent(Int.self, forKey: .jbhTime)
                    self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: .isMuteUponEntry) ?? false
                    self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark) ?? false
                    self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
                    self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
                    self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
                    self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
                    self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
                    self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
                    self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
                    self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
                    self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration) ?? false
                    self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
                    self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
                    self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: .globalDialInNumbers)
                    self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
                    self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
                    self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
                    self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
                    self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
                    self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
                    self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
                    self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
                    self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
                    self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
                    self.encryptionType = try values.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
                    self.approvedOrDeniedCountriesOrRegions = try values.decodeIfPresent(ApprovedOrDeniedCountriesOrRegions.self, forKey: .approvedOrDeniedCountriesOrRegions)
                    self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: .authenticationException)
                    self.breakoutRoom = try values.decodeIfPresent(BreakoutRoom.self, forKey: .breakoutRoom)
                    self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
                    self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: .customKeys)
                    self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostsEmailNotification) ?? true
                    self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: .isFocusMode)
                    self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: .isPrivateMeeting)
                    self.calendarType = try values.decodeIfPresent(Int.self, forKey: .calendarType)
                }
            }

            public struct TrackingField: Decodable {
                /// Label of the tracking field.
                public var field: String?
                /// Value for the field.
                public var value: String?
                /// Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
                /// 
                /// `true`: Tracking field is visible. <br>
                /// 
                /// `false`: Tracking field is not visible to the users in the meeting options in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
                public var isVisible: Bool?

                public init(field: String? = nil, value: String? = nil, isVisible: Bool? = nil) {
                    self.field = field
                    self.value = value
                    self.isVisible = isVisible
                }

                private enum CodingKeys: String, CodingKey {
                    case field
                    case value
                    case isVisible = "visible"
                }
            }

            public init(agenda: String? = nil, assistantID: String? = nil, createdAt: Date? = nil, duration: Int? = nil, h323Password: String? = nil, hostEmail: String? = nil, id: Int? = nil, joinURL: String? = nil, occurrences: [Occurrence]? = nil, password: String? = nil, pmi: Int? = nil, isPreSchedule: Bool? = nil, recurrence: Recurrence? = nil, registrationURL: String? = nil, settings: Settings? = nil, startTime: Date? = nil, startURL: String? = nil, timezone: String? = nil, topic: String? = nil, trackingFields: [TrackingField]? = nil, type: Int? = nil) {
                self.agenda = agenda
                self.assistantID = assistantID
                self.createdAt = createdAt
                self.duration = duration
                self.h323Password = h323Password
                self.hostEmail = hostEmail
                self.id = id
                self.joinURL = joinURL
                self.occurrences = occurrences
                self.password = password
                self.pmi = pmi
                self.isPreSchedule = isPreSchedule ?? false
                self.recurrence = recurrence
                self.registrationURL = registrationURL
                self.settings = settings
                self.startTime = startTime
                self.startURL = startURL
                self.timezone = timezone
                self.topic = topic
                self.trackingFields = trackingFields
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case agenda
                case assistantID = "assistant_id"
                case createdAt = "created_at"
                case duration
                case h323Password = "h323_password"
                case hostEmail = "host_email"
                case id
                case joinURL = "join_url"
                case occurrences
                case password
                case pmi
                case isPreSchedule = "pre_schedule"
                case recurrence
                case registrationURL = "registration_url"
                case settings
                case startTime = "start_time"
                case startURL = "start_url"
                case timezone
                case topic
                case trackingFields = "tracking_fields"
                case type
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.agenda = try values.decodeIfPresent(String.self, forKey: .agenda)
                self.assistantID = try values.decodeIfPresent(String.self, forKey: .assistantID)
                self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
                self.duration = try values.decodeIfPresent(Int.self, forKey: .duration)
                self.h323Password = try values.decodeIfPresent(String.self, forKey: .h323Password)
                self.hostEmail = try values.decodeIfPresent(String.self, forKey: .hostEmail)
                self.id = try values.decodeIfPresent(Int.self, forKey: .id)
                self.joinURL = try values.decodeIfPresent(String.self, forKey: .joinURL)
                self.occurrences = try values.decodeIfPresent([Occurrence].self, forKey: .occurrences)
                self.password = try values.decodeIfPresent(String.self, forKey: .password)
                self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
                self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: .isPreSchedule) ?? false
                self.recurrence = try values.decodeIfPresent(Recurrence.self, forKey: .recurrence)
                self.registrationURL = try values.decodeIfPresent(String.self, forKey: .registrationURL)
                self.settings = try values.decodeIfPresent(Settings.self, forKey: .settings)
                self.startTime = try values.decodeIfPresent(Date.self, forKey: .startTime)
                self.startURL = try values.decodeIfPresent(String.self, forKey: .startURL)
                self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
                self.topic = try values.decodeIfPresent(String.self, forKey: .topic)
                self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: .trackingFields)
                self.type = try values.decodeIfPresent(Int.self, forKey: .type)
            }
        }

        /// The base meeting object.
        public struct PostRequest: Encodable {
            /// The meeting's topic.
            public var topic: String?
            /// The type of meeting:
            /// * `1`  An instant meeting. 
            /// * `2`  A scheduled meeting. 
            /// * `3`  A recurring meeting with no fixed time. 
            /// * `8`  A recurring meeting with fixed time.
            public var type: Int?
            /// Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
            /// * `true`  Create a prescheduled meeting. 
            /// * `false`  Create a regular meeting.
            public var isPreSchedule: Bool
            /// The meeting's start time. This field is only used for scheduled and/or recurring meetings with a fixed time. This supports local time and GMT formats. 
            /// * To set a meeting's start time in GMT, use the `yyyy-MM-ddTHH:mm:ssZ` date-time format. For example, `2020-03-31T12:02:00Z`. 
            /// * To set a meeting's start time using a specific timezone, use the `yyyy-MM-ddTHH:mm:ss` date-time format and specify the [timezone ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) in the `timezone` field. If you do not specify a timezone, the `timezone` value defaults to your Zoom account's timezone. You can also use `UTC` for the `timezone` value.
            public var startTime: Date?
            /// The meeting's scheduled duration, in minutes. This field is only used for scheduled meetings (`2`).
            public var duration: Int?
            /// The email address or user ID of the user to schedule a meeting for.
            public var scheduleFor: String?
            /// The timezome to assign to the `start_time` value. This field is only used for scheduled meetings (`2`).
            /// 
            /// For a list of supported timezones and their format, refer to our [timezone list documentation](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones).
            public var timezone: String?
            /// The password required to join the meeting. By default, a password can **only** have a maximum length of 10 characters and only contain alphanumeric characters and the `@`, `-`, `_`, and `*` characters. 
            /// * If the account owner or administrator has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the password **must** meet those requirements. 
            /// * If password requirements are enabled, use the [**Get User Settings**](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) API or the [**Get Account Settings**](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API to get the requirements.
            public var password: String?
            /// Whether to generate a default password using the user's settings. This value defaults to `false`. 
            /// 
            /// If this value is `true` and the user has the PMI setting enabled with a password, then the user's meetings will use the PMI password. It will **not** use a default password.
            public var isDefaultPassword: Bool
            /// The meeting's agenda. This value has a maximum length of 2,000 characters.
            public var agenda: String?
            /// Information about the meeting's tracking fields.
            public var trackingFields: [TrackingField]?
            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public var recurrence: Recurrence?
            /// Information about the meeting's settings.
            public var settings: Settings?
            /// The **account admin meeting template** ID with which to schedule a meeting using a [meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates). For a list of account admin-provided meeting templates, use the [**List meeting templates**](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/listmeetingtemplates) API. 
            /// * At this time, this field **only** accepts account admin meeting template IDs. 
            /// * To enable the account admin meeting templates feature, [contact Zoom support](https://support.zoom.us/hc/en-us).
            public var templateID: String?

            public struct TrackingField: Encodable {
                /// The tracking field's label.
                public var field: String
                /// The tracking field's value.
                public var value: String?

                public init(field: String, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public struct Recurrence: Encodable {
                /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
                public var repeatInterval: Int?
                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: WeeklyDays?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
                /// 
                /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public enum WeeklyDays: String, Codable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                    case _3 = "3"
                    case _4 = "4"
                    case _5 = "5"
                    case _6 = "6"
                    case _7 = "7"
                }

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            /// Information about the meeting's settings.
            public struct Settings: Encodable {
                /// Whether to start meetings with the host video on.
                public var isHostVideo: Bool?
                /// Whether to start meetings with the participant video on.
                public var isParticipantVideo: Bool?
                /// Whether to host the meeting in China (CN). This value defaults to `false`.
                public var isCnMeeting: Bool
                /// Whether to host the meeting in India (IN). This value defaults to `false`.
                public var isInMeeting: Bool
                /// Whether participants can join the meeting before its host. This field is only used for scheduled meetings (`2`) or recurring meetings (`3` and `8`). This value defaults to `false`.
                /// 
                /// If the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room) is enabled, this setting is **disabled**.
                public var isJoinBeforeHost: Bool
                /// If the value of the `join_before_host` field is `true`, this field indicates the time limits within which a participant can join a meeting before the meeting's host:
                /// 
                /// * `0`  Allow the participant to join the meeting at anytime.
                /// * `5`  Allow the participant to join 5 minutes before the meeting's start time.
                /// * `10`  Allow the participant to join 10 minutes before the meeting's start time.
                public var jbhTime: Int?
                /// Whether to mute participants upon entry.
                public var isMuteUponEntry: Bool
                /// Whether to add a watermark when viewing a shared screen.
                public var isWatermark: Bool
                /// Whether to use a [PMI (Personal Meeting ID)](https://support.zoom.us/hc/en-us/articles/203276937-Using-Personal-Meeting-ID-PMI-) instead of a generated meeting ID. This field is only used for scheduled meetings (`2`), instant meetings (`1`), or recurring meetings with no fixed time (`3`). This value defaults to `false`.
                public var usePmi: Bool
                /// Enable meeting registration approval: 
                /// * `0`  Automatically approve registration.
                /// * `1`  Manually approve registration.
                /// * `2`  No registration required.
                /// 
                /// This value defaults to `2`.
                public var approvalType: Int?
                /// The meeting's registration type: 
                /// * `1`  Attendees register once and can attend any meeting occurrence. 
                /// * `2`  Attendees must register for each meeting occurrence. 
                /// * `3`  Attendees register once and can select one or more meeting occurrences to attend.
                /// 
                /// This field is only for recurring meetings with fixed times (`8`). This value defaults to `1`.
                public var registrationType: Int?
                /// How participants join the audio portion of the meeting: 
                /// * `both`  Both telephony and VoIP. 
                /// * `telephony`  Telephony only. 
                /// * `voip`  VoIP only.
                /// 
                /// This value defaults to `both`.
                public var audio: Audio?
                /// The automatic recording settings: 
                /// * `local`  Record the meeting locally. 
                /// * `cloud`  Record the meeting to the cloud. 
                /// * `none`  Auto-recording disabled.
                /// 
                /// This value defaults to `none`.
                public var autoRecording: AutoRecording?
                /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
                public var alternativeHosts: String?
                /// Whether to close registration after the event date. This value defaults to `false`.
                public var isCloseRegistration: Bool
                /// Whether to enable the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room). If this value is `true`, this **disables** the `join_before_host` setting.
                public var isWaitingRoom: Bool?
                /// A list of available global dial-in countries.
                public var globalDialInCountries: [String]?
                /// The contact name for meeting registration.
                public var contactName: String?
                /// The contact email address for meeting registration.
                public var contactEmail: String?
                /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
                /// 
                /// * `true`  Send an email notification.
                /// * `false`  Do not send an email notification.
                /// 
                ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
                public var isRegistrantsEmailNotification: Bool?
                /// Whether to send registrants an email confirmation: 
                /// * `true`  Send a confirmation email. 
                /// * `false`  Do not send a confirmation email.
                public var isRegistrantsConfirmationEmail: Bool?
                /// If true, only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join the meeting.
                public var isMeetingAuthentication: Bool?
                /// If the `meeting_authentication` value is `true`, the type of authentication required for users to join a meeting.
                /// 
                /// To get this value, use the `authentication_options` array's `id` value in the [**Get User Settings**](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) API response.
                public var authenticationOption: String?
                /// The meeting's authenticated domains. Only Zoom users whose email address contains an authenticated domain can join the meeting. Comma-separate multiple domains or use a wildcard for listing domains.
                public var authenticationDomains: String?
                /// A list of participants that can bypass meeting authentication. These participants will receive a unique meeting invite.
                public var authenticationException: [AuthenticationExceptionItem]?
                /// Add additional meeting [data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars). Provide this value as an array of [country codes](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for the countries available as data center regions in the [**Account Profile**](https://zoom.us/account/setting) interface but have been opted out of in the [user settings](https://zoom.us/profile).
                /// 
                /// For example, the data center regions selected in your [**Account Profile**](https://zoom.us/account) are "Europe", "Hong Kong SAR", "Australia", "India", "Japan", "China", "United States", and "Canada". However, in the [**My Profile**](https://zoom.us/profile) settings, you did **not** select "India" and "Japan" for meeting and webinar traffic routing.
                /// 
                /// To include "India" and "Japan" as additional data centers, use the `["IN", "TY"]` value for this field.
                public var additionalDataCenterRegions: [String]?
                /// The [pre-assigned breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) settings.
                public var breakoutRoom: BreakoutRoom?
                /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                public var languageInterpretation: LanguageInterpretation?
                /// Whether to include social media sharing buttons on the meeting's registration page. This setting is only applied to meetings with registration enabled.
                public var isShowShareButton: Bool?
                /// Whether to allow attendees to join a meeting from multiple devices. This setting is only applied to meetings with registration enabled.
                public var allowMultipleDevices: Bool?
                /// The type of [end-to-end (E2EE) encryption](https://support.zoom.us/hc/en-us/articles/360048660871) to use for the meeting: 
                /// * `enhanced_encryption`  Enhanced encryption. Encryption is stored in the cloud when you enable this option. 
                /// * `e2ee`  End-to-end encryption. The encryption key is stored on your local device and **cannot** be obtained by anyone else. When you use E2EE encryption, [certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording or phone and SIP/H.323 dial-in, are **disabled**.
                public var encryptionType: EncryptionType?
                /// The list of approved or blocked users from specific countries or regions who can join the meeting.
                public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
                /// Whether to send email notifications to alternative hosts. This value defaults to `true`.
                public var isAlternativeHostsEmailNotification: Bool
                /// Whether to enable the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) when the meeting starts.
                public var isFocusMode: Bool?
                /// A list of the meeting's invitees.
                public var meetingInvitees: [MeetingInvitee]?
                /// Whether to set the meeting as private.
                public var isPrivateMeeting: Bool?
                /// The calendar type: 
                /// * `1`  Outlook calendar. 
                /// * `2`  Google Calendar.
                public var calendarType: Int?

                /// How participants join the audio portion of the meeting: 
                /// * `both`  Both telephony and VoIP. 
                /// * `telephony`  Telephony only. 
                /// * `voip`  VoIP only.
                /// 
                /// This value defaults to `both`.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// The automatic recording settings: 
                /// * `local`  Record the meeting locally. 
                /// * `cloud`  Record the meeting to the cloud. 
                /// * `none`  Auto-recording disabled.
                /// 
                /// This value defaults to `none`.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                public struct AuthenticationExceptionItem: Encodable {
                    /// The participant's name.
                    public var name: String?
                    /// The participant's email address.
                    public var email: String?

                    public init(name: String? = nil, email: String? = nil) {
                        self.name = name
                        self.email = email
                    }
                }

                /// The [pre-assigned breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) settings.
                public struct BreakoutRoom: Encodable {
                    /// Whether to enable the [**Breakout Room pre-assign**](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) option.
                    public var enable: Bool?
                    /// Information about the breakout rooms.
                    public var rooms: [Room]?

                    public struct Room: Encodable {
                        /// The breakout room's name.
                        public var name: String?
                        /// The email addresses of the participants to assign to the breakout room.
                        public var participants: [String]?

                        public init(name: String? = nil, participants: [String]? = nil) {
                            self.name = name
                            self.participants = participants
                        }
                    }

                    public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                        self.enable = enable
                        self.rooms = rooms
                    }
                }

                /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                public struct LanguageInterpretation: Encodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
                    public var enable: Bool?
                    /// Information about the meeting's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Encodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                /// The type of [end-to-end (E2EE) encryption](https://support.zoom.us/hc/en-us/articles/360048660871) to use for the meeting: 
                /// * `enhanced_encryption`  Enhanced encryption. Encryption is stored in the cloud when you enable this option. 
                /// * `e2ee`  End-to-end encryption. The encryption key is stored on your local device and **cannot** be obtained by anyone else. When you use E2EE encryption, [certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording or phone and SIP/H.323 dial-in, are **disabled**.
                public enum EncryptionType: String, Codable, CaseIterable {
                    case enhancedEncryption = "enhanced_encryption"
                    case e2ee
                }

                /// The list of approved or blocked users from specific countries or regions who can join the meeting.
                public struct ApprovedOrDeniedCountriesOrRegions: Encodable {
                    /// Whether to enable the [**Approve or block entry for users from specific countries/regions**](https://support.zoom.us/hc/en-us/articles/360060086231-Approve-or-block-entry-for-users-from-specific-countries-regions) setting.
                    public var enable: Bool?
                    /// Whether to allow or block users from specific countries or regions: 
                    /// * `approve`  Allow users from specific countries or regions to join the meeting. If you select this setting, you must include the approved countries or regions in the `approved_list` field. 
                    /// * `deny`  Block users from specific countries or regions from joining the meeting. If you select this setting, you must include the blocked countries or regions in the `denied_list` field.
                    public var method: Method?
                    /// The list of approved countries or regions.
                    public var approvedList: [String]?
                    /// The list of blocked countries or regions.
                    public var deniedList: [String]?

                    /// Whether to allow or block users from specific countries or regions: 
                    /// * `approve`  Allow users from specific countries or regions to join the meeting. If you select this setting, you must include the approved countries or regions in the `approved_list` field. 
                    /// * `deny`  Block users from specific countries or regions from joining the meeting. If you select this setting, you must include the blocked countries or regions in the `denied_list` field.
                    public enum Method: String, Codable, CaseIterable {
                        case approve
                        case deny
                    }

                    public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                        self.enable = enable
                        self.method = method
                        self.approvedList = approvedList
                        self.deniedList = deniedList
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case method
                        case approvedList = "approved_list"
                        case deniedList = "denied_list"
                    }
                }

                public struct MeetingInvitee: Encodable {
                    /// The invitee's email address.
                    public var email: String?

                    public init(email: String? = nil) {
                        self.email = email
                    }
                }

                public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, additionalDataCenterRegions: [String]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, meetingInvitees: [MeetingInvitee]? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isParticipantVideo = isParticipantVideo
                    self.isCnMeeting = isCnMeeting ?? false
                    self.isInMeeting = isInMeeting ?? false
                    self.isJoinBeforeHost = isJoinBeforeHost ?? false
                    self.jbhTime = jbhTime
                    self.isMuteUponEntry = isMuteUponEntry ?? false
                    self.isWatermark = isWatermark ?? false
                    self.usePmi = usePmi ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration ?? false
                    self.isWaitingRoom = isWaitingRoom
                    self.globalDialInCountries = globalDialInCountries
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.authenticationException = authenticationException
                    self.additionalDataCenterRegions = additionalDataCenterRegions
                    self.breakoutRoom = breakoutRoom
                    self.languageInterpretation = languageInterpretation
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.encryptionType = encryptionType
                    self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
                    self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
                    self.isFocusMode = isFocusMode
                    self.meetingInvitees = meetingInvitees
                    self.isPrivateMeeting = isPrivateMeeting
                    self.calendarType = calendarType
                }

                private enum CodingKeys: String, CodingKey {
                    case isHostVideo = "host_video"
                    case isParticipantVideo = "participant_video"
                    case isCnMeeting = "cn_meeting"
                    case isInMeeting = "in_meeting"
                    case isJoinBeforeHost = "join_before_host"
                    case jbhTime = "jbh_time"
                    case isMuteUponEntry = "mute_upon_entry"
                    case isWatermark = "watermark"
                    case usePmi = "use_pmi"
                    case approvalType = "approval_type"
                    case registrationType = "registration_type"
                    case audio
                    case autoRecording = "auto_recording"
                    case alternativeHosts = "alternative_hosts"
                    case isCloseRegistration = "close_registration"
                    case isWaitingRoom = "waiting_room"
                    case globalDialInCountries = "global_dial_in_countries"
                    case contactName = "contact_name"
                    case contactEmail = "contact_email"
                    case isRegistrantsEmailNotification = "registrants_email_notification"
                    case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
                    case isMeetingAuthentication = "meeting_authentication"
                    case authenticationOption = "authentication_option"
                    case authenticationDomains = "authentication_domains"
                    case authenticationException = "authentication_exception"
                    case additionalDataCenterRegions = "additional_data_center_regions"
                    case breakoutRoom = "breakout_room"
                    case languageInterpretation = "language_interpretation"
                    case isShowShareButton = "show_share_button"
                    case allowMultipleDevices = "allow_multiple_devices"
                    case encryptionType = "encryption_type"
                    case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
                    case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
                    case isFocusMode = "focus_mode"
                    case meetingInvitees = "meeting_invitees"
                    case isPrivateMeeting = "private_meeting"
                    case calendarType = "calendar_type"
                }
            }

            public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, startTime: Date? = nil, duration: Int? = nil, scheduleFor: String? = nil, timezone: String? = nil, password: String? = nil, isDefaultPassword: Bool? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil, templateID: String? = nil) {
                self.topic = topic
                self.type = type
                self.isPreSchedule = isPreSchedule ?? false
                self.startTime = startTime
                self.duration = duration
                self.scheduleFor = scheduleFor
                self.timezone = timezone
                self.password = password
                self.isDefaultPassword = isDefaultPassword ?? false
                self.agenda = agenda
                self.trackingFields = trackingFields
                self.recurrence = recurrence
                self.settings = settings
                self.templateID = templateID
            }

            private enum CodingKeys: String, CodingKey {
                case topic
                case type
                case isPreSchedule = "pre_schedule"
                case startTime = "start_time"
                case duration
                case scheduleFor = "schedule_for"
                case timezone
                case password
                case isDefaultPassword = "default_password"
                case agenda
                case trackingFields = "tracking_fields"
                case recurrence
                case settings
                case templateID = "template_id"
            }
        }
    }
}

extension Paths.Meetings {
    public func meetingID(_ meetingID: Int) -> WithMeetingID {
        WithMeetingID(path: "\(path)/\(meetingID)")
    }

    public struct WithMeetingID {
        /// Path: `/meetings/{meetingId}`
        public let path: String

        /// Get a meeting
        ///
        /// Retrieve the details of a meeting.<br><br>
        /// **Scopes:** `meeting:read:admin` `meeting:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func get(occurrenceID: String? = nil, isShowPreviousOccurrences: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(occurrenceID, isShowPreviousOccurrences))
        }

        public struct GetResponse: Decodable {
            /// Meeting description
            public var agenda: String?
            /// The ID of the user who scheduled this meeting on behalf of the host.
            public var assistantID: String?
            /// Time of creation.
            public var createdAt: Date?
            /// Meeting duration.
            public var duration: Int?
            /// Encrypted passcode for third party endpoints (H323/SIP).
            public var encryptedPassword: String?
            /// H.323/SIP room system passcode.
            public var h323Password: String?
            /// Email address of the meeting host.
            public var hostEmail: String?
            /// ID of the user who is set as host of meeting.
            public var hostID: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
            public var joinURL: String?
            /// Array of occurrence objects.
            public var occurrences: [Occurrence]?
            /// Meeting passcode.
            public var password: String?
            /// Personal Meeting Id. Only used for scheduled meetings and recurring meetings with no fixed time.
            public var pmi: Int?
            /// Whether the preschedule meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
            /// * `true`  A GSuite prescheduled meeting. 
            /// * `false`  A regular meeting.
            public var isPreSchedule: Bool
            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public var recurrence: Recurrence?
            /// Meeting settings.
            public var settings: Settings?
            /// Meeting start time in GMT/UTC. Start time will not be returned if the meeting is an **instant** meeting.
            public var startTime: Date?
            /// <br><aside>The <code>start_url</code> of a Meeting is a URL using which a host or an alternative host can start the Meeting. 
            /// 
            /// The expiration time for the <code>start_url</code> field listed in the response of [Create a Meeting API](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meetingcreate) is two hours for all regular users. 
            /// 	
            /// For users created using the <code>custCreate</code> option via the [Create Users](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usercreate) API, the expiration time of the <code>start_url</code> field is 90 days.
            /// 	
            /// For security reasons, to retrieve the updated value for the <code>start_url</code> field programmatically (after the expiry time), you must call the [Retrieve a Meeting API](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meeting) and refer to the value of the <code>start_url</code> field in the response.</aside><br>This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
            public var startURL: String?
            /// Meeting status
            public var status: Status?
            /// Timezone to format the meeting start time on the .
            public var timezone: String?
            /// Meeting topic.
            public var topic: String?
            /// Tracking fields
            public var trackingFields: [TrackingField]?
            /// Meeting Types:<br>`1` - Instant meeting.<br>`2` - Scheduled meeting.<br>`3` - Recurring meeting with no fixed time.<br>`4` - PMI Meeting<br>
            /// `8` - Recurring meeting with a fixed time.
            public var type: Int?
            /// Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). You can retrieve a list of UUIDs from past meeting instances using [this API](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/pastmeetings) . Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
            public var uuid: String?

            /// Occurrence object. This object is only returned for Recurring Webinars.
            public struct Occurrence: Decodable {
                /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
                public var occurrenceID: String?
                /// Start time.
                public var startTime: Date?
                /// Duration.
                public var duration: Int?
                /// Occurrence status.
                public var status: String?

                public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
                    self.occurrenceID = occurrenceID
                    self.startTime = startTime
                    self.duration = duration
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case occurrenceID = "occurrence_id"
                    case startTime = "start_time"
                    case duration
                    case status
                }
            }

            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public struct Recurrence: Decodable {
                /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
                public var repeatInterval: Int?
                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: WeeklyDays?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
                /// 
                /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public enum WeeklyDays: String, Codable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                    case _3 = "3"
                    case _4 = "4"
                    case _5 = "5"
                    case _6 = "6"
                    case _7 = "7"
                }

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            /// Meeting settings.
            public struct Settings: Decodable {
                /// Start video when the host joins the meeting.
                public var isHostVideo: Bool?
                /// Start video when participants join the meeting.
                public var isParticipantVideo: Bool?
                /// Host meeting in China.
                public var isCnMeeting: Bool
                /// Host meeting in India.
                public var isInMeeting: Bool
                /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
                public var isJoinBeforeHost: Bool
                /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
                /// 
                /// *  `0`: Allow participant to join anytime.
                /// *  `5`: Allow participant to join 5 minutes before meeting start time.
                ///  * `10`: Allow participant to join 10 minutes before meeting start time.
                public var jbhTime: Int?
                /// Mute participants upon entry.
                public var isMuteUponEntry: Bool
                /// Add watermark when viewing a shared screen.
                public var isWatermark: Bool
                /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
                public var usePmi: Bool
                /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
                /// 
                /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                public var approvalType: Int?
                /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
                public var registrationType: Int?
                /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
                public var audio: Audio?
                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public var autoRecording: AutoRecording?
                /// Only signed in users can join this meeting.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
                public var enforceLogin: Bool?
                /// Only signed in users with specified domains can join meetings.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
                public var enforceLoginDomains: String?
                /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
                public var alternativeHosts: String?
                /// Close registration after event date
                public var isCloseRegistration: Bool
                /// Enable waiting room
                public var isWaitingRoom: Bool
                /// List of global dial-in countries
                public var globalDialInCountries: [String]?
                /// Global Dial-in Countries/Regions
                public var globalDialInNumbers: [GlobalDialInNumber]?
                /// Contact name for registration
                public var contactName: String?
                /// Contact email for registration
                public var contactEmail: String?
                /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
                /// 
                /// * `true`  Send an email notification.
                /// * `false`  Do not send an email notification.
                /// 
                ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
                public var isRegistrantsEmailNotification: Bool?
                /// Whether to send registrants an email confirmation:
                /// * `true`  Send a confirmation email.
                /// * `false`  Do not send a confirmation email.
                public var isRegistrantsConfirmationEmail: Bool?
                /// `true`- Only authenticated users can join meetings.
                public var isMeetingAuthentication: Bool?
                /// Meeting authentication option id.
                public var authenticationOption: String?
                /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
                public var authenticationDomains: String?
                /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
                public var authenticationName: String?
                /// Show social share buttons on the meeting registration page.
                /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
                public var isShowShareButton: Bool?
                /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
                public var allowMultipleDevices: Bool?
                /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
                /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
                /// 
                /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
                public var encryptionType: EncryptionType?
                /// Approve or block users from specific regions/countries from joining this meeting.
                public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
                /// The participants added here will receive unique meeting invite links and bypass authentication.
                public var authenticationException: [AuthenticationExceptionItem]?
                /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
                public var breakoutRoom: BreakoutRoom?
                /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                public var languageInterpretation: LanguageInterpretation?
                /// Custom keys and values assigned to the meeting.
                public var customKeys: [CustomKey]?
                /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
                public var isAlternativeHostsEmailNotification: Bool
                /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
                public var isFocusMode: Bool?
                /// Whether the meeting is set as private.
                public var isPrivateMeeting: Bool?
                /// The calendar type: 
                /// * `1`  Outlook calendar. 
                /// * `2`  Google Calendar.
                public var calendarType: Int?

                /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                public struct GlobalDialInNumber: Decodable {
                    /// Country code. For example, BR.
                    public var country: String?
                    /// Full name of country. For example, Brazil.
                    public var countryName: String?
                    /// City of the number, if any. For example, Chicago.
                    public var city: String?
                    /// Phone number. For example, +1 2332357613.
                    public var number: String?
                    /// Type of number.
                    public var type: `Type`?

                    /// Type of number.
                    public enum `Type`: String, Codable, CaseIterable {
                        case toll
                        case tollfree
                    }

                    public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                        self.country = country
                        self.countryName = countryName
                        self.city = city
                        self.number = number
                        self.type = type
                    }

                    private enum CodingKeys: String, CodingKey {
                        case country
                        case countryName = "country_name"
                        case city
                        case number
                        case type
                    }
                }

                /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
                /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
                /// 
                /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
                public enum EncryptionType: String, Codable, CaseIterable {
                    case enhancedEncryption = "enhanced_encryption"
                    case e2ee
                }

                /// Approve or block users from specific regions/countries from joining this meeting.
                public struct ApprovedOrDeniedCountriesOrRegions: Decodable {
                    /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
                    /// 
                    /// `false`: Setting disabled.
                    public var enable: Bool?
                    /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
                    /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
                    /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
                    public var method: Method?
                    /// List of countries/regions from where participants can join this meeting.
                    public var approvedList: [String]?
                    /// List of countries/regions from where participants can not join this meeting.
                    public var deniedList: [String]?

                    /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
                    /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
                    /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
                    public enum Method: String, Codable, CaseIterable {
                        case approve
                        case deny
                    }

                    public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                        self.enable = enable
                        self.method = method
                        self.approvedList = approvedList
                        self.deniedList = deniedList
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case method
                        case approvedList = "approved_list"
                        case deniedList = "denied_list"
                    }
                }

                public struct AuthenticationExceptionItem: Decodable {
                    /// Name of the participant.
                    public var name: String?
                    /// Email address of the participant.
                    public var email: String?

                    public init(name: String? = nil, email: String? = nil) {
                        self.name = name
                        self.email = email
                    }
                }

                /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
                public struct BreakoutRoom: Decodable {
                    /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
                    public var enable: Bool?
                    /// Create room(s).
                    public var rooms: [Room]?

                    public struct Room: Decodable {
                        /// Name of the breakout room.
                        public var name: String?
                        /// Email addresses of the participants who are to be assigned to the breakout room.
                        public var participants: [String]?

                        public init(name: String? = nil, participants: [String]? = nil) {
                            self.name = name
                            self.participants = participants
                        }
                    }

                    public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                        self.enable = enable
                        self.rooms = rooms
                    }
                }

                /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                public struct LanguageInterpretation: Decodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
                    public var enable: Bool?
                    /// Information about the meeting's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Decodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                public struct CustomKey: Decodable {
                    /// Custom key associated with the user.
                    public var key: String?
                    /// Value of the custom key associated with the user.
                    public var value: String?

                    public init(key: String? = nil, value: String? = nil) {
                        self.key = key
                        self.value = value
                    }
                }

                public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isParticipantVideo = isParticipantVideo
                    self.isCnMeeting = isCnMeeting ?? false
                    self.isInMeeting = isInMeeting ?? false
                    self.isJoinBeforeHost = isJoinBeforeHost ?? false
                    self.jbhTime = jbhTime
                    self.isMuteUponEntry = isMuteUponEntry ?? false
                    self.isWatermark = isWatermark ?? false
                    self.usePmi = usePmi ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.enforceLogin = enforceLogin
                    self.enforceLoginDomains = enforceLoginDomains
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration ?? false
                    self.isWaitingRoom = isWaitingRoom ?? false
                    self.globalDialInCountries = globalDialInCountries
                    self.globalDialInNumbers = globalDialInNumbers
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.authenticationName = authenticationName
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.encryptionType = encryptionType
                    self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
                    self.authenticationException = authenticationException
                    self.breakoutRoom = breakoutRoom
                    self.languageInterpretation = languageInterpretation
                    self.customKeys = customKeys
                    self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
                    self.isFocusMode = isFocusMode
                    self.isPrivateMeeting = isPrivateMeeting
                    self.calendarType = calendarType
                }

                private enum CodingKeys: String, CodingKey {
                    case isHostVideo = "host_video"
                    case isParticipantVideo = "participant_video"
                    case isCnMeeting = "cn_meeting"
                    case isInMeeting = "in_meeting"
                    case isJoinBeforeHost = "join_before_host"
                    case jbhTime = "jbh_time"
                    case isMuteUponEntry = "mute_upon_entry"
                    case isWatermark = "watermark"
                    case usePmi = "use_pmi"
                    case approvalType = "approval_type"
                    case registrationType = "registration_type"
                    case audio
                    case autoRecording = "auto_recording"
                    case enforceLogin = "enforce_login"
                    case enforceLoginDomains = "enforce_login_domains"
                    case alternativeHosts = "alternative_hosts"
                    case isCloseRegistration = "close_registration"
                    case isWaitingRoom = "waiting_room"
                    case globalDialInCountries = "global_dial_in_countries"
                    case globalDialInNumbers = "global_dial_in_numbers"
                    case contactName = "contact_name"
                    case contactEmail = "contact_email"
                    case isRegistrantsEmailNotification = "registrants_email_notification"
                    case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
                    case isMeetingAuthentication = "meeting_authentication"
                    case authenticationOption = "authentication_option"
                    case authenticationDomains = "authentication_domains"
                    case authenticationName = "authentication_name"
                    case isShowShareButton = "show_share_button"
                    case allowMultipleDevices = "allow_multiple_devices"
                    case encryptionType = "encryption_type"
                    case approvedOrDeniedCountriesOrRegions = "approved_or_denied_countries_or_regions"
                    case authenticationException = "authentication_exception"
                    case breakoutRoom = "breakout_room"
                    case languageInterpretation = "language_interpretation"
                    case customKeys = "custom_keys"
                    case isAlternativeHostsEmailNotification = "alternative_hosts_email_notification"
                    case isFocusMode = "focus_mode"
                    case isPrivateMeeting = "private_meeting"
                    case calendarType = "calendar_type"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
                    self.isParticipantVideo = try values.decodeIfPresent(Bool.self, forKey: .isParticipantVideo)
                    self.isCnMeeting = try values.decodeIfPresent(Bool.self, forKey: .isCnMeeting) ?? false
                    self.isInMeeting = try values.decodeIfPresent(Bool.self, forKey: .isInMeeting) ?? false
                    self.isJoinBeforeHost = try values.decodeIfPresent(Bool.self, forKey: .isJoinBeforeHost) ?? false
                    self.jbhTime = try values.decodeIfPresent(Int.self, forKey: .jbhTime)
                    self.isMuteUponEntry = try values.decodeIfPresent(Bool.self, forKey: .isMuteUponEntry) ?? false
                    self.isWatermark = try values.decodeIfPresent(Bool.self, forKey: .isWatermark) ?? false
                    self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
                    self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
                    self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
                    self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
                    self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
                    self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
                    self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
                    self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
                    self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration) ?? false
                    self.isWaitingRoom = try values.decodeIfPresent(Bool.self, forKey: .isWaitingRoom) ?? false
                    self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
                    self.globalDialInNumbers = try values.decodeIfPresent([GlobalDialInNumber].self, forKey: .globalDialInNumbers)
                    self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
                    self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
                    self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
                    self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
                    self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
                    self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
                    self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
                    self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
                    self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
                    self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
                    self.encryptionType = try values.decodeIfPresent(EncryptionType.self, forKey: .encryptionType)
                    self.approvedOrDeniedCountriesOrRegions = try values.decodeIfPresent(ApprovedOrDeniedCountriesOrRegions.self, forKey: .approvedOrDeniedCountriesOrRegions)
                    self.authenticationException = try values.decodeIfPresent([AuthenticationExceptionItem].self, forKey: .authenticationException)
                    self.breakoutRoom = try values.decodeIfPresent(BreakoutRoom.self, forKey: .breakoutRoom)
                    self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
                    self.customKeys = try values.decodeIfPresent([CustomKey].self, forKey: .customKeys)
                    self.isAlternativeHostsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isAlternativeHostsEmailNotification) ?? true
                    self.isFocusMode = try values.decodeIfPresent(Bool.self, forKey: .isFocusMode)
                    self.isPrivateMeeting = try values.decodeIfPresent(Bool.self, forKey: .isPrivateMeeting)
                    self.calendarType = try values.decodeIfPresent(Int.self, forKey: .calendarType)
                }
            }

            /// Meeting status
            public enum Status: String, Codable, CaseIterable {
                case waiting
                case started
            }

            public struct TrackingField: Decodable {
                /// Label of the tracking field.
                public var field: String?
                /// Value for the field.
                public var value: String?
                /// Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
                /// 
                /// `true`: Tracking field is visible. <br>
                /// 
                /// `false`: Tracking field is not visible to the users when they look at the meeting details in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
                public var isVisible: Bool?

                public init(field: String? = nil, value: String? = nil, isVisible: Bool? = nil) {
                    self.field = field
                    self.value = value
                    self.isVisible = isVisible
                }

                private enum CodingKeys: String, CodingKey {
                    case field
                    case value
                    case isVisible = "visible"
                }
            }

            public init(agenda: String? = nil, assistantID: String? = nil, createdAt: Date? = nil, duration: Int? = nil, encryptedPassword: String? = nil, h323Password: String? = nil, hostEmail: String? = nil, hostID: String? = nil, id: Int? = nil, joinURL: String? = nil, occurrences: [Occurrence]? = nil, password: String? = nil, pmi: Int? = nil, isPreSchedule: Bool? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil, startTime: Date? = nil, startURL: String? = nil, status: Status? = nil, timezone: String? = nil, topic: String? = nil, trackingFields: [TrackingField]? = nil, type: Int? = nil, uuid: String? = nil) {
                self.agenda = agenda
                self.assistantID = assistantID
                self.createdAt = createdAt
                self.duration = duration
                self.encryptedPassword = encryptedPassword
                self.h323Password = h323Password
                self.hostEmail = hostEmail
                self.hostID = hostID
                self.id = id
                self.joinURL = joinURL
                self.occurrences = occurrences
                self.password = password
                self.pmi = pmi
                self.isPreSchedule = isPreSchedule ?? false
                self.recurrence = recurrence
                self.settings = settings
                self.startTime = startTime
                self.startURL = startURL
                self.status = status
                self.timezone = timezone
                self.topic = topic
                self.trackingFields = trackingFields
                self.type = type
                self.uuid = uuid
            }

            private enum CodingKeys: String, CodingKey {
                case agenda
                case assistantID = "assistant_id"
                case createdAt = "created_at"
                case duration
                case encryptedPassword = "encrypted_password"
                case h323Password = "h323_password"
                case hostEmail = "host_email"
                case hostID = "host_id"
                case id
                case joinURL = "join_url"
                case occurrences
                case password
                case pmi
                case isPreSchedule = "pre_schedule"
                case recurrence
                case settings
                case startTime = "start_time"
                case startURL = "start_url"
                case status
                case timezone
                case topic
                case trackingFields = "tracking_fields"
                case type
                case uuid
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.agenda = try values.decodeIfPresent(String.self, forKey: .agenda)
                self.assistantID = try values.decodeIfPresent(String.self, forKey: .assistantID)
                self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
                self.duration = try values.decodeIfPresent(Int.self, forKey: .duration)
                self.encryptedPassword = try values.decodeIfPresent(String.self, forKey: .encryptedPassword)
                self.h323Password = try values.decodeIfPresent(String.self, forKey: .h323Password)
                self.hostEmail = try values.decodeIfPresent(String.self, forKey: .hostEmail)
                self.hostID = try values.decodeIfPresent(String.self, forKey: .hostID)
                self.id = try values.decodeIfPresent(Int.self, forKey: .id)
                self.joinURL = try values.decodeIfPresent(String.self, forKey: .joinURL)
                self.occurrences = try values.decodeIfPresent([Occurrence].self, forKey: .occurrences)
                self.password = try values.decodeIfPresent(String.self, forKey: .password)
                self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
                self.isPreSchedule = try values.decodeIfPresent(Bool.self, forKey: .isPreSchedule) ?? false
                self.recurrence = try values.decodeIfPresent(Recurrence.self, forKey: .recurrence)
                self.settings = try values.decodeIfPresent(Settings.self, forKey: .settings)
                self.startTime = try values.decodeIfPresent(Date.self, forKey: .startTime)
                self.startURL = try values.decodeIfPresent(String.self, forKey: .startURL)
                self.status = try values.decodeIfPresent(Status.self, forKey: .status)
                self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
                self.topic = try values.decodeIfPresent(String.self, forKey: .topic)
                self.trackingFields = try values.decodeIfPresent([TrackingField].self, forKey: .trackingFields)
                self.type = try values.decodeIfPresent(Int.self, forKey: .type)
                self.uuid = try values.decodeIfPresent(String.self, forKey: .uuid)
            }
        }

        private func makeGetQuery(_ occurrenceID: String?, _ isShowPreviousOccurrences: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            encoder.encode(isShowPreviousOccurrences, forKey: "show_previous_occurrences")
            return encoder.items
        }

        /// Update a meeting
        ///
        /// Use this API to update a meeting's details.
        /// 
        /// **Note:** 
        /// * This API has a rate limit of **100 requests per day**. Because of this, a meeting can only be updated for a maximum of **100 times within a 24-hour period**. 
        /// * The `start_time` value **must** be a future date. If the value is omitted or a date in the past, the API ignores this value and will **not** update any recurring meetings. 
        /// * If the `start_time` value is a future date, the `recurrence` object is **required**.
        /// 
        /// **Scopes:** `meeting:write:admin`, `meeting:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(occurrenceID: String? = nil, _ body: PatchRequest) -> Request<Void> {
            .patch(path, query: makePatchQuery(occurrenceID), body: body)
        }

        private func makePatchQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }

        public struct PatchRequest: Encodable {
            /// The email address or `userId` of the user to schedule a meeting for.
            public var scheduleFor: String?
            /// Meeting object
            public var b: B

            /// Meeting object
            public struct B: Encodable {
                /// Meeting topic.
                public var topic: String?
                /// Meeting Types:<br>`1` - Instant meeting.<br>`2` - Scheduled meeting.<br>`3` - Recurring meeting with no fixed time.<br>`8` - Recurring meeting with a fixed time.
                public var type: Int?
                /// Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time): 
                /// * `true`  Create a prescheduled meeting. 
                /// * `false`  Create a regular meeting.
                public var isPreSchedule: Bool
                /// Meeting start time. When using a format like "yyyy-MM-dd'T'HH:mm:ss'Z'", always use GMT time. When using a format like "yyyy-MM-dd'T'HH:mm:ss", you should use local time and  specify the time zone. Only used for scheduled meetings and recurring meetings with a fixed time.
                public var startTime: Date?
                /// Meeting duration (minutes). Used for scheduled meetings only.
                public var duration: Int?
                /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [time zone](#timezones) list for supported time zones and their formats.
                public var timezone: String?
                /// Meeting passcode. Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *] and can have a maximum of 10 characters.
                /// 
                /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
                public var password: String?
                /// Meeting description.
                public var agenda: String?
                /// Unique identifier of the meeting template. 
                /// 
                /// Use this field if you would like to [schedule the meeting from a meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates#h_86f06cff-0852-4998-81c5-c83663c176fb). You can retrieve the value of this field by calling the [List meeting templates]() API.
                public var templateID: String?
                /// Tracking fields
                public var trackingFields: [TrackingField]?
                /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
                public var recurrence: Recurrence?
                public var settings: Settings?

                public struct TrackingField: Encodable {
                    /// Tracking fields type
                    public var field: String?
                    /// Tracking fields value
                    public var value: String?

                    public init(field: String? = nil, value: String? = nil) {
                        self.field = field
                        self.value = value
                    }
                }

                /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
                public struct Recurrence: Encodable {
                    /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                    public var type: Int
                    /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                    /// 
                    /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
                    public var repeatInterval: Int?
                    /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                    /// 
                    ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                    public var weeklyDays: WeeklyDays?
                    /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
                    /// 
                    /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                    public var monthlyDay: Int?
                    /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                    public var monthlyWeek: Int?
                    /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
                    /// 
                    /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                    public var monthlyWeekDay: Int?
                    /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
                    public var endTimes: Int?
                    /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                    public var endDateTime: Date?

                    /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                    /// 
                    ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                    public enum WeeklyDays: String, Codable, CaseIterable {
                        case _1 = "1"
                        case _2 = "2"
                        case _3 = "3"
                        case _4 = "4"
                        case _5 = "5"
                        case _6 = "6"
                        case _7 = "7"
                    }

                    public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                        self.type = type
                        self.repeatInterval = repeatInterval
                        self.weeklyDays = weeklyDays
                        self.monthlyDay = monthlyDay
                        self.monthlyWeek = monthlyWeek
                        self.monthlyWeekDay = monthlyWeekDay
                        self.endTimes = endTimes
                        self.endDateTime = endDateTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case type
                        case repeatInterval = "repeat_interval"
                        case weeklyDays = "weekly_days"
                        case monthlyDay = "monthly_day"
                        case monthlyWeek = "monthly_week"
                        case monthlyWeekDay = "monthly_week_day"
                        case endTimes = "end_times"
                        case endDateTime = "end_date_time"
                    }
                }

                public struct Settings: Encodable {
                    /// Start video when the host joins the meeting.
                    public var isHostVideo: Bool?
                    /// Start video when participants join the meeting.
                    public var isParticipantVideo: Bool?
                    /// Host meeting in China.
                    public var isCnMeeting: Bool
                    /// Host meeting in India.
                    public var isInMeeting: Bool
                    /// Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
                    public var isJoinBeforeHost: Bool
                    /// If the value of "join_before_host" field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
                    /// 
                    /// *  `0`: Allow participant to join anytime.
                    /// *  `5`: Allow participant to join 5 minutes before meeting start time.
                    ///  * `10`: Allow participant to join 10 minutes before meeting start time.
                    public var jbhTime: Int?
                    /// Mute participants upon entry.
                    public var isMuteUponEntry: Bool
                    /// Add watermark when viewing a shared screen.
                    public var isWatermark: Bool
                    /// Use a personal meeting ID. Only used for scheduled meetings and recurring meetings with no fixed time.
                    public var usePmi: Bool
                    /// Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.** <br><br>
                    /// 
                    /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                    public var approvalType: Int?
                    /// Registration type. Used for recurring meeting with fixed time only. <br>`1` Attendees register once and can attend any of the occurrences.<br>`2` Attendees need to register for each occurrence to attend.<br>`3` Attendees register once and can choose one or more occurrences to attend.
                    public var registrationType: Int?
                    /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
                    public var audio: Audio?
                    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                    public var autoRecording: AutoRecording?
                    /// Only signed in users can join this meeting.
                    /// 
                    /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
                    public var enforceLogin: Bool?
                    /// Only signed in users with specified domains can join meetings.
                    /// 
                    /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
                    public var enforceLoginDomains: String?
                    /// A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
                    public var alternativeHosts: String?
                    /// Close registration after event date
                    public var isCloseRegistration: Bool
                    /// Enable waiting room
                    public var isWaitingRoom: Bool
                    /// List of global dial-in countries
                    public var globalDialInCountries: [String]?
                    /// Global Dial-in Countries/Regions
                    public var globalDialInNumbers: [GlobalDialInNumber]?
                    /// Contact name for registration
                    public var contactName: String?
                    /// Contact email for registration
                    public var contactEmail: String?
                    /// Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
                    /// 
                    /// * `true`  Send an email notification.
                    /// * `false`  Do not send an email notification.
                    /// 
                    ///  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
                    public var isRegistrantsEmailNotification: Bool?
                    /// Whether to send registrants an email confirmation:
                    /// * `true`  Send a confirmation email.
                    /// * `false`  Do not send a confirmation email.
                    public var isRegistrantsConfirmationEmail: Bool?
                    /// `true`- Only authenticated users can join meetings.
                    public var isMeetingAuthentication: Bool?
                    /// Meeting authentication option id.
                    public var authenticationOption: String?
                    /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
                    public var authenticationDomains: String?
                    /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
                    public var authenticationName: String?
                    /// Show social share buttons on the meeting registration page.
                    /// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
                    public var isShowShareButton: Bool?
                    /// Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
                    public var allowMultipleDevices: Bool?
                    /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
                    /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
                    /// 
                    /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
                    public var encryptionType: EncryptionType?
                    /// Approve or block users from specific regions/countries from joining this meeting.
                    public var approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions?
                    /// The participants added here will receive unique meeting invite links and bypass authentication.
                    public var authenticationException: [AuthenticationExceptionItem]?
                    /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
                    public var breakoutRoom: BreakoutRoom?
                    /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                    /// 
                    /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                    public var languageInterpretation: LanguageInterpretation?
                    /// Custom keys and values assigned to the meeting.
                    public var customKeys: [CustomKey]?
                    /// Flag to determine whether to send email notifications to alternative hosts, default value is true.
                    public var isAlternativeHostsEmailNotification: Bool
                    /// Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
                    public var isFocusMode: Bool?
                    /// Whether the meeting is set as private.
                    public var isPrivateMeeting: Bool?
                    /// The calendar type: 
                    /// * `1`  Outlook calendar. 
                    /// * `2`  Google Calendar.
                    public var calendarType: Int?
                    /// A list of the meeting's invitees.
                    public var meetingInvitees: [MeetingInvitee]?

                    /// Determine how participants can join the audio portion of the meeting.<br>`both` - Both Telephony and VoIP.<br>`telephony` - Telephony only.<br>`voip` - VoIP only.
                    public enum Audio: String, Codable, CaseIterable {
                        case both
                        case telephony
                        case voip
                    }

                    /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                    public enum AutoRecording: String, Codable, CaseIterable {
                        case local
                        case cloud
                        case `none`
                    }

                    public struct GlobalDialInNumber: Encodable {
                        /// Country code. For example, BR.
                        public var country: String?
                        /// Full name of country. For example, Brazil.
                        public var countryName: String?
                        /// City of the number, if any. For example, Chicago.
                        public var city: String?
                        /// Phone number. For example, +1 2332357613.
                        public var number: String?
                        /// Type of number.
                        public var type: `Type`?

                        /// Type of number.
                        public enum `Type`: String, Codable, CaseIterable {
                            case toll
                            case tollfree
                        }

                        public init(country: String? = nil, countryName: String? = nil, city: String? = nil, number: String? = nil, type: `Type`? = nil) {
                            self.country = country
                            self.countryName = countryName
                            self.city = city
                            self.number = number
                            self.type = type
                        }

                        private enum CodingKeys: String, CodingKey {
                            case country
                            case countryName = "country_name"
                            case city
                            case number
                            case type
                        }
                    }

                    /// Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**. <br><br>The value of this field can be one of the following:<br>
                    /// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option. <br>
                    /// 
                    /// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
                    public enum EncryptionType: String, Codable, CaseIterable {
                        case enhancedEncryption = "enhanced_encryption"
                        case e2ee
                    }

                    /// Approve or block users from specific regions/countries from joining this meeting.
                    public struct ApprovedOrDeniedCountriesOrRegions: Encodable {
                        /// `true`: Setting enabled to either allow users or block users from specific regions to join your meetings. <br>
                        /// 
                        /// `false`: Setting disabled.
                        public var enable: Bool?
                        /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
                        /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
                        /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
                        public var method: Method?
                        /// List of countries/regions from where participants can join this meeting.
                        public var approvedList: [String]?
                        /// List of countries/regions from where participants can not join this meeting.
                        public var deniedList: [String]?

                        /// Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting. <br><br>
                        /// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.<br><br>
                        /// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
                        public enum Method: String, Codable, CaseIterable {
                            case approve
                            case deny
                        }

                        public init(enable: Bool? = nil, method: Method? = nil, approvedList: [String]? = nil, deniedList: [String]? = nil) {
                            self.enable = enable
                            self.method = method
                            self.approvedList = approvedList
                            self.deniedList = deniedList
                        }

                        private enum CodingKeys: String, CodingKey {
                            case enable
                            case method
                            case approvedList = "approved_list"
                            case deniedList = "denied_list"
                        }
                    }

                    public struct AuthenticationExceptionItem: Encodable {
                        /// Name of the participant.
                        public var name: String?
                        /// Email address of the participant.
                        public var email: String?

                        public init(name: String? = nil, email: String? = nil) {
                            self.name = name
                            self.email = email
                        }
                    }

                    /// Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
                    public struct BreakoutRoom: Encodable {
                        /// Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
                        public var enable: Bool?
                        /// Create room(s).
                        public var rooms: [Room]?

                        public struct Room: Encodable {
                            /// Name of the breakout room.
                            public var name: String?
                            /// Email addresses of the participants who are to be assigned to the breakout room.
                            public var participants: [String]?

                            public init(name: String? = nil, participants: [String]? = nil) {
                                self.name = name
                                self.participants = participants
                            }
                        }

                        public init(enable: Bool? = nil, rooms: [Room]? = nil) {
                            self.enable = enable
                            self.rooms = rooms
                        }
                    }

                    /// The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                    /// 
                    /// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
                    public struct LanguageInterpretation: Encodable {
                        /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
                        public var enable: Bool?
                        /// Information about the meeting's language interpreters.
                        public var interpreters: [Interpreter]?

                        public struct Interpreter: Encodable {
                            /// The interpreter's email address.
                            public var email: String?
                            /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                            /// 
                            /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                            public var languages: String?

                            public init(email: String? = nil, languages: String? = nil) {
                                self.email = email
                                self.languages = languages
                            }
                        }

                        public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                            self.enable = enable
                            self.interpreters = interpreters
                        }
                    }

                    public struct CustomKey: Encodable {
                        /// Custom key associated with the user.
                        public var key: String?
                        /// Value of the custom key associated with the user.
                        public var value: String?

                        public init(key: String? = nil, value: String? = nil) {
                            self.key = key
                            self.value = value
                        }
                    }

                    public struct MeetingInvitee: Encodable {
                        /// The invitee's email address.
                        public var email: String?

                        public init(email: String? = nil) {
                            self.email = email
                        }
                    }

                    public init(isHostVideo: Bool? = nil, isParticipantVideo: Bool? = nil, isCnMeeting: Bool? = nil, isInMeeting: Bool? = nil, isJoinBeforeHost: Bool? = nil, jbhTime: Int? = nil, isMuteUponEntry: Bool? = nil, isWatermark: Bool? = nil, usePmi: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isWaitingRoom: Bool? = nil, globalDialInCountries: [String]? = nil, globalDialInNumbers: [GlobalDialInNumber]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isRegistrantsConfirmationEmail: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, encryptionType: EncryptionType? = nil, approvedOrDeniedCountriesOrRegions: ApprovedOrDeniedCountriesOrRegions? = nil, authenticationException: [AuthenticationExceptionItem]? = nil, breakoutRoom: BreakoutRoom? = nil, languageInterpretation: LanguageInterpretation? = nil, customKeys: [CustomKey]? = nil, isAlternativeHostsEmailNotification: Bool? = nil, isFocusMode: Bool? = nil, isPrivateMeeting: Bool? = nil, calendarType: Int? = nil, meetingInvitees: [MeetingInvitee]? = nil) {
                        self.isHostVideo = isHostVideo
                        self.isParticipantVideo = isParticipantVideo
                        self.isCnMeeting = isCnMeeting ?? false
                        self.isInMeeting = isInMeeting ?? false
                        self.isJoinBeforeHost = isJoinBeforeHost ?? false
                        self.jbhTime = jbhTime
                        self.isMuteUponEntry = isMuteUponEntry ?? false
                        self.isWatermark = isWatermark ?? false
                        self.usePmi = usePmi ?? false
                        self.approvalType = approvalType
                        self.registrationType = registrationType
                        self.audio = audio
                        self.autoRecording = autoRecording
                        self.enforceLogin = enforceLogin
                        self.enforceLoginDomains = enforceLoginDomains
                        self.alternativeHosts = alternativeHosts
                        self.isCloseRegistration = isCloseRegistration ?? false
                        self.isWaitingRoom = isWaitingRoom ?? false
                        self.globalDialInCountries = globalDialInCountries
                        self.globalDialInNumbers = globalDialInNumbers
                        self.contactName = contactName
                        self.contactEmail = contactEmail
                        self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                        self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                        self.isMeetingAuthentication = isMeetingAuthentication
                        self.authenticationOption = authenticationOption
                        self.authenticationDomains = authenticationDomains
                        self.authenticationName = authenticationName
                        self.isShowShareButton = isShowShareButton
                        self.allowMultipleDevices = allowMultipleDevices
                        self.encryptionType = encryptionType
                        self.approvedOrDeniedCountriesOrRegions = approvedOrDeniedCountriesOrRegions
                        self.authenticationException = authenticationException
                        self.breakoutRoom = breakoutRoom
                        self.languageInterpretation = languageInterpretation
                        self.customKeys = customKeys
                        self.isAlternativeHostsEmailNotification = isAlternativeHostsEmailNotification ?? true
                        self.isFocusMode = isFocusMode
                        self.isPrivateMeeting = isPrivateMeeting
                        self.calendarType = calendarType
                        self.meetingInvitees = meetingInvitees
                    }

                    public func encode(to encoder: Encoder) throws {
                        var values = encoder.container(keyedBy: StringCodingKey.self)
                        try values.encodeIfPresent(isHostVideo, forKey: "host_video")
                        try values.encodeIfPresent(isParticipantVideo, forKey: "participant_video")
                        try values.encodeIfPresent(isCnMeeting, forKey: "cn_meeting")
                        try values.encodeIfPresent(isInMeeting, forKey: "in_meeting")
                        try values.encodeIfPresent(isJoinBeforeHost, forKey: "join_before_host")
                        try values.encodeIfPresent(jbhTime, forKey: "jbh_time")
                        try values.encodeIfPresent(isMuteUponEntry, forKey: "mute_upon_entry")
                        try values.encodeIfPresent(isWatermark, forKey: "watermark")
                        try values.encodeIfPresent(usePmi, forKey: "use_pmi")
                        try values.encodeIfPresent(approvalType, forKey: "approval_type")
                        try values.encodeIfPresent(registrationType, forKey: "registration_type")
                        try values.encodeIfPresent(audio, forKey: "audio")
                        try values.encodeIfPresent(autoRecording, forKey: "auto_recording")
                        try values.encodeIfPresent(enforceLogin, forKey: "enforce_login")
                        try values.encodeIfPresent(enforceLoginDomains, forKey: "enforce_login_domains")
                        try values.encodeIfPresent(alternativeHosts, forKey: "alternative_hosts")
                        try values.encodeIfPresent(isCloseRegistration, forKey: "close_registration")
                        try values.encodeIfPresent(isWaitingRoom, forKey: "waiting_room")
                        try values.encodeIfPresent(globalDialInCountries, forKey: "global_dial_in_countries")
                        try values.encodeIfPresent(globalDialInNumbers, forKey: "global_dial_in_numbers")
                        try values.encodeIfPresent(contactName, forKey: "contact_name")
                        try values.encodeIfPresent(contactEmail, forKey: "contact_email")
                        try values.encodeIfPresent(isRegistrantsEmailNotification, forKey: "registrants_email_notification")
                        try values.encodeIfPresent(isRegistrantsConfirmationEmail, forKey: "registrants_confirmation_email")
                        try values.encodeIfPresent(isMeetingAuthentication, forKey: "meeting_authentication")
                        try values.encodeIfPresent(authenticationOption, forKey: "authentication_option")
                        try values.encodeIfPresent(authenticationDomains, forKey: "authentication_domains")
                        try values.encodeIfPresent(authenticationName, forKey: "authentication_name")
                        try values.encodeIfPresent(isShowShareButton, forKey: "show_share_button")
                        try values.encodeIfPresent(allowMultipleDevices, forKey: "allow_multiple_devices")
                        try values.encodeIfPresent(encryptionType, forKey: "encryption_type")
                        try values.encodeIfPresent(approvedOrDeniedCountriesOrRegions, forKey: "approved_or_denied_countries_or_regions")
                        try values.encodeIfPresent(authenticationException, forKey: "authentication_exception")
                        try values.encodeIfPresent(breakoutRoom, forKey: "breakout_room")
                        try values.encodeIfPresent(languageInterpretation, forKey: "language_interpretation")
                        try values.encodeIfPresent(customKeys, forKey: "custom_keys")
                        try values.encodeIfPresent(isAlternativeHostsEmailNotification, forKey: "alternative_hosts_email_notification")
                        try values.encodeIfPresent(isFocusMode, forKey: "focus_mode")
                        try values.encodeIfPresent(isPrivateMeeting, forKey: "private_meeting")
                        try values.encodeIfPresent(calendarType, forKey: "calendar_type")
                        try values.encodeIfPresent(meetingInvitees, forKey: "meeting_invitees")
                    }
                }

                public init(topic: String? = nil, type: Int? = nil, isPreSchedule: Bool? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, templateID: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil) {
                    self.topic = topic
                    self.type = type
                    self.isPreSchedule = isPreSchedule ?? false
                    self.startTime = startTime
                    self.duration = duration
                    self.timezone = timezone
                    self.password = password
                    self.agenda = agenda
                    self.templateID = templateID
                    self.trackingFields = trackingFields
                    self.recurrence = recurrence
                    self.settings = settings
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(topic, forKey: "topic")
                    try values.encodeIfPresent(type, forKey: "type")
                    try values.encodeIfPresent(isPreSchedule, forKey: "pre_schedule")
                    try values.encodeIfPresent(startTime, forKey: "start_time")
                    try values.encodeIfPresent(duration, forKey: "duration")
                    try values.encodeIfPresent(timezone, forKey: "timezone")
                    try values.encodeIfPresent(password, forKey: "password")
                    try values.encodeIfPresent(agenda, forKey: "agenda")
                    try values.encodeIfPresent(templateID, forKey: "template_id")
                    try values.encodeIfPresent(trackingFields, forKey: "tracking_fields")
                    try values.encodeIfPresent(recurrence, forKey: "recurrence")
                    try values.encodeIfPresent(settings, forKey: "settings")
                }
            }

            public init(scheduleFor: String? = nil, b: B) {
                self.scheduleFor = scheduleFor
                self.b = b
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(scheduleFor, forKey: "schedule_for")
                try values.encode(b, forKey: "b")
            }
        }

        /// Delete a meeting
        ///
        /// Delete a meeting.<br><br>
        /// **Scopes:** `meeting:write:admin` `meeting:write`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            public var occurrenceID: String?
            public var isScheduleForReminder: Bool?
            public var cancelMeetingReminder: String?

            public init(occurrenceID: String? = nil, isScheduleForReminder: Bool? = nil, cancelMeetingReminder: String? = nil) {
                self.occurrenceID = occurrenceID
                self.isScheduleForReminder = isScheduleForReminder
                self.cancelMeetingReminder = cancelMeetingReminder
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(occurrenceID, forKey: "occurrence_id")
                encoder.encode(isScheduleForReminder, forKey: "schedule_for_reminder")
                encoder.encode(cancelMeetingReminder, forKey: "cancel_meeting_reminder")
                return encoder.items
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/meetings/{meetingId}/status`
        public let path: String

        /// Update meeting status
        ///
        /// Update the status of a meeting.<br><br>
        /// **Scopes:** `meeting:write:admin` `meeting:write`
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func put(action: PutRequest.Action? = nil) -> Request<Void> {
            .put(path, body: PutRequest(action: action))
        }

        public struct PutRequest: Encodable {
            /// `end` - End a meeting.<br>
            /// `recover` - [Recover](https://support.zoom.us/hc/en-us/articles/360038297111-Recover-a-deleted-meeting) a deleted meeting.
            public var action: Action?

            /// `end` - End a meeting.<br>
            /// `recover` - [Recover](https://support.zoom.us/hc/en-us/articles/360038297111-Recover-a-deleted-meeting) a deleted meeting.
            public enum Action: String, Codable, CaseIterable {
                case end
                case recover
            }

            public init(action: Action? = nil) {
                self.action = action
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var registrants: Registrants {
        Registrants(path: path + "/registrants")
    }

    public struct Registrants {
        /// Path: `/meetings/{meetingId}/registrants`
        public let path: String

        /// List meeting registrants
        ///
        /// A host or a user with admin permission can require [registration for a Zoom meeting](https://support.zoom.us/hc/en-us/articles/211579443-Registration-for-Meetings). Use this API to list users that have registered for a meeting.<br><br>
        /// **Scopes**: `meeting:read:admin` `meeting:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Registration List
        ///
        /// List of users.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var occurrenceID: String?
            public var status: Status?
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public enum Status: String, Codable, CaseIterable {
                case pending
                case approved
                case denied
            }

            public init(occurrenceID: String? = nil, status: Status? = nil, pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.occurrenceID = occurrenceID
                self.status = status
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(occurrenceID, forKey: "occurrence_id")
                encoder.encode(status, forKey: "status")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Add meeting registrant
        ///
        /// Register a participant for a meeting.<br><br> Note that there is a maximum limit of 4999 registrants per meeting and users will see an error if the capacity has reached.
        /// 
        /// **Prerequisite:**<br>
        /// * Host user type must be "Licensed".
        /// 
        /// **Scopes:** `meeting:write:admin` `meeting:write`
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(occurrenceIDs: String? = nil, _ body: PostRequest) -> Request<PostResponse> {
            .post(path, query: makePostQuery(occurrenceIDs), body: body)
        }

        public struct PostResponse: Decodable {
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Unique URL for this registrant to join the meeting. This URL should only be shared with the registrant for whom the API request was made.
            /// If the meeting was [created](https://marketplace.zoom.us/docs/api-reference/zoom-api/meetings/meetingcreate) with manual approval type (`approval_type`: 1), the join URL will not be returned in the response.
            public var joinURL: String?
            /// Unique identifier of the registrant.
            public var registrantID: String?
            /// The start time for the meeting.
            public var startTime: String?
            /// Topic of the meeting.
            public var topic: String?

            public init(id: Int? = nil, joinURL: String? = nil, registrantID: String? = nil, startTime: String? = nil, topic: String? = nil) {
                self.id = id
                self.joinURL = joinURL
                self.registrantID = registrantID
                self.startTime = startTime
                self.topic = topic
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case joinURL = "join_url"
                case registrantID = "registrant_id"
                case startTime = "start_time"
                case topic
            }
        }

        private func makePostQuery(_ occurrenceIDs: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceIDs, forKey: "occurrence_ids")
            return encoder.items
        }

        /// Registrant.
        public struct PostRequest: Encodable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?
            /// Registrant's language preference for confirmation  emails. The value can be one of the following:
            /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
            public var language: String?
            public var isAutoApprove: Bool?

            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Encodable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil, language: String? = nil, isAutoApprove: Bool? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
                self.language = language
                self.isAutoApprove = isAutoApprove
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
                try values.encodeIfPresent(language, forKey: "language")
                try values.encodeIfPresent(isAutoApprove, forKey: "auto_approve")
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Registrants {
    public func registrantID(_ registrantID: String) -> WithRegistrantID {
        WithRegistrantID(path: "\(path)/\(registrantID)")
    }

    public struct WithRegistrantID {
        /// Path: `/meetings/{meetingId}/registrants/{registrantId}`
        public let path: String

        /// Get a meeting registrant
        ///
        /// Use this API to get details on a specific user who has registered for the meeting. A host or a user with administrative permissions can require [registration for Zoom meetings](https://support.zoom.us/hc/en-us/articles/211579443-Registration-for-Meetings).
        /// 
        /// **Scopes:** `meeting:read:admin`, `meeting:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * The account must have a Meeting plan
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Meeting Registrant
        public struct GetResponse: Decodable {
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's questions and comments.
            public var comments: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?
            /// The registrant's email address.
            public var email: String
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's ZIP or postal code.
            public var zip: String?

            /// Information about custom questions.
            public struct CustomQuestion: Decodable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            public init(address: String? = nil, city: String? = nil, comments: String? = nil, country: String? = nil, customQuestions: [CustomQuestion]? = nil, email: String, firstName: String, industry: String? = nil, jobTitle: String? = nil, lastName: String? = nil, noOfEmployees: NoOfEmployees? = nil, org: String? = nil, phone: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, state: String? = nil, status: Status? = nil, zip: String? = nil) {
                self.address = address
                self.city = city
                self.comments = comments
                self.country = country
                self.customQuestions = customQuestions
                self.email = email
                self.firstName = firstName
                self.industry = industry
                self.jobTitle = jobTitle
                self.lastName = lastName
                self.noOfEmployees = noOfEmployees
                self.org = org
                self.phone = phone
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.state = state
                self.status = status
                self.zip = zip
            }

            private enum CodingKeys: String, CodingKey {
                case address
                case city
                case comments
                case country
                case customQuestions = "custom_questions"
                case email
                case firstName = "first_name"
                case industry
                case jobTitle = "job_title"
                case lastName = "last_name"
                case noOfEmployees = "no_of_employees"
                case org
                case phone
                case purchasingTimeFrame = "purchasing_time_frame"
                case roleInPurchaseProcess = "role_in_purchase_process"
                case state
                case status
                case zip
            }
        }

        /// Delete a meeting registrant
        ///
        /// Delete a meeting registrant.<br><br>
        /// **Scopes**: `meeting:write:admin` `meeting:write`<br>
        ///  <br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func delete(occurrenceID: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(occurrenceID))
        }

        private func makeDeleteQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }
    }
}

extension Paths.Meetings.WithMeetingID.Registrants {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/meetings/{meetingId}/registrants/status`
        public let path: String

        /// Update registrant's status
        ///
        /// Update a meeting registrant's status by either approving, cancelling or denying a registrant from joining the meeting.<br><br>
        /// **Scopes:** `meeting:write:admin` `meeting:write`
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(occurrenceID: String? = nil, _ body: PutRequest) -> Request<Void> {
            .put(path, query: makePutQuery(occurrenceID), body: body)
        }

        private func makePutQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// Registrant Status:<br>`approve` - Approve registrant.<br>`cancel` - Cancel previously approved registrant's registration.<br>`deny` - Deny registrant.
            public var action: Action
            /// List of registrants.
            public var registrants: [Registrant]?

            /// Registrant Status:<br>`approve` - Approve registrant.<br>`cancel` - Cancel previously approved registrant's registration.<br>`deny` - Deny registrant.
            public enum Action: String, Codable, CaseIterable {
                case approve
                case cancel
                case deny
            }

            public struct Registrant: Encodable {
                public var id: String?
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(action: Action, registrants: [Registrant]? = nil) {
                self.action = action
                self.registrants = registrants
            }
        }
    }
}

extension Paths.PastMeetings {
    public func meetingUUID(_ meetingUUID: String) -> WithMeetingUUID {
        WithMeetingUUID(path: "\(path)/\(meetingUUID)")
    }

    public struct WithMeetingUUID {
        /// Path: `/past_meetings/{meetingUUID}`
        public let path: String

        /// Get past meeting details
        ///
        /// Use this API to get information about a past meeting. 
        /// 
        ///  **Scopes:** `meeting:read:admin`, `meeting:read` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The meeting's UUID. You **must** double encode this value if the meeting UUID begins with a `/` character or contains the `//` character.
            public var uuid: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Host ID.
            public var hostID: String?
            /// Meeting type.
            public var type: Int?
            /// Meeting topic.
            public var topic: String?
            /// User display name.
            public var userName: String?
            /// User email.
            public var userEmail: String?
            /// Meeting start time (GMT).
            public var startTime: Date?
            /// Meeting end time (GMT).
            public var endTime: Date?
            /// Meeting duration.
            public var duration: Int?
            /// Sum of meeting minutes from all participants in the meeting.
            public var totalMinutes: Int?
            /// Number of meeting participants.
            public var participantsCount: Int?
            /// The meeting host's department.
            public var dept: String?
            /// Whether the meeting was created directly through Zoom or via an API request: 
            /// * If the meeting was created via an OAuth app, this field returns the OAuth app's name. 
            /// * If the meeting was created via JWT or the Zoom Web Portal, this returns the `Zoom` value.
            public var source: String?

            public init(uuid: String? = nil, id: Int? = nil, hostID: String? = nil, type: Int? = nil, topic: String? = nil, userName: String? = nil, userEmail: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: Int? = nil, totalMinutes: Int? = nil, participantsCount: Int? = nil, dept: String? = nil, source: String? = nil) {
                self.uuid = uuid
                self.id = id
                self.hostID = hostID
                self.type = type
                self.topic = topic
                self.userName = userName
                self.userEmail = userEmail
                self.startTime = startTime
                self.endTime = endTime
                self.duration = duration
                self.totalMinutes = totalMinutes
                self.participantsCount = participantsCount
                self.dept = dept
                self.source = source
            }

            private enum CodingKeys: String, CodingKey {
                case uuid
                case id
                case hostID = "host_id"
                case type
                case topic
                case userName = "user_name"
                case userEmail = "user_email"
                case startTime = "start_time"
                case endTime = "end_time"
                case duration
                case totalMinutes = "total_minutes"
                case participantsCount = "participants_count"
                case dept
                case source
            }
        }
    }
}

extension Paths.PastMeetings.WithMeetingUUID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/past_meetings/{meetingUUID}/participants`
        public let path: String

        /// Get past meeting participants
        ///
        /// Retrieve information on participants from a past meeting. <br><br>
        /// **Scopes:** `meeting:read:admin` `meeting:read`
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// **Prerequisites:**<br>
        /// * Paid account on a Pro or higher plan.
        /// 
        /// <br> <br>  **Note**: Please double encode your UUID when using this API if the UUID begins with a '/'or contains '//' in it.
        public func get(pageSize: Int? = nil, nextPageToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, nextPageToken))
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Array of meeting participant objects.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// Universally unique identifier of the Participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.
                public var id: String?
                /// Participant display name.
                public var name: String?
                /// Email address of the user. This field will be returned if the user logged into Zoom to join the meeting.
                public var userEmail: String?

                public init(id: String? = nil, name: String? = nil, userEmail: String? = nil) {
                    self.id = id
                    self.name = name
                    self.userEmail = userEmail
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case userEmail = "user_email"
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ nextPageToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(nextPageToken, forKey: "next_page_token")
            return encoder.items
        }
    }
}

extension Paths.PastMeetings.WithMeetingID {
    public var instances: Instances {
        Instances(path: path + "/instances")
    }

    public struct Instances {
        /// Path: `/past_meetings/{meetingId}/instances`
        public let path: String

        /// List ended meeting instances
        ///
        /// Get a list of ended meeting instances<br><br>
        /// **Scopes:** `meeting:read:admin` `meeting:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var polls: Polls {
        Polls(path: path + "/polls")
    }

    public struct Polls {
        /// Path: `/meetings/{meetingId}/polls`
        public let path: String

        /// List meeting polls
        ///
        /// Polls allow the meeting host to survey attendees. Use this API to list [polls](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings) of a meeting.<br><br>
        /// 
        /// **Scopes**: `meeting:read:admin` `meeting:read`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites**:<br>
        /// * Host user type must be **Pro** or higher plan.
        /// * Meeting must be a scheduled meeting. Instant meetings do not have polling features enabled.
        public func get(isAnonymous: Bool? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(isAnonymous))
        }

        private func makeGetQuery(_ isAnonymous: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isAnonymous, forKey: "anonymous")
            return encoder.items
        }

        /// Create a meeting poll
        ///
        /// Polls allow the meeting host to survey attendees. Use this API to create a [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings) for a meeting.<br><br>
        /// 
        /// **Scopes**: `meeting:write:admin` `meeting:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites**:<br>
        /// * Host user type must be **Pro** or higher plan.
        /// * Polling feature must be enabled in the host's account.
        /// * Meeting must be a scheduled meeting. Instant meetings do not have polling features enabled.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of created Meeting Poll
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Meeting Poll ID
            public var id: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Information about the poll's questions.
            public var questions: [Question]?
            /// Status of the Meeting Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public var status: Status?
            /// The poll's title, up to 64 characters.
            public var title: String?

            public struct Question: Decodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Decodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.name = try values.decodeIfPresent(String.self, forKey: .name)
                    self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                    self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                    self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                    self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                    self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
                    self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
                    self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                    self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                    self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
                    self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                    self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                    self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                    self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                }
            }

            /// Status of the Meeting Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public enum Status: String, Codable, CaseIterable {
                case notstart
                case started
                case ended
                case sharing
            }

            public init(isAnonymous: Bool? = nil, id: String? = nil, pollType: Int? = nil, questions: [Question]? = nil, status: Status? = nil, title: String? = nil) {
                self.isAnonymous = isAnonymous ?? false
                self.id = id
                self.pollType = pollType
                self.questions = questions
                self.status = status
                self.title = title
            }

            private enum CodingKeys: String, CodingKey {
                case isAnonymous = "anonymous"
                case id
                case pollType = "poll_type"
                case questions
                case status
                case title
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
                self.id = try values.decodeIfPresent(String.self, forKey: .id)
                self.pollType = try values.decodeIfPresent(Int.self, forKey: .pollType)
                self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
                self.status = try values.decodeIfPresent(Status.self, forKey: .status)
                self.title = try values.decodeIfPresent(String.self, forKey: .title)
            }
        }

        public struct PostRequest: Encodable {
            /// The poll's title, up to 64 characters.
            public var title: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Information about the poll's questions.
            public var questions: [Question]?

            public struct Question: Encodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Encodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }
            }

            public init(title: String? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                self.title = title
                self.pollType = pollType
                self.isAnonymous = isAnonymous ?? false
                self.questions = questions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(title, forKey: "title")
                try values.encodeIfPresent(pollType, forKey: "poll_type")
                try values.encodeIfPresent(isAnonymous, forKey: "anonymous")
                try values.encodeIfPresent(questions, forKey: "questions")
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Polls {
    public func pollID(_ pollID: String) -> WithPollID {
        WithPollID(path: "\(path)/\(pollID)")
    }

    public struct WithPollID {
        /// Path: `/meetings/{meetingId}/polls/{pollId}`
        public let path: String

        /// Get a meeting poll
        ///
        /// Polls allow the meeting host to survey attendees. Use this API to get information about a specific meeting [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings).<br><br>
        /// **Scopes**: `meeting:read:admin` `meeting:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Meeting Poll ID
            public var id: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Information about the poll's questions.
            public var questions: [Question]?
            /// Status of the Meeting Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public var status: Status?
            /// The poll's title, up to 64 characters.
            public var title: String?

            public struct Question: Decodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Decodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.name = try values.decodeIfPresent(String.self, forKey: .name)
                    self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                    self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                    self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                    self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                    self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
                    self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
                    self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                    self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                    self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
                    self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                    self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                    self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                    self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                }
            }

            /// Status of the Meeting Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public enum Status: String, Codable, CaseIterable {
                case notstart
                case started
                case ended
                case sharing
            }

            public init(isAnonymous: Bool? = nil, id: String? = nil, pollType: Int? = nil, questions: [Question]? = nil, status: Status? = nil, title: String? = nil) {
                self.isAnonymous = isAnonymous ?? false
                self.id = id
                self.pollType = pollType
                self.questions = questions
                self.status = status
                self.title = title
            }

            private enum CodingKeys: String, CodingKey {
                case isAnonymous = "anonymous"
                case id
                case pollType = "poll_type"
                case questions
                case status
                case title
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
                self.id = try values.decodeIfPresent(String.self, forKey: .id)
                self.pollType = try values.decodeIfPresent(Int.self, forKey: .pollType)
                self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
                self.status = try values.decodeIfPresent(Status.self, forKey: .status)
                self.title = try values.decodeIfPresent(String.self, forKey: .title)
            }
        }

        /// Update a meeting poll
        ///
        /// Polls allow the meeting host to survey attendees. Use this API to update information of a specific meeting [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings)<br><br>
        /// **Scopes**: `meeting:write:admin` `meeting:write`
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The poll's title, up to 64 characters.
            public var title: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Information about the poll's questions.
            public var questions: [Question]?

            public struct Question: Encodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Encodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }
            }

            public init(title: String? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                self.title = title
                self.pollType = pollType
                self.isAnonymous = isAnonymous ?? false
                self.questions = questions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(title, forKey: "title")
                try values.encodeIfPresent(pollType, forKey: "poll_type")
                try values.encodeIfPresent(isAnonymous, forKey: "anonymous")
                try values.encodeIfPresent(questions, forKey: "questions")
            }
        }

        /// Delete a meeting poll
        ///
        /// Polls allow the meeting host to survey attendees. Use this API to delete a meeting [poll](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings).<br>
        /// **Scopes**: `meeting:write:admin` `meeting:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>
        /// **Prerequisites**:<br>
        /// * Host user type must be **Pro**.
        /// * Polling feature should be enabled in the host's account.
        /// * Meeting must be a scheduled meeting. Instant meetings do not have polling features enabled.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Meetings.WithMeetingID.Registrants {
    public var questions: Questions {
        Questions(path: path + "/questions")
    }

    public struct Questions {
        /// Path: `/meetings/{meetingId}/registrants/questions`
        public let path: String

        /// List registration questions
        ///
        /// List registration questions that will be displayed to users while [registering for a meeting](https://support.zoom.us/hc/en-us/articles/211579443-Registration-for-Meetings).<br>
        /// 
        /// **Scopes:** `meeting:read`, `meeting:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Array of Registrant Custom Questions
            public var customQuestions: [CustomQuestion]?
            /// Array of Registrant Questions
            public var questions: [Question]?

            public struct CustomQuestion: Decodable {
                /// Title of the custom question.
                public var title: String?
                /// Type of the question being asked.
                public var type: `Type`?
                /// Indicates whether or not the custom question is required to be answered by participants or not.
                public var isRequired: Bool?
                /// Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.
                public var answers: [String]?

                /// Type of the question being asked.
                public enum `Type`: String, Codable, CaseIterable {
                    case short
                    case single
                }

                public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
                    self.title = title
                    self.type = type
                    self.isRequired = isRequired
                    self.answers = answers
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case type
                    case isRequired = "required"
                    case answers
                }
            }

            public struct Question: Decodable {
                /// Field name of the question.
                public var fieldName: FieldName?
                /// Indicates whether or not the displayed fields are required to be filled out by registrants.
                public var isRequired: Bool?

                /// Field name of the question.
                public enum FieldName: String, Codable, CaseIterable {
                    case address
                    case city
                    case country
                    case zip
                    case state
                    case phone
                    case industry
                    case org
                    case jobTitle = "job_title"
                    case purchasingTimeFrame = "purchasing_time_frame"
                    case roleInPurchaseProcess = "role_in_purchase_process"
                    case noOfEmployees = "no_of_employees"
                    case comments
                }

                public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
                    self.fieldName = fieldName
                    self.isRequired = isRequired
                }

                private enum CodingKeys: String, CodingKey {
                    case fieldName = "field_name"
                    case isRequired = "required"
                }
            }

            public init(customQuestions: [CustomQuestion]? = nil, questions: [Question]? = nil) {
                self.customQuestions = customQuestions
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case customQuestions = "custom_questions"
                case questions
            }
        }

        /// Update registration questions
        ///
        /// Update registration questions that will be displayed to users while [registering for a meeting](https://support.zoom.us/hc/en-us/articles/211579443-Registration-for-Meetings).<br><br>
        /// **Scopes:** `meeting:write`, `meeting:write:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// Array of Registrant Questions
            public var questions: [Question]?
            /// Array of Registrant Custom Questions
            public var customQuestions: [CustomQuestion]?

            public struct Question: Encodable {
                /// Field name of the question.
                public var fieldName: FieldName?
                /// Indicates whether or not the displayed fields are required to be filled out by registrants.
                public var isRequired: Bool?

                /// Field name of the question.
                public enum FieldName: String, Codable, CaseIterable {
                    case address
                    case city
                    case country
                    case zip
                    case state
                    case phone
                    case industry
                    case org
                    case jobTitle = "job_title"
                    case purchasingTimeFrame = "purchasing_time_frame"
                    case roleInPurchaseProcess = "role_in_purchase_process"
                    case noOfEmployees = "no_of_employees"
                    case comments
                }

                public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
                    self.fieldName = fieldName
                    self.isRequired = isRequired
                }

                private enum CodingKeys: String, CodingKey {
                    case fieldName = "field_name"
                    case isRequired = "required"
                }
            }

            public struct CustomQuestion: Encodable {
                /// Title of the custom question.
                public var title: String?
                /// Type of the question being asked.
                public var type: `Type`?
                /// Indicates whether or not the custom question is required to be answered by participants or not.
                public var isRequired: Bool?
                /// Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.
                public var answers: [String]?

                /// Type of the question being asked.
                public enum `Type`: String, Codable, CaseIterable {
                    case short
                    case single
                }

                public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
                    self.title = title
                    self.type = type
                    self.isRequired = isRequired
                    self.answers = answers
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case type
                    case isRequired = "required"
                    case answers
                }
            }

            public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.questions = questions
                self.customQuestions = customQuestions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(questions, forKey: "questions")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var invitation: Invitation {
        Invitation(path: path + "/invitation")
    }

    public struct Invitation {
        /// Path: `/meetings/{meetingId}/invitation`
        public let path: String

        /// Get meeting invitation
        ///
        /// Retrieve the meeting invite note that was sent for a specific meeting.<br><br>
        /// **Scopes:** `meeting:read:admin` `meeting:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Meeting Invitation
        ///
        /// Meeting invitation details.
        public struct GetResponse: Decodable {
            /// Meeting invitation.
            public var invitation: String?

            public init(invitation: String? = nil) {
                self.invitation = invitation
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var livestream: Livestream {
        Livestream(path: path + "/livestream")
    }

    public struct Livestream {
        /// Path: `/meetings/{meetingId}/livestream`
        public let path: String

        /// Get live stream details
        ///
        /// Zoom allows users to [live stream a meeting](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service) to a custom platform. Use this API to get a meeting's live stream configuration details such as Stream URL, Stream Key and Page URL.<br><br>
        /// **Prerequisites:**<br>
        /// * Meeting host must be a licensed user with a Pro or higher plan.<br>
        /// * Live streaming details must have been [configured](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service#h_01589a6f-a40a-4e18-a448-cb746e52ebc5) for the meeting.<br><br>
        /// **Scopes:** `meeting:read:admin` `meeting:read`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Stream URL.
            public var streamURL: String?
            /// Stream Key.
            public var streamKey: String?
            /// Live streaming page URL. This is the URL using which anyone can view the live stream of the meeting.
            public var pageURL: String?

            public init(streamURL: String? = nil, streamKey: String? = nil, pageURL: String? = nil) {
                self.streamURL = streamURL
                self.streamKey = streamKey
                self.pageURL = pageURL
            }

            private enum CodingKeys: String, CodingKey {
                case streamURL = "stream_url"
                case streamKey = "stream_key"
                case pageURL = "page_url"
            }
        }

        /// Update a live stream
        ///
        /// Use this API to update a meeting's live stream information. Zoom allows users to [live stream a meeting](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service) to a custom platform.
        /// 
        /// **Scopes:** `meeting:write:admin`, `meeting:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Meeting host must have a Pro license.
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Meeting live stream.
        public struct PatchRequest: Encodable {
            /// Streaming URL.
            public var streamURL: String
            /// Stream name and key.
            public var streamKey: String
            /// The live stream page URL.
            public var pageURL: URL

            public init(streamURL: String, streamKey: String, pageURL: URL) {
                self.streamURL = streamURL
                self.streamKey = streamKey
                self.pageURL = pageURL
            }

            private enum CodingKeys: String, CodingKey {
                case streamURL = "stream_url"
                case streamKey = "stream_key"
                case pageURL = "page_url"
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID.Livestream {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/meetings/{meetingId}/livestream/status`
        public let path: String

        /// Update Live Stream Status
        ///
        /// Zoom allows users to [live stream a meeting](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service) to a custom platform. Use this API to update the status of a meeting's live stream.<br><br>
        /// **Prerequisites:**<br>
        /// * Meeting host must have a Pro license.<br>
        /// **Scopes:** `meeting:write:admin` `meeting:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Meeting live stream status.
        public struct PatchRequest: Encodable {
            /// Update the status of a live stream.
            /// 
            /// The value can be one of the following:<br>
            /// `start`: Start a live stream. <br>
            /// `stop`: Stop an ongoing live stream.
            public var action: Action?
            /// Update the settings of a live streaming session. The settings can only be updated for a live stream that has been stopped. You can not update the settings of an ongoing live stream.
            public var settings: Settings?

            /// Update the status of a live stream.
            /// 
            /// The value can be one of the following:<br>
            /// `start`: Start a live stream. <br>
            /// `stop`: Stop an ongoing live stream.
            public enum Action: String, Codable, CaseIterable {
                case start
                case stop
            }

            /// Update the settings of a live streaming session. The settings can only be updated for a live stream that has been stopped. You can not update the settings of an ongoing live stream.
            public struct Settings: Encodable {
                /// Display the name of the active speaker during a live stream.
                public var isActiveSpeakerName: Bool?
                /// Display name of the live stream.
                public var displayName: String?

                public init(isActiveSpeakerName: Bool? = nil, displayName: String? = nil) {
                    self.isActiveSpeakerName = isActiveSpeakerName
                    self.displayName = displayName
                }

                private enum CodingKeys: String, CodingKey {
                    case isActiveSpeakerName = "active_speaker_name"
                    case displayName = "display_name"
                }
            }

            public init(action: Action? = nil, settings: Settings? = nil) {
                self.action = action
                self.settings = settings
            }
        }
    }
}

extension Paths.PastMeetings.WithMeetingID {
    public var polls: Polls {
        Polls(path: path + "/polls")
    }

    public struct Polls {
        /// Path: `/past_meetings/{meetingId}/polls`
        public let path: String

        /// List past meeting's poll results
        ///
        /// [Polls](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings) allow the meeting host to survey attendees. Use this API to list poll results of a meeting.<br><br>
        /// 
        /// **Scopes**: `meeting:read:admin`, `meeting:read`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` <br>
        /// **Prerequisites**:<br>
        /// * Host user type must be **Pro**.
        /// * Meeting must be a scheduled meeting. Instant meetings do not have polling features enabled.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Meeting UUID.
            public var uuid: String?
            /// The start time of the meeting.
            public var startTime: Date?
            public var questions: [Question]?

            public struct Question: Decodable {
                /// Name of the user who submitted answers to the poll. If "anonymous" option is enabled for a poll, the participant's polling information will be kept anonymous and the value of `name` field will be "Anonymous Attendee".
                public var name: String?
                /// Email address of the user who submitted answers to the poll.
                public var email: String?
                public var questionDetails: [QuestionDetail]?

                public struct QuestionDetail: Decodable {
                    /// Question asked during the poll.
                    public var question: String?
                    /// Answer submitted by the user.
                    public var answer: String?
                    /// Unique identifier of the poll.
                    public var pollingID: String?
                    /// Date and time at which the answer to the poll was submitted.
                    public var dateTime: Date?

                    public init(question: String? = nil, answer: String? = nil, pollingID: String? = nil, dateTime: Date? = nil) {
                        self.question = question
                        self.answer = answer
                        self.pollingID = pollingID
                        self.dateTime = dateTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case question
                        case answer
                        case pollingID = "polling_id"
                        case dateTime = "date_time"
                    }
                }

                public init(name: String? = nil, email: String? = nil, questionDetails: [QuestionDetail]? = nil) {
                    self.name = name
                    self.email = email
                    self.questionDetails = questionDetails
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case email
                    case questionDetails = "question_details"
                }
            }

            public init(id: Int? = nil, uuid: String? = nil, startTime: Date? = nil, questions: [Question]? = nil) {
                self.id = id
                self.uuid = uuid
                self.startTime = startTime
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case uuid
                case startTime = "start_time"
                case questions
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var batchRegistrants: BatchRegistrants {
        BatchRegistrants(path: path + "/batch_registrants")
    }

    public struct BatchRegistrants {
        /// Path: `/meetings/{meetingId}/batch_registrants`
        public let path: String

        /// Perform batch registration
        ///
        /// Register up to 30 registrants at once for a meeting that requires [registration](https://support.zoom.us/hc/en-us/articles/211579443-Registration-for-Meetings). <br>
        /// 
        /// **Prerequisites:**<br>
        /// * The meeting host must be a Licensed user.
        /// * The meeting must require registration and should be of type `2`, i.e., they should be scheduled meetings. Instant meetings and Recurring meetings are not supported by this API.<br><br>
        /// **Scope:** `meeting:write`, `meeting:write:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var registrants: [Registrant]?

            public struct Registrant: Decodable {
                /// Unique identifier of the registrant.
                public var registrantID: String?
                /// Email address of the registrant.
                public var email: String?
                /// Unique URL using which registrant can join the meeting.
                public var joinURL: String?

                public init(registrantID: String? = nil, email: String? = nil, joinURL: String? = nil) {
                    self.registrantID = registrantID
                    self.email = email
                    self.joinURL = joinURL
                }

                private enum CodingKeys: String, CodingKey {
                    case registrantID = "registrant_id"
                    case email
                    case joinURL = "join_url"
                }
            }

            public init(registrants: [Registrant]? = nil) {
                self.registrants = registrants
            }
        }

        public struct PostRequest: Encodable {
            /// If a meeting was scheduled with approval_type `1` (manual approval), but you would like to automatically approve the registrants that are added via this API, you can set the value of this field to `true`. 
            /// 
            /// You **cannot** use this field to change approval setting for a meeting  that was originally scheduled with approval_type `0` (automatic approval).
            public var isAutoApprove: Bool?
            public var registrants: [Registrant]?

            public struct Registrant: Encodable {
                /// First name of the registrant.
                public var firstName: String
                /// Last name of the registrant.
                public var lastName: String?
                /// Email address of the registrant.
                public var email: String

                public init(firstName: String, lastName: String? = nil, email: String) {
                    self.firstName = firstName
                    self.lastName = lastName
                    self.email = email
                }

                private enum CodingKeys: String, CodingKey {
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case email
                }
            }

            public init(isAutoApprove: Bool? = nil, registrants: [Registrant]? = nil) {
                self.isAutoApprove = isAutoApprove
                self.registrants = registrants
            }

            private enum CodingKeys: String, CodingKey {
                case isAutoApprove = "auto_approve"
                case registrants
            }
        }
    }
}

extension Paths {
    public static var liveMeetings: LiveMeetings {
        LiveMeetings(path: "/live_meetings")
    }

    public struct LiveMeetings {
        /// Path: `/live_meetings`
        public let path: String
    }
}

extension Paths.LiveMeetings {
    public func meetingID(_ meetingID: String) -> WithMeetingID {
        WithMeetingID(path: "\(path)/\(meetingID)")
    }

    public struct WithMeetingID {
        /// Path: `/live_meetings/{meetingId}`
        public let path: String
    }
}

extension Paths.LiveMeetings.WithMeetingID {
    public var events: Events {
        Events(path: path + "/events")
    }

    public struct Events {
        /// Path: `/live_meetings/{meetingId}/events`
        public let path: String

        /// Use in-meeting cloud recording controls
        ///
        /// Use this API to control [in-meeting](https://support.zoom.us/hc/en-us/articles/360021921032-In-Meeting-Controls) cloud recording features. In-meeting controls include starting and stopping a recording, pausing and resuming a recording, and inviting participants. 
        /// 
        /// **Note:** This API only works for cloud recordings. It does **not** work for local recordings. 
        /// 
        /// **Scopes:** `meeting:write`, `meeting:write:admin`, `meeting:master` 
        /// 
        /// **Prerequisites:**
        /// * The meeting **must** be a live meeting. 
        /// * [Cloud recording](https://support.zoom.us/hc/en-us/articles/360060231472-Enabling-cloud-recording) must be enabled on the account. 
        /// * The user calling this API must be the host or an alternative meeting host.
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The in-meeting recording method to control: 
            /// * `recording.start`  Start the recording. 
            /// * `recording.stop`  Stop the recording. 
            /// * `recording.pause`  Pause the recording. 
            /// * `recording.resume`  Resume a paused recording. 
            /// * `participant.invite`  Invite a participant to the meeting.
            public var method: String?
            /// The in-meeting parameters.
            public var params: Params?

            /// The in-meeting parameters.
            public struct Params: Encodable {
                /// The user's email address or the user ID, up to a maximum of 10 contacts. The account must be a part of the meeting host's account.
                public var contacts: [Contact]?

                public struct Contact: Encodable {
                    /// The user's ID.
                    public var id: String?
                    /// The user's email address. Use this value if you do not have the user's ID. 
                    /// 
                    /// If you pass the `id` value, the API ignores this query parameter.
                    public var email: String?

                    public init(id: String? = nil, email: String? = nil) {
                        self.id = id
                        self.email = email
                    }
                }

                public init(contacts: [Contact]? = nil) {
                    self.contacts = contacts
                }
            }

            public init(method: String? = nil, params: Params? = nil) {
                self.method = method
                self.params = params
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var batchPolls: BatchPolls {
        BatchPolls(path: path + "/batch_polls")
    }

    public struct BatchPolls {
        /// Path: `/meetings/{meetingId}/batch_polls`
        public let path: String

        /// Perform batch poll creation
        ///
        /// Polls allow the meeting host to survey attendees. Use this API to create batch [polls](https://support.zoom.us/hc/en-us/articles/213756303-Polling-for-Meetings) for a meeting.<br><br>
        /// 
        /// **Scopes**: `meeting:write:admin` `meeting:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites**:<br>
        /// * Host user type must be **Pro** or higher plan.
        /// * Polling feature must be enabled in the host's account.
        /// * Meeting must be a scheduled meeting. Instant meetings do not have polling features enabled.
        public var post: Request<PostResponse> {
            .post(path)
        }

        public struct PostResponse: Decodable {
            public var polls: [Poll]?

            public struct Poll: Decodable {
                /// Meeting Poll ID
                public var id: String?
                /// Title for the Poll
                public var title: String?
                /// Status of the Meeting Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
                public var status: Status?
                /// The type of poll: 
                /// * `1`  Poll. 
                /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
                /// * `3`  Quiz. This feature must be enabled in your Zoom account.
                public var pollType: Int?
                /// Whether to allow meeting participants to answer poll questions anonymously: 
                /// * `true`  Anonymous polls enabled. 
                /// * `false`  Participants cannot answer poll questions anonymously.
                public var isAnonymous: Bool?
                /// Information about the poll's questions.
                public var questions: [Question]?

                /// Status of the Meeting Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
                public enum Status: String, Codable, CaseIterable {
                    case notstart
                    case started
                    case ended
                    case sharing
                }

                public struct Question: Decodable {
                    /// The poll question's title. For `fill_in_the_blank` polls, this field is the poll's question.
                    public var name: String?
                    /// The poll's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `matching`  Matching. 
                    /// * `rank_order`  Rank order. 
                    /// * `short_answer`  Short answer. 
                    /// * `long_answer`  Long answer. 
                    /// * `fill_in_the_blank`  Fill in the blank. 
                    /// * `rating_scale`  Rating scale.
                    public var type: `Type`?
                    /// Whether to display the radio selection as a drop-down box: 
                    /// * `true`  Show as a drop-down box. 
                    /// * `false`  Do not show as a drop-down box.
                    public var isShowAsDropdown: Bool?
                    /// Whether participants must answer the question: 
                    /// * `true`  The participant must answer the question. 
                    /// * `false`  The participant does not need to answer the question.
                    public var isAnswerRequired: Bool?
                    /// The poll question's available answers.
                    public var answers: [String]?
                    /// The poll question's correct answer(s).
                    public var rightAnswers: [String]?
                    /// Information about the prompt questions. This object only returns for `matching` and `rank_order` polls.
                    public var prompts: [Prompt]?
                    /// The allowed minimum number of characters. This field only returns for `short_answer` and `long_answer` polls.
                    public var answerMinCharacter: Int?
                    /// The allowed maximum number of characters. This field only returns for `short_answer` and `long_answer` polls.
                    public var answerMaxCharacter: Int?
                    /// Whether the correct answer is case sensitive. This field only returns for `fill_in_the_blank` polls: 
                    /// * `true`  The answer is case-sensitive. 
                    /// * `false`  The answer is not case-sensitive.
                    public var isCaseSensitive: Bool
                    /// The rating scale's minimum value. This field only returns for `rating_scale` polls.
                    public var ratingMinValue: Int?
                    /// The rating scale's maximum value. This field only returns for `rating_scale` polls.
                    public var ratingMaxValue: Int?
                    /// The low score label used for the `rating_min_value` field. This field only returns for `rating_scale` polls.
                    public var ratingMinLabel: String?
                    /// The high score label used for the `rating_max_value` field. This field only returns for `rating_scale` polls.
                    public var ratingMaxLabel: String?

                    /// The poll's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `matching`  Matching. 
                    /// * `rank_order`  Rank order. 
                    /// * `short_answer`  Short answer. 
                    /// * `long_answer`  Long answer. 
                    /// * `fill_in_the_blank`  Fill in the blank. 
                    /// * `rating_scale`  Rating scale.
                    public enum `Type`: String, Codable, CaseIterable {
                        case single
                        case multiple
                        case matching
                        case rankOrder = "rank_order"
                        case shortAnswer = "short_answer"
                        case longAnswer = "long_answer"
                        case fillInTheBlank = "fill_in_the_blank"
                        case ratingScale = "rating_scale"
                    }

                    public struct Prompt: Decodable {
                        /// The question prompt's title.
                        public var promptQuestion: String?
                        /// The question prompt's correct answers.
                        public var promptRightAnswers: [String]?

                        public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                            self.promptQuestion = promptQuestion
                            self.promptRightAnswers = promptRightAnswers
                        }

                        private enum CodingKeys: String, CodingKey {
                            case promptQuestion = "prompt_question"
                            case promptRightAnswers = "prompt_right_answers"
                        }
                    }

                    public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                        self.name = name
                        self.type = type
                        self.isShowAsDropdown = isShowAsDropdown
                        self.isAnswerRequired = isAnswerRequired
                        self.answers = answers
                        self.rightAnswers = rightAnswers
                        self.prompts = prompts
                        self.answerMinCharacter = answerMinCharacter
                        self.answerMaxCharacter = answerMaxCharacter
                        self.isCaseSensitive = isCaseSensitive ?? false
                        self.ratingMinValue = ratingMinValue
                        self.ratingMaxValue = ratingMaxValue
                        self.ratingMinLabel = ratingMinLabel
                        self.ratingMaxLabel = ratingMaxLabel
                    }

                    private enum CodingKeys: String, CodingKey {
                        case name
                        case type
                        case isShowAsDropdown = "show_as_dropdown"
                        case isAnswerRequired = "answer_required"
                        case answers
                        case rightAnswers = "right_answers"
                        case prompts
                        case answerMinCharacter = "answer_min_character"
                        case answerMaxCharacter = "answer_max_character"
                        case isCaseSensitive = "case_sensitive"
                        case ratingMinValue = "rating_min_value"
                        case ratingMaxValue = "rating_max_value"
                        case ratingMinLabel = "rating_min_label"
                        case ratingMaxLabel = "rating_max_label"
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: CodingKeys.self)
                        self.name = try values.decodeIfPresent(String.self, forKey: .name)
                        self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                        self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown)
                        self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired)
                        self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                        self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
                        self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
                        self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                        self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                        self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
                        self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                        self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                        self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                        self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                    }
                }

                public init(id: String? = nil, title: String? = nil, status: Status? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                    self.id = id
                    self.title = title
                    self.status = status
                    self.pollType = pollType
                    self.isAnonymous = isAnonymous
                    self.questions = questions
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case title
                    case status
                    case pollType = "poll_type"
                    case isAnonymous = "anonymous"
                    case questions
                }
            }

            public init(polls: [Poll]? = nil) {
                self.polls = polls
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var meetingTemplates: MeetingTemplates {
        MeetingTemplates(path: path + "/meeting_templates")
    }

    public struct MeetingTemplates {
        /// Path: `/users/{userId}/meeting_templates`
        public let path: String

        /// List meeting templates
        ///
        /// Use this API to list [meeting templates](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates) that are available to be used by a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `meeting:read` or `meeting:read:admin`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Total records found for this request.
            public var totalRecords: Int?
            public var templates: [Template]?

            public struct Template: Decodable {
                /// Unique identifier of the template.
                public var id: String?
                /// Name of the template.
                public var name: String?
                /// Type of the template. The value of this field can be one of the following:<br>
                /// `1`: meeting template <br>
                /// `2`: admin meeting template
                public var type: Int?

                public init(id: String? = nil, name: String? = nil, type: Int? = nil) {
                    self.id = id
                    self.name = name
                    self.type = type
                }
            }

            public init(totalRecords: Int? = nil, templates: [Template]? = nil) {
                self.totalRecords = totalRecords
                self.templates = templates
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case templates
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var inviteLinks: InviteLinks {
        InviteLinks(path: path + "/invite_links")
    }

    public struct InviteLinks {
        /// Path: `/meetings/{meetingId}/invite_links`
        public let path: String

        /// Create meeting's invite links
        ///
        /// Use this API to create a batch of invitation links for a meeting.
        /// 
        /// **Scopes**: `meeting:write:admin`, `meeting:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// The location of the created meeting invite links.
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// The attendee list.
            public var attendees: [Attendee]?

            public struct Attendee: Decodable {
                /// The user's display name.
                public var name: String?
                /// The URL to join the meeting.
                public var joinURL: String?

                public init(name: String? = nil, joinURL: String? = nil) {
                    self.name = name
                    self.joinURL = joinURL
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case joinURL = "join_url"
                }
            }

            public init(attendees: [Attendee]? = nil) {
                self.attendees = attendees
            }
        }

        public struct PostRequest: Encodable {
            /// The invite link's expiration time, in seconds. 
            /// 
            /// This value defaults to `7200`.
            public var ttl: Int?
            /// The attendees list.
            public var attendees: [Attendee]?

            public struct Attendee: Encodable {
                /// User display name.
                public var name: String

                public init(name: String) {
                    self.name = name
                }
            }

            public init(ttl: Int? = nil, attendees: [Attendee]? = nil) {
                self.ttl = ttl
                self.attendees = attendees
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(ttl, forKey: "ttl")
                try values.encodeIfPresent(attendees, forKey: "attendees")
            }
        }
    }
}

extension Paths.Meetings.WithMeetingID {
    public var survey: Survey {
        Survey(path: path + "/survey")
    }

    public struct Survey {
        /// Path: `/meetings/{meetingId}/survey`
        public let path: String

        /// Get a meeting survey
        ///
        /// Use this API to return information about a [meeting survey](https://support.zoom.us/hc/en-us/articles/4404969060621-Post-meeting-survey-and-reporting). 
        /// 
        ///  **Scopes:** `meeting:read`, `meeting:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Prerequisites:** 
        /// * The host must be a **Pro** user type. 
        /// * The [**Meeting Survey**](https://support.zoom.us/hc/en-us/articles/4404939095053-Enabling-meeting-surveys) feature enabled in the host's account. 
        /// * The meeting must be a scheduled meeting. Instant meetings do not have survey features enabled.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Information about the customized meeting survey.
            public var customSurvey: CustomSurvey?
            /// Whether the **Show in the browser when the meeting ends** option is enabled: 
            /// * `true`  Enabled. 
            /// * `false`  Disabled. 
            /// 
            ///  This value defaults to `true`.
            public var isShowInTheBrowser: Bool
            /// The link to the third party meeting survey.
            public var thirdPartySurvey: String?

            /// Information about the customized meeting survey.
            public struct CustomSurvey: Decodable {
                /// Whether to allow participants to anonymously answer survey questions: 
                /// * `true`  Anonymous survey enabled. 
                /// * `false`  Participants cannot answer survey questions anonymously. 
                /// 
                ///  This value defaults to `true`.
                public var isAnonymous: Bool
                /// Information about the meeting survey's questions.
                public var questions: [Question]?

                public struct Question: Decodable {
                    /// The survey question, up to 255 characters.
                    public var name: String?
                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public var type: `Type`?
                    /// Whether to display the radio selection as a drop-down box: 
                    /// * `true`  Show as a drop-down box. 
                    /// * `false`  Do not show as a drop-down box. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isShowAsDropdown: Bool
                    /// Whether participants must answer the question: 
                    /// * `true`  The participant must answer the question. 
                    /// * `false`  The participant does not need to answer the question. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isAnswerRequired: Bool
                    /// The survey question's available answers. This field requires a **minimum** of two answers. 
                    /// 
                    /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                    /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                    /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                    public var answers: [String]?
                    /// The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
                    public var answerMinCharacter: Int?
                    /// The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
                    public var answerMaxCharacter: Int?
                    /// The rating scale's minimum value. This value cannot be less than zero. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMinValue: Int?
                    /// The rating scale's maximum value, up to a maximum value of 10. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxValue: Int?
                    /// The low score label used for the `rating_min_value` field. 
                    /// 
                    /// T his field only applies to the `rating_scale` survey.
                    public var ratingMinLabel: String?
                    /// The high score label used for the `rating_max_value` field. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxLabel: String?

                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public enum `Type`: String, Codable, CaseIterable {
                        case single
                        case multiple
                        case ratingScale = "rating_scale"
                        case longAnswer = "long_answer"
                    }

                    public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                        self.name = name
                        self.type = type
                        self.isShowAsDropdown = isShowAsDropdown ?? false
                        self.isAnswerRequired = isAnswerRequired ?? false
                        self.answers = answers
                        self.answerMinCharacter = answerMinCharacter
                        self.answerMaxCharacter = answerMaxCharacter
                        self.ratingMinValue = ratingMinValue
                        self.ratingMaxValue = ratingMaxValue
                        self.ratingMinLabel = ratingMinLabel
                        self.ratingMaxLabel = ratingMaxLabel
                    }

                    private enum CodingKeys: String, CodingKey {
                        case name
                        case type
                        case isShowAsDropdown = "show_as_dropdown"
                        case isAnswerRequired = "answer_required"
                        case answers
                        case answerMinCharacter = "answer_min_character"
                        case answerMaxCharacter = "answer_max_character"
                        case ratingMinValue = "rating_min_value"
                        case ratingMaxValue = "rating_max_value"
                        case ratingMinLabel = "rating_min_label"
                        case ratingMaxLabel = "rating_max_label"
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: CodingKeys.self)
                        self.name = try values.decodeIfPresent(String.self, forKey: .name)
                        self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                        self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                        self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                        self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                        self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                        self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                        self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                        self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                        self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                        self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                    }
                }

                public init(isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                    self.isAnonymous = isAnonymous ?? false
                    self.questions = questions
                }

                private enum CodingKeys: String, CodingKey {
                    case isAnonymous = "anonymous"
                    case questions
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
                    self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
                }
            }

            public init(customSurvey: CustomSurvey? = nil, isShowInTheBrowser: Bool? = nil, thirdPartySurvey: String? = nil) {
                self.customSurvey = customSurvey
                self.isShowInTheBrowser = isShowInTheBrowser ?? true
                self.thirdPartySurvey = thirdPartySurvey
            }

            private enum CodingKeys: String, CodingKey {
                case customSurvey = "custom_survey"
                case isShowInTheBrowser = "show_in_the_browser"
                case thirdPartySurvey = "third_party_survey"
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.customSurvey = try values.decodeIfPresent(CustomSurvey.self, forKey: .customSurvey)
                self.isShowInTheBrowser = try values.decodeIfPresent(Bool.self, forKey: .isShowInTheBrowser) ?? true
                self.thirdPartySurvey = try values.decodeIfPresent(String.self, forKey: .thirdPartySurvey)
            }
        }

        /// Update a meeting survey
        ///
        /// Use this API to update a [meeting survey](https://support.zoom.us/hc/en-us/articles/4404969060621-Post-meeting-survey-and-reporting). 
        /// 
        ///  **Scopes:** `meeting:write`, `meeting:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Prerequisites:** 
        /// * The host must be a **Pro** user type. 
        /// * The [**Meeting Survey**](https://support.zoom.us/hc/en-us/articles/4404939095053-Enabling-meeting-surveys) feature enabled in the host's account. 
        /// * The meeting must be a scheduled meeting. Instant meetings do not have survey features enabled.
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The link to the third party meeting survey.
            public var thirdPartySurvey: String?
            /// Information about the customized meeting survey.
            public var customSurvey: CustomSurvey?
            /// Whether the **Show in the browser when the meeting ends** option is enabled: 
            /// * `true`  Enabled. 
            /// * `false`  Disabled. 
            /// 
            ///  This value defaults to `true`.
            public var isShowInTheBrowser: Bool

            /// Information about the customized meeting survey.
            public struct CustomSurvey: Encodable {
                /// Whether to allow participants to anonymously answer survey questions: 
                /// * `true`  Anonymous survey enabled. 
                /// * `false`  Participants cannot answer survey questions anonymously. 
                /// 
                ///  This value defaults to `true`.
                public var isAnonymous: Bool
                /// Information about the meeting survey's questions.
                public var questions: [Question]?

                public struct Question: Encodable {
                    /// The survey question, up to 255 characters.
                    public var name: String?
                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public var type: `Type`?
                    /// Whether to display the radio selection as a drop-down box: 
                    /// * `true`  Show as a drop-down box. 
                    /// * `false`  Do not show as a drop-down box. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isShowAsDropdown: Bool
                    /// Whether participants must answer the question: 
                    /// * `true`  The participant must answer the question. 
                    /// * `false`  The participant does not need to answer the question. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isAnswerRequired: Bool
                    /// The survey question's available answers. This field requires a **minimum** of two answers. 
                    /// 
                    /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                    /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                    /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                    public var answers: [String]?
                    /// The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
                    public var answerMinCharacter: Int?
                    /// The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
                    public var answerMaxCharacter: Int?
                    /// The rating scale's minimum value. This value cannot be less than zero. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMinValue: Int?
                    /// The rating scale's maximum value, up to a maximum value of 10. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxValue: Int?
                    /// The low score label used for the `rating_min_value` field. 
                    /// 
                    /// T his field only applies to the `rating_scale` survey.
                    public var ratingMinLabel: String?
                    /// The high score label used for the `rating_max_value` field. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxLabel: String?

                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public enum `Type`: String, Codable, CaseIterable {
                        case single
                        case multiple
                        case ratingScale = "rating_scale"
                        case longAnswer = "long_answer"
                    }

                    public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                        self.name = name
                        self.type = type
                        self.isShowAsDropdown = isShowAsDropdown ?? false
                        self.isAnswerRequired = isAnswerRequired ?? false
                        self.answers = answers
                        self.answerMinCharacter = answerMinCharacter
                        self.answerMaxCharacter = answerMaxCharacter
                        self.ratingMinValue = ratingMinValue
                        self.ratingMaxValue = ratingMaxValue
                        self.ratingMinLabel = ratingMinLabel
                        self.ratingMaxLabel = ratingMaxLabel
                    }

                    private enum CodingKeys: String, CodingKey {
                        case name
                        case type
                        case isShowAsDropdown = "show_as_dropdown"
                        case isAnswerRequired = "answer_required"
                        case answers
                        case answerMinCharacter = "answer_min_character"
                        case answerMaxCharacter = "answer_max_character"
                        case ratingMinValue = "rating_min_value"
                        case ratingMaxValue = "rating_max_value"
                        case ratingMinLabel = "rating_min_label"
                        case ratingMaxLabel = "rating_max_label"
                    }
                }

                public init(isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                    self.isAnonymous = isAnonymous ?? false
                    self.questions = questions
                }

                private enum CodingKeys: String, CodingKey {
                    case isAnonymous = "anonymous"
                    case questions
                }
            }

            public init(thirdPartySurvey: String? = nil, customSurvey: CustomSurvey? = nil, isShowInTheBrowser: Bool? = nil) {
                self.thirdPartySurvey = thirdPartySurvey
                self.customSurvey = customSurvey
                self.isShowInTheBrowser = isShowInTheBrowser ?? true
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(thirdPartySurvey, forKey: "third_party_survey")
                try values.encodeIfPresent(customSurvey, forKey: "custom_survey")
                try values.encodeIfPresent(isShowInTheBrowser, forKey: "show_in_the_browser")
            }
        }

        /// Delete a meeting survey
        ///
        /// Use this API to delete a [meeting survey](https://support.zoom.us/hc/en-us/articles/4404969060621-Post-meeting-survey-and-reporting). 
        /// 
        ///  **Scopes:** `meeting:write`, `meeting:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Prerequisites:** 
        /// * The host must be a **Pro** user type. 
        /// * The [**Meeting Survey**](https://support.zoom.us/hc/en-us/articles/4404939095053-Enabling-meeting-surveys) feature enabled in the host's account. 
        /// * The meeting must be a scheduled meeting. Instant meetings do not have survey features enabled.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var h323: H323 {
        H323(path: "/h323")
    }

    public struct H323 {
        /// Path: `/h323`
        public let path: String
    }
}

extension Paths.H323 {
    public var devices: Devices {
        Devices(path: path + "/devices")
    }

    public struct Devices {
        /// Path: `/h323/devices`
        public let path: String

        /// List H.323/SIP devices
        ///
        /// A H.323 or SIP device can make a video call to a [Room Connector](https://support.zoom.us/hc/en-us/articles/201363273-Getting-Started-With-H-323-SIP-Room-Connector) to join a Zoom cloud meeting. A Room Connector can also call out to a H.323 or SIP device to join a Zoom cloud meeting. Use this API to list all H.323/SIP Devices on a Zoom account.<br><br>
        /// **Scopes:** `h323:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// H.323/SIP Device List
        ///
        /// List of H.323/SIP Devices.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public init(pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Create a H.323/SIP device
        ///
        /// A H.323 or SIP device can make a video call to a [Room Connector](https://support.zoom.us/hc/en-us/articles/201363273-Getting-Started-With-H-323-SIP-Room-Connector) to join a Zoom cloud meeting. A Room Connector can also call out to a H.323 or SIP device to join a Zoom cloud meeting. Use this API to add a H.323/SIP device to your Zoom account<br><br>
        /// **Scopes:** `h323:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` <br>
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        /// The H.323/SIP device object.
        public struct PostRequest: Encodable {
            /// Device name.
            public var name: String
            /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
            public var `protocol`: `Protocol`
            /// Device IP.
            public var ip: String
            /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
            public var encryption: Encryption

            /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
            public enum `Protocol`: String, Codable, CaseIterable {
                case h323 = "H.323"
                case sip = "SIP"
            }

            /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
            public enum Encryption: String, Codable, CaseIterable {
                case auto
                case yes
                case no
            }

            public init(name: String, `protocol`: `Protocol`, ip: String, encryption: Encryption) {
                self.name = name
                self.protocol = `protocol`
                self.ip = ip
                self.encryption = encryption
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case `protocol` = "protocol"
                case ip
                case encryption
            }
        }
    }
}

extension Paths.H323.Devices {
    public func deviceID(_ deviceID: String) -> WithDeviceID {
        WithDeviceID(path: "\(path)/\(deviceID)")
    }

    public struct WithDeviceID {
        /// Path: `/h323/devices/{deviceId}`
        public let path: String

        /// Update a H.323/SIP device
        ///
        /// A H.323 or SIP device can make a video call to a [Room Connector](https://support.zoom.us/hc/en-us/articles/201363273-Getting-Started-With-H-323-SIP-Room-Connector) to join a Zoom cloud meeting. A Room Connector can also call out to a H.323 or SIP device to join a Zoom cloud meeting. Use this API to edit information of a H.323/SIP device from your Zoom account.<br><br>
        /// **Scopes:** `h323:write:admin`<br>
        ///  <br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// The H.323/SIP device object.
        public struct PatchRequest: Encodable {
            /// Device name.
            public var name: String
            /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
            public var `protocol`: `Protocol`
            /// Device IP.
            public var ip: String
            /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
            public var encryption: Encryption

            /// Device protocol:<br>`H.323` - H.323.<br>`SIP` - SIP.
            public enum `Protocol`: String, Codable, CaseIterable {
                case h323 = "H.323"
                case sip = "SIP"
            }

            /// Device encryption:<br>`auto` - auto.<br>`yes` - yes.<br>`no` - no.
            public enum Encryption: String, Codable, CaseIterable {
                case auto
                case yes
                case no
            }

            public init(name: String, `protocol`: `Protocol`, ip: String, encryption: Encryption) {
                self.name = name
                self.protocol = `protocol`
                self.ip = ip
                self.encryption = encryption
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case `protocol` = "protocol"
                case ip
                case encryption
            }
        }

        /// Delete a H.323/SIP device
        ///
        /// A H.323 or SIP device can make a video call to a [Room Connector](https://support.zoom.us/hc/en-us/articles/201363273-Getting-Started-With-H-323-SIP-Room-Connector) to join a Zoom cloud meeting. A Room Connector can also call out to a H.323 or SIP device to join a Zoom cloud meeting. Use this API to delete a H.323/SIP device from your Zoom account.<br><br>
        /// **Scopes:** `h323:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var users: Users {
        Users(path: "/users")
    }

    public struct Users {
        /// Path: `/users`
        public let path: String

        /// List users
        ///
        /// Use this API to list your account's users. 
        /// 
        /// **Scopes:** `user:read:admin` 
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The page number of the current results.
            public var pageNumber: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?
            /// Information about the users.
            public var users: [User]?

            public struct User: Decodable {
                /// The user's ID. 
                /// 
                /// The API does **not** return this value for users with the `pending` status.
                public var id: String?
                /// The user's first name.
                public var firstName: String?
                /// The user's last name.
                public var lastName: String?
                /// The user's email address.
                public var email: String
                /// The user's assigned plan type: 
                /// * `1`  Basic. 
                /// * `2`  Licensed. 
                /// * `3`  On-prem. 
                /// * `99`  None (this can only be set with `ssoCreate`).
                public var type: Int
                /// The user's status: 
                /// * `active`  An active user. 
                /// * `inactive`  A deactivated user. 
                /// * `pending`  A pending user.
                ///
                /// Example: "active"
                public var status: Status?
                /// The user's [PMI (personal meeting ID)](https://support.zoom.us/hc/en-us/articles/201362843-What-is-Personal-Meeting-ID-PMI-and-Personal-Link-).
                public var pmi: Int?
                /// The user's timezone.
                public var timezone: String?
                /// The user's department.
                public var dept: String?
                /// The unique ID of the user's assigned [role](https://marketplace.zoom.us/docs/api-reference/zoom-api/roles/roles).
                public var roleID: String?
                /// The time at which the user's account was created.
                public var createdAt: Date?
                /// The user's last login time. This field has a three-day buffer period.
                /// 
                /// For example, if user first logged in on `2020-01-01` and then logged out and logged in on `2020-01-02`, this value will still reflect the login time of `2020-01-01`. However, if the user logs in on `2020-01-04`, the value of this field will reflect the corresponding login time since it exceeds the three-day buffer period.
                public var lastLoginTime: Date?
                /// The last client version that user used to log in.
                public var lastClientVersion: String?
                /// The IDs of groups where the user is a member.
                public var groupIDs: [String]?
                /// The IDs of IM directory groups where the user is a member.
                public var imGroupIDs: [String]?
                /// Display whether the user's email address for the Zoom account is verified: 
                /// * `1`  A verified user email. 
                /// * `0`  The user's email **not** verified.
                public var verified: Int?
                /// Information about the user's custom attributes.
                /// 
                /// This field is **only** returned if users are assigned custom attributes and you provided the `custom_attributes` value for the `include_fields` query parameter in the API request.
                public var customAttributes: [CustomAttribute]?
                /// The user's [host key](https://support.zoom.us/hc/en-us/articles/205172555-Using-your-host-key).
                /// 
                /// This field is **only** returned if users are assigned a host key and you provided the `host_key` value for the `include_fields` query parameter in the API request.
                public var hostKey: String?
                /// This field is returned if the user is enrolled in the [Zoom United](https://zoom.us/pricing/zoom-bundles) plan.
                public var planUnitedType: String?
                /// The employee's unique ID. The this field only returns when: 
                /// * SAML single sign-on (SSO) is enabled. 
                /// * The `login_type` value is `101` (SSO).
                public var employeeUniqueID: String?

                /// The user's status: 
                /// * `active`  An active user. 
                /// * `inactive`  A deactivated user. 
                /// * `pending`  A pending user.
                ///
                /// Example: "active"
                public enum Status: String, Codable, CaseIterable {
                    case active
                    case inactive
                    case pending
                }

                public struct CustomAttribute: Decodable {
                    /// The custom attribute's unique ID.
                    public var key: String?
                    /// The custom attribute's name.
                    public var name: String?
                    /// The custom attribute's value.
                    public var value: String?

                    public init(key: String? = nil, name: String? = nil, value: String? = nil) {
                        self.key = key
                        self.name = name
                        self.value = value
                    }
                }

                public init(id: String? = nil, firstName: String? = nil, lastName: String? = nil, email: String, type: Int, status: Status? = nil, pmi: Int? = nil, timezone: String? = nil, dept: String? = nil, roleID: String? = nil, createdAt: Date? = nil, lastLoginTime: Date? = nil, lastClientVersion: String? = nil, groupIDs: [String]? = nil, imGroupIDs: [String]? = nil, verified: Int? = nil, customAttributes: [CustomAttribute]? = nil, hostKey: String? = nil, planUnitedType: String? = nil, employeeUniqueID: String? = nil) {
                    self.id = id
                    self.firstName = firstName
                    self.lastName = lastName
                    self.email = email
                    self.type = type
                    self.status = status
                    self.pmi = pmi
                    self.timezone = timezone
                    self.dept = dept
                    self.roleID = roleID
                    self.createdAt = createdAt
                    self.lastLoginTime = lastLoginTime
                    self.lastClientVersion = lastClientVersion
                    self.groupIDs = groupIDs
                    self.imGroupIDs = imGroupIDs
                    self.verified = verified
                    self.customAttributes = customAttributes
                    self.hostKey = hostKey
                    self.planUnitedType = planUnitedType
                    self.employeeUniqueID = employeeUniqueID
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case email
                    case type
                    case status
                    case pmi
                    case timezone
                    case dept
                    case roleID = "role_id"
                    case createdAt = "created_at"
                    case lastLoginTime = "last_login_time"
                    case lastClientVersion = "last_client_version"
                    case groupIDs = "group_ids"
                    case imGroupIDs = "im_group_ids"
                    case verified
                    case customAttributes = "custom_attributes"
                    case hostKey = "host_key"
                    case planUnitedType = "plan_united_type"
                    case employeeUniqueID = "employee_unique_id"
                }
            }

            public init(pageCount: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, users: [User]? = nil) {
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.users = users
            }

            private enum CodingKeys: String, CodingKey {
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case users
            }
        }

        public struct GetParameters {
            public var status: Status?
            public var pageSize: Int?
            public var roleID: String?
            public var pageNumber: String?
            public var includeFields: IncludeFields?
            public var nextPageToken: String?

            public enum Status: String, Codable, CaseIterable {
                case active
                case inactive
                case pending
            }

            public enum IncludeFields: String, Codable, CaseIterable {
                case customAttributes = "custom_attributes"
                case hostKey = "host_key"
            }

            public init(status: Status? = nil, pageSize: Int? = nil, roleID: String? = nil, pageNumber: String? = nil, includeFields: IncludeFields? = nil, nextPageToken: String? = nil) {
                self.status = status
                self.pageSize = pageSize
                self.roleID = roleID
                self.pageNumber = pageNumber
                self.includeFields = includeFields
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(status, forKey: "status")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(roleID, forKey: "role_id")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(includeFields, forKey: "include_fields")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Create users
        ///
        /// Use this API to add a new user to your Zoom account. 
        /// 
        /// **Scopes:** `user:write:admin`, `user:write` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Note:** The following rate limits apply when you use the `create` value for the `action` field: 
        /// * 50 requests per day for **Free** accounts. 
        /// * 1,500 requests per day for **Pro** accounts. 
        /// * 10,000 requests per day for **Business+** accounts. 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of created User
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// User ID.
            public var id: String?
            /// User's first name.
            public var firstName: String?
            /// User's last name.
            public var lastName: String?
            /// User email address.
            public var email: String?
            /// User type:<br>`1` - Basic.<br>`2` - Licensed.<br>`3` - On-prem.<br>`99` - None (this can only be set with `ssoCreate`).
            public var type: Int?

            public init(id: String? = nil, firstName: String? = nil, lastName: String? = nil, email: String? = nil, type: Int? = nil) {
                self.id = id
                self.firstName = firstName
                self.lastName = lastName
                self.email = email
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case firstName = "first_name"
                case lastName = "last_name"
                case email
                case type
            }
        }

        public struct PostRequest: Encodable {
            /// The action to take to create the new user: 
            /// * `create`  The user receives an email from Zoom containing a confirmation link. The user must then use the link to activate their Zoom account. The user can then set or change their password. 
            /// * `autoCreate`  This action is for Enterprise customers with a managed domain. This feature is disabled by default because of the security risk involved in creating a user who does not belong to your domain. 
            /// * `custCreate`  Users created with this action do not have passwords and will **not** have the ability to log into the Zoom web portal or the Zoom client. These users can still host and join meetings using the `start_url` and `join_url` respectively. To use this option, you must [contact the Integrated Software Vendor (ISV) sales team](https://docs.google.com/forms/d/e/1FAIpQLSe8FundLOYp8TMptSwWYeFt7QGKlp4yw4YHilta9M0ycxdoNw/viewform). 
            /// * `ssoCreate`  This action is provided for the enabled Pre-provisioning SSO User option. A user created this way has no password. If it is **not** a Basic user, a personal vanity URL with the username (no domain) of the provisioning email is generated. If the username or PMI is invalid or occupied, it uses a random number or random personal vanity URL.
            public var action: Action
            public var userInfo: UserInfo?

            /// The action to take to create the new user: 
            /// * `create`  The user receives an email from Zoom containing a confirmation link. The user must then use the link to activate their Zoom account. The user can then set or change their password. 
            /// * `autoCreate`  This action is for Enterprise customers with a managed domain. This feature is disabled by default because of the security risk involved in creating a user who does not belong to your domain. 
            /// * `custCreate`  Users created with this action do not have passwords and will **not** have the ability to log into the Zoom web portal or the Zoom client. These users can still host and join meetings using the `start_url` and `join_url` respectively. To use this option, you must [contact the Integrated Software Vendor (ISV) sales team](https://docs.google.com/forms/d/e/1FAIpQLSe8FundLOYp8TMptSwWYeFt7QGKlp4yw4YHilta9M0ycxdoNw/viewform). 
            /// * `ssoCreate`  This action is provided for the enabled Pre-provisioning SSO User option. A user created this way has no password. If it is **not** a Basic user, a personal vanity URL with the username (no domain) of the provisioning email is generated. If the username or PMI is invalid or occupied, it uses a random number or random personal vanity URL.
            public enum Action: String, Codable, CaseIterable {
                case create
                case autoCreate
                case custCreate
                case ssoCreate
            }

            public struct UserInfo: Encodable {
                /// User email address.
                public var email: String
                /// User type:<br>`1` - Basic.<br>`2` - Licensed.<br>`3` - On-prem.<br>`99` - None (this can only be set with `ssoCreate`).
                public var type: Int
                /// User's first name: cannot contain more than 5 Chinese words.
                public var firstName: String?
                /// User's last name: cannot contain more than 5 Chinese words.
                public var lastName: String?
                /// User password. Only used for the "autoCreate" function. The password has to have a minimum of 8 characters and maximum of 32 characters. By default (basic requirement), password must have at least one letter (a, b, c..), at least one number (1, 2, 3...) and include both uppercase and lowercase letters. It should not contain only one identical character repeatedly ('11111111' or 'aaaaaaaa') and it cannot contain consecutive characters ('12345678' or 'abcdefgh').
                /// 
                /// **Note:** If the account owner or admin has enabled [enhanced password requirements](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_fa9186e4-6818-4f7a-915c-2e25c19f0acd), the value provided in this field must meet those requirements. These requirements can be retrieved by calling the [Get Account Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) and referring to the `password_requirement` field present in the `security` object.
                public var password: String?

                public init(email: String, type: Int, firstName: String? = nil, lastName: String? = nil, password: String? = nil) {
                    self.email = email
                    self.type = type
                    self.firstName = firstName
                    self.lastName = lastName
                    self.password = password
                }

                private enum CodingKeys: String, CodingKey {
                    case email
                    case type
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case password
                }
            }

            public init(action: Action, userInfo: UserInfo? = nil) {
                self.action = action
                self.userInfo = userInfo
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case userInfo = "user_info"
            }
        }
    }
}

extension Paths.Users {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/users/{userId}`
        public let path: String

        /// Get a user
        ///
        /// Use this API to view a user's information on a Zoom account. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        /// **Note:** Users who have not activated their account will have a `pending` status. These users' `created_at` timestamp will also display the time at which the API call was made, **not** the account's creation date. 
        /// 
        /// **Scopes:** `user:read:admin`, `user:read`, `user_info:read` <br> 
        /// * **Note:** The `user_info:read` scope is only available when you pass the `me` value for the `$userId` value. 
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// User's account ID.
            public var accountID: String?
            /// The user's account number.
            public var accountNumber: Int?
            /// CMS ID of user, only enabled for Kaltura integration.
            public var cmsUserID: String?
            /// User's company.
            public var company: String?
            /// The date and time at which this user was created.
            public var createdAt: Date?
            /// Custom attribute(s) that have been assigned to the user.
            public var customAttributes: CustomAttributes?
            /// Department.
            public var dept: String?
            /// User's email address.
            public var email: String
            /// The employee's unique ID. This field only returns when: 
            /// * SAML single sign-on (SSO) is enabled. 
            /// * The `login_type` value is `101` (SSO).
            public var employeeUniqueID: String?
            /// User's first name.
            public var firstName: String?
            /// IDs of the web groups user belongs to.
            public var groupIDs: [String]?
            /// User's host key.
            public var hostKey: String?
            /// User ID.
            public var id: String?
            /// IM IDs of the groups user belongs to.
            public var imGroupIDs: [String]?
            public var jid: String?
            /// User's job title.
            public var jobTitle: String?
            /// Default language for the Zoom Web Portal.
            public var language: String?
            /// User last login client version.
            public var lastClientVersion: String?
            /// User last login time.
            public var lastLoginTime: Date?
            /// User's last name.
            public var lastName: String?
            /// User's location.
            public var location: String?
            /// The user's login method:
            /// 
            /// `0`  Facebook OAuth</br>`1`  Google OAuth</br>`24`  Apple OAuth</br>`27`  Microsoft OAuth</br>`97`  Mobile device</br>`98`  RingCentral OAuth</br>`99`  API user</br>`100`  Zoom Work email</br>`101`  Single Sign-On (SSO)
            /// 
            /// The following login methods are only available in China:
            /// 
            /// `11`  Phone number</br>`21`  WeChat</br>`23`  Alipay
            public var loginType: Int?
            /// The manager for the user.
            public var manager: String?
            /// User's personal meeting url.
            public var personalMeetingURL: String?
            /// **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead of this field. <br> User's country for Company Phone Number.
            public var phoneCountry: String?
            /// **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead of this field. <br> User's phone number.
            public var phoneNumber: String?
            public var phoneNumbers: [PhoneNumber]?
            /// The URL for user's profile picture.
            public var picURL: String?
            /// United plan [type](https://marketplace.zoom.us/docs/api-reference/other-references/plans#zoom-united-plans). Only returned if user is enrolled in the Zoom United plan.
            public var planUnitedType: String?
            /// Personal meeting ID.
            public var pmi: Int?
            /// The user's pronouns.
            public var pronouns: String?
            /// The user's display pronouns setting:
            /// * `1`  Ask the user every time they join meetings and webinars. 
            /// * `2`  Always display pronouns in meetings and webinars. 
            /// * `3`  Do not display pronouns in meetings and webinars.
            public var pronounsOption: Int?
            /// Unique identifier of the [role](https://marketplace.zoom.us/docs/api-reference/zoom-api/roles/roles) assigned to the user.
            public var roleID: String?
            /// User's [role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) name.
            public var roleName: String?
            /// Status of user's account.
            public var status: Status?
            /// The time zone of the user.
            public var timezone: String?
            /// User's plan type:<br>`1` - Basic.<br>`2` - Licensed.<br>`3` - On-prem.<br>`99` - None (this can only be set with `ssoCreate`).
            public var type: Int
            /// Displays `true` if user has enabled PMI for instant meetinsgs, `false` otherwise.
            public var usePmi: Bool
            /// Personal meeting room URL, if the user has one.
            public var vanityURL: String?
            /// Displays whether user is verified or not. <br>
            /// `1` - Account verified.<br>
            /// `0` - Account not verified.
            public var verified: Int?

            /// Custom attribute(s) that have been assigned to the user.
            public struct CustomAttributes: Decodable {
                /// Identifier for the custom attribute.
                public var key: String?
                /// Name of the custom attribute.
                public var name: String?
                /// Value of the custom attribute.
                public var value: String?

                public init(key: String? = nil, name: String? = nil, value: String? = nil) {
                    self.key = key
                    self.name = name
                    self.value = value
                }
            }

            public struct PhoneNumber: Decodable {
                /// The phone number's [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). For example, if the phone number provided in the `number` field is a Brazil-based number, this will be the `BR` value.
                public var country: String?
                /// The phone number's country code. For example, for United States phone numbers, this will be a `+1` value.
                public var code: String?
                /// The user's phone number.
                public var number: String?
                /// Whether Zoom has verified the phone number.
                public var isVerified: Bool?
                /// The phone number's label:
                /// * `Mobile`
                /// * `Office`
                /// * `Home`
                ///  * `Fax`
                public var label: Label?

                /// The phone number's label:
                /// * `Mobile`
                /// * `Office`
                /// * `Home`
                ///  * `Fax`
                public enum Label: String, Codable, CaseIterable {
                    case mobile = "Mobile"
                    case office = "Office"
                    case home = "Home"
                    case fax = "Fax"
                }

                public init(country: String? = nil, code: String? = nil, number: String? = nil, isVerified: Bool? = nil, label: Label? = nil) {
                    self.country = country
                    self.code = code
                    self.number = number
                    self.isVerified = isVerified
                    self.label = label
                }

                private enum CodingKeys: String, CodingKey {
                    case country
                    case code
                    case number
                    case isVerified = "verified"
                    case label
                }
            }

            /// Status of user's account.
            public enum Status: String, Codable, CaseIterable {
                case pending
                case active
                case inactive
            }

            public init(accountID: String? = nil, accountNumber: Int? = nil, cmsUserID: String? = nil, company: String? = nil, createdAt: Date? = nil, customAttributes: CustomAttributes? = nil, dept: String? = nil, email: String, employeeUniqueID: String? = nil, firstName: String? = nil, groupIDs: [String]? = nil, hostKey: String? = nil, id: String? = nil, imGroupIDs: [String]? = nil, jid: String? = nil, jobTitle: String? = nil, language: String? = nil, lastClientVersion: String? = nil, lastLoginTime: Date? = nil, lastName: String? = nil, location: String? = nil, loginType: Int? = nil, manager: String? = nil, personalMeetingURL: String? = nil, phoneCountry: String? = nil, phoneNumber: String? = nil, phoneNumbers: [PhoneNumber]? = nil, picURL: String? = nil, planUnitedType: String? = nil, pmi: Int? = nil, pronouns: String? = nil, pronounsOption: Int? = nil, roleID: String? = nil, roleName: String? = nil, status: Status? = nil, timezone: String? = nil, type: Int, usePmi: Bool? = nil, vanityURL: String? = nil, verified: Int? = nil) {
                self.accountID = accountID
                self.accountNumber = accountNumber
                self.cmsUserID = cmsUserID
                self.company = company
                self.createdAt = createdAt
                self.customAttributes = customAttributes
                self.dept = dept
                self.email = email
                self.employeeUniqueID = employeeUniqueID
                self.firstName = firstName
                self.groupIDs = groupIDs
                self.hostKey = hostKey
                self.id = id
                self.imGroupIDs = imGroupIDs
                self.jid = jid
                self.jobTitle = jobTitle
                self.language = language
                self.lastClientVersion = lastClientVersion
                self.lastLoginTime = lastLoginTime
                self.lastName = lastName
                self.location = location
                self.loginType = loginType
                self.manager = manager
                self.personalMeetingURL = personalMeetingURL
                self.phoneCountry = phoneCountry
                self.phoneNumber = phoneNumber
                self.phoneNumbers = phoneNumbers
                self.picURL = picURL
                self.planUnitedType = planUnitedType
                self.pmi = pmi
                self.pronouns = pronouns
                self.pronounsOption = pronounsOption
                self.roleID = roleID
                self.roleName = roleName
                self.status = status
                self.timezone = timezone
                self.type = type
                self.usePmi = usePmi ?? false
                self.vanityURL = vanityURL
                self.verified = verified
            }

            private enum CodingKeys: String, CodingKey {
                case accountID = "account_id"
                case accountNumber = "account_number"
                case cmsUserID = "cms_user_id"
                case company
                case createdAt = "created_at"
                case customAttributes = "custom_attributes"
                case dept
                case email
                case employeeUniqueID = "employee_unique_id"
                case firstName = "first_name"
                case groupIDs = "group_ids"
                case hostKey = "host_key"
                case id
                case imGroupIDs = "im_group_ids"
                case jid
                case jobTitle = "job_title"
                case language
                case lastClientVersion = "last_client_version"
                case lastLoginTime = "last_login_time"
                case lastName = "last_name"
                case location
                case loginType = "login_type"
                case manager
                case personalMeetingURL = "personal_meeting_url"
                case phoneCountry = "phone_country"
                case phoneNumber = "phone_number"
                case phoneNumbers = "phone_numbers"
                case picURL = "pic_url"
                case planUnitedType = "plan_united_type"
                case pmi
                case pronouns
                case pronounsOption = "pronouns_option"
                case roleID = "role_id"
                case roleName = "role_name"
                case status
                case timezone
                case type
                case usePmi = "use_pmi"
                case vanityURL = "vanity_url"
                case verified
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.accountID = try values.decodeIfPresent(String.self, forKey: .accountID)
                self.accountNumber = try values.decodeIfPresent(Int.self, forKey: .accountNumber)
                self.cmsUserID = try values.decodeIfPresent(String.self, forKey: .cmsUserID)
                self.company = try values.decodeIfPresent(String.self, forKey: .company)
                self.createdAt = try values.decodeIfPresent(Date.self, forKey: .createdAt)
                self.customAttributes = try values.decodeIfPresent(CustomAttributes.self, forKey: .customAttributes)
                self.dept = try values.decodeIfPresent(String.self, forKey: .dept)
                self.email = try values.decode(String.self, forKey: .email)
                self.employeeUniqueID = try values.decodeIfPresent(String.self, forKey: .employeeUniqueID)
                self.firstName = try values.decodeIfPresent(String.self, forKey: .firstName)
                self.groupIDs = try values.decodeIfPresent([String].self, forKey: .groupIDs)
                self.hostKey = try values.decodeIfPresent(String.self, forKey: .hostKey)
                self.id = try values.decodeIfPresent(String.self, forKey: .id)
                self.imGroupIDs = try values.decodeIfPresent([String].self, forKey: .imGroupIDs)
                self.jid = try values.decodeIfPresent(String.self, forKey: .jid)
                self.jobTitle = try values.decodeIfPresent(String.self, forKey: .jobTitle)
                self.language = try values.decodeIfPresent(String.self, forKey: .language)
                self.lastClientVersion = try values.decodeIfPresent(String.self, forKey: .lastClientVersion)
                self.lastLoginTime = try values.decodeIfPresent(Date.self, forKey: .lastLoginTime)
                self.lastName = try values.decodeIfPresent(String.self, forKey: .lastName)
                self.location = try values.decodeIfPresent(String.self, forKey: .location)
                self.loginType = try values.decodeIfPresent(Int.self, forKey: .loginType)
                self.manager = try values.decodeIfPresent(String.self, forKey: .manager)
                self.personalMeetingURL = try values.decodeIfPresent(String.self, forKey: .personalMeetingURL)
                self.phoneCountry = try values.decodeIfPresent(String.self, forKey: .phoneCountry)
                self.phoneNumber = try values.decodeIfPresent(String.self, forKey: .phoneNumber)
                self.phoneNumbers = try values.decodeIfPresent([PhoneNumber].self, forKey: .phoneNumbers)
                self.picURL = try values.decodeIfPresent(String.self, forKey: .picURL)
                self.planUnitedType = try values.decodeIfPresent(String.self, forKey: .planUnitedType)
                self.pmi = try values.decodeIfPresent(Int.self, forKey: .pmi)
                self.pronouns = try values.decodeIfPresent(String.self, forKey: .pronouns)
                self.pronounsOption = try values.decodeIfPresent(Int.self, forKey: .pronounsOption)
                self.roleID = try values.decodeIfPresent(String.self, forKey: .roleID)
                self.roleName = try values.decodeIfPresent(String.self, forKey: .roleName)
                self.status = try values.decodeIfPresent(Status.self, forKey: .status)
                self.timezone = try values.decodeIfPresent(String.self, forKey: .timezone)
                self.type = try values.decode(Int.self, forKey: .type)
                self.usePmi = try values.decodeIfPresent(Bool.self, forKey: .usePmi) ?? false
                self.vanityURL = try values.decodeIfPresent(String.self, forKey: .vanityURL)
                self.verified = try values.decodeIfPresent(Int.self, forKey: .verified)
            }
        }

        public struct GetParameters {
            public var loginType: LoginType?
            public var isEncryptedEmail: Bool?
            public var isSearchByUniqueID: Bool?

            public enum LoginType: String, Codable, CaseIterable {
                case _0 = "0"
                case _1 = "1"
                case _11 = "11"
                case _21 = "21"
                case _23 = "23"
                case _24 = "24"
                case _27 = "27"
                case _97 = "97"
                case _98 = "98"
                case _99 = "99"
                case _100 = "100"
                case _101 = "101"
            }

            public init(loginType: LoginType? = nil, isEncryptedEmail: Bool? = nil, isSearchByUniqueID: Bool? = nil) {
                self.loginType = loginType
                self.isEncryptedEmail = isEncryptedEmail
                self.isSearchByUniqueID = isSearchByUniqueID
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(loginType, forKey: "login_type")
                encoder.encode(isEncryptedEmail, forKey: "encrypted_email")
                encoder.encode(isSearchByUniqueID, forKey: "search_by_unique_id")
                return encoder.items
            }
        }

        /// Update a user
        ///
        /// Update information on a user's [Zoom profile](https://support.zoom.us/hc/en-us/articles/201363203-My-Profile). For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `user:write:admin` `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(loginType: LoginType? = nil, isRemoveTspCredentials: Bool? = nil, _ body: PatchRequest) -> Request<Void> {
            .patch(path, query: makePatchQuery(loginType, isRemoveTspCredentials), body: body)
        }

        private func makePatchQuery(_ loginType: LoginType?, _ isRemoveTspCredentials: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(loginType, forKey: "login_type")
            encoder.encode(isRemoveTspCredentials, forKey: "remove_tsp_credentials")
            return encoder.items
        }

        public enum LoginType: String, Codable, CaseIterable {
            case _0 = "0"
            case _1 = "1"
            case _11 = "11"
            case _21 = "21"
            case _23 = "23"
            case _24 = "24"
            case _27 = "27"
            case _97 = "97"
            case _98 = "98"
            case _99 = "99"
            case _100 = "100"
            case _101 = "101"
        }

        /// The user update object represents a user on Zoom.
        public struct PatchRequest: Encodable {
            /// User's first name. Cannot contain more than 5 Chinese characters.
            public var firstName: String?
            /// User's last name. Cannot contain more than 5 Chinese characters.
            public var lastName: String?
            /// User types:<br>`1` - Basic.<br>`2` - Licensed.<br>`3` - On-prem.<br>`99` - None (this can only be set with `ssoCreate`).
            public var type: Int?
            /// Personal meeting ID: length must be 10.
            public var pmi: Int?
            /// Use Personal Meeting ID for instant meetings.
            public var usePmi: Bool
            /// The time zone ID for a user profile. For this parameter value please refer to the ID value in the [timezone](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) list.
            public var timezone: String?
            /// Language
            public var language: String?
            /// Department for user profile: use for report.
            public var dept: String?
            /// Personal meeting room name.
            public var vanityName: String?
            /// Host key. It should be a 6-10 digit number.
            public var hostKey: String?
            /// Kaltura user ID.
            public var cmsUserID: String?
            /// User's job title.
            public var jobTitle: String?
            /// User's company.
            public var company: String?
            /// User's location.
            public var location: String?
            /// **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead to assign phone number(s) to a user.
            /// 
            /// 
            /// Phone number of the user. To update a phone number, you must also provide the `phone_country` field.
            public var phoneNumber: String?
            /// **Note:** This field has been **deprecated** and will not be supported in the future. Use the **country** field of the **phone_numbers** object instead to select the country for the phone number.
            /// 
            /// 
            /// 
            /// [Country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) of the phone number. For example, if the phone number provided in the `phone_number` field is a Brazil based number, the value of the `phone_country` field should be `BR`.
            public var phoneCountry: String?
            /// Custom attribute(s) of the user.
            public var customAttributes: CustomAttributes?
            /// Provide unique identifier of the group that you would like to add a [pending user](https://support.zoom.us/hc/en-us/articles/201363183-Managing-users#h_13c87a2a-ecd6-40ad-be61-a9935e660edb) to. The value of this field can be retrieved from [List Groups](https://marketplace.zoom.us/docs/api-reference/zoom-api/groups/groups) API.
            public var groupID: String?
            public var phoneNumbers: PhoneNumbers?
            /// The manager for the user.
            public var manager: String?
            /// The user's pronouns.
            public var pronouns: String?
            /// The user's display pronouns setting:
            /// * `1`  Ask the user every time they join meetings and webinars. 
            /// * `2`  Always display pronouns in meetings and webinars. 
            /// * `3`  Do not display pronouns in meetings and webinars.
            public var pronounsOption: Int?

            /// Custom attribute(s) of the user.
            public struct CustomAttributes: Encodable {
                /// Identifier for the custom attribute.
                public var key: String?
                /// Name of the custom attribute.
                public var name: String?
                /// Value of the custom attribute.
                public var value: String?

                public init(key: String? = nil, name: String? = nil, value: String? = nil) {
                    self.key = key
                    self.name = name
                    self.value = value
                }
            }

            public struct PhoneNumbers: Encodable {
                /// [Country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) of the phone number. For example, if the phone number provided in the `number` field is a Brazil based number, the value of the `country` field should be `BR`.
                public var country: String?
                /// Country code of the phone number. For example, for United States phone numbers, the value of this field should be "+1".
                public var code: String?
                /// Phone number of the user.
                public var number: String?
                /// The label to add to the user's phone number. You can only add one label to the user's phone number:
                /// 
                /// * `Mobile`
                /// * `Office`
                /// * `Home`
                /// * `Fax`
                public var label: Label?

                /// The label to add to the user's phone number. You can only add one label to the user's phone number:
                /// 
                /// * `Mobile`
                /// * `Office`
                /// * `Home`
                /// * `Fax`
                public enum Label: String, Codable, CaseIterable {
                    case mobile = "Mobile"
                    case office = "Office"
                    case home = "Home"
                    case fax = "Fax"
                }

                public init(country: String? = nil, code: String? = nil, number: String? = nil, label: Label? = nil) {
                    self.country = country
                    self.code = code
                    self.number = number
                    self.label = label
                }
            }

            public init(firstName: String? = nil, lastName: String? = nil, type: Int? = nil, pmi: Int? = nil, usePmi: Bool? = nil, timezone: String? = nil, language: String? = nil, dept: String? = nil, vanityName: String? = nil, hostKey: String? = nil, cmsUserID: String? = nil, jobTitle: String? = nil, company: String? = nil, location: String? = nil, phoneNumber: String? = nil, phoneCountry: String? = nil, customAttributes: CustomAttributes? = nil, groupID: String? = nil, phoneNumbers: PhoneNumbers? = nil, manager: String? = nil, pronouns: String? = nil, pronounsOption: Int? = nil) {
                self.firstName = firstName
                self.lastName = lastName
                self.type = type
                self.pmi = pmi
                self.usePmi = usePmi ?? false
                self.timezone = timezone
                self.language = language
                self.dept = dept
                self.vanityName = vanityName
                self.hostKey = hostKey
                self.cmsUserID = cmsUserID
                self.jobTitle = jobTitle
                self.company = company
                self.location = location
                self.phoneNumber = phoneNumber
                self.phoneCountry = phoneCountry
                self.customAttributes = customAttributes
                self.groupID = groupID
                self.phoneNumbers = phoneNumbers
                self.manager = manager
                self.pronouns = pronouns
                self.pronounsOption = pronounsOption
            }

            private enum CodingKeys: String, CodingKey {
                case firstName = "first_name"
                case lastName = "last_name"
                case type
                case pmi
                case usePmi = "use_pmi"
                case timezone
                case language
                case dept
                case vanityName = "vanity_name"
                case hostKey = "host_key"
                case cmsUserID = "cms_user_id"
                case jobTitle = "job_title"
                case company
                case location
                case phoneNumber = "phone_number"
                case phoneCountry = "phone_country"
                case customAttributes = "custom_attributes"
                case groupID = "group_id"
                case phoneNumbers = "phone_numbers"
                case manager
                case pronouns
                case pronounsOption = "pronouns_option"
            }
        }

        /// Delete a user
        ///
        /// Use this API to disassociate (unlink) a user or permanently delete a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Deleting** a user **permanently** removes the user and their data from Zoom. Users can create a new Zoom account using the same email address. An account owner or an account admin can transfer meetings, webinars and cloud recordings to another Zoom user account before deleting.
        /// 
        /// **Disassociating** a user unlinks the user from the associated Zoom account and provides the user their own basic free Zoom account. The disassociated user can then purchase their own Zoom licenses. An account owner or account admin can transfer the user's meetings, webinars, and cloud recordings to another user before disassociation.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func delete(parameters: DeleteParameters? = nil) -> Request<Void> {
            .delete(path, query: parameters?.asQuery)
        }

        public struct DeleteParameters {
            public var action: Action?
            public var transferEmail: String?
            public var isTransferMeeting: Bool?
            public var isTransferWebinar: Bool?
            public var isTransferRecording: Bool?

            public enum Action: String, Codable, CaseIterable {
                case disassociate
                case delete
            }

            public init(action: Action? = nil, transferEmail: String? = nil, isTransferMeeting: Bool? = nil, isTransferWebinar: Bool? = nil, isTransferRecording: Bool? = nil) {
                self.action = action
                self.transferEmail = transferEmail
                self.isTransferMeeting = isTransferMeeting
                self.isTransferWebinar = isTransferWebinar
                self.isTransferRecording = isTransferRecording
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(action, forKey: "action")
                encoder.encode(transferEmail, forKey: "transfer_email")
                encoder.encode(isTransferMeeting, forKey: "transfer_meeting")
                encoder.encode(isTransferWebinar, forKey: "transfer_webinar")
                encoder.encode(isTransferRecording, forKey: "transfer_recording")
                return encoder.items
            }
        }
    }
}

extension Paths.Users {
    public var me: Me {
        Me(path: path + "/me")
    }

    public struct Me {
        /// Path: `/users/me`
        public let path: String
    }
}

extension Paths.Users.Me {
    public var zak: Zak {
        Zak(path: path + "/zak")
    }

    public struct Zak {
        /// Path: `/users/me/zak`
        public let path: String

        /// Get user's ZAK
        ///
        /// Get Users Zoom Access Token (ZAK). You can use a ZAK to enable a non-login user to join a meeting on your app. Non-login users do not need to enter their username and password to join meetings.
        /// 
        /// **Scope:** `user_zak:read`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The user's ZAK.
            public var token: String?

            public init(token: String? = nil) {
                self.token = token
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var assistants: Assistants {
        Assistants(path: path + "/assistants")
    }

    public struct Assistants {
        /// Path: `/users/{userId}/assistants`
        public let path: String

        /// List user assistants
        ///
        /// List a user's assistants. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Assistants are the users to whom the current user has assigned [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting on behalf of the current user as well as manage and act as an alternative host for all meetings if the admin has enabled [Co-host option](https://zoom.us/account/setting) on the account.
        /// 
        /// **Scopes:** `user:read:admin`, `user:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * Current user as well as the assistant must have Licensed or an On-prem license.
        /// * Assistants must be under the current user's account.
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// User assistants List
        ///
        /// List of user's assistants.
        public struct GetResponse: Decodable {
            /// List of User's assistants.
            public var assistants: [Assistant]?

            public struct Assistant: Decodable {
                /// Assistant's user ID.
                public var id: String?
                /// Assistant's email address.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(assistants: [Assistant]? = nil) {
                self.assistants = assistants
            }
        }

        /// Add assistants
        ///
        /// Use this API to assign assistants to a user. In the request body, provide either the user's ID or the user's email address. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        ///  Assistants are users to whom the current user has assigned the [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meetings on behalf of the current user. Assistants can also manage and act as an alternative host for the user's meetings if the administrator has enabled the [co-host feature](https://support.zoom.us/hc/en-us/articles/206330935-Enabling-and-adding-a-co-host) on the account.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write` </br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` 
        /// 
        /// **Prerequisites:** 
        /// * The user and the assistant must have a Licensed or an On-prem license. 
        /// * Assistants must be under the current user's account or in the same organization with the current user's account.
        public func post(assistants: [PostRequest.Assistant]? = nil) -> Request<PostResponse> {
            .post(path, body: PostRequest(assistants: assistants))
        }

        public enum PostResponseHeaders {
            /// Location of created assistant
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// User ID.
            public var ids: String?
            public var addAt: Date?

            public init(ids: String? = nil, addAt: Date? = nil) {
                self.ids = ids
                self.addAt = addAt
            }

            private enum CodingKeys: String, CodingKey {
                case ids
                case addAt = "add_at"
            }
        }

        /// User assistants List
        ///
        /// List of user's assistants.
        public struct PostRequest: Encodable {
            /// List of User's assistants.
            public var assistants: [Assistant]?

            public struct Assistant: Encodable {
                /// Assistant's user ID.
                public var id: String?
                /// Assistant's email address.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(assistants: [Assistant]? = nil) {
                self.assistants = assistants
            }
        }

        /// Delete user assistants
        ///
        /// Delete all assistants of the current user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Assistants are the users to whom the current user has assigned [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting on behalf of the current user as well as manage and act as an alternative host for all meetings if the admin has enabled [Co-host option](https://zoom.us/account/setting) on the account.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * The user as well as the assistant must have Licensed or an On-prem license.
        /// * Assistants must be under the current user's account.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID.Assistants {
    public func assistantID(_ assistantID: String) -> WithAssistantID {
        WithAssistantID(path: "\(path)/\(assistantID)")
    }

    public struct WithAssistantID {
        /// Path: `/users/{userId}/assistants/{assistantId}`
        public let path: String

        /// Delete a user assistant
        ///
        /// Delete a specific assistant of a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Assistants are the users to whom the current user has assigned [scheduling privilege](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-Privilege). These assistants can schedule meeting on behalf of the current user as well as manage and act as an alternative host for all meetings if the admin has enabled [Co-host option](https://zoom.us/account/setting) on the account.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * The user as well as the assistant must have Licensed or an On-prem license.
        /// * Assistants must be under the current user's account.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var schedulers: Schedulers {
        Schedulers(path: path + "/schedulers")
    }

    public struct Schedulers {
        /// Path: `/users/{userId}/schedulers`
        public let path: String

        /// List user schedulers
        ///
        /// List all the schedulers of a user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Schedulers in this context are the users for whom the current user can schedule meetings for. For example, if the current user (the user whose `userId` was passed in the `path` parameter) is "user A", the response of this API will contain a list of user(s), for whom user A can schedule and manage meetings. User A is the assistant of these users and thus has scheduling privilege for these user(s).
        /// 
        /// **Scopes:** `user:read:admin`, `user:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * Current user must be under the same account as the scheduler.
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// User schedulers List
        ///
        /// List of user's schedulers.
        public struct GetResponse: Decodable {
            /// List of users for whom the current user can schedule meetings.
            public var schedulers: [Scheduler]?

            public struct Scheduler: Decodable {
                /// Unique Identifier (User ID) of the Scheduler.
                public var id: String?
                /// Email address of the scheduler.
                public var email: String?
                /// PMI of the meeting host in long (int64) format.
                public var pmi: Int?

                public init(id: String? = nil, email: String? = nil, pmi: Int? = nil) {
                    self.id = id
                    self.email = email
                    self.pmi = pmi
                }
            }

            public init(schedulers: [Scheduler]? = nil) {
                self.schedulers = schedulers
            }
        }

        /// Delete user schedulers
        ///
        /// Delete all of a user's schedulers. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Schedulers are users on whose behalf the current user (assistant) can schedule meetings for. By calling this API, the current user will no longer be a scheduling assistant of any user. 
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Current user (assistant) must be under the same account as the scheduler.
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID.Schedulers {
    public func schedulerID(_ schedulerID: String) -> WithSchedulerID {
        WithSchedulerID(path: "\(path)/\(schedulerID)")
    }

    public struct WithSchedulerID {
        /// Path: `/users/{userId}/schedulers/{schedulerId}`
        public let path: String

        /// Delete a scheduler
        ///
        /// Delete a scheduler. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Schedulers are users on whose behalf the current user (assistant) can schedule meetings for. By calling this API, the current user will no longer be a scheduling assistant of this scheduler.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Current user must be under the same account as the scheduler.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var picture: Picture {
        Picture(path: path + "/picture")
    }

    public struct Picture {
        /// Path: `/users/{userId}/picture`
        public let path: String

        /// Upload a user's profile picture
        ///
        /// Upload a user's profile picture. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Provide `multipart/form-data` as the value of the `content-type` header for this request. This API supports `.jpeg` and `.png` file formats.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func post(_ body: Data) -> Request<Void> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of user's picture
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        /// Delete a user's profile picture
        ///
        /// Use this API to delete a user's profile picture. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        /// **Scopes:** `user:write:admin`, `user:write` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users.WithUserID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/users/{userId}/settings`
        public let path: String

        /// Get user settings
        ///
        /// Retrieve a user's settings. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `user:read:admin`, `user:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var loginType: LoginType?
            public var option: Option?
            public var customQueryFields: String?

            public enum LoginType: String, Codable, CaseIterable {
                case _0 = "0"
                case _1 = "1"
                case _11 = "11"
                case _21 = "21"
                case _23 = "23"
                case _24 = "24"
                case _27 = "27"
                case _97 = "97"
                case _98 = "98"
                case _99 = "99"
                case _100 = "100"
                case _101 = "101"
            }

            public enum Option: String, Codable, CaseIterable {
                case meetingAuthentication = "meeting_authentication"
                case recordingAuthentication = "recording_authentication"
                case meetingSecurity = "meeting_security"
            }

            public init(loginType: LoginType? = nil, option: Option? = nil, customQueryFields: String? = nil) {
                self.loginType = loginType
                self.option = option
                self.customQueryFields = customQueryFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(loginType, forKey: "login_type")
                encoder.encode(option, forKey: "option")
                encoder.encode(customQueryFields, forKey: "custom_query_fields")
                return encoder.items
            }
        }

        /// Update user settings
        ///
        /// Update a user's settings. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(option: Option? = nil, _ body: [String: AnyJSON]) -> Request<Void> {
            .patch(path, query: makePatchQuery(option), body: body)
        }

        private func makePatchQuery(_ option: Option?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            return encoder.items
        }

        public enum Option: String, Codable, CaseIterable {
            case meetingAuthentication = "meeting_authentication"
            case recordingAuthentication = "recording_authentication"
            case meetingSecurity = "meeting_security"
        }
    }
}

extension Paths.Users.WithUserID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/users/{userId}/status`
        public let path: String

        /// Update user status
        ///
        /// Use this API to [deactivate](https://support.zoom.us/hc/en-us/articles/115005269946-Remove-User-from-your-Account#h_6a9bc1c3-d739-4945-b1f2-00b3b88fb5cc) an active user or to [reactivate](https://support.zoom.us/hc/en-us/articles/115005269946-Remove-User-from-your-Account#h_16319724-d120-4be6-af5d-31582d134ea0) a deactivated user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// An account owner or admins can deactivate as well as activate a user in a Zoom account. Deactivating a user will remove all licenses associated with a user. It will prevent the deactivated user from logging into their Zoom account. A deactivated user can be reactivated. Reactivating a user grants the user access to login to their Zoom account.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func put(action: PutRequest.Action) -> Request<Void> {
            .put(path, body: PutRequest(action: action))
        }

        /// The action.
        public struct PutRequest: Encodable {
            /// The action types:<br>`activate` - Activate a deactivated user.<br>`deactivate` - Deactivate a user.
            public var action: Action

            /// The action types:<br>`activate` - Activate a deactivated user.<br>`deactivate` - Deactivate a user.
            public enum Action: String, Codable, CaseIterable {
                case activate
                case deactivate
            }

            public init(action: Action) {
                self.action = action
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var password: Password {
        Password(path: path + "/password")
    }

    public struct Password {
        /// Path: `/users/{userId}/password`
        public let path: String

        /// Update a user's password
        ///
        /// Update the [password](https://support.zoom.us/hc/en-us/articles/206344385-Change-a-User-s-Password) of a user using which the user can login to Zoom. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// After this request is processed successfully, an email notification will be sent to the user stating that the password was changed.<br>
        /// **Scopes:** `user:write:admin` `user:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// **Prerequisites:**<br>
        /// * Owner or admin of the Zoom account.
        public func put(password: String) -> Request<Void> {
            .put(path, body: ["password": password])
        }
    }
}

extension Paths.Users.WithUserID {
    public var permissions: Permissions {
        Permissions(path: path + "/permissions")
    }

    public struct Permissions {
        /// Path: `/users/{userId}/permissions`
        public let path: String

        /// Get user permissions
        ///
        /// Use this API to get permissions that have been granted to the user. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Users can be assigned a set of permissions that allows them to access only the pages/information that a user needs to view or edit.
        /// 
        /// **Scopes:** `user:read:admin`, `user:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// List of user permissions.
            public var permissions: [String]?

            public init(permissions: [String]? = nil) {
                self.permissions = permissions
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var token: Token {
        Token(path: path + "/token")
    }

    public struct Token {
        /// Path: `/users/{userId}/token`
        public let path: String

        /// Get a user token
        ///
        /// Retrieve a user's token. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// This token is used for starting meetings with the Client SDK. If a user signed into Zoom using Google or Facebook, a null value will be returned for the token. To get the token with this API, ask the user to sign into Zoom using their email and password instead.
        /// 
        /// **Scopes:** `user:read:admin`, `user:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func get(type: `Type`? = nil, ttl: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(type, ttl))
        }

        public struct GetResponse: Decodable {
            /// User token.
            public var token: String?

            public init(token: String? = nil) {
                self.token = token
            }
        }

        private func makeGetQuery(_ type: `Type`?, _ ttl: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            encoder.encode(ttl, forKey: "ttl")
            return encoder.items
        }

        public enum `Type`: String, Codable, CaseIterable {
            case token
            case zak
        }

        /// Revoke a user's SSO token
        ///
        /// Revoke a user's SSO token. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// After calling this API, the SSO user will be logged out of their current Zoom session.
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Users {
    public var email: Email {
        Email(path: path + "/email")
    }

    public struct Email {
        /// Path: `/users/email`
        public let path: String

        /// Check a user email
        ///
        /// Verify if a user's email is registered with Zoom.<br><br>
        /// 
        /// <b>Note: </b>You can successfully check if a user is a registered Zoom user only if the user **signed up for Zoom via email and is within your account.** If you provide an email address of a user who is not in your account, the value of "existed_email" parameter will be "false" irrespective of whether or not the user is registered with Zoom. The response of this API call will not include users who joined Zoom using options such as "Sign in with SSO", "Sign in with Google" or "Sign in with Facebook" even if they are in the same account as yours.
        /// 
        /// **Scopes:** `user:read:admin` `user:read`
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func get(email: String) -> Request<GetResponse> {
            .get(path, query: [("email", email)])
        }

        public struct GetResponse: Decodable {
            /// Indicates whether or not the email already exists in Zoom.
            public var isExistedEmail: Bool?

            public init(isExistedEmail: Bool? = nil) {
                self.isExistedEmail = isExistedEmail
            }

            private enum CodingKeys: String, CodingKey {
                case isExistedEmail = "existed_email"
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var email: Email {
        Email(path: path + "/email")
    }

    public struct Email {
        /// Path: `/users/{userId}/email`
        public let path: String

        /// Update a user's email
        ///
        /// Change a user's [email address](https://support.zoom.us/hc/en-us/articles/201362563-How-Do-I-Change-the-Email-on-My-Account-) on a Zoom account that has managed domain set up. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// * If the Zoom account in which the user belongs has multiple [managed domains](https://support.zoom.us/hc/en-us/articles/203395207-What-is-Managed-Domain-), then the email to be updated **must** match one of the managed domains.
        /// * A user's email address can **only** be changed for a maximum of 3 times in a day (24 hours).
        /// 
        /// **Scopes:** `user:write:admin`, `user:write`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * Managed domain must be enabled in the account. 
        /// * The new email address should not already exist in Zoom.
        public func put(email: String) -> Request<Void> {
            .put(path, body: ["email": email])
        }
    }
}

extension Paths.Users {
    public var vanityName: VanityName {
        VanityName(path: path + "/vanity_name")
    }

    public struct VanityName {
        /// Path: `/users/vanity_name`
        public let path: String

        /// Check a user's PM room
        ///
        /// A personal meeting room is a virtual meeting room that can be permanently assigned to a user.
        /// Use this API to check if a personal meeting room with the given name exists or not.<br><br>
        /// **Scopes:** `user:read:admin` `user:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func get(vanityName: String) -> Request<GetResponse> {
            .get(path, query: [("vanity_name", vanityName)])
        }

        public struct GetResponse: Decodable {
            /// If `true`, it indicates that the personal meeting room with the given name exists.<br> `false` - The room name does not exist.
            public var isExisted: Bool?

            public init(isExisted: Bool? = nil) {
                self.isExisted = isExisted
            }

            private enum CodingKeys: String, CodingKey {
                case isExisted = "existed"
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var presenceStatus: PresenceStatus {
        PresenceStatus(path: path + "/presence_status")
    }

    public struct PresenceStatus {
        /// Path: `/users/{userId}/presence_status`
        public let path: String

        /// Update a user's presence status
        ///
        /// Use this API to update a user's presence status. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// A user's status **cannot** be updated more than once per minute. For example, you can only submit a maximum of one update request per minute for a single user.
        /// 
        /// Users in the Zoom desktop client and mobile apps are assigned with a [presence status](https://support.zoom.us/hc/en-us/articles/360032554051-Status-Icons). The presence status informs users of their contact's availability. Users can also change their own presence status to one the following:
        /// * **Away**
        /// * **Do not disturb**
        /// * **Available**
        /// * **In a calendar event**
        /// * **Presenting**
        /// * **In a Zoom meeting**
        /// * **On a call**
        /// 
        /// Note that a user's presence status **cannot** be updated via this API if the user is not logged in to the Zoom client.
        /// 
        /// **Scopes:** `user:write`, `user:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(_ body: PutRequest? = nil) -> Request<[String: AnyJSON]> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// Presence status of the user. The value can be set to one of the following:<br>
            /// * `Away`
            /// * `Do_Not_Disturb`
            /// * `Available`
            /// * `In_Calendar_Event`
            /// * `Presenting`
            /// * `In_A_Zoom_Meeting`
            /// * `On_A_Call`
            /// 
            /// Users who are on Zoom Client with a version **lower than 5.3.0** can update the status from:
            /// * `Away` to `Do_Not_Disturb` 
            /// * `Available` to `Do_Not_Disturb`
            /// 
            /// Users who are on **Zoom Client 5.3.0** or higher can update the status from:
            /// * `Do_Not_Disturb` to `Away`
            /// * `Do_Not_Disturb` to `Available`
            /// * `Available` to `Away`
            /// * `Away` to `Available`
            public var status: Status?
            /// If you're updating the status to `Do_Not_Disturb`, specify a duration in minutes for which the status should remain as `Do_Not_Disturb`. 
            /// 
            /// The default value is 20 minutes and the maximum allowed value is 1440 minutes.
            public var duration: Int?

            /// Presence status of the user. The value can be set to one of the following:<br>
            /// * `Away`
            /// * `Do_Not_Disturb`
            /// * `Available`
            /// * `In_Calendar_Event`
            /// * `Presenting`
            /// * `In_A_Zoom_Meeting`
            /// * `On_A_Call`
            /// 
            /// Users who are on Zoom Client with a version **lower than 5.3.0** can update the status from:
            /// * `Away` to `Do_Not_Disturb` 
            /// * `Available` to `Do_Not_Disturb`
            /// 
            /// Users who are on **Zoom Client 5.3.0** or higher can update the status from:
            /// * `Do_Not_Disturb` to `Away`
            /// * `Do_Not_Disturb` to `Available`
            /// * `Available` to `Away`
            /// * `Away` to `Available`
            public enum Status: String, Codable, CaseIterable {
                case doNoDisturb = "Do_No_Disturb"
                case away = "Away"
                case available = "Available"
                case inCalendarEvent = "In_Calendar_Event"
                case presenting = "Presenting"
                case inAZoomMeeting = "In_A_Zoom_Meeting"
                case onACall = "On_A_Call"
            }

            public init(status: Status? = nil, duration: Int? = nil) {
                self.status = status
                self.duration = duration
            }
        }
    }
}

extension Paths.Users.WithUserID.Settings {
    public var virtualBackgrounds: VirtualBackgrounds {
        VirtualBackgrounds(path: path + "/virtual_backgrounds")
    }

    public struct VirtualBackgrounds {
        /// Path: `/users/{userId}/settings/virtual_backgrounds`
        public let path: String

        /// Upload virtual background file
        ///
        /// Use this API to [upload a virtual background file](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background) to a user's profile. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        ///  **Note:** 
        /// * A user profile cannot exceed more than 10 virtual background files. 
        /// * You can only upload image files that are in JPG/JPEG, GIF or PNG format. 
        /// * Video files must be in MP4 or MOV file format with a minimum resolution of 480 by 360 pixels (360p) and a maximum resolution of 1920 by 1080 pixels (1080p). 
        /// * The virtual background file size cannot exceed 15 megabytes (MB). 
        /// 
        /// **Scopes:** `user:write`, `user:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` 
        /// 
        /// **Prerequisites:** 
        /// * The [**Virtual Background**](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) feature must be enabled on the account.
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// The virtual background file's ID.
            public var id: String?
            /// The virtual background file's name.
            public var name: String?
            /// The virtual background file's file type: 
            /// * `image`  An image file. 
            /// * `video`  A video file.
            public var type: `Type`?
            /// Whether the virtual background file is set as the default virtual background: 
            /// * `true`  The default virtual background. 
            /// * `false`  Not the default virtual background.
            public var isDefault: Bool?
            /// The virtual background file's size, in bytes.
            public var size: String?

            /// The virtual background file's file type: 
            /// * `image`  An image file. 
            /// * `video`  A video file.
            public enum `Type`: String, Codable, CaseIterable {
                case image
                case video
            }

            public init(id: String? = nil, name: String? = nil, type: `Type`? = nil, isDefault: Bool? = nil, size: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.isDefault = isDefault
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case isDefault = "is_default"
                case size
            }
        }

        /// Delete virtual background files
        ///
        /// Use this API to delete a user's virtual background files. For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        /// **Scopes:** `user:write`, `user:write:admin` <br >**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        /// **Prerequisites:** 
        /// * The [**Virtual Background**](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) feature must be enabled on the account.
        public func delete(fileIDs: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(fileIDs))
        }

        private func makeDeleteQuery(_ fileIDs: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fileIDs, forKey: "file_ids")
            return encoder.items
        }
    }
}

extension Paths {
    public static var metrics: Metrics {
        Metrics(path: "/metrics")
    }

    public struct Metrics {
        /// Path: `/metrics`
        public let path: String
    }
}

extension Paths.Metrics {
    public var meetings: Meetings {
        Meetings(path: path + "/meetings")
    }

    public struct Meetings {
        /// Path: `/metrics/meetings`
        public let path: String

        /// List meetings
        ///
        /// List total live or past meetings that occurred during a specified period of time. This overview will show if features such as audio, video, screen sharing, and recording were being used in the meeting. You can also see the license types of each user on your account.<br> You can specify a monthly date range for the dashboard data using the `from` and `to` query parameters. The month should fall within the last six months.<br>
        /// **Scopes:** `dashboard_meetings:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Resource-intensive`<br><br>
        /// **Prerequisites:** <br>
        /// * Business or a higher plan.<br><br>
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date for this report in 'yyyy-mm-dd' format.
            public var from: NaiveDate?
            /// Array of meeting objects.
            public var meetings: [Meeting]?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// End date for this report in 'yyyy-mm-dd' format.
            public var to: NaiveDate?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            /// Metrics
            ///
            /// Meeting metric details.
            public struct Meeting: Decodable {
                /// Meeting UUID. Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
                public var uuid: String?
                /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
                public var id: Int?
                /// Meeting topic.
                public var topic: String?
                /// Host display name.
                public var host: String?
                /// Email address of the host.
                public var email: String?
                /// License type of the user.
                public var userType: String?
                /// Meeting start time.
                public var startTime: Date?
                /// Meeting end time.
                public var endTime: Date?
                /// Meeting duration. Formatted as hh:mm:ss, for example: `16:08` for 16 minutes and 8 seconds.
                public var duration: String?
                /// Meeting participant count.
                public var participants: Int?
                /// Indicates whether or not the PSTN was used in the meeting.
                public var hasPstn: Bool?
                /// Indicates whether or not VoIP was used in the meeting.
                public var hasVoip: Bool?
                /// Indicates whether or not [third party audio](https://support.zoom.us/hc/en-us/articles/202470795-3rd-Party-Audio-Conference) was used in the meeting.
                public var isHas3rdPartyAudio: Bool?
                /// Indicates whether or not video was used in the meeting.
                public var hasVideo: Bool?
                /// Indicates whether or not screenshare feature was used in the meeting.
                public var hasScreenShare: Bool?
                /// Indicates whether or not the recording feature was used in the meeting.
                public var hasRecording: Bool?
                /// Indicates whether or not someone joined the meeting using SIP.
                public var hasSip: Bool?
                /// Whether the archiving feature was used in the meeting.
                public var hasArchiving: Bool?
                /// The number of Zoom Room participants in the meeting.
                public var inRoomParticipants: Int?
                /// Department of the host.
                public var dept: String?
                /// Custom keys and values assigned to the meeting.
                public var customKeys: [CustomKey]?
                /// Tracking fields and values assigned to the meeting.
                public var trackingFields: [TrackingField]?

                public struct CustomKey: Decodable {
                    /// Custom key associated with the meeting.
                    public var key: String?
                    /// Value of the custom key associated with the meeting.
                    public var value: String?

                    public init(key: String? = nil, value: String? = nil) {
                        self.key = key
                        self.value = value
                    }
                }

                public struct TrackingField: Decodable {
                    /// Label of the tracking field.
                    public var field: String?
                    /// Value of the tracking field.
                    public var value: String?

                    public init(field: String? = nil, value: String? = nil) {
                        self.field = field
                        self.value = value
                    }
                }

                public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, inRoomParticipants: Int? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil, trackingFields: [TrackingField]? = nil) {
                    self.uuid = uuid
                    self.id = id
                    self.topic = topic
                    self.host = host
                    self.email = email
                    self.userType = userType
                    self.startTime = startTime
                    self.endTime = endTime
                    self.duration = duration
                    self.participants = participants
                    self.hasPstn = hasPstn
                    self.hasVoip = hasVoip
                    self.isHas3rdPartyAudio = isHas3rdPartyAudio
                    self.hasVideo = hasVideo
                    self.hasScreenShare = hasScreenShare
                    self.hasRecording = hasRecording
                    self.hasSip = hasSip
                    self.hasArchiving = hasArchiving
                    self.inRoomParticipants = inRoomParticipants
                    self.dept = dept
                    self.customKeys = customKeys
                    self.trackingFields = trackingFields
                }

                private enum CodingKeys: String, CodingKey {
                    case uuid
                    case id
                    case topic
                    case host
                    case email
                    case userType = "user_type"
                    case startTime = "start_time"
                    case endTime = "end_time"
                    case duration
                    case participants
                    case hasPstn = "has_pstn"
                    case hasVoip = "has_voip"
                    case isHas3rdPartyAudio = "has_3rd_party_audio"
                    case hasVideo = "has_video"
                    case hasScreenShare = "has_screen_share"
                    case hasRecording = "has_recording"
                    case hasSip = "has_sip"
                    case hasArchiving = "has_archiving"
                    case inRoomParticipants = "in_room_participants"
                    case dept
                    case customKeys = "custom_keys"
                    case trackingFields = "tracking_fields"
                }
            }

            public init(from: NaiveDate? = nil, meetings: [Meeting]? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil) {
                self.from = from
                self.meetings = meetings
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.to = to
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case meetings
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case to
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeFields: IncludeFields?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case pastOne
                case live
            }

            public enum IncludeFields: String, Codable, CaseIterable {
                case trackingFields = "tracking_fields"
            }

            public init(type: `Type`? = nil, from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil, includeFields: IncludeFields? = nil) {
                self.type = type
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeFields = includeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeFields, forKey: "include_fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Meetings {
    public func meetingID(_ meetingID: String) -> WithMeetingID {
        WithMeetingID(path: "\(path)/\(meetingID)")
    }

    public struct WithMeetingID {
        /// Path: `/metrics/meetings/{meetingId}`
        public let path: String

        /// Get meeting details
        ///
        /// Get details on live or past meetings. This overview will show if features such as audio, video, screen sharing, and recording were being used in the meeting. You can also see the license types of each user on your account.<br> You can specify a monthly date range for the dashboard data using the `from` and `to` query parameters. The month should fall within the last six months.  <br>
        /// **Scopes:** `dashboard_meetings:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:** <br>
        /// * Business or a higher plan.
        public func get(type: `Type`? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(type))
        }

        /// Meeting Metrics
        ///
        /// Meeting metric details.
        public struct GetResponse: Decodable {
            /// Meeting UUID. Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
            public var uuid: String?
            /// [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in "**long**" format(represented as int64 data type in JSON), also known as the meeting number.
            public var id: Int?
            /// Meeting topic.
            public var topic: String?
            /// Host display name.
            public var host: String?
            /// Email address of the host.
            public var email: String?
            /// License type of the user.
            public var userType: String?
            /// Meeting start time.
            public var startTime: Date?
            /// Meeting end time.
            public var endTime: Date?
            /// Meeting duration.
            public var duration: String?
            /// Meeting participant count.
            public var participants: Int?
            /// Indicates whether or not the PSTN was used in the meeting.
            public var hasPstn: Bool?
            /// Indicates whether or not VoIP was used in the meeting.
            public var hasVoip: Bool?
            /// Indicates whether or not [third party audio](https://support.zoom.us/hc/en-us/articles/202470795-3rd-Party-Audio-Conference) was used in the meeting.
            public var isHas3rdPartyAudio: Bool?
            /// Indicates whether or not video was used in the meeting.
            public var hasVideo: Bool?
            /// Indicates whether or not screenshare feature was used in the meeting.
            public var hasScreenShare: Bool?
            /// Indicates whether or not the recording feature was used in the meeting.
            public var hasRecording: Bool?
            /// Indicates whether or not someone joined the meeting using SIP.
            public var hasSip: Bool?
            /// Whether the archiving feature was used in the meeting.
            public var hasArchiving: Bool?
            /// The number of Zoom Room participants in the meeting.
            public var inRoomParticipants: Int?
            /// Department of the host.
            public var dept: String?
            /// Custom keys and values assigned to the meeting.
            public var customKeys: [CustomKey]?

            public struct CustomKey: Decodable {
                /// Custom key associated with the meeting.
                public var key: String?
                /// Value of the custom key associated with the meeting.
                public var value: String?

                public init(key: String? = nil, value: String? = nil) {
                    self.key = key
                    self.value = value
                }
            }

            public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, inRoomParticipants: Int? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
                self.uuid = uuid
                self.id = id
                self.topic = topic
                self.host = host
                self.email = email
                self.userType = userType
                self.startTime = startTime
                self.endTime = endTime
                self.duration = duration
                self.participants = participants
                self.hasPstn = hasPstn
                self.hasVoip = hasVoip
                self.isHas3rdPartyAudio = isHas3rdPartyAudio
                self.hasVideo = hasVideo
                self.hasScreenShare = hasScreenShare
                self.hasRecording = hasRecording
                self.hasSip = hasSip
                self.hasArchiving = hasArchiving
                self.inRoomParticipants = inRoomParticipants
                self.dept = dept
                self.customKeys = customKeys
            }

            private enum CodingKeys: String, CodingKey {
                case uuid
                case id
                case topic
                case host
                case email
                case userType = "user_type"
                case startTime = "start_time"
                case endTime = "end_time"
                case duration
                case participants
                case hasPstn = "has_pstn"
                case hasVoip = "has_voip"
                case isHas3rdPartyAudio = "has_3rd_party_audio"
                case hasVideo = "has_video"
                case hasScreenShare = "has_screen_share"
                case hasRecording = "has_recording"
                case hasSip = "has_sip"
                case hasArchiving = "has_archiving"
                case inRoomParticipants = "in_room_participants"
                case dept
                case customKeys = "custom_keys"
            }
        }

        private func makeGetQuery(_ type: `Type`?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            return encoder.items
        }

        public enum `Type`: String, Codable, CaseIterable {
            case past
            case pastOne
            case live
        }
    }
}

extension Paths.Metrics.Meetings.WithMeetingID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/metrics/meetings/{meetingId}/participants`
        public let path: String

        /// List meeting participants
        ///
        /// Use this API to return a list of participants from live or past meetings. 
        /// 
        ///  If you do not provide the `type` query parameter, the default value will be set to the `live` value. This API will only return metrics for participants in a live meeting, if any exist. You can specify a monthly date range for the dashboard data using the `from` and `to` query parameters. The month should fall within the last six months. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `dashboard_meetings:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business or higher plan.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Information about the meeting participants. If a participant left a meeting and rejoined the same meeting, their information will appear as many times as they joined the meeting.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// The participant's universally unique ID. This value is the same as the participant's user ID if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging into Zoom, this returns an empty value.
                public var id: String?
                /// The participant's ID. This value assigned to a participant upon joining a meeting and is only valid for the meeting's duration.
                public var userID: String?
                /// The participant's display name.
                public var userName: String?
                /// The type of device the participant used to join the meeting: 
                /// * `Phone`  The participant joined via PSTN. 
                /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
                /// * `Windows`  The participant joined via VoIP using a Windows device. 
                /// * `Mac`  The participant joined via VoIP using a Mac device. 
                /// * `iOS`  The participant joined via VoIP using an iOS device. 
                /// * `Android`  The participant joined via VoIP using an Android device. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var device: Device?
                /// The participant's IP address.
                public var ipAddress: String?
                /// The participant's location.
                public var location: String?
                /// The participant's network type: 
                /// 
                /// * `Wired` 
                /// * `Wifi` 
                /// * `PPP`  Point-to-Point. 
                /// * `Cellular`  3G, 4G, and 5G cellular. 
                /// * `Others`  An unknown device.
                public var networkType: NetworkType?
                /// The type of microphone that the participant used during the meeting. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var microphone: String?
                /// The type of speaker that the participant used during the meeting. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var speaker: String?
                /// The type of camera that the participant used during the meeting. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var camera: String?
                /// The data center where participant's meeting data is stored.
                public var dataCenter: String?
                /// The data center where participant's meeting data is stored. This field includes a semicolon-separated list of HTTP Tunnel (HT), Cloud Room Connector (CRC), and Real-Time Web Gateway (RWG) location information.
                public var fullDataCenter: String?
                /// The participant's connection type.
                public var connectionType: String?
                /// The time at which participant joined the meeting.
                public var joinTime: Date?
                /// The time at which a participant left the meeting. For live meetings, this field will only return if a participant has left the ongoing meeting.
                public var leaveTime: Date?
                /// Whether the participant chose to share an iPhone/iPad app during the screenshare.
                public var isShareApplication: Bool?
                /// Whether the participant chose to share their desktop during the screenshare.
                public var isShareDesktop: Bool?
                /// Whether the participant chose to share their whiteboard during the screenshare.
                public var isShareWhiteboard: Bool?
                /// Whether the recording feature was used during the meeting.
                public var isRecording: Bool?
                /// The participant's PC name.
                public var pcName: String?
                /// The participant's PC domain. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var domain: String?
                /// The participant's MAC address. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var macAddr: String?
                /// The participant's hard disk ID. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var harddiskID: String?
                /// The participant's Zoom client version.
                public var version: String?
                /// The number of participants that joined via Zoom Room.
                public var inRoomParticipants: Int?
                /// The reason why the participant left the meeting, where `$name` is the participant's username: 
                /// * `$name left the meeting.` 
                /// * `$name got disconnected from the meeting.` 
                /// * `Host ended the meeting.` 
                /// * `Host closed the meeting.` 
                /// * `Host started a new meeting.` 
                /// * `Network connection error.` 
                /// * `Host did not join.` 
                /// * `Exceeded free meeting minutes limit.` 
                /// * `Removed by host.` 
                /// * `Unknown reason.` 
                /// * `Leave waiting room.` 
                /// * `Removed by host from waiting room.`
                public var leaveReason: LeaveReason?
                /// The participant's email address of the participant.
                public var email: String?
                /// The participant's unique registrant ID. This field only returns if you pass the `registrant_id` value for the `include_fields` query parameter. 
                /// 
                /// This field does not return if the `type` query parameter is the `live` value.
                public var registrantID: String?
                /// The participant's audio quality.
                /// 
                /// The API only returns this value when the **Meeting quality scores and network alerts on Dashboard** setting is enabled in the Zoom Web Portal and the **Show meeting quality score and network alerts on Dashboard** option is selected in [**Account Settings**](https://zoom.us/account/setting).
                public var audioQuality: AudioQuality?
                /// The participant's video quality.
                /// 
                /// The API only returns this value when the **Meeting quality scores and network alerts on Dashboard** setting is enabled in the Zoom Web Portal and the **Show meeting quality score and network alerts on Dashboard** option is selected in [**Account Settings**](https://zoom.us/account/setting).
                public var videoQuality: VideoQuality?
                /// The participant's screen share quality.
                /// 
                /// The API only returns this value when the **Meeting quality scores and network alerts on Dashboard** setting is enabled in the Zoom Web Portal and the **Show meeting quality score and network alerts on Dashboard** option is selected in [**Account Settings**](https://zoom.us/account/setting).
                public var screenShareQuality: ScreenShareQuality?
                /// A participant identifier. This value can be numbers or characters, up to a maximum length of 15 characters.
                public var customerKey: String?
                /// The participant's status: 
                /// * `in_meeting`  In a meeting. 
                /// * `in_waiting_room`  In a waiting room.
                public var status: Status?
                /// The meeting participant's SIP (Session Initiation Protocol) Contact header URI. The API only returns this response when the participant joins a meeting via SIP.
                public var sipUri: String?
                /// The meeting participant's SIP From header URI. The API only returns this response when the participant joins a meeting via SIP.
                public var fromSipUri: String?
                /// The participant's role: 
                /// * `host`  Host. 
                /// * `attendee`  Attendee.
                public var role: Role?

                /// The type of device the participant used to join the meeting: 
                /// * `Phone`  The participant joined via PSTN. 
                /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
                /// * `Windows`  The participant joined via VoIP using a Windows device. 
                /// * `Mac`  The participant joined via VoIP using a Mac device. 
                /// * `iOS`  The participant joined via VoIP using an iOS device. 
                /// * `Android`  The participant joined via VoIP using an Android device. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public enum Device: String, Codable, CaseIterable {
                    case phone = "Phone"
                    case h323Sip = "H.323/SIP"
                    case windows = "Windows"
                    case mac = "Mac"
                    case iOS
                    case android = "Android"
                }

                /// The participant's network type: 
                /// 
                /// * `Wired` 
                /// * `Wifi` 
                /// * `PPP`  Point-to-Point. 
                /// * `Cellular`  3G, 4G, and 5G cellular. 
                /// * `Others`  An unknown device.
                public enum NetworkType: String, Codable, CaseIterable {
                    case wired = "Wired"
                    case wifi = "Wifi"
                    case ppp = "PPP"
                    case cellular = "Cellular"
                    case others = "Others"
                }

                /// The reason why the participant left the meeting, where `$name` is the participant's username: 
                /// * `$name left the meeting.` 
                /// * `$name got disconnected from the meeting.` 
                /// * `Host ended the meeting.` 
                /// * `Host closed the meeting.` 
                /// * `Host started a new meeting.` 
                /// * `Network connection error.` 
                /// * `Host did not join.` 
                /// * `Exceeded free meeting minutes limit.` 
                /// * `Removed by host.` 
                /// * `Unknown reason.` 
                /// * `Leave waiting room.` 
                /// * `Removed by host from waiting room.`
                public enum LeaveReason: String, Codable, CaseIterable {
                    case nameLeftTheMeeting = "$name left the meeting."
                    case nameGotDisconnectedFromTheMeeting = "$name got disconnected from the meeting."
                    case hostEndedTheMeeting = "Host ended the meeting."
                    case hostClosedTheMeeting = "Host closed the meeting."
                    case hostStartedANewMeeting = "Host started a new meeting."
                    case networkConnectionError = "Network connection error."
                    case hostDidNotJoin = "Host did not join."
                    case exceededFreeMeetingMinutesLimit = "Exceeded free meeting minutes limit."
                    case removedByHost = "Removed by host."
                    case unknownReason = "Unknown reason."
                    case leaveWaitingRoom = "Leave waiting room."
                    case removedByHostFromWaitingRoom = "Removed by host from waiting room."
                }

                /// The participant's audio quality.
                /// 
                /// The API only returns this value when the **Meeting quality scores and network alerts on Dashboard** setting is enabled in the Zoom Web Portal and the **Show meeting quality score and network alerts on Dashboard** option is selected in [**Account Settings**](https://zoom.us/account/setting).
                public enum AudioQuality: String, Codable, CaseIterable {
                    case empty = " "
                    case good
                    case fair
                    case poor
                    case bad
                }

                /// The participant's video quality.
                /// 
                /// The API only returns this value when the **Meeting quality scores and network alerts on Dashboard** setting is enabled in the Zoom Web Portal and the **Show meeting quality score and network alerts on Dashboard** option is selected in [**Account Settings**](https://zoom.us/account/setting).
                public enum VideoQuality: String, Codable, CaseIterable {
                    case empty = " "
                    case good
                    case fair
                    case poor
                    case bad
                }

                /// The participant's screen share quality.
                /// 
                /// The API only returns this value when the **Meeting quality scores and network alerts on Dashboard** setting is enabled in the Zoom Web Portal and the **Show meeting quality score and network alerts on Dashboard** option is selected in [**Account Settings**](https://zoom.us/account/setting).
                public enum ScreenShareQuality: String, Codable, CaseIterable {
                    case empty = " "
                    case good
                    case fair
                    case poor
                    case bad
                }

                /// The participant's status: 
                /// * `in_meeting`  In a meeting. 
                /// * `in_waiting_room`  In a waiting room.
                public enum Status: String, Codable, CaseIterable {
                    case inMeeting = "in_meeting"
                    case inWaitingRoom = "in_waiting_room"
                }

                /// The participant's role: 
                /// * `host`  Host. 
                /// * `attendee`  Attendee.
                public enum Role: String, Codable, CaseIterable {
                    case host
                    case attendee
                }

                public init(id: String? = nil, userID: String? = nil, userName: String? = nil, device: Device? = nil, ipAddress: String? = nil, location: String? = nil, networkType: NetworkType? = nil, microphone: String? = nil, speaker: String? = nil, camera: String? = nil, dataCenter: String? = nil, fullDataCenter: String? = nil, connectionType: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, isShareApplication: Bool? = nil, isShareDesktop: Bool? = nil, isShareWhiteboard: Bool? = nil, isRecording: Bool? = nil, pcName: String? = nil, domain: String? = nil, macAddr: String? = nil, harddiskID: String? = nil, version: String? = nil, inRoomParticipants: Int? = nil, leaveReason: LeaveReason? = nil, email: String? = nil, registrantID: String? = nil, audioQuality: AudioQuality? = nil, videoQuality: VideoQuality? = nil, screenShareQuality: ScreenShareQuality? = nil, customerKey: String? = nil, status: Status? = nil, sipUri: String? = nil, fromSipUri: String? = nil, role: Role? = nil) {
                    self.id = id
                    self.userID = userID
                    self.userName = userName
                    self.device = device
                    self.ipAddress = ipAddress
                    self.location = location
                    self.networkType = networkType
                    self.microphone = microphone
                    self.speaker = speaker
                    self.camera = camera
                    self.dataCenter = dataCenter
                    self.fullDataCenter = fullDataCenter
                    self.connectionType = connectionType
                    self.joinTime = joinTime
                    self.leaveTime = leaveTime
                    self.isShareApplication = isShareApplication
                    self.isShareDesktop = isShareDesktop
                    self.isShareWhiteboard = isShareWhiteboard
                    self.isRecording = isRecording
                    self.pcName = pcName
                    self.domain = domain
                    self.macAddr = macAddr
                    self.harddiskID = harddiskID
                    self.version = version
                    self.inRoomParticipants = inRoomParticipants
                    self.leaveReason = leaveReason
                    self.email = email
                    self.registrantID = registrantID
                    self.audioQuality = audioQuality
                    self.videoQuality = videoQuality
                    self.screenShareQuality = screenShareQuality
                    self.customerKey = customerKey
                    self.status = status
                    self.sipUri = sipUri
                    self.fromSipUri = fromSipUri
                    self.role = role
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userID = "user_id"
                    case userName = "user_name"
                    case device
                    case ipAddress = "ip_address"
                    case location
                    case networkType = "network_type"
                    case microphone
                    case speaker
                    case camera
                    case dataCenter = "data_center"
                    case fullDataCenter = "full_data_center"
                    case connectionType = "connection_type"
                    case joinTime = "join_time"
                    case leaveTime = "leave_time"
                    case isShareApplication = "share_application"
                    case isShareDesktop = "share_desktop"
                    case isShareWhiteboard = "share_whiteboard"
                    case isRecording = "recording"
                    case pcName = "pc_name"
                    case domain
                    case macAddr = "mac_addr"
                    case harddiskID = "harddisk_id"
                    case version
                    case inRoomParticipants = "in_room_participants"
                    case leaveReason = "leave_reason"
                    case email
                    case registrantID = "registrant_id"
                    case audioQuality = "audio_quality"
                    case videoQuality = "video_quality"
                    case screenShareQuality = "screen_share_quality"
                    case customerKey = "customer_key"
                    case status
                    case sipUri = "sip_uri"
                    case fromSipUri = "from_sip_uri"
                    case role
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeFields: IncludeFields?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case pastOne
                case live
            }

            public enum IncludeFields: String, Codable, CaseIterable {
                case registrantID = "registrant_id"
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, includeFields: IncludeFields? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeFields = includeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeFields, forKey: "include_fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Meetings.WithMeetingID.Participants {
    public func participantID(_ participantID: String) -> WithParticipantID {
        WithParticipantID(path: "\(path)/\(participantID)")
    }

    public struct WithParticipantID {
        /// Path: `/metrics/meetings/{meetingId}/participants/{participantId}`
        public let path: String
    }
}

extension Paths.Metrics.Meetings.WithMeetingID.Participants.WithParticipantID {
    public var qos: Qos {
        Qos(path: path + "/qos")
    }

    public struct Qos {
        /// Path: `/metrics/meetings/{meetingId}/participants/{participantId}/qos`
        public let path: String

        /// Get meeting participant QoS
        ///
        /// Use this API to return the quality of service (QoS) report for participants from live or past meetings. The data returned indicates the connection quality for sending/receiving video, audio, and shared content. The API returns this data for either the API request or when the API request was last received. 
        /// 
        /// When the sender sends data, a timestamp is attached to the senders data packet. The receiver then returns this timestamp to the sender. This helps determine the upstream and downstream latency, which includes the application processing time. The latency data returned is the five second average and five second maximum. 
        /// 
        ///  This API will **not** return data if there is no data being sent or received at the time of request. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `dashboard_meetings:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(type: `Type`? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(type))
        }

        /// Participant QOS
        ///
        /// Information about the participant and their quality of service (QoS).
        public struct GetResponse: Decodable {
            /// The participant's ID. This value is assigned to a participant upon joining a meeting and is only valid for the meeting's duration.
            public var userID: String?
            /// The participant's display name.
            public var userName: String?
            /// The type of device the participant used to join the meeting: 
            /// * `Phone`  The participant joined via PSTN. 
            /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
            /// * `Windows`  The participant joined via VoIP using a Windows device. 
            /// * `Mac`  The participant joined via VoIP using a Mac device. 
            /// * `iOS`  The participant joined via VoIP using an iOS device. 
            /// * `Android`  The participant joined via VoIP using an Android device. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var device: Device?
            /// The participant's IP address.
            public var ipAddress: String?
            /// The participant's location.
            public var location: String?
            /// The time at which the participant joined the meeting.
            public var joinTime: Date?
            /// The time at which the participant left the meeting.
            public var leaveTime: Date?
            /// The participant's PC name.
            public var pcName: String?
            /// The participant's PC domain. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var domain: String?
            /// The participant's MAC address. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var macAddr: String?
            /// The participant's hard disk ID. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var harddiskID: String?
            /// The participant's Zoom client version.
            public var version: String?
            /// The participant's quality of service information.
            public var userQos: [UserQo]?

            /// The type of device the participant used to join the meeting: 
            /// * `Phone`  The participant joined via PSTN. 
            /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
            /// * `Windows`  The participant joined via VoIP using a Windows device. 
            /// * `Mac`  The participant joined via VoIP using a Mac device. 
            /// * `iOS`  The participant joined via VoIP using an iOS device. 
            /// * `Android`  The participant joined via VoIP using an Android device. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public enum Device: String, Codable, CaseIterable {
                case phone = "Phone"
                case h323Sip = "H.323/SIP"
                case windows = "Windows"
                case mac = "Mac"
                case iOS
                case android = "Android"
            }

            public struct UserQo: Decodable {
                /// The QoS date and time.
                public var dateTime: Date?
                /// Audio QoS Object
                public var audioInput: AudioInput?
                /// Audio QoS Object
                public var audioOutput: AudioOutput?
                /// Video QoS Object
                public var videoInput: VideoInput?
                /// Video QoS Object
                public var videoOutput: VideoOutput?
                /// Video QoS Object
                public var asInput: AsInput?
                /// Video QoS Object
                public var asOutput: AsOutput?
                public var cpuUsage: CpuUsage?
                /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
                public var audioDeviceFromCrc: AudioDeviceFromCrc?
                /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
                public var audioDeviceToCrc: AudioDeviceToCrc?
                /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
                public var videoDeviceFromCrc: VideoDeviceFromCrc?
                /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
                public var videoDeviceToCrc: VideoDeviceToCrc?
                /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
                public var asDeviceFromCrc: AsDeviceFromCrc?
                /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
                public var asDeviceToCrc: AsDeviceToCrc?

                /// Audio QoS Object
                public struct AudioInput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// Audio QoS Object
                public struct AudioOutput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// Video QoS Object
                public struct VideoInput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                /// Video QoS Object
                public struct VideoOutput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                /// Video QoS Object
                public struct AsInput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                /// Video QoS Object
                public struct AsOutput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                public struct CpuUsage: Decodable {
                    /// Zoom's minimum CPU usage.
                    public var zoomMinCpuUsage: String?
                    /// Zoom's average CPU usage.
                    public var zoomAvgCpuUsage: String?
                    /// Zoom's maximum CPU usage.
                    public var zoomMaxCpuUsage: String?
                    /// The system's maximum CPU usage.
                    public var systemMaxCpuUsage: String?

                    public init(zoomMinCpuUsage: String? = nil, zoomAvgCpuUsage: String? = nil, zoomMaxCpuUsage: String? = nil, systemMaxCpuUsage: String? = nil) {
                        self.zoomMinCpuUsage = zoomMinCpuUsage
                        self.zoomAvgCpuUsage = zoomAvgCpuUsage
                        self.zoomMaxCpuUsage = zoomMaxCpuUsage
                        self.systemMaxCpuUsage = systemMaxCpuUsage
                    }

                    private enum CodingKeys: String, CodingKey {
                        case zoomMinCpuUsage = "zoom_min_cpu_usage"
                        case zoomAvgCpuUsage = "zoom_avg_cpu_usage"
                        case zoomMaxCpuUsage = "zoom_max_cpu_usage"
                        case systemMaxCpuUsage = "system_max_cpu_usage"
                    }
                }

                /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
                public struct AudioDeviceFromCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
                public struct AudioDeviceToCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
                public struct VideoDeviceFromCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
                public struct VideoDeviceToCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
                public struct AsDeviceFromCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
                public struct AsDeviceToCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                public init(dateTime: Date? = nil, audioInput: AudioInput? = nil, audioOutput: AudioOutput? = nil, videoInput: VideoInput? = nil, videoOutput: VideoOutput? = nil, asInput: AsInput? = nil, asOutput: AsOutput? = nil, cpuUsage: CpuUsage? = nil, audioDeviceFromCrc: AudioDeviceFromCrc? = nil, audioDeviceToCrc: AudioDeviceToCrc? = nil, videoDeviceFromCrc: VideoDeviceFromCrc? = nil, videoDeviceToCrc: VideoDeviceToCrc? = nil, asDeviceFromCrc: AsDeviceFromCrc? = nil, asDeviceToCrc: AsDeviceToCrc? = nil) {
                    self.dateTime = dateTime
                    self.audioInput = audioInput
                    self.audioOutput = audioOutput
                    self.videoInput = videoInput
                    self.videoOutput = videoOutput
                    self.asInput = asInput
                    self.asOutput = asOutput
                    self.cpuUsage = cpuUsage
                    self.audioDeviceFromCrc = audioDeviceFromCrc
                    self.audioDeviceToCrc = audioDeviceToCrc
                    self.videoDeviceFromCrc = videoDeviceFromCrc
                    self.videoDeviceToCrc = videoDeviceToCrc
                    self.asDeviceFromCrc = asDeviceFromCrc
                    self.asDeviceToCrc = asDeviceToCrc
                }

                private enum CodingKeys: String, CodingKey {
                    case dateTime = "date_time"
                    case audioInput = "audio_input"
                    case audioOutput = "audio_output"
                    case videoInput = "video_input"
                    case videoOutput = "video_output"
                    case asInput = "as_input"
                    case asOutput = "as_output"
                    case cpuUsage = "cpu_usage"
                    case audioDeviceFromCrc = "audio_device_from_crc"
                    case audioDeviceToCrc = "audio_device_to_crc"
                    case videoDeviceFromCrc = "video_device_from_crc"
                    case videoDeviceToCrc = "video_device_to_crc"
                    case asDeviceFromCrc = "as_device_from_crc"
                    case asDeviceToCrc = "as_device_to_crc"
                }
            }

            public init(userID: String? = nil, userName: String? = nil, device: Device? = nil, ipAddress: String? = nil, location: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, pcName: String? = nil, domain: String? = nil, macAddr: String? = nil, harddiskID: String? = nil, version: String? = nil, userQos: [UserQo]? = nil) {
                self.userID = userID
                self.userName = userName
                self.device = device
                self.ipAddress = ipAddress
                self.location = location
                self.joinTime = joinTime
                self.leaveTime = leaveTime
                self.pcName = pcName
                self.domain = domain
                self.macAddr = macAddr
                self.harddiskID = harddiskID
                self.version = version
                self.userQos = userQos
            }

            private enum CodingKeys: String, CodingKey {
                case userID = "user_id"
                case userName = "user_name"
                case device
                case ipAddress = "ip_address"
                case location
                case joinTime = "join_time"
                case leaveTime = "leave_time"
                case pcName = "pc_name"
                case domain
                case macAddr = "mac_addr"
                case harddiskID = "harddisk_id"
                case version
                case userQos = "user_qos"
            }
        }

        private func makeGetQuery(_ type: `Type`?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            return encoder.items
        }

        public enum `Type`: String, Codable, CaseIterable {
            case past
            case live
        }
    }
}

extension Paths.Metrics.Meetings.WithMeetingID.Participants {
    public var qos: Qos {
        Qos(path: path + "/qos")
    }

    public struct Qos {
        /// Path: `/metrics/meetings/{meetingId}/participants/qos`
        public let path: String

        /// List meeting participants QoS
        ///
        /// Use this API to return a list of meeting participants from live or past meetings and their quality of service recieved during the meeting. The data returned indicates the connection quality for sending/receiving video, audio, and shared content. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `dashboard_meetings:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business or a higher plan.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Participant QOS List
        ///
        /// Participant QOS list.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceed the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of items per page.
            public var pageSize: Int?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case live
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Meetings.WithMeetingID.Participants {
    public var sharing: Sharing {
        Sharing(path: path + "/sharing")
    }

    public struct Sharing {
        /// Path: `/metrics/meetings/{meetingId}/participants/sharing`
        public let path: String

        /// Get sharing/recording details
        ///
        /// Retrieve the sharing and recording details of participants from live or past meetings.<br>
        /// **Scopes:** `dashboard_meetings:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:** <br>
        /// * Business or a higher plan.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Array of participants.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// Universally unique identifier of the Participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.
                public var id: String?
                /// Participant ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.
                public var userID: String?
                /// Participant display name.
                public var userName: String?
                /// Array of sharing and recording details.
                public var details: [Detail]?

                public struct Detail: Decodable {
                    /// Type of content shared.
                    public var content: String?
                    /// Start time of sharing.
                    public var startTime: String?
                    /// End time of sharing.
                    public var endTime: String?

                    public init(content: String? = nil, startTime: String? = nil, endTime: String? = nil) {
                        self.content = content
                        self.startTime = startTime
                        self.endTime = endTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case content
                        case startTime = "start_time"
                        case endTime = "end_time"
                    }
                }

                public init(id: String? = nil, userID: String? = nil, userName: String? = nil, details: [Detail]? = nil) {
                    self.id = id
                    self.userID = userID
                    self.userName = userName
                    self.details = details
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userID = "user_id"
                    case userName = "user_name"
                    case details
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case live
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics {
    public var webinars: Webinars {
        Webinars(path: path + "/webinars")
    }

    public struct Webinars {
        /// Path: `/metrics/webinars`
        public let path: String

        /// List webinars
        ///
        /// List all the live or past webinars from a specified period of time. <br><br>
        /// **Scopes:** `dashboard_webinars:read:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Resource-intensive`<br>
        /// **Prerequisites:**<br>
        /// * Business, Education or API Plan with Webinar add-on.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date for this report in 'yyyy-mm-dd' format.
            public var from: NaiveDate?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// End date for this report in 'yyyy-mm-dd' format.
            public var to: NaiveDate?
            /// The number of all records available across pages.
            public var totalRecords: Int?
            /// Array of webinar objects.
            public var webinars: [Webinar]?

            /// Webinar Metrics
            ///
            /// Webinar metric details.
            public struct Webinar: Decodable {
                /// Webinar UUID.
                public var uuid: String?
                /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
                public var id: Int?
                /// Webinar topic.
                public var topic: String?
                /// User display name.
                public var host: String?
                /// User email.
                public var email: String?
                /// User type.
                public var userType: String?
                /// Webinar start time.
                public var startTime: Date?
                /// Webinar end time.
                public var endTime: Date?
                /// Webinar duration, formatted as hh:mm:ss, for example: `10:00` for ten minutes.
                public var duration: String?
                /// Webinar participant count.
                public var participants: Int?
                /// Indicates whether or not PSTN was used for the Webinar.
                public var hasPstn: Bool?
                /// Indicates whether or not VoIP was used for the Webinar.
                public var hasVoip: Bool?
                /// Indicates whether or not TSP was used for the Webinar.
                public var isHas3rdPartyAudio: Bool?
                /// Indicates whether or not video was used for the Webinar.
                public var hasVideo: Bool?
                /// Indicates whether or not screen sharing was used for the Webinar.
                public var hasScreenShare: Bool?
                /// Indicates whether or not recording was used for the Webinar.
                public var hasRecording: Bool?
                /// Indicates whether or not SIP was used for the Webinar.
                public var hasSip: Bool?
                /// Whether the archiving feature was used in the webinar.
                public var hasArchiving: Bool?
                /// Department of the host.
                public var dept: String?
                /// Custom keys and values assigned to the Webinar.
                public var customKeys: [CustomKey]?

                public struct CustomKey: Decodable {
                    /// Custom key associated with the Webinar.
                    public var key: String?
                    /// Value of the custom key associated with the Webinar.
                    public var value: String?

                    public init(key: String? = nil, value: String? = nil) {
                        self.key = key
                        self.value = value
                    }
                }

                public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
                    self.uuid = uuid
                    self.id = id
                    self.topic = topic
                    self.host = host
                    self.email = email
                    self.userType = userType
                    self.startTime = startTime
                    self.endTime = endTime
                    self.duration = duration
                    self.participants = participants
                    self.hasPstn = hasPstn
                    self.hasVoip = hasVoip
                    self.isHas3rdPartyAudio = isHas3rdPartyAudio
                    self.hasVideo = hasVideo
                    self.hasScreenShare = hasScreenShare
                    self.hasRecording = hasRecording
                    self.hasSip = hasSip
                    self.hasArchiving = hasArchiving
                    self.dept = dept
                    self.customKeys = customKeys
                }

                private enum CodingKeys: String, CodingKey {
                    case uuid
                    case id
                    case topic
                    case host
                    case email
                    case userType = "user_type"
                    case startTime = "start_time"
                    case endTime = "end_time"
                    case duration
                    case participants
                    case hasPstn = "has_pstn"
                    case hasVoip = "has_voip"
                    case isHas3rdPartyAudio = "has_3rd_party_audio"
                    case hasVideo = "has_video"
                    case hasScreenShare = "has_screen_share"
                    case hasRecording = "has_recording"
                    case hasSip = "has_sip"
                    case hasArchiving = "has_archiving"
                    case dept
                    case customKeys = "custom_keys"
                }
            }

            public init(from: NaiveDate? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil, webinars: [Webinar]? = nil) {
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.to = to
                self.totalRecords = totalRecords
                self.webinars = webinars
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case to
                case totalRecords = "total_records"
                case webinars
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case live
            }

            public init(type: `Type`? = nil, from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Webinars {
    public func webinarID(_ webinarID: String) -> WithWebinarID {
        WithWebinarID(path: "\(path)/\(webinarID)")
    }

    public struct WithWebinarID {
        /// Path: `/metrics/webinars/{webinarId}`
        public let path: String

        /// Get webinar details
        ///
        /// Retrieve details from live or past webinars.<br><br>
        /// **Scopes:** `dashboard_webinars:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Business, Education or API Plan with Webinar add-on.
        public func get(type: `Type`? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(type))
        }

        /// Webinar Metrics
        ///
        /// Webinar metric details.
        public struct GetResponse: Decodable {
            /// Webinar UUID.
            public var uuid: String?
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// Webinar topic.
            public var topic: String?
            /// User display name.
            public var host: String?
            /// User email.
            public var email: String?
            /// User type.
            public var userType: String?
            /// Webinar start time.
            public var startTime: Date?
            /// Webinar end time.
            public var endTime: Date?
            /// Webinar duration, formatted as hh:mm:ss, for example: `10:00` for ten minutes.
            public var duration: String?
            /// Webinar participant count.
            public var participants: Int?
            /// Indicates whether or not PSTN was used for the Webinar.
            public var hasPstn: Bool?
            /// Indicates whether or not VoIP was used for the Webinar.
            public var hasVoip: Bool?
            /// Indicates whether or not TSP was used for the Webinar.
            public var isHas3rdPartyAudio: Bool?
            /// Indicates whether or not video was used for the Webinar.
            public var hasVideo: Bool?
            /// Indicates whether or not screen sharing was used for the Webinar.
            public var hasScreenShare: Bool?
            /// Indicates whether or not recording was used for the Webinar.
            public var hasRecording: Bool?
            /// Indicates whether or not SIP was used for the Webinar.
            public var hasSip: Bool?
            /// Whether the archiving feature was used in the webinar.
            public var hasArchiving: Bool?
            /// Department of the host.
            public var dept: String?
            /// Custom keys and values assigned to the Webinar.
            public var customKeys: [CustomKey]?

            public struct CustomKey: Decodable {
                /// Custom key associated with the Webinar.
                public var key: String?
                /// Value of the custom key associated with the Webinar.
                public var value: String?

                public init(key: String? = nil, value: String? = nil) {
                    self.key = key
                    self.value = value
                }
            }

            public init(uuid: String? = nil, id: Int? = nil, topic: String? = nil, host: String? = nil, email: String? = nil, userType: String? = nil, startTime: Date? = nil, endTime: Date? = nil, duration: String? = nil, participants: Int? = nil, hasPstn: Bool? = nil, hasVoip: Bool? = nil, isHas3rdPartyAudio: Bool? = nil, hasVideo: Bool? = nil, hasScreenShare: Bool? = nil, hasRecording: Bool? = nil, hasSip: Bool? = nil, hasArchiving: Bool? = nil, dept: String? = nil, customKeys: [CustomKey]? = nil) {
                self.uuid = uuid
                self.id = id
                self.topic = topic
                self.host = host
                self.email = email
                self.userType = userType
                self.startTime = startTime
                self.endTime = endTime
                self.duration = duration
                self.participants = participants
                self.hasPstn = hasPstn
                self.hasVoip = hasVoip
                self.isHas3rdPartyAudio = isHas3rdPartyAudio
                self.hasVideo = hasVideo
                self.hasScreenShare = hasScreenShare
                self.hasRecording = hasRecording
                self.hasSip = hasSip
                self.hasArchiving = hasArchiving
                self.dept = dept
                self.customKeys = customKeys
            }

            private enum CodingKeys: String, CodingKey {
                case uuid
                case id
                case topic
                case host
                case email
                case userType = "user_type"
                case startTime = "start_time"
                case endTime = "end_time"
                case duration
                case participants
                case hasPstn = "has_pstn"
                case hasVoip = "has_voip"
                case isHas3rdPartyAudio = "has_3rd_party_audio"
                case hasVideo = "has_video"
                case hasScreenShare = "has_screen_share"
                case hasRecording = "has_recording"
                case hasSip = "has_sip"
                case hasArchiving = "has_archiving"
                case dept
                case customKeys = "custom_keys"
            }
        }

        private func makeGetQuery(_ type: `Type`?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            return encoder.items
        }

        public enum `Type`: String, Codable, CaseIterable {
            case past
            case live
        }
    }
}

extension Paths.Metrics.Webinars.WithWebinarID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/metrics/webinars/{webinarId}/participants`
        public let path: String

        /// Get webinar participants
        ///
        /// Use this API to return information about participants from live or past webinars. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `dashboard_webinars:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, or API Plan with Webinar add-on.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Information about the webinar participants.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// The participant's universally unique ID. This value is the same as the participant's user ID if the participant joins the webinar by logging into Zoom. If the participant joins the webinar without logging into Zoom, this returns an empty value.
                public var id: String?
                /// The participant's ID. This value assigned to a participant upon joining a webinar and is only valid for the webinar's duration.
                public var userID: String?
                /// The participant's display name.
                public var userName: String?
                /// The type of device the participant used to join the webinar: 
                /// * `Phone`  The participant joined via PSTN. 
                /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
                /// * `Windows`  The participant joined via VoIP using a Windows device. 
                /// * `Mac`  The participant joined via VoIP using a Mac device. 
                /// * `iOS`  The participant joined via VoIP using an iOS device. 
                /// * `Android`  The participant joined via VoIP using an Android device. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var device: Device?
                /// The participant's IP address.
                public var ipAddress: String?
                /// The participant's location.
                public var location: String?
                /// The participant's network type: 
                /// 
                /// * `Wired` 
                /// * `Wifi` 
                /// * `PPP`  Point-to-Point. 
                /// * `Cellular`  3G, 4G, and 5G cellular. 
                /// * `Others`  An unknown device.
                public var networkType: NetworkType?
                /// The type of microphone that the participant used during the webinar. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var microphone: String?
                /// The type of speaker that the participant used during the webinar. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var speaker: String?
                /// The data center where participant's webinar data is stored.
                public var dataCenter: String?
                /// The data center where participant's meeting data is stored. This field includes a semicolon-separated list of HTTP Tunnel (HT), Cloud Room Connector (CRC), and Real-Time Web Gateway (RWG) location information.
                public var fullDataCenter: String?
                /// The participant's connection type.
                public var connectionType: String?
                /// The time at which participant joined the webinar.
                public var joinTime: Date?
                /// The time at which a participant left the webinar. For live webinars, this field will only return if a participant has left the ongoing webinar.
                public var leaveTime: Date?
                /// Whether the participant chose to share an iPhone/iPad app during the screenshare.
                public var isShareApplication: Bool?
                /// Whether the participant chose to share their desktop during the screenshare.
                public var isShareDesktop: Bool?
                /// Whether the participant chose to share their whiteboard during the screenshare.
                public var isShareWhiteboard: Bool?
                /// Whether the recording feature was used during the webinar.
                public var isRecording: Bool?
                /// The participant's PC name.
                public var pcName: String?
                /// The participant's PC domain. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var domain: String?
                /// The participant's MAC address. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var macAddr: String?
                /// The participant's hard disk ID. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public var harddiskID: String?
                /// The participant's Zoom client version.
                public var version: String?
                /// The reason why the participant left the webinar, where `$name` is the participant's username: 
                /// * `$name left the meeting.` 
                /// * `$name got disconnected from the meeting.` 
                /// * `Host ended the meeting.` 
                /// * `Host closed the meeting.` 
                /// * `Host started a new meeting.` 
                /// * `Network connection error.` 
                /// * `Host did not join.` 
                /// * `Exceeded free meeting minutes limit.` 
                /// * `Removed by host.` 
                /// * `Unknown reason.` 
                /// * `Leave waiting room.` 
                /// * `Removed by host from waiting room.`
                public var leaveReason: LeaveReason?
                /// The participant's email address of the participant.
                public var email: String?
                /// The participant's unique registrant ID. This field only returns if you pass the `registrant_id` value for the `include_fields` query parameter. 
                /// 
                /// This field does not return if the `type` query parameter is the `live` value.
                public var registrantID: String?
                /// The participant's audio quality.
                public var audioQuality: AudioQuality?
                /// The participant's video quality.
                public var videoQuality: VideoQuality?
                /// The participant's screen share quality.
                public var screenShareQuality: ScreenShareQuality?
                /// A participant identifier. This value can be numbers or characters, up to a maximum length of 15 characters.
                public var customerKey: String?
                /// The meeting participant's SIP (Session Initiation Protocol) Contact header URI. The API only returns this response when the participant joins a meeting via SIP.
                public var sipUri: String?
                /// The meeting participant's SIP From header URI. The API only returns this response when the participant joins a meeting via SIP.
                public var fromSipUri: String?
                /// The participant's role: 
                /// * `host`  Host. 
                /// * `attendee`  Attendee. 
                /// * `panelist`  Panelist.
                public var role: Role?

                /// The type of device the participant used to join the webinar: 
                /// * `Phone`  The participant joined via PSTN. 
                /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
                /// * `Windows`  The participant joined via VoIP using a Windows device. 
                /// * `Mac`  The participant joined via VoIP using a Mac device. 
                /// * `iOS`  The participant joined via VoIP using an iOS device. 
                /// * `Android`  The participant joined via VoIP using an Android device. 
                /// 
                /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the hosts account (external users).
                public enum Device: String, Codable, CaseIterable {
                    case phone = "Phone"
                    case h323Sip = "H.323/SIP"
                    case windows = "Windows"
                    case mac = "Mac"
                    case iOS
                    case android = "Android"
                }

                /// The participant's network type: 
                /// 
                /// * `Wired` 
                /// * `Wifi` 
                /// * `PPP`  Point-to-Point. 
                /// * `Cellular`  3G, 4G, and 5G cellular. 
                /// * `Others`  An unknown device.
                public enum NetworkType: String, Codable, CaseIterable {
                    case wired = "Wired"
                    case wifi = "Wifi"
                    case ppp = "PPP"
                    case cellular = "Cellular"
                    case others = "Others"
                }

                /// The reason why the participant left the webinar, where `$name` is the participant's username: 
                /// * `$name left the meeting.` 
                /// * `$name got disconnected from the meeting.` 
                /// * `Host ended the meeting.` 
                /// * `Host closed the meeting.` 
                /// * `Host started a new meeting.` 
                /// * `Network connection error.` 
                /// * `Host did not join.` 
                /// * `Exceeded free meeting minutes limit.` 
                /// * `Removed by host.` 
                /// * `Unknown reason.` 
                /// * `Leave waiting room.` 
                /// * `Removed by host from waiting room.`
                public enum LeaveReason: String, Codable, CaseIterable {
                    case nameLeftTheWebinar = "$name left the webinar."
                    case nameGotDisconnectedFromTheWebinar = "$name got disconnected from the webinar."
                    case hostEndedTheWebinar = "Host ended the webinar."
                    case hostClosedTheWebinar = "Host closed the webinar."
                    case hostStartedANewWebinar = "Host started a new webinar."
                    case networkConnectionError = "Network connection error."
                    case hostDidNotJoin = "Host did not join."
                    case exceededFreeWebinarMinutesLimit = "Exceeded free webinar minutes limit."
                    case removedByHost = "Removed by host."
                    case unknownReason = "Unknown reason."
                    case leaveWaitingRoom = "Leave waiting room."
                    case removedByHostFromWaitingRoom = "Removed by host from waiting room."
                }

                /// The participant's audio quality.
                public enum AudioQuality: String, Codable, CaseIterable {
                    case empty = " "
                    case good
                    case fair
                    case poor
                    case bad
                }

                /// The participant's video quality.
                public enum VideoQuality: String, Codable, CaseIterable {
                    case empty = " "
                    case good
                    case fair
                    case poor
                    case bad
                }

                /// The participant's screen share quality.
                public enum ScreenShareQuality: String, Codable, CaseIterable {
                    case empty = " "
                    case good
                    case fair
                    case poor
                    case bad
                }

                /// The participant's role: 
                /// * `host`  Host. 
                /// * `attendee`  Attendee. 
                /// * `panelist`  Panelist.
                public enum Role: String, Codable, CaseIterable {
                    case host
                    case attendee
                    case panelist
                }

                public init(id: String? = nil, userID: String? = nil, userName: String? = nil, device: Device? = nil, ipAddress: String? = nil, location: String? = nil, networkType: NetworkType? = nil, microphone: String? = nil, speaker: String? = nil, dataCenter: String? = nil, fullDataCenter: String? = nil, connectionType: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, isShareApplication: Bool? = nil, isShareDesktop: Bool? = nil, isShareWhiteboard: Bool? = nil, isRecording: Bool? = nil, pcName: String? = nil, domain: String? = nil, macAddr: String? = nil, harddiskID: String? = nil, version: String? = nil, leaveReason: LeaveReason? = nil, email: String? = nil, registrantID: String? = nil, audioQuality: AudioQuality? = nil, videoQuality: VideoQuality? = nil, screenShareQuality: ScreenShareQuality? = nil, customerKey: String? = nil, sipUri: String? = nil, fromSipUri: String? = nil, role: Role? = nil) {
                    self.id = id
                    self.userID = userID
                    self.userName = userName
                    self.device = device
                    self.ipAddress = ipAddress
                    self.location = location
                    self.networkType = networkType
                    self.microphone = microphone
                    self.speaker = speaker
                    self.dataCenter = dataCenter
                    self.fullDataCenter = fullDataCenter
                    self.connectionType = connectionType
                    self.joinTime = joinTime
                    self.leaveTime = leaveTime
                    self.isShareApplication = isShareApplication
                    self.isShareDesktop = isShareDesktop
                    self.isShareWhiteboard = isShareWhiteboard
                    self.isRecording = isRecording
                    self.pcName = pcName
                    self.domain = domain
                    self.macAddr = macAddr
                    self.harddiskID = harddiskID
                    self.version = version
                    self.leaveReason = leaveReason
                    self.email = email
                    self.registrantID = registrantID
                    self.audioQuality = audioQuality
                    self.videoQuality = videoQuality
                    self.screenShareQuality = screenShareQuality
                    self.customerKey = customerKey
                    self.sipUri = sipUri
                    self.fromSipUri = fromSipUri
                    self.role = role
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userID = "user_id"
                    case userName = "user_name"
                    case device
                    case ipAddress = "ip_address"
                    case location
                    case networkType = "network_type"
                    case microphone
                    case speaker
                    case dataCenter = "data_center"
                    case fullDataCenter = "full_data_center"
                    case connectionType = "connection_type"
                    case joinTime = "join_time"
                    case leaveTime = "leave_time"
                    case isShareApplication = "share_application"
                    case isShareDesktop = "share_desktop"
                    case isShareWhiteboard = "share_whiteboard"
                    case isRecording = "recording"
                    case pcName = "pc_name"
                    case domain
                    case macAddr = "mac_addr"
                    case harddiskID = "harddisk_id"
                    case version
                    case leaveReason = "leave_reason"
                    case email
                    case registrantID = "registrant_id"
                    case audioQuality = "audio_quality"
                    case videoQuality = "video_quality"
                    case screenShareQuality = "screen_share_quality"
                    case customerKey = "customer_key"
                    case sipUri = "sip_uri"
                    case fromSipUri = "from_sip_uri"
                    case role
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?
            public var includeFields: IncludeFields?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case live
            }

            public enum IncludeFields: String, Codable, CaseIterable {
                case registrantID = "registrant_id"
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil, includeFields: IncludeFields? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.includeFields = includeFields
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(includeFields, forKey: "include_fields")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Webinars.WithWebinarID.Participants {
    public func participantID(_ participantID: String) -> WithParticipantID {
        WithParticipantID(path: "\(path)/\(participantID)")
    }

    public struct WithParticipantID {
        /// Path: `/metrics/webinars/{webinarId}/participants/{participantId}`
        public let path: String
    }
}

extension Paths.Metrics.Webinars.WithWebinarID.Participants.WithParticipantID {
    public var qos: Qos {
        Qos(path: path + "/qos")
    }

    public struct Qos {
        /// Path: `/metrics/webinars/{webinarId}/participants/{participantId}/qos`
        public let path: String

        /// Get webinar participant QoS
        ///
        /// Use this API to return the quality of service (QoS) for participants during live or past webinars. This data returned indicates the connection quality for sending/receiving video, audio, and shared content. The API returns this data for either the API request or when the API request was last received. 
        /// 
        /// When the sender sends its data, a timestamp is attached to the senders data packet. The receiver then returns this timestamp to the sender. This helps determine the upstream and downstream latency, which includes the application processing time. The latency data returned is the five second average and five second maximum. 
        /// 
        /// This API will **not** return data if there is no data being sent or received at the time of request. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `dashboard_webinars:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, or API Plan with Zoom Rooms set up.
        public func get(type: `Type`? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(type))
        }

        /// Participant QOS
        ///
        /// Information about the participant and their quality of service (QoS).
        public struct GetResponse: Decodable {
            /// The participant's ID. This value is assigned to a participant upon joining a meeting and is only valid for the meeting's duration.
            public var userID: String?
            /// The participant's display name.
            public var userName: String?
            /// The type of device the participant used to join the meeting: 
            /// * `Phone`  The participant joined via PSTN. 
            /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
            /// * `Windows`  The participant joined via VoIP using a Windows device. 
            /// * `Mac`  The participant joined via VoIP using a Mac device. 
            /// * `iOS`  The participant joined via VoIP using an iOS device. 
            /// * `Android`  The participant joined via VoIP using an Android device. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var device: Device?
            /// The participant's IP address.
            public var ipAddress: String?
            /// The participant's location.
            public var location: String?
            /// The time at which the participant joined the meeting.
            public var joinTime: Date?
            /// The time at which the participant left the meeting.
            public var leaveTime: Date?
            /// The participant's PC name.
            public var pcName: String?
            /// The participant's PC domain. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var domain: String?
            /// The participant's MAC address. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var macAddr: String?
            /// The participant's hard disk ID. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public var harddiskID: String?
            /// The participant's Zoom client version.
            public var version: String?
            /// The participant's quality of service information.
            public var userQos: [UserQo]?

            /// The type of device the participant used to join the meeting: 
            /// * `Phone`  The participant joined via PSTN. 
            /// * `H.323/SIP`  The participant joined via an H.323 or SIP device. 
            /// * `Windows`  The participant joined via VoIP using a Windows device. 
            /// * `Mac`  The participant joined via VoIP using a Mac device. 
            /// * `iOS`  The participant joined via VoIP using an iOS device. 
            /// * `Android`  The participant joined via VoIP using an Android device. 
            /// 
            /// **Note:** This response returns an empty string (``) value for any users who are **not** a part of the host's account (external users).
            public enum Device: String, Codable, CaseIterable {
                case phone = "Phone"
                case h323Sip = "H.323/SIP"
                case windows = "Windows"
                case mac = "Mac"
                case iOS
                case android = "Android"
            }

            public struct UserQo: Decodable {
                /// The QoS date and time.
                public var dateTime: Date?
                /// Audio QoS Object
                public var audioInput: AudioInput?
                /// Audio QoS Object
                public var audioOutput: AudioOutput?
                /// Video QoS Object
                public var videoInput: VideoInput?
                /// Video QoS Object
                public var videoOutput: VideoOutput?
                /// Video QoS Object
                public var asInput: AsInput?
                /// Video QoS Object
                public var asOutput: AsOutput?
                public var cpuUsage: CpuUsage?
                /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
                public var audioDeviceFromCrc: AudioDeviceFromCrc?
                /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
                public var audioDeviceToCrc: AudioDeviceToCrc?
                /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
                public var videoDeviceFromCrc: VideoDeviceFromCrc?
                /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
                public var videoDeviceToCrc: VideoDeviceToCrc?
                /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
                public var asDeviceFromCrc: AsDeviceFromCrc?
                /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
                public var asDeviceToCrc: AsDeviceToCrc?

                /// Audio QoS Object
                public struct AudioInput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// Audio QoS Object
                public struct AudioOutput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// Video QoS Object
                public struct VideoInput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                /// Video QoS Object
                public struct VideoOutput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                /// Video QoS Object
                public struct AsInput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                /// Video QoS Object
                public struct AsOutput: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?
                    /// The number of pixels in each dimension that the video camera can display.
                    public var resolution: String?
                    /// The rate at which the video camera can produce unique images (frames). Zoom supports a frame rate of up to 30fps.
                    public var frameRate: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil, resolution: String? = nil, frameRate: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                        self.resolution = resolution
                        self.frameRate = frameRate
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: StringCodingKey.self)
                        self.bitrate = try values.decodeIfPresent(String.self, forKey: "bitrate")
                        self.latency = try values.decodeIfPresent(String.self, forKey: "latency")
                        self.jitter = try values.decodeIfPresent(String.self, forKey: "jitter")
                        self.avgLoss = try values.decodeIfPresent(String.self, forKey: "avg_loss")
                        self.maxLoss = try values.decodeIfPresent(String.self, forKey: "max_loss")
                        self.resolution = try values.decodeIfPresent(String.self, forKey: "resolution")
                        self.frameRate = try values.decodeIfPresent(String.self, forKey: "frame_rate")
                    }
                }

                public struct CpuUsage: Decodable {
                    /// Zoom's minimum CPU usage.
                    public var zoomMinCpuUsage: String?
                    /// Zoom's average CPU usage.
                    public var zoomAvgCpuUsage: String?
                    /// Zoom's maximum CPU usage.
                    public var zoomMaxCpuUsage: String?
                    /// The system's maximum CPU usage.
                    public var systemMaxCpuUsage: String?

                    public init(zoomMinCpuUsage: String? = nil, zoomAvgCpuUsage: String? = nil, zoomMaxCpuUsage: String? = nil, systemMaxCpuUsage: String? = nil) {
                        self.zoomMinCpuUsage = zoomMinCpuUsage
                        self.zoomAvgCpuUsage = zoomAvgCpuUsage
                        self.zoomMaxCpuUsage = zoomMaxCpuUsage
                        self.systemMaxCpuUsage = systemMaxCpuUsage
                    }

                    private enum CodingKeys: String, CodingKey {
                        case zoomMinCpuUsage = "zoom_min_cpu_usage"
                        case zoomAvgCpuUsage = "zoom_avg_cpu_usage"
                        case zoomMaxCpuUsage = "zoom_max_cpu_usage"
                        case systemMaxCpuUsage = "system_max_cpu_usage"
                    }
                }

                /// The QoS metrics for audio sent by a participant who joined the meeting via a Cloud Room Connector (CRC).
                public struct AudioDeviceFromCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for audio received by a participant who joined the meeting via CRC.
                public struct AudioDeviceToCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for video input being sent by a participant who joined the meeting via CRC.
                public struct VideoDeviceFromCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for video output being sent by a participant who joined the meeting via CRC.
                public struct VideoDeviceToCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for screen sharing by a participant who joined the meeting via CRC.
                public struct AsDeviceFromCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                /// The QoS metrics for screen sharing output received by a participant who joined the meeting via CRC.
                public struct AsDeviceToCrc: Decodable {
                    /// The bits per second transmitted along a digital network, in kbsp.
                    public var bitrate: String?
                    /// The time it took a packet to travel from one point to another, in milliseconds.
                    public var latency: String?
                    /// The variation in the delay of received packets, in milliseconds.
                    public var jitter: String?
                    /// The average amount of packet loss. For example, the percentage of packets that failed to arrive at their destination.
                    public var avgLoss: String?
                    /// The maximum amount of packet loss. For example, the maximum percentage of packets that failed to arrive at their destination.
                    public var maxLoss: String?

                    public init(bitrate: String? = nil, latency: String? = nil, jitter: String? = nil, avgLoss: String? = nil, maxLoss: String? = nil) {
                        self.bitrate = bitrate
                        self.latency = latency
                        self.jitter = jitter
                        self.avgLoss = avgLoss
                        self.maxLoss = maxLoss
                    }

                    private enum CodingKeys: String, CodingKey {
                        case bitrate
                        case latency
                        case jitter
                        case avgLoss = "avg_loss"
                        case maxLoss = "max_loss"
                    }
                }

                public init(dateTime: Date? = nil, audioInput: AudioInput? = nil, audioOutput: AudioOutput? = nil, videoInput: VideoInput? = nil, videoOutput: VideoOutput? = nil, asInput: AsInput? = nil, asOutput: AsOutput? = nil, cpuUsage: CpuUsage? = nil, audioDeviceFromCrc: AudioDeviceFromCrc? = nil, audioDeviceToCrc: AudioDeviceToCrc? = nil, videoDeviceFromCrc: VideoDeviceFromCrc? = nil, videoDeviceToCrc: VideoDeviceToCrc? = nil, asDeviceFromCrc: AsDeviceFromCrc? = nil, asDeviceToCrc: AsDeviceToCrc? = nil) {
                    self.dateTime = dateTime
                    self.audioInput = audioInput
                    self.audioOutput = audioOutput
                    self.videoInput = videoInput
                    self.videoOutput = videoOutput
                    self.asInput = asInput
                    self.asOutput = asOutput
                    self.cpuUsage = cpuUsage
                    self.audioDeviceFromCrc = audioDeviceFromCrc
                    self.audioDeviceToCrc = audioDeviceToCrc
                    self.videoDeviceFromCrc = videoDeviceFromCrc
                    self.videoDeviceToCrc = videoDeviceToCrc
                    self.asDeviceFromCrc = asDeviceFromCrc
                    self.asDeviceToCrc = asDeviceToCrc
                }

                private enum CodingKeys: String, CodingKey {
                    case dateTime = "date_time"
                    case audioInput = "audio_input"
                    case audioOutput = "audio_output"
                    case videoInput = "video_input"
                    case videoOutput = "video_output"
                    case asInput = "as_input"
                    case asOutput = "as_output"
                    case cpuUsage = "cpu_usage"
                    case audioDeviceFromCrc = "audio_device_from_crc"
                    case audioDeviceToCrc = "audio_device_to_crc"
                    case videoDeviceFromCrc = "video_device_from_crc"
                    case videoDeviceToCrc = "video_device_to_crc"
                    case asDeviceFromCrc = "as_device_from_crc"
                    case asDeviceToCrc = "as_device_to_crc"
                }
            }

            public init(userID: String? = nil, userName: String? = nil, device: Device? = nil, ipAddress: String? = nil, location: String? = nil, joinTime: Date? = nil, leaveTime: Date? = nil, pcName: String? = nil, domain: String? = nil, macAddr: String? = nil, harddiskID: String? = nil, version: String? = nil, userQos: [UserQo]? = nil) {
                self.userID = userID
                self.userName = userName
                self.device = device
                self.ipAddress = ipAddress
                self.location = location
                self.joinTime = joinTime
                self.leaveTime = leaveTime
                self.pcName = pcName
                self.domain = domain
                self.macAddr = macAddr
                self.harddiskID = harddiskID
                self.version = version
                self.userQos = userQos
            }

            private enum CodingKeys: String, CodingKey {
                case userID = "user_id"
                case userName = "user_name"
                case device
                case ipAddress = "ip_address"
                case location
                case joinTime = "join_time"
                case leaveTime = "leave_time"
                case pcName = "pc_name"
                case domain
                case macAddr = "mac_addr"
                case harddiskID = "harddisk_id"
                case version
                case userQos = "user_qos"
            }
        }

        private func makeGetQuery(_ type: `Type`?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(type, forKey: "type")
            return encoder.items
        }

        public enum `Type`: String, Codable, CaseIterable {
            case past
            case live
        }
    }
}

extension Paths.Metrics.Webinars.WithWebinarID.Participants {
    public var qos: Qos {
        Qos(path: path + "/qos")
    }

    public struct Qos {
        /// Path: `/metrics/webinars/{webinarId}/participants/qos`
        public let path: String

        /// List webinar participant QoS
        ///
        /// Use this API to return a list of webinar participants from live or past webinars and the quality of service they received during the webinar. The data returned indicates the connection quality for sending/receiving video, audio, and shared content. 
        /// 
        /// **Note:** 
        /// 
        /// This API may return empty values for participants' `user_name`, `ip_address`, `location`, and `email` responses when the account calling this API: 
        /// * Does **not** have a signed HIPAA business associate agreement (BAA). 
        /// * Is a [**legacy** HIPAA BAA account](https://marketplace.zoom.us/docs/api-reference/other-references/legacy-business-associate-agreements). 
        /// 
        /// **Scopes:** `dashboard_webinars:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business, Education, or API Plan with Webinar add-on.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Participant QOS List
        ///
        /// Participant QOS list.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceed the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of items per page.
            public var pageSize: Int?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case live
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Webinars.WithWebinarID.Participants {
    public var sharing: Sharing {
        Sharing(path: path + "/sharing")
    }

    public struct Sharing {
        /// Path: `/metrics/webinars/{webinarId}/participants/sharing`
        public let path: String

        /// Get sharing/recording details
        ///
        /// Retrieve the sharing and recording details of participants from live or past webinars. <br><br>
        /// **Scopes:** `dashboard_webinars:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` <br>
        /// **Prerequisites:**<br>
        /// * Business, Education or API Plan with Webinar add-on.
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// Array of participants.
            public var participants: [Participant]?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct Participant: Decodable {
                /// Universally unique identifier of the Participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.
                public var id: String?
                /// Participant ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.
                public var userID: String?
                /// Participant display name.
                public var userName: String?
                /// Array of sharing and recording details.
                public var details: [Detail]?

                public struct Detail: Decodable {
                    /// Type of content shared.
                    public var content: String?
                    /// Start time of sharing.
                    public var startTime: String?
                    /// End time of sharing.
                    public var endTime: String?

                    public init(content: String? = nil, startTime: String? = nil, endTime: String? = nil) {
                        self.content = content
                        self.startTime = startTime
                        self.endTime = endTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case content
                        case startTime = "start_time"
                        case endTime = "end_time"
                    }
                }

                public init(id: String? = nil, userID: String? = nil, userName: String? = nil, details: [Detail]? = nil) {
                    self.id = id
                    self.userID = userID
                    self.userName = userName
                    self.details = details
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case userID = "user_id"
                    case userName = "user_name"
                    case details
                }
            }

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, participants: [Participant]? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.participants = participants
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case participants
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case live
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics {
    public var zoomrooms: Zoomrooms {
        Zoomrooms(path: path + "/zoomrooms")
    }

    public struct Zoomrooms {
        /// Path: `/metrics/zoomrooms`
        public let path: String

        /// List Zoom Rooms
        ///
        /// List information on all Zoom Rooms in an account.<br><br>
        /// **Scopes:** `dashboard_zr:read:admin`
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Resource-intensive`<br>
        ///  **Prerequisites:**<br>
        /// * Business, Education or API Plan with Zoom Rooms set up.
        public func get(parameters: GetParameters? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public init(pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Zoomrooms {
    public func zoomroomID(_ zoomroomID: String) -> WithZoomroomID {
        WithZoomroomID(path: "\(path)/\(zoomroomID)")
    }

    public struct WithZoomroomID {
        /// Path: `/metrics/zoomrooms/{zoomroomId}`
        public let path: String

        /// Get Zoom Rooms details
        ///
        /// The Zoom Rooms dashboard metrics lets you know the type of configuration a Zoom room has and details on the meetings held in that room. 
        /// 
        /// Use this API to retrieve information on a specific room.<br><br>
        /// **Scopes:** `dashboard_zr:read:admin`<br> <br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`**Prerequisites:**<br>
        /// * Business, Education or API Plan with Zoom Rooms set up.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics {
    public var crc: Crc {
        Crc(path: path + "/crc")
    }

    public struct Crc {
        /// Path: `/metrics/crc`
        public let path: String

        /// Get CRC port usage
        ///
        /// A Cloud Room Connector allows H.323/SIP endpoints to connect to a Zoom meeting. 
        /// 
        /// Use this API to get the hour by hour CRC Port usage for a specified period of time. <aside class='notice'>We will provide the report for a maximum of one month. For example, if "from" is set to "2017-08-05" and "to" is set to "2017-10-10", we will adjust "from" to "2017-09-10".</aside><br><br>
        /// **Prerequisites:**<br>
        /// * Business, Education or API Plan.
        /// * Room Connector must be enabled on the account.<br><br>
        /// **Scopes:** `dashboard_crc:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(from: NaiveDate, to: NaiveDate) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(from, to))
        }

        private func makeGetQuery(_ from: NaiveDate, _ to: NaiveDate) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Metrics {
    public var im: Im {
        Im(path: path + "/im")
    }

    public struct Im {
        /// Path: `/metrics/im`
        public let path: String

        /// Get IM metrics
        ///
        /// Get [metrics](https://support.zoom.us/hc/en-us/articles/204654719-Dashboard#h_cc7e9749-1c70-4afb-a9a2-9680654821e4) on how users are utilizing the Zoom Chat client.
        /// 
        /// You can specify a monthly date range for the dashboard data using the `from` and `to` query parameters. The month should fall within the last six months.<p style="background-color:#e1f5fe; color:#000000; padding:8px"><b>Deprecated:</b> We will completely deprecate this endpoint in a future release. You can continue using this endpoint to query data for messages sent <b>before</b> July 1, 2021.</br></br>To get metrics on chat messages sent <b>on and after</b> July 1, 2021, use the <a href="https://marketplace.zoom.us/docs/api-reference/zoom-api/dashboards/dashboardchat">Get chat metrics API</a>.</p>
        /// 
        /// **Scopes:** `dashboard_im:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Resource-intensive`
        /// 
        /// **Prerequisites:**
        /// 
        /// * Business or a higher plan.
        @available(*, deprecated, message: "Deprecated")
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date for this report.
            public var from: NaiveDate?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// End date for this report.
            public var to: NaiveDate?
            /// The number of all records available across pages.
            public var totalRecords: Int?
            public var users: [User]?

            public struct User: Decodable {
                /// User ID.
                public var userID: String?
                /// User display name.
                public var userName: String?
                /// User email.
                public var email: String?
                /// Total number of messages sent by the user.
                public var totalSend: Int?
                /// Total number of messages received by the user.
                public var totalReceive: Int?
                /// Total number of messages sent by the user in channels.
                public var groupSend: Int?
                /// Total number of messages received by the user in channels.
                public var groupReceive: Int?
                /// Total number of instant meeting calls made by the user.
                public var callsSend: Int?
                /// Total number of instant meeting calls received by the user.
                public var callsReceive: Int?
                /// Total number of files sent by the user.
                public var filesSend: Int?
                /// Total number of files received by the user.
                public var filesReceive: Int?
                /// Total number of images sent by the user.
                public var imagesSend: Int?
                /// Total number of images received by the user.
                public var imagesReceive: Int?
                /// Total number of voice files sent by the user.
                public var voiceSend: Int?
                /// Total number of voice files received by the user.
                public var voiceReceive: Int?
                /// Total number of video files sent by the user.
                public var videosSend: Int?
                /// Total number of video files received by the user.
                public var videosReceive: Int?
                /// Total number of emojis sent by the user.
                public var emojiSend: Int?
                /// Total number of emojis received by the user.
                public var emojiReceive: Int?

                public init(userID: String? = nil, userName: String? = nil, email: String? = nil, totalSend: Int? = nil, totalReceive: Int? = nil, groupSend: Int? = nil, groupReceive: Int? = nil, callsSend: Int? = nil, callsReceive: Int? = nil, filesSend: Int? = nil, filesReceive: Int? = nil, imagesSend: Int? = nil, imagesReceive: Int? = nil, voiceSend: Int? = nil, voiceReceive: Int? = nil, videosSend: Int? = nil, videosReceive: Int? = nil, emojiSend: Int? = nil, emojiReceive: Int? = nil) {
                    self.userID = userID
                    self.userName = userName
                    self.email = email
                    self.totalSend = totalSend
                    self.totalReceive = totalReceive
                    self.groupSend = groupSend
                    self.groupReceive = groupReceive
                    self.callsSend = callsSend
                    self.callsReceive = callsReceive
                    self.filesSend = filesSend
                    self.filesReceive = filesReceive
                    self.imagesSend = imagesSend
                    self.imagesReceive = imagesReceive
                    self.voiceSend = voiceSend
                    self.voiceReceive = voiceReceive
                    self.videosSend = videosSend
                    self.videosReceive = videosReceive
                    self.emojiSend = emojiSend
                    self.emojiReceive = emojiReceive
                }

                private enum CodingKeys: String, CodingKey {
                    case userID = "user_id"
                    case userName = "user_name"
                    case email
                    case totalSend = "total_send"
                    case totalReceive = "total_receive"
                    case groupSend = "group_send"
                    case groupReceive = "group_receive"
                    case callsSend = "calls_send"
                    case callsReceive = "calls_receive"
                    case filesSend = "files_send"
                    case filesReceive = "files_receive"
                    case imagesSend = "images_send"
                    case imagesReceive = "images_receive"
                    case voiceSend = "voice_send"
                    case voiceReceive = "voice_receive"
                    case videosSend = "videos_send"
                    case videosReceive = "videos_receive"
                    case emojiSend = "emoji_send"
                    case emojiReceive = "emoji_receive"
                }
            }

            public init(from: NaiveDate? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil, users: [User]? = nil) {
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.to = to
                self.totalRecords = totalRecords
                self.users = users
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case to
                case totalRecords = "total_records"
                case users
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics {
    public var chat: Chat {
        Chat(path: path + "/chat")
    }

    public struct Chat {
        /// Path: `/metrics/chat`
        public let path: String

        /// Get chat metrics
        ///
        /// Get [metrics](https://support.zoom.us/hc/en-us/articles/204654719-Dashboard#h_cc7e9749-1c70-4afb-a9a2-9680654821e4) for how users are utilizing Zoom Chat to send messages.
        /// 
        /// Use the `from` and `to` query parameters to specify a monthly date range for the dashboard data. The monthly date range must be within the last six months.
        /// 
        /// > **Note:** To query chat metrics from July 1, 2021 and later, use this endpoint instead of the [Get IM metrics API](https://marketplace.zoom.us/docs/api-reference/zoom-api/dashboards/dashboardim).
        /// 
        /// **Scope:** `dashboard_im:read:admin`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Resource-intensive`
        /// 
        /// **Prerequisites:**
        /// 
        /// * Business or a higher plan
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The report's start date.
            public var from: NaiveDate?
            /// The report's [`next_page_token` value](https://marketplace.zoom.us/docs/api-reference/pagination#next-page-token). The API returns this value when the set of available results exceeds the current page size. This token expires after 15 minutes.
            public var nextPageToken: String?
            /// The number of records to return within a single API call.
            public var pageSize: Int?
            /// The report's end date.
            public var to: NaiveDate?
            public var users: [User]?

            public struct User: Decodable {
                /// The user's ID.
                public var userID: String?
                /// The user's display name.
                public var userName: String?
                /// UThe user's email address.
                public var email: String?
                /// The user's total number of messages sent.
                public var totalSent: Int?
                /// The user's total number of peer-to-peer (P2P) chat messages sent.
                public var p2pSent: Int?
                /// The user's total number of messages sent in Zoom Chat channels.
                public var groupSent: Int?
                /// The user's total number of text messages sent.
                public var textSent: Int?
                /// The user's total number of files sent.
                public var filesSent: Int?
                /// The user's total number of images sent.
                public var imagesSent: Int?
                /// The user's total number of code snippets sent.
                public var codeSippetSent: Int?
                /// The user's total number of [GIPHY](https://giphy.com/) images sent.
                public var giphysSent: Int?
                /// The user's total number of audio files sent.
                public var audioSent: Int?
                /// The user's total number of video files sent.
                public var videoSent: Int?

                public init(userID: String? = nil, userName: String? = nil, email: String? = nil, totalSent: Int? = nil, p2pSent: Int? = nil, groupSent: Int? = nil, textSent: Int? = nil, filesSent: Int? = nil, imagesSent: Int? = nil, codeSippetSent: Int? = nil, giphysSent: Int? = nil, audioSent: Int? = nil, videoSent: Int? = nil) {
                    self.userID = userID
                    self.userName = userName
                    self.email = email
                    self.totalSent = totalSent
                    self.p2pSent = p2pSent
                    self.groupSent = groupSent
                    self.textSent = textSent
                    self.filesSent = filesSent
                    self.imagesSent = imagesSent
                    self.codeSippetSent = codeSippetSent
                    self.giphysSent = giphysSent
                    self.audioSent = audioSent
                    self.videoSent = videoSent
                }

                private enum CodingKeys: String, CodingKey {
                    case userID = "user_id"
                    case userName = "user_name"
                    case email
                    case totalSent = "total_sent"
                    case p2pSent = "p2p_sent"
                    case groupSent = "group_sent"
                    case textSent = "text_sent"
                    case filesSent = "files_sent"
                    case imagesSent = "images_sent"
                    case codeSippetSent = "code_sippet_sent"
                    case giphysSent = "giphys_sent"
                    case audioSent = "audio_sent"
                    case videoSent = "video_sent"
                }
            }

            public init(from: NaiveDate? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, users: [User]? = nil) {
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.to = to
                self.users = users
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case to
                case users
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics {
    public var client: Client {
        Client(path: path + "/client")
    }

    public struct Client {
        /// Path: `/metrics/client`
        public let path: String
    }
}

extension Paths.Metrics.Client {
    public var feedback: Feedback {
        Feedback(path: path + "/feedback")
    }

    public struct Feedback {
        /// Path: `/metrics/client/feedback`
        public let path: String

        /// List Zoom meetings client feedback
        ///
        /// Use this API to return [Zoom meetings client feedback](https://support.zoom.us/hc/en-us/articles/115005855266-End-of-Meeting-Feedback-Survey#h_e30d552b-6d8e-4e0a-a588-9ca8180c4dbf) survey results. You can specify a monthly date range for the Dashboard data using the `from` and `to` query parameters. The month should fall within the last six months. 
        /// 
        /// **Scopes:** `dashboard_home:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business or higher account. 
        /// * The "[**Feedback to Zoom**](https://support.zoom.us/hc/en-us/articles/115005838023)" option enabled.
        public func get(from: NaiveDate, to: NaiveDate) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(from, to))
        }

        public struct GetResponse: Decodable {
            /// Start date for this report
            public var from: NaiveDate?
            /// End date for this report
            public var to: NaiveDate?
            /// The number of all records available across pages
            public var totalRecords: Int?
            public var clientFeedbacks: [ClientFeedback]?

            public struct ClientFeedback: Decodable {
                /// Feedback Id
                public var feedbackID: String?
                /// Feedback Name
                public var feedbackName: String?
                /// The number of participants that upvoted the feedback.
                public var participantsCount: Int?

                public init(feedbackID: String? = nil, feedbackName: String? = nil, participantsCount: Int? = nil) {
                    self.feedbackID = feedbackID
                    self.feedbackName = feedbackName
                    self.participantsCount = participantsCount
                }

                private enum CodingKeys: String, CodingKey {
                    case feedbackID = "feedback_id"
                    case feedbackName = "feedback_name"
                    case participantsCount = "participants_count"
                }
            }

            public init(from: NaiveDate? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil, clientFeedbacks: [ClientFeedback]? = nil) {
                self.from = from
                self.to = to
                self.totalRecords = totalRecords
                self.clientFeedbacks = clientFeedbacks
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case totalRecords = "total_records"
                case clientFeedbacks = "client_feedbacks"
            }
        }

        private func makeGetQuery(_ from: NaiveDate, _ to: NaiveDate) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Metrics.Zoomrooms {
    public var issues: Issues {
        Issues(path: path + "/issues")
    }

    public struct Issues {
        /// Path: `/metrics/zoomrooms/issues`
        public let path: String

        /// Get top 25 issues of Zoom Rooms
        ///
        /// Get top 25 issues of Zoom Rooms.<br>
        /// **Scopes:** `dashboard_zr:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        ///  **Prerequisites:**<br>
        /// * Business, Education or API Plan with Zoom Rooms set up.
        public func get(from: NaiveDate, to: NaiveDate) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(from, to))
        }

        private func makeGetQuery(_ from: NaiveDate, _ to: NaiveDate) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Metrics {
    public var issues: Issues {
        Issues(path: path + "/issues")
    }

    public struct Issues {
        /// Path: `/metrics/issues`
        public let path: String
    }
}

extension Paths.Metrics.Issues {
    public var zoomrooms: Zoomrooms {
        Zoomrooms(path: path + "/zoomrooms")
    }

    public struct Zoomrooms {
        /// Path: `/metrics/issues/zoomrooms`
        public let path: String

        /// Get top 25 Zoom Rooms with issues
        ///
        /// Get information on top 25 Zoom Rooms with issues in a month. The month specified with the "from" and "to" range should fall within the last six months.<br>
        /// **Scope:** `dashboard_home:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        /// **Prerequisites:**<br>
        /// * Business or a higher plan.
        /// * Zoom Room must be enabled in the account.
        public func get(from: NaiveDate, to: NaiveDate) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(from, to))
        }

        private func makeGetQuery(_ from: NaiveDate, _ to: NaiveDate) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Metrics.Issues.Zoomrooms {
    public func zoomroomID(_ zoomroomID: String) -> WithZoomroomID {
        WithZoomroomID(path: "\(path)/\(zoomroomID)")
    }

    public struct WithZoomroomID {
        /// Path: `/metrics/issues/zoomrooms/{zoomroomId}`
        public let path: String

        /// Get issues of Zoom Rooms
        ///
        /// Use this API to return information about the Zoom Rooms in an account with issues, such as disconnected hardware or bandwidth issues. You can specify a monthly date range for the Dashboard data using the `from` and `to` query parameters. The month should fall within the last six months. 
        /// 
        /// **Scopes:** `dashboard_home:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business or a higher plan. 
        /// * A Zoom Room must be enabled in the account.
        public func get(parameters: GetParameters) -> Request<GetResponse> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetResponse: Decodable {
            /// Start date for this report
            public var from: NaiveDate?
            public var issueDetails: [IssueDetail]?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// End date for this report
            public var to: NaiveDate?
            /// The number of all records available across pages.
            public var totalRecords: Int?

            public struct IssueDetail: Decodable {
                /// Zoom Room Issue Detail.<br> The value of the this field could be one of the following:<br>
                /// * `Room Controller disconnected`<br>
                /// * `Room Controller connected`
                /// * `Selected camera has disconnected`
                /// * `Selected camera is reconnected`
                /// * `Selected microphone has disconnected`
                /// * `Selected microphone is reconnected`
                /// * `Selected speaker has disconnected`
                /// * `Selected speaker is reconnected`
                /// * `Zoom room is offline`
                /// * `Zoom room is online`
                /// * `High CPU usage is detected`
                /// * `Low bandwidth network is detected`
                /// * `{name} battery is low`
                /// * `{name} battery is normal`
                /// * `{name} disconnected`
                /// * `{name} connected`
                /// * `{name} is not charging`
                /// 
                /// Possible values for {name}: <br>
                /// * Zoom Rooms Computer 
                /// * Controller
                /// * Scheduling Display
                public var issue: String?
                /// Time at which the issue was encountered.
                public var time: Date?

                public init(issue: String? = nil, time: Date? = nil) {
                    self.issue = issue
                    self.time = time
                }
            }

            public init(from: NaiveDate? = nil, issueDetails: [IssueDetail]? = nil, nextPageToken: String? = nil, pageCount: Int? = nil, pageSize: Int? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil) {
                self.from = from
                self.issueDetails = issueDetails
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.to = to
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case issueDetails = "issue_details"
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageSize = "page_size"
                case to
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate, to: NaiveDate, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics {
    public var quality: Quality {
        Quality(path: path + "/quality")
    }

    public struct Quality {
        /// Path: `/metrics/quality`
        public let path: String

        /// Get meeting quality scores
        ///
        /// Use this API to return [meeting quality score](https://support.zoom.us/hc/en-us/articles/360061244651-Meeting-quality-scores-and-network-alerts-on-Dashboard) information. Meeting quality scores are based on the mean opinion score (MOS). The MOS measures a meeting's quality on a scale of "Good" (5-4), "Fair" (4-3), "Poor" (3-2), or "Bad" (2-1). 
        /// 
        /// **Scopes:** `dashboard_home:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy` 
        /// 
        /// **Prerequisites:** 
        /// * A Business or a higher plan.
        public func get(parameters: GetParameters) -> Request<[String: AnyJSON]> {
            .get(path, query: parameters.asQuery)
        }

        public struct GetParameters {
            public var from: NaiveDate
            public var to: NaiveDate
            public var type: `Type`?

            public enum `Type`: String, Codable, CaseIterable {
                case meeting
                case participants
            }

            public init(from: NaiveDate, to: NaiveDate, type: `Type`? = nil) {
                self.from = from
                self.to = to
                self.type = type
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(type, forKey: "type")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Client.Feedback {
    public func feedbackID(_ feedbackID: String) -> WithFeedbackID {
        WithFeedbackID(path: "\(path)/\(feedbackID)")
    }

    public struct WithFeedbackID {
        /// Path: `/metrics/client/feedback/{feedbackId}`
        public let path: String

        /// Get zoom meetings client feedback
        ///
        /// Retrieve detailed information on a [Zoom meetings client feedback](https://support.zoom.us/hc/en-us/articles/115005855266-End-of-Meeting-Feedback-Survey#h_e30d552b-6d8e-4e0a-a588-9ca8180c4dbf). <br> You can specify a monthly date range for the dashboard data using the `from` and `to` query parameters. The month should fall within the last six months.
        /// 
        /// **Prerequisites:**
        /// * Business or higher account
        /// * [Feedback to Zoom](https://support.zoom.us/hc/en-us/articles/115005838023) enabled.
        /// 
        /// **Scope:** `dashboard_home:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        /// 
        /// `
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var clientFeedbackDetails: [ClientFeedbackDetail]?
            /// Start date for this report
            public var from: NaiveDate?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of the available result list exceeds the page size. The expiration period is 15 minutes.
            public var nextPageToken: String?
            /// The amount of records returns within a single API call.
            public var pageSize: Int?
            /// End date for this report
            public var to: NaiveDate?

            public struct ClientFeedbackDetail: Decodable {
                /// Participant Name
                public var participantName: String?
                /// Meeting ID
                public var meetingID: String?
                /// Time at which the feedback was submitted by the participant.
                public var time: Date?
                /// Email address of the participant.
                public var email: String?

                public init(participantName: String? = nil, meetingID: String? = nil, time: Date? = nil, email: String? = nil) {
                    self.participantName = participantName
                    self.meetingID = meetingID
                    self.time = time
                    self.email = email
                }

                private enum CodingKeys: String, CodingKey {
                    case participantName = "participant_name"
                    case meetingID = "meeting_id"
                    case time
                    case email
                }
            }

            public init(clientFeedbackDetails: [ClientFeedbackDetail]? = nil, from: NaiveDate? = nil, nextPageToken: String? = nil, pageSize: Int? = nil, to: NaiveDate? = nil) {
                self.clientFeedbackDetails = clientFeedbackDetails
                self.from = from
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case clientFeedbackDetails = "client_feedback_details"
                case from
                case nextPageToken = "next_page_token"
                case pageSize = "page_size"
                case to
            }
        }

        public struct GetParameters {
            public var from: NaiveDate?
            public var to: NaiveDate?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(from: NaiveDate? = nil, to: NaiveDate? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.from = from
                self.to = to
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(from, forKey: "from")
                encoder.encode(to, forKey: "to")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Client {
    public var satisfaction: Satisfaction {
        Satisfaction(path: path + "/satisfaction")
    }

    public struct Satisfaction {
        /// Path: `/metrics/client/satisfaction`
        public let path: String

        /// List client meeting satisfaction
        ///
        /// If the [End of Meeting Feedback Survey](https://support.zoom.us/hc/en-us/articles/115005855266) option is enabled, attendees will be prompted with a survey window where they can tap either the **Thumbs Up** or **Thumbs Down** button that indicates their Zoom meeting experience. With this API, you can get information on the attendees' meeting satisfaction. Specify a monthly date range for the query using the from and to query parameters. The month should fall within the last six months.
        /// 
        /// To get information on the survey results with negative experiences (indicated by **Thumbs Down**), use the [Get Zoom Meetings Client Feedback API](https://marketplace.zoom.us/docs/api-reference/zoom-api/dashboards/dashboardclientfeedbackdetail).<br>
        /// **Scopes:** `dashboard:read:admin`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(from: NaiveDate? = nil, to: NaiveDate? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(from, to))
        }

        public struct GetResponse: Decodable {
            /// Start date for this report in 'yyyy-mm-dd' format.
            public var from: NaiveDate?
            /// End date for this report in 'yyyy-mm-dd' format.
            public var to: NaiveDate?
            /// The total number of records available across all pages.
            public var totalRecords: Int?
            public var clientSatisfaction: [ClientSatisfactionItem]?

            public struct ClientSatisfactionItem: Decodable {
                /// Date of the report.
                public var date: NaiveDate?
                /// Satisfaction Percentage.
                /// The satisfaction percentage is calculated as `(good_count + none_count)` / `total_count`.
                public var satisfactionPercent: Double?
                /// The total number of "thumbs up" received for this meeting.
                public var goodCount: Int?
                /// The total number of "thumbs down" received for this meeting.
                public var notGoodCount: Int?
                /// The total number of attendees who didn't submit any response (neither thumbs up nor thumbs down).
                public var noneCount: Int?

                public init(date: NaiveDate? = nil, satisfactionPercent: Double? = nil, goodCount: Int? = nil, notGoodCount: Int? = nil, noneCount: Int? = nil) {
                    self.date = date
                    self.satisfactionPercent = satisfactionPercent
                    self.goodCount = goodCount
                    self.notGoodCount = notGoodCount
                    self.noneCount = noneCount
                }

                private enum CodingKeys: String, CodingKey {
                    case date
                    case satisfactionPercent = "satisfaction_percent"
                    case goodCount = "good_count"
                    case notGoodCount = "not_good_count"
                    case noneCount = "none_count"
                }
            }

            public init(from: NaiveDate? = nil, to: NaiveDate? = nil, totalRecords: Int? = nil, clientSatisfaction: [ClientSatisfactionItem]? = nil) {
                self.from = from
                self.to = to
                self.totalRecords = totalRecords
                self.clientSatisfaction = clientSatisfaction
            }

            private enum CodingKeys: String, CodingKey {
                case from
                case to
                case totalRecords = "total_records"
                case clientSatisfaction = "client_satisfaction"
            }
        }

        private func makeGetQuery(_ from: NaiveDate?, _ to: NaiveDate?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(from, forKey: "from")
            encoder.encode(to, forKey: "to")
            return encoder.items
        }
    }
}

extension Paths.Metrics.Meetings.WithMeetingID.Participants {
    public var satisfaction: Satisfaction {
        Satisfaction(path: path + "/satisfaction")
    }

    public struct Satisfaction {
        /// Path: `/metrics/meetings/{meetingId}/participants/satisfaction`
        public let path: String

        /// Get post meeting feedback
        ///
        /// When a meeting ends, each attendee will be prompted to share their meeting experience by clicking either thumbs up or thumbs down. Use this API to retrieve the feedback submitted for a specific meeting. Note that this API only works for meetings scheduled after December 20, 2020.
        /// 
        /// **Prerequisites:**
        /// * [Feedback to Zoom](https://support.zoom.us/hc/en-us/articles/115005838023) setting must be enabled by the participant prior to the meeting.
        /// * The user making the API request must be enrolled in a Business or a higher plan.
        /// 
        /// <br> **Scope:** `dashboard_meetings:read:admiin`
        /// 
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var participants: [Participant]?

            public struct Participant: Decodable {
                /// User ID of the participant.
                public var userID: String?
                /// Email address of the participant.
                public var email: String?
                /// Feedback submitted by the participant. 
                /// 
                /// * `GOOD`: Thumbs up.
                /// * `NOT GOOD`: Thumbs down.
                public var quality: Quality?
                /// Date and time at which the feedback was submitted.
                public var dateTime: Date?

                /// Feedback submitted by the participant. 
                /// 
                /// * `GOOD`: Thumbs up.
                /// * `NOT GOOD`: Thumbs down.
                public enum Quality: String, Codable, CaseIterable {
                    case good = "GOOD"
                    case notGood = "NOT GOOD"
                }

                public init(userID: String? = nil, email: String? = nil, quality: Quality? = nil, dateTime: Date? = nil) {
                    self.userID = userID
                    self.email = email
                    self.quality = quality
                    self.dateTime = dateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case userID = "user_id"
                    case email
                    case quality
                    case dateTime = "date_time"
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, participants: [Participant]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.participants = participants
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case participants
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var nextPageToken: String?
            public var pageSize: Int?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case pastOne
                case live
            }

            public init(type: `Type`? = nil, nextPageToken: String? = nil, pageSize: Int? = nil) {
                self.type = type
                self.nextPageToken = nextPageToken
                self.pageSize = pageSize
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                encoder.encode(pageSize, forKey: "page_size")
                return encoder.items
            }
        }
    }
}

extension Paths.Metrics.Webinars.WithWebinarID.Participants {
    public var satisfaction: Satisfaction {
        Satisfaction(path: path + "/satisfaction")
    }

    public struct Satisfaction {
        /// Path: `/metrics/webinars/{webinarId}/participants/satisfaction`
        public let path: String

        /// Get post webinar feedback
        ///
        /// When a Webinar ends, each attendee will be prompted to share their Webinar experience by clicking either thumbs up or thumbs down. Use this API to retrieve the feedback submitted for a specific webinar. Note that this API only works for meetings scheduled after December 20, 2020.
        /// 
        /// **Prerequisites:**
        /// * [Feedback to Zoom](https://support.zoom.us/hc/en-us/articles/115005838023) setting must be enabled by the participant prior to the meeting.
        /// * The user making the API request must be enrolled in a Business or a higher plan.
        /// 
        /// 
        /// <br> **Scope:** `dashboard_webinars:read:admin`
        /// 
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            /// The number of records returned within a single API call.
            public var pageSize: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var participants: [Participant]?

            public struct Participant: Decodable {
                /// User ID of the participant.
                public var userID: String?
                /// Email address of the participant.
                public var email: String?
                /// Feedback submitted by the participant. 
                /// 
                /// * `GOOD`: Thumbs up.
                /// * `NOT GOOD`: Thumbs down.
                public var quality: Quality?
                /// Date and time at which the feedback was submitted.
                public var dateTime: Date?

                /// Feedback submitted by the participant. 
                /// 
                /// * `GOOD`: Thumbs up.
                /// * `NOT GOOD`: Thumbs down.
                public enum Quality: String, Codable, CaseIterable {
                    case good = "GOOD"
                    case notGood = "NOT GOOD"
                }

                public init(userID: String? = nil, email: String? = nil, quality: Quality? = nil, dateTime: Date? = nil) {
                    self.userID = userID
                    self.email = email
                    self.quality = quality
                    self.dateTime = dateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case userID = "user_id"
                    case email
                    case quality
                    case dateTime = "date_time"
                }
            }

            public init(pageSize: Int? = nil, nextPageToken: String? = nil, participants: [Participant]? = nil) {
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
                self.participants = participants
            }

            private enum CodingKeys: String, CodingKey {
                case pageSize = "page_size"
                case nextPageToken = "next_page_token"
                case participants
            }
        }

        public struct GetParameters {
            public var type: `Type`?
            public var pageSize: Int?
            public var nextPageToken: String?

            public enum `Type`: String, Codable, CaseIterable {
                case past
                case pastOne
                case live
            }

            public init(type: `Type`? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.type = type
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(type, forKey: "type")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths {
    public static var groups: Groups {
        Groups(path: "/groups")
    }

    public struct Groups {
        /// Path: `/groups`
        public let path: String

        /// List groups
        ///
        /// List [groups](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under an account.
        /// 
        /// **Prerequisite**: Pro or higher account.<br>
        /// **Scopes**: `group:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// List of Groups.
        public struct GetResponse: Decodable {
            /// Total records.
            public var totalRecords: Int?
            /// List of Group objects.
            public var groups: [Group]?

            public struct Group: Decodable {
                /// Group ID.
                public var id: String?
                /// Group name.
                public var name: String?
                /// Total number of members in this group.
                public var totalMembers: Int?

                public init(id: String? = nil, name: String? = nil, totalMembers: Int? = nil) {
                    self.id = id
                    self.name = name
                    self.totalMembers = totalMembers
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decodeIfPresent(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.totalMembers = try values.decodeIfPresent(Int.self, forKey: "total_members")
                }
            }

            public init(totalRecords: Int? = nil, groups: [Group]? = nil) {
                self.totalRecords = totalRecords
                self.groups = groups
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case groups
            }
        }

        /// Create a group
        ///
        /// Use this API to create a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-). You can add a **maximum** of 100 groups in one account per day, and a maximum of 5000 groups in one account.
        /// 
        /// If you enabled a new group via the user interface, you can also choose whether to display the group and set its privacy level.
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites**: 
        /// * A Pro or higher account
        public func post(name: String? = nil) -> Request<Void> {
            .post(path, body: ["name": name])
        }
    }
}

extension Paths.Groups {
    public func groupID(_ groupID: String) -> WithGroupID {
        WithGroupID(path: "\(path)/\(groupID)")
    }

    public struct WithGroupID {
        /// Path: `/groups/{groupId}`
        public let path: String

        /// Get a group
        ///
        /// Get a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under an account.
        /// 
        /// **Prerequisite**: Pro, Business, or Education account<br>
        /// **Scopes**: `group:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Group ID.
            public var id: String?
            /// Group name.
            public var name: String?
            /// Total count of members in the group.
            public var totalMembers: Int?

            public init(id: String? = nil, name: String? = nil, totalMembers: Int? = nil) {
                self.id = id
                self.name = name
                self.totalMembers = totalMembers
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case totalMembers = "total_members"
            }
        }

        /// Update a group
        ///
        /// Update a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under your account.
        /// 
        /// **Prerequisite**: Pro, Business, or Education account<br>
        /// **Scopes**: `group:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(name: String? = nil) -> Request<Void> {
            .patch(path, body: ["name": name])
        }

        /// Delete a group
        ///
        /// Use this API to delete a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-).
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * A Pro, Business, or Education account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Groups.WithGroupID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/groups/{groupId}/members`
        public let path: String

        /// List group members
        ///
        /// List the members of a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under your account.
        /// 
        /// **Prerequisite**: Pro, Business, or Education account<br>
        /// **Scopes**: `group:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        public struct GetResponse: Decodable {
            public var members: [Member]?
            /// The number of pages returned from this request.
            public var pageCount: Int?
            /// The page number of the current results.
            public var pageNumber: Int?
            /// The number of records returned from a single API call.
            public var pageSize: Int?
            /// The total number of records available across all pages.
            public var totalRecords: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?

            public struct Member: Decodable {
                /// User's email address.
                public var email: String?
                /// First name of the user.
                public var firstName: String?
                /// Unique Identifier of the user.
                public var id: String?
                /// Last name of the user.
                public var lastName: String?
                /// User type: <br> `1` - Basic<br> `2` - Licensed<br> `3` - On-prem
                public var type: Int?

                public init(email: String? = nil, firstName: String? = nil, id: String? = nil, lastName: String? = nil, type: Int? = nil) {
                    self.email = email
                    self.firstName = firstName
                    self.id = id
                    self.lastName = lastName
                    self.type = type
                }

                private enum CodingKeys: String, CodingKey {
                    case email
                    case firstName = "first_name"
                    case id
                    case lastName = "last_name"
                    case type
                }
            }

            public init(members: [Member]? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil) {
                self.members = members
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.nextPageToken = nextPageToken
            }

            private enum CodingKeys: String, CodingKey {
                case members
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case nextPageToken = "next_page_token"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public init(pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Add group members
        ///
        /// Use this API to add users to a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) in your account.
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * A Pro, Business, or Education account
        public func post(members: [PostRequest.Member]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(members: members))
        }

        public struct PostRequest: Encodable {
            /// List of Group members
            public var members: [Member]?

            public struct Member: Encodable {
                /// User ID.
                public var id: String?
                /// User email. If the user ID is given then the user email should be ignored.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(members: [Member]? = nil) {
                self.members = members
            }
        }
    }
}

extension Paths.Groups.WithGroupID.Members {
    public func memberID(_ memberID: String) -> WithMemberID {
        WithMemberID(path: "\(path)/\(memberID)")
    }

    public struct WithMemberID {
        /// Path: `/groups/{groupId}/members/{memberId}`
        public let path: String

        /// Update a group member
        ///
        /// Use this API to perform either of the following tasks: 
        /// * Remove a group member from one group and move them to a different group. 
        /// * Set a user's primary group. By default, the primary group is the first group that user is added to.
        /// 
        /// If a user is a member of multiple groups, you can [assign the user a primary group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-#h_d07c7dcd-4fd8-485a-b5fe-a322e8d21c09). The user will use the primary groups settings by default. However, if the user is a member of a group with locked settings, those group settings will remain locked to the user.
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher account
        public func patch(_ body: PatchRequest? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The action to perform: 
            /// * `move`  Remove the group member from one group and move them to a different group. 
            /// * `set_primary`  Set the user's primary group.
            public var action: Action
            /// The target group's ID. To get this value, use the [List Groups](https://marketplace.zoom.us/docs/api-reference/zoom-api/groups/groups) API. 
            /// * To set a user's primary group, use the designated primary group's `groupId` value. 
            /// * To move a group member from one group to another, use the `groupId` of the designated group.
            public var targetGroupID: String?

            /// The action to perform: 
            /// * `move`  Remove the group member from one group and move them to a different group. 
            /// * `set_primary`  Set the user's primary group.
            public enum Action: String, Codable, CaseIterable {
                case move
                case setPrimary = "set_primary"
            }

            public init(action: Action, targetGroupID: String? = nil) {
                self.action = action
                self.targetGroupID = targetGroupID
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case targetGroupID = "target_group_id"
            }
        }

        /// Delete a group member
        ///
        /// Use this API to remove a user from a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) in an account.
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * A Pro, Business, or Education account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Groups.WithGroupID {
    public var admins: Admins {
        Admins(path: path + "/admins")
    }

    public struct Admins {
        /// Path: `/groups/{groupId}/admins`
        public let path: String

        /// List group admins
        ///
        /// Use this API to return a list of [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) administrators under your account.
        /// 
        /// **Scopes:** `group:read:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * A Pro, Business, or Education account
        public func get(pageSize: Int? = nil, nextPageToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, nextPageToken))
        }

        public struct GetResponse: Decodable {
            public var admins: [Admin]?
            /// The number of records returned in a single API call.
            public var pageSize: Int?
            /// The total number of records available across all pages.
            public var totalRecords: Int?
            /// The next page token is used to paginate through large result sets. A next page token is returned when the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?

            public struct Admin: Decodable {
                /// The user's email address.
                public var email: String?
                /// The user's display name.
                public var name: String?

                public init(email: String? = nil, name: String? = nil) {
                    self.email = email
                    self.name = name
                }
            }

            public init(admins: [Admin]? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil) {
                self.admins = admins
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.nextPageToken = nextPageToken
            }

            private enum CodingKeys: String, CodingKey {
                case admins
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case nextPageToken = "next_page_token"
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ nextPageToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(nextPageToken, forKey: "next_page_token")
            return encoder.items
        }

        /// Add group admins
        ///
        /// Use this API to add administrators to a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) under your account.
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:** 
        /// * A Pro, Business, or Education account
        public func post(admins: [PostRequest.Admin]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(admins: admins))
        }

        public struct PostRequest: Encodable {
            /// A list of the administrators to add to a group.
            public var admins: [Admin]?

            public struct Admin: Encodable {
                /// The user's ID.
                public var id: String?
                /// The user's email. Use this value if you do not have the user's ID.
                /// 
                /// If you pass the `id` value, the API ignores this parameter.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(admins: [Admin]? = nil) {
                self.admins = admins
            }
        }
    }
}

extension Paths.Groups.WithGroupID.Admins {
    public func userID(_ userID: String) -> WithUserID {
        WithUserID(path: "\(path)/\(userID)")
    }

    public struct WithUserID {
        /// Path: `/groups/{groupId}/admins/{userId}`
        public let path: String

        /// Delete a group admin
        ///
        /// Use this API to remove a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) administrator in a Zoom account.
        /// 
        /// **Scopes:** `group:write:admin`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:** 
        /// * A Pro, Business, or Education account
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Im {
    public var groups: Groups {
        Groups(path: path + "/groups")
    }

    public struct Groups {
        /// Path: `/im/groups`
        public let path: String

        /// List IM directory groups
        ///
        /// List [IM directory groups](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management).<br><br>
        /// **Scopes**: `imgroup:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }

        /// Create an IM directory group
        ///
        /// Create an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) under your account.<br><br>
        /// **Scopes**: `imgroup:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func post(_ body: PostRequest) -> Request<Void> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Group name: must be unique to one account.
            public var name: String?
            /// IM Group types:<br>`normal` - Only members can see automatically see the other members of this group. Other people can search for members within this group. <br>`shared` - Everyone under an account can see the group members automatically.<br>`restricted` - Nobody can see the group or search for members except the members in the group.
            public var type: `Type`?
            /// Members can search for others in the same email domain.
            public var isSearchByDomain: Bool?
            /// Members can search for others under same account.
            public var isSearchByAccount: Bool?
            /// Members can search for others under same master account, including all sub accounts.
            public var isSearchByMaAccount: Bool?

            /// IM Group types:<br>`normal` - Only members can see automatically see the other members of this group. Other people can search for members within this group. <br>`shared` - Everyone under an account can see the group members automatically.<br>`restricted` - Nobody can see the group or search for members except the members in the group.
            public enum `Type`: String, Codable, CaseIterable {
                case normal
                case shared
                case restricted
            }

            public init(name: String? = nil, type: `Type`? = nil, isSearchByDomain: Bool? = nil, isSearchByAccount: Bool? = nil, isSearchByMaAccount: Bool? = nil) {
                self.name = name
                self.type = type
                self.isSearchByDomain = isSearchByDomain
                self.isSearchByAccount = isSearchByAccount
                self.isSearchByMaAccount = isSearchByMaAccount
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case type
                case isSearchByDomain = "search_by_domain"
                case isSearchByAccount = "search_by_account"
                case isSearchByMaAccount = "search_by_ma_account"
            }
        }
    }
}

extension Paths.Im.Groups {
    public func groupID(_ groupID: String) -> WithGroupID {
        WithGroupID(path: "\(path)/\(groupID)")
    }

    public struct WithGroupID {
        /// Path: `/im/groups/{groupId}`
        public let path: String

        /// Retrieve an IM directory group
        ///
        /// Retrieve an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) under your account.<br><br>
        /// Scopes: `imgroup:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Group ID.
            public var id: String?
            /// Group name.
            public var name: String?
            /// Total number of members in this group.
            public var totalMembers: Int?

            public init(id: String? = nil, name: String? = nil, totalMembers: Int? = nil) {
                self.id = id
                self.name = name
                self.totalMembers = totalMembers
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case totalMembers = "total_members"
            }
        }

        /// Update an IM directory group
        ///
        /// Update an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) under your account.<br><br>
        /// **Scopes**: `imgroup:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// Group name: must be unique to one account.
            public var name: String?
            /// IM Group types:<br>`normal` - Only group members can automatically see others in their group. Other people can search for members in the group.<br>`shared` - Everyone under the account can see the group and members automatically.<br>`restricted` - Nobody can see the group or search for members except for the members in the group.
            public var type: `Type`?
            /// Members can search for others in the same email domain.
            public var isSearchByDomain: Bool?
            /// Members can search for others under same account.
            public var isSearchByAccount: Bool?
            /// Members can search for others under same master account, including all sub accounts.
            public var isSearchByMaAccount: Bool?

            /// IM Group types:<br>`normal` - Only group members can automatically see others in their group. Other people can search for members in the group.<br>`shared` - Everyone under the account can see the group and members automatically.<br>`restricted` - Nobody can see the group or search for members except for the members in the group.
            public enum `Type`: String, Codable, CaseIterable {
                case normal
                case shared
                case restricted
            }

            public init(name: String? = nil, type: `Type`? = nil, isSearchByDomain: Bool? = nil, isSearchByAccount: Bool? = nil, isSearchByMaAccount: Bool? = nil) {
                self.name = name
                self.type = type
                self.isSearchByDomain = isSearchByDomain
                self.isSearchByAccount = isSearchByAccount
                self.isSearchByMaAccount = isSearchByMaAccount
            }

            private enum CodingKeys: String, CodingKey {
                case name
                case type
                case isSearchByDomain = "search_by_domain"
                case isSearchByAccount = "search_by_account"
                case isSearchByMaAccount = "search_by_ma_account"
            }
        }

        /// Delete an IM directory group
        ///
        /// Delete an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) under your account.<br><br>
        /// Scopes: `imgroup:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Im.Groups.WithGroupID {
    public var members: Members {
        Members(path: path + "/members")
    }

    public struct Members {
        /// Path: `/im/groups/{groupId}/members`
        public let path: String

        /// List IM directory group members
        ///
        /// List the members of an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management).<br><br>
        /// **Scope:** `imgroup:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Group Member List
        ///
        /// List of Group Members.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public init(pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Add IM directory group members
        ///
        /// Add members to an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) under an account.<br><br>
        /// **Scope:** `imgroup:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func post(members: [PostRequest.Member]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(members: members))
        }

        public struct PostRequest: Encodable {
            /// List of IM group members.
            public var members: [Member]?

            public struct Member: Encodable {
                /// User ID.
                public var id: String?
                /// User email. If the user ID is given then ignore the user email.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(members: [Member]? = nil) {
                self.members = members
            }
        }
    }
}

extension Paths.Im.Groups.WithGroupID.Members {
    public func memberID(_ memberID: String) -> WithMemberID {
        WithMemberID(path: "\(path)/\(memberID)")
    }

    public struct WithMemberID {
        /// Path: `/im/groups/{groupId}/members/{memberId}`
        public let path: String

        /// Delete IM directory group member
        ///
        /// Delete a member from an [IM directory group](https://support.zoom.us/hc/en-us/articles/203749815-IM-Management) under an account.<br><br>
        /// Scopes: `imgroup:write:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Groups.WithGroupID {
    public var settings: Settings {
        Settings(path: path + "/settings")
    }

    public struct Settings {
        /// Path: `/groups/{groupId}/settings`
        public let path: String

        /// Get a group's settings
        ///
        /// Get settings for a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-). 
        /// **Prerequisite**: Pro, Business, or Education account<br>
        /// **Scopes**: `group:read:admin`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(option: Option? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(option))
        }

        private func makeGetQuery(_ option: Option?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            return encoder.items
        }

        public enum Option: String, Codable, CaseIterable {
            case meetingAuthentication = "meeting_authentication"
            case recordingAuthentication = "recording_authentication"
            case meetingSecurity = "meeting_security"
        }

        /// Update a group's settings
        ///
        /// Update settings for a [group](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-).<p style="background-color:#FEEFB3; color:#9F6000"><br>Note:</b> The `force_pmi_jbh_password` field under meeting settings is planned to be deprecated on September 22, 2019. This field will be replaced by another field that will provide the same functionality.</p>
        /// **Prerequisite**: Pro, Business, or Education account<br> 
        /// **Scopes**: `group:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(option: Option? = nil, _ body: [String: AnyJSON]? = nil) -> Request<Void> {
            .patch(path, query: makePatchQuery(option), body: body)
        }

        private func makePatchQuery(_ option: Option?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            return encoder.items
        }
    }
}

extension Paths.Groups.WithGroupID {
    public var lockSettings: LockSettings {
        LockSettings(path: path + "/lock_settings")
    }

    public struct LockSettings {
        /// Path: `/groups/{groupId}/lock_settings`
        public let path: String

        /// Get locked settings
        ///
        /// Retrieve a [group's](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) locked settings. If you lock a setting, the group members will not be able to modify it individually. <p style="background-color:#FEEFB3; color:#9F6000"><br>Note:</b> The `force_pmi_jbh_password` field under meeting settings is planned to be deprecated on September 22, 2019. This field will be replaced by another field that will provide the same functionality.</p>
        /// 
        /// **Prerequisite**: Pro, Business, or Education account<br>
        /// **Scopes**: `group:read:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func get(option: String? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(option))
        }

        private func makeGetQuery(_ option: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            return encoder.items
        }

        /// Update locked settings
        ///
        /// Update a [group's](https://support.zoom.us/hc/en-us/articles/204519819-Group-Management-) locked settings. If you lock a setting, the group members will not be able to modify it individually. <p style="background-color:#FEEFB3; color:#9F6000"><br>Note:</b> The `force_pmi_jbh_password` field under meeting settings is planned to be deprecated on September 22, 2019. This field will be replaced by another field that will provide the same functionality.</p>
        /// 
        /// **Prerequisite**: Pro, Business, or Education account<br>
        /// **Scopes**: `group:write:admin`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func patch(option: String? = nil, _ body: [String: AnyJSON]? = nil) -> Request<[String: AnyJSON]> {
            .patch(path, query: makePatchQuery(option), body: body)
        }

        private func makePatchQuery(_ option: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(option, forKey: "option")
            return encoder.items
        }
    }
}

extension Paths.Groups.WithGroupID.Settings {
    public var virtualBackgrounds: VirtualBackgrounds {
        VirtualBackgrounds(path: path + "/virtual_backgrounds")
    }

    public struct VirtualBackgrounds {
        /// Path: `/groups/{groupId}/settings/virtual_backgrounds`
        public let path: String

        /// Upload virtual background files
        ///
        /// Use this API to [upload virtual background files](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_01EJF3YFEWGT8YA0ZJ079JEDQE) for all users in a group to use. 
        /// 
        /// 
        /// **Prerequisites:**<br>
        /// * Virtual background feature must be [enabled](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) on the account.
        /// <br> **Scope:** `group:write:admin`<br><br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// 
        /// 
        /// `
        public func post(_ body: Data? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            /// Unique identifier of the file.
            public var id: String?
            /// File name.
            public var name: String?
            /// File type.
            public var type: String?
            /// Indicate whether or not this file is the default virtual background file.
            public var isDefault: Bool?
            /// File size.
            public var size: String?

            public init(id: String? = nil, name: String? = nil, type: String? = nil, isDefault: Bool? = nil, size: String? = nil) {
                self.id = id
                self.name = name
                self.type = type
                self.isDefault = isDefault
                self.size = size
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case name
                case type
                case isDefault = "is_default"
                case size
            }
        }

        /// Delete virtual background files
        ///
        /// Delete existing virtual background file(s) from an account. 
        /// 
        /// **Prerequisites:**<br>
        /// * Virtual background feature must be [enabled](https://support.zoom.us/hc/en-us/articles/210707503-Virtual-Background#h_2ef28080-fce9-4ac2-b567-dc958afab1b7) on the account.
        /// <br> **Scope:** `group:write:admin`<br><br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func delete(fileIDs: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(fileIDs))
        }

        private func makeDeleteQuery(_ fileIDs: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(fileIDs, forKey: "file_ids")
            return encoder.items
        }
    }
}

extension Paths.Users.WithUserID {
    public var webinars: Webinars {
        Webinars(path: path + "/webinars")
    }

    public struct Webinars {
        /// Path: `/users/{userId}/webinars`
        public let path: String

        /// List webinars
        ///
        /// Use this API to list all the webinars that are scheduled by or on-behalf a user (webinar host). For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter.
        /// 
        /// Zoom users with a [Webinar Plan](https://zoom.us/webinar) have access to creating and managing webinars. Webinars allow a host to broadcast a Zoom meeting to up to 10,000 attendees.
        /// 
        /// **Scopes:** `webinar:read:admin`, `webinar:read`<br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        /// 
        /// **Prerequisites:**
        /// * Pro or higher plan with a Webinar Add-on.
        public func get(pageSize: Int? = nil, pageNumber: Int? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, pageNumber))
        }

        /// User List
        ///
        /// List of webinars.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ pageNumber: Int?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(pageNumber, forKey: "page_number")
            return encoder.items
        }

        /// Create a webinar
        ///
        /// Use this API to schedule a webinar for a user (webinar host). For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        /// Zoom users with a [Webinar plan](https://zoom.us/webinar) have access to creating and managing webinars. Webinars allow a host to broadcast a Zoom meeting to up to 10,000 attendees. 
        /// 
        /// **Scopes:** `webinar:write:admin`, `webinar:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// * This API has a daily rate limit of **100 requests per day**. The rate limit is applied to the `userId` of the **webinar host** used to make the request. 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan with a Webinar add-on.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of created Webinar
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// Webinar agenda.
            public var agenda: String?
            /// Create time.
            public var createdAt: Date?
            /// Webinar duration.
            public var duration: Int?
            /// Email address of the meeting host.
            public var hostEmail: String?
            /// ID of the user set as host of the webinar.
            public var hostID: String?
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// URL to join the Webinar. This URL should only be shared with the users who should be invited to the Webinar.
            public var joinURL: String?
            /// Array of occurrence objects.
            public var occurrences: [Occurrence]?
            /// Webinar passcode. 
            /// 
            /// If "Require a passcode when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
            /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
            public var password: String?
            /// Recurrence Webinar
            ///
            /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
            public var recurrence: Recurrence?
            /// Specify whether or not registrants of this Webinar should receieve confirmation emails.
            public var isRegistrantsConfirmationEmail: Bool?
            /// Webinar settings.
            public var settings: Settings?
            /// Webinar start time in GMT/UTC.
            public var startTime: Date?
            /// <br><aside>The <code>start_url</code> of a Webinar is a URL using which a host or an alternative host can start the Webinar. This URL should only be used by the host of the meeting and should not be shared with anyone other than the host of the Webinar. 
            /// 
            /// The expiration time for the <code>start_url</code> field listed in the response of [Create a Webinar API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinarcreate) is two hours for all regular users. 
            /// 	
            /// For users created using the <code>custCreate</code> option via the [Create Users](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usercreate) API, the expiration time of the <code>start_url</code> field is 90 days.
            /// 	
            /// For security reasons, to retrieve the latest value for the <code>start_url</code> field programmatically (after expiry), you must call the [Retrieve a Webinar API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinar) and refer to the value of the <code>start_url</code> field in the response.</aside><br><br><br>
            public var startURL: String?
            /// Unique identifier of the Webinar template. Use this field only if you would like to [schedule the webinar using an existing template](https://support.zoom.us/hc/en-us/articles/115001079746-Webinar-Templates#schedule). The value of this field can be retrieved from [List Webinar Templates](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/listwebinartemplates) API.
            /// You must provide the user ID of the host instead of the email address in the `userId` path parameter in order to use a template for scheduling a Webinar.
            public var templateID: String?
            /// Time zone to format start_time.
            public var timezone: String?
            /// Webinar topic.
            public var topic: String?
            /// Tracking fields
            public var trackingFields: [TrackingField]?
            /// Webinar Types:<br>`5` - Webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
            public var type: Int?
            /// Unique identifier of a Webinar. Each Webinar instance will generate its own UUID(i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). Once a Webinar ends, the value of uuid for the same webinar will be different from when it was scheduled.
            public var uuid: String?

            /// Occurrence object. This object is only returned for Recurring Webinars.
            public struct Occurrence: Decodable {
                /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
                public var occurrenceID: String?
                /// Start time.
                public var startTime: Date?
                /// Duration.
                public var duration: Int?
                /// Occurrence status.
                public var status: String?

                public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
                    self.occurrenceID = occurrenceID
                    self.startTime = startTime
                    self.duration = duration
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case occurrenceID = "occurrence_id"
                    case startTime = "start_time"
                    case duration
                    case status
                }
            }

            /// Recurrence Webinar
            ///
            /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
            public struct Recurrence: Decodable {
                /// Recurrence webinar types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.
                public var repeatInterval: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat. <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `"1"` as the value of this field.  <br><br> **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                /// <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: String?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field. <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the webinar will recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: String? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            /// Webinar settings.
            public struct Settings: Decodable {
                /// Start video when host joins webinar.
                public var isHostVideo: Bool?
                /// Start video when panelists join webinar.
                public var isPanelistsVideo: Bool?
                /// Enable practice session.
                public var isPracticeSession: Bool
                /// Default to HD video.
                public var isHdVideo: Bool
                /// Whether HD video for attendees is enabled. This value defaults to `false`.
                public var isHdVideoForAttendees: Bool
                /// Whether to always send 1080p video to attendees. This value defaults to `false`.
                public var isSend1080pVideoToAttendees: Bool
                /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                public var approvalType: Int?
                /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
                public var registrationType: Int?
                /// Determine how participants can join the audio portion of the webinar.
                public var audio: Audio?
                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public var autoRecording: AutoRecording?
                /// Only signed in users can join this meeting.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
                public var enforceLogin: Bool?
                /// Only signed in users with specified domains can join meetings.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
                public var enforceLoginDomains: String?
                /// Alternative host emails or IDs. Multiple values separated by comma.
                public var alternativeHosts: String?
                /// Close registration after event date.
                public var isCloseRegistration: Bool?
                /// Show social share buttons on the registration page.
                public var isShowShareButton: Bool?
                /// Allow attendees to join from multiple devices.
                public var allowMultipleDevices: Bool?
                /// Make the webinar on-demand
                public var isOnDemand: Bool
                /// List of global dial-in countries
                public var globalDialInCountries: [String]?
                /// Contact name for registration
                public var contactName: String?
                /// Contact email for registration
                public var contactEmail: String?
                /// Send confirmation email to registrants
                public var isRegistrantsConfirmationEmail: Bool?
                /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
                public var registrantsRestrictNumber: Int?
                /// Send notification email to registrants when the host updates a webinar.
                public var isNotifyRegistrants: Bool?
                /// Zoom will open a survey page in attendees' browsers after leaving the webinar
                public var isPostWebinarSurvey: Bool?
                /// Survey url for post webinar survey
                public var surveyURL: String?
                /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
                public var isRegistrantsEmailNotification: Bool?
                /// `true`- Only authenticated users can join Webinar.
                public var isMeetingAuthentication: Bool?
                /// Webinar authentication option id.
                public var authenticationOption: String?
                /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
                public var authenticationDomains: String?
                /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
                public var authenticationName: String?
                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public var questionAndAnswer: QuestionAndAnswer?
                /// Set the email language to one of the following:
                /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
                public var emailLanguage: String?
                /// * `true`: Send invitation email to panelists.
                /// 
                /// * `false`: Do not send invitation email to panelists.
                public var isPanelistsInvitationEmailNotification: Bool?
                /// Send reminder email to attendees and panelists.
                public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
                /// Send follow-up email to attendees.
                public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
                /// Send follow-up email to absentees.
                public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public var languageInterpretation: LanguageInterpretation?

                /// Determine how participants can join the audio portion of the webinar.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public struct QuestionAndAnswer: Decodable {
                    /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                    /// 
                    /// * `false`: Disable Q&A for webinar.
                    public var enable: Bool?
                    /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
                    /// 
                    /// * `false`: Do not allow anonymous questions.
                    public var allowAnonymousQuestions: Bool?
                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public var answerQuestions: AnswerQuestions?
                    /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
                    /// 
                    /// * `false`: Attendees can not click the thumbs up button on questions.
                    public var attendeesCanUpvote: Bool?
                    /// * `true`: Attendees can answer questions or leave a comment in the question thread.
                    /// 
                    /// * `false`: Attendees can not answer questions or leave a comment in the question thread
                    public var attendeesCanComment: Bool?

                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public enum AnswerQuestions: String, Codable, CaseIterable {
                        case only
                        case all
                    }

                    public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                        self.enable = enable
                        self.allowAnonymousQuestions = allowAnonymousQuestions
                        self.answerQuestions = answerQuestions
                        self.attendeesCanUpvote = attendeesCanUpvote
                        self.attendeesCanComment = attendeesCanComment
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case allowAnonymousQuestions = "allow_anonymous_questions"
                        case answerQuestions = "answer_questions"
                        case attendeesCanUpvote = "attendees_can_upvote"
                        case attendeesCanComment = "attendees_can_comment"
                    }
                }

                /// Send reminder email to attendees and panelists.
                public struct AttendeesAndPanelistsReminderEmailNotification: Decodable {
                    /// * `true`: Send reminder email to attendees and panelists.
                    /// 
                    /// * `false`: Do not send reminder email to attendees and panelists.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to attendees.
                public struct FollowUpAttendeesEmailNotification: Decodable {
                    /// * `true`: Send follow-up email to attendees.
                    /// 
                    /// * `false`: Do not send follow-up email to attendees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to absentees.
                public struct FollowUpAbsenteesEmailNotification: Decodable {
                    /// * `true`: Send follow-up email to absentees.
                    /// 
                    /// * `false`: Do not send follow-up email to absentees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public struct LanguageInterpretation: Decodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
                    public var enable: Bool?
                    /// Information about the webinar's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Decodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isPanelistsVideo = isPanelistsVideo
                    self.isPracticeSession = isPracticeSession ?? false
                    self.isHdVideo = isHdVideo ?? false
                    self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
                    self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.enforceLogin = enforceLogin
                    self.enforceLoginDomains = enforceLoginDomains
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.isOnDemand = isOnDemand ?? false
                    self.globalDialInCountries = globalDialInCountries
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                    self.registrantsRestrictNumber = registrantsRestrictNumber
                    self.isNotifyRegistrants = isNotifyRegistrants
                    self.isPostWebinarSurvey = isPostWebinarSurvey
                    self.surveyURL = surveyURL
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.authenticationName = authenticationName
                    self.questionAndAnswer = questionAndAnswer
                    self.emailLanguage = emailLanguage
                    self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
                    self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
                    self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
                    self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
                    self.languageInterpretation = languageInterpretation
                }

                private enum CodingKeys: String, CodingKey {
                    case isHostVideo = "host_video"
                    case isPanelistsVideo = "panelists_video"
                    case isPracticeSession = "practice_session"
                    case isHdVideo = "hd_video"
                    case isHdVideoForAttendees = "hd_video_for_attendees"
                    case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
                    case approvalType = "approval_type"
                    case registrationType = "registration_type"
                    case audio
                    case autoRecording = "auto_recording"
                    case enforceLogin = "enforce_login"
                    case enforceLoginDomains = "enforce_login_domains"
                    case alternativeHosts = "alternative_hosts"
                    case isCloseRegistration = "close_registration"
                    case isShowShareButton = "show_share_button"
                    case allowMultipleDevices = "allow_multiple_devices"
                    case isOnDemand = "on_demand"
                    case globalDialInCountries = "global_dial_in_countries"
                    case contactName = "contact_name"
                    case contactEmail = "contact_email"
                    case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
                    case registrantsRestrictNumber = "registrants_restrict_number"
                    case isNotifyRegistrants = "notify_registrants"
                    case isPostWebinarSurvey = "post_webinar_survey"
                    case surveyURL = "survey_url"
                    case isRegistrantsEmailNotification = "registrants_email_notification"
                    case isMeetingAuthentication = "meeting_authentication"
                    case authenticationOption = "authentication_option"
                    case authenticationDomains = "authentication_domains"
                    case authenticationName = "authentication_name"
                    case questionAndAnswer = "question_and_answer"
                    case emailLanguage = "email_language"
                    case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
                    case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
                    case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
                    case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
                    case languageInterpretation = "language_interpretation"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
                    self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsVideo)
                    self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: .isPracticeSession) ?? false
                    self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: .isHdVideo) ?? false
                    self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: .isHdVideoForAttendees) ?? false
                    self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: .isSend1080pVideoToAttendees) ?? false
                    self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
                    self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
                    self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
                    self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
                    self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
                    self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
                    self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
                    self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration)
                    self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
                    self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
                    self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: .isOnDemand) ?? false
                    self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
                    self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
                    self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
                    self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
                    self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: .registrantsRestrictNumber)
                    self.isNotifyRegistrants = try values.decodeIfPresent(Bool.self, forKey: .isNotifyRegistrants)
                    self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isPostWebinarSurvey)
                    self.surveyURL = try values.decodeIfPresent(String.self, forKey: .surveyURL)
                    self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
                    self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
                    self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
                    self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
                    self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
                    self.questionAndAnswer = try values.decodeIfPresent(QuestionAndAnswer.self, forKey: .questionAndAnswer)
                    self.emailLanguage = try values.decodeIfPresent(String.self, forKey: .emailLanguage)
                    self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsInvitationEmailNotification)
                    self.attendeesAndPanelistsReminderEmailNotification = try values.decodeIfPresent(AttendeesAndPanelistsReminderEmailNotification.self, forKey: .attendeesAndPanelistsReminderEmailNotification)
                    self.followUpAttendeesEmailNotification = try values.decodeIfPresent(FollowUpAttendeesEmailNotification.self, forKey: .followUpAttendeesEmailNotification)
                    self.followUpAbsenteesEmailNotification = try values.decodeIfPresent(FollowUpAbsenteesEmailNotification.self, forKey: .followUpAbsenteesEmailNotification)
                    self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
                }
            }

            public struct TrackingField: Decodable {
                /// Tracking fields type
                public var field: String?
                /// Tracking fields value
                public var value: String?

                public init(field: String? = nil, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            public init(agenda: String? = nil, createdAt: Date? = nil, duration: Int? = nil, hostEmail: String? = nil, hostID: String? = nil, id: Int? = nil, joinURL: String? = nil, occurrences: [Occurrence]? = nil, password: String? = nil, recurrence: Recurrence? = nil, isRegistrantsConfirmationEmail: Bool? = nil, settings: Settings? = nil, startTime: Date? = nil, startURL: String? = nil, templateID: String? = nil, timezone: String? = nil, topic: String? = nil, trackingFields: [TrackingField]? = nil, type: Int? = nil, uuid: String? = nil) {
                self.agenda = agenda
                self.createdAt = createdAt
                self.duration = duration
                self.hostEmail = hostEmail
                self.hostID = hostID
                self.id = id
                self.joinURL = joinURL
                self.occurrences = occurrences
                self.password = password
                self.recurrence = recurrence
                self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                self.settings = settings
                self.startTime = startTime
                self.startURL = startURL
                self.templateID = templateID
                self.timezone = timezone
                self.topic = topic
                self.trackingFields = trackingFields
                self.type = type
                self.uuid = uuid
            }

            private enum CodingKeys: String, CodingKey {
                case agenda
                case createdAt = "created_at"
                case duration
                case hostEmail = "host_email"
                case hostID = "host_id"
                case id
                case joinURL = "join_url"
                case occurrences
                case password
                case recurrence
                case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
                case settings
                case startTime = "start_time"
                case startURL = "start_url"
                case templateID = "template_id"
                case timezone
                case topic
                case trackingFields = "tracking_fields"
                case type
                case uuid
            }
        }

        /// Webinar object.
        public struct PostRequest: Encodable {
            /// Webinar topic.
            public var topic: String?
            /// Webinar Types:<br>`5` - Webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
            public var type: Int?
            /// Webinar start time. We support two formats for `start_time` - local time and GMT.<br> 
            /// 
            /// To set time as GMT the format should be `yyyy-MM-dd`T`HH:mm:ssZ`.
            /// 
            /// To set time using a specific timezone, use `yyyy-MM-dd`T`HH:mm:ss` format and specify the timezone [ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) in the `timezone` field OR leave it blank and the timezone set on your Zoom account will be used. You can also set the time as UTC as the timezone field.
            /// 
            /// The `start_time` should only be used for scheduled and / or recurring webinars with fixed time.
            public var startTime: Date?
            /// Webinar duration (minutes). Used for scheduled webinars only.
            public var duration: Int?
            /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [timezone](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones) list for supported time zones and their formats.
            public var timezone: String?
            /// Webinar passcode. Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ * !]. Max of 10 characters.
            /// 
            /// If "Require a passcode when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
            /// 
            /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
            public var password: String?
            /// Webinar description.
            public var agenda: String?
            /// Tracking fields
            public var trackingFields: [TrackingField]?
            /// Recurrence Webinar
            ///
            /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
            public var recurrence: Recurrence?
            /// Create Webinar settings.
            public var settings: Settings?
            /// The webinar template ID with which to schedule a webinar using a [webinar template](https://support.zoom.us/hc/en-us/articles/115001079746-Webinar-Templates). For a list of webinar templates, use the [**List webinar templates**](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/listwebinartemplates) API.
            public var templateID: String?

            public struct TrackingField: Encodable {
                /// Tracking fields type
                public var field: String
                /// Tracking fields value
                public var value: String?

                public init(field: String, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            /// Recurrence Webinar
            ///
            /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
            public struct Recurrence: Encodable {
                /// Recurrence webinar types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.
                public var repeatInterval: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat. <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `"1"` as the value of this field.  <br><br> **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                /// <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: String?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field. <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the webinar will recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: String? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            /// Create Webinar settings.
            public struct Settings: Encodable {
                /// Start video when host joins webinar.
                public var isHostVideo: Bool?
                /// Start video when panelists join webinar.
                public var isPanelistsVideo: Bool?
                /// Enable practice session.
                public var isPracticeSession: Bool
                /// Default to HD video.
                public var isHdVideo: Bool
                /// Whether HD video for attendees is enabled. This value defaults to `false`.
                public var isHdVideoForAttendees: Bool
                /// Whether to always send 1080p video to attendees. This value defaults to `false`.
                public var isSend1080pVideoToAttendees: Bool
                /// The default value is `2`. To enable registration required, set the approval type to `0` or `1`.  Values include:<br>
                /// 
                /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                public var approvalType: Int?
                /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
                public var registrationType: Int?
                /// Determine how participants can join the audio portion of the meeting.
                public var audio: Audio?
                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public var autoRecording: AutoRecording?
                /// Only signed-in users can join this meeting. 
                /// 
                /// **This field is deprecated and will not be supported in future.** <br><br> Instead of this field, use the "meeting_authentication", "authentication_option" and/or "authentication_domains" fields to establish the authentication mechanism for this Webinar.
                public var enforceLogin: Bool?
                /// Only signed-in users with specified domains can join meetings.
                /// 
                /// **This field is deprecated and will not be supported in future.** <br><br> Instead of this field, use the "authentication_domains" field for this Webinar.
                public var enforceLoginDomains: String?
                /// Alternative host emails or IDs. Multiple values separated by comma.
                public var alternativeHosts: String?
                /// Close registration after event date.
                public var isCloseRegistration: Bool?
                /// Show social share buttons on the registration page.
                public var isShowShareButton: Bool?
                /// Allow attendees to join from multiple devices.
                public var allowMultipleDevices: Bool?
                /// Make the webinar on-demand
                public var isOnDemand: Bool
                /// List of global dial-in countries
                public var globalDialInCountries: [String]?
                /// Contact name for registration
                public var contactName: String?
                /// Contact email for registration
                public var contactEmail: String?
                /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
                public var registrantsRestrictNumber: Int?
                /// Zoom will open a survey page in attendees' browsers after leaving the webinar
                public var isPostWebinarSurvey: Bool?
                /// Survey url for post webinar survey
                public var surveyURL: String?
                /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
                public var isRegistrantsEmailNotification: Bool?
                /// Only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join meeting if the value of this field is set to `true`.
                public var isMeetingAuthentication: Bool?
                /// Specify the authentication type for users to join a Webinar with`meeting_authentication` setting set to `true`. The value of this field can be retrieved from the `id` field within `authentication_options` array in the response of [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings).
                public var authenticationOption: String?
                /// Meeting authentication domains. This option, allows you to specify the rule so that Zoom users, whose email address contains a certain domain, can join the Webinar. You can either provide multiple domains, using a comma in between and/or use a wildcard for listing domains.
                public var authenticationDomains: String?
                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public var questionAndAnswer: QuestionAndAnswer?
                /// Set the email language to one of the following:
                /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
                public var emailLanguage: String?
                /// * `true`: Send invitation email to panelists.
                /// 
                /// * `false`: Do not send invitation email to panelists.
                public var isPanelistsInvitationEmailNotification: Bool?
                /// Send reminder email to attendees and panelists.
                public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
                /// Send follow-up email to attendees.
                public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
                /// Send follow-up email to absentees.
                public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public var languageInterpretation: LanguageInterpretation?

                /// Determine how participants can join the audio portion of the meeting.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public struct QuestionAndAnswer: Encodable {
                    /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                    /// 
                    /// * `false`: Disable Q&A for webinar.
                    public var enable: Bool?
                    /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
                    /// 
                    /// * `false`: Do not allow anonymous questions.
                    public var allowAnonymousQuestions: Bool?
                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public var answerQuestions: AnswerQuestions?
                    /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
                    /// 
                    /// * `false`: Attendees can not click the thumbs up button on questions.
                    public var attendeesCanUpvote: Bool?
                    /// * `true`: Attendees can answer questions or leave a comment in the question thread.
                    /// 
                    /// * `false`: Attendees can not answer questions or leave a comment in the question thread
                    public var attendeesCanComment: Bool?

                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public enum AnswerQuestions: String, Codable, CaseIterable {
                        case only
                        case all
                    }

                    public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                        self.enable = enable
                        self.allowAnonymousQuestions = allowAnonymousQuestions
                        self.answerQuestions = answerQuestions
                        self.attendeesCanUpvote = attendeesCanUpvote
                        self.attendeesCanComment = attendeesCanComment
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case allowAnonymousQuestions = "allow_anonymous_questions"
                        case answerQuestions = "answer_questions"
                        case attendeesCanUpvote = "attendees_can_upvote"
                        case attendeesCanComment = "attendees_can_comment"
                    }
                }

                /// Send reminder email to attendees and panelists.
                public struct AttendeesAndPanelistsReminderEmailNotification: Encodable {
                    /// * `true`: Send reminder email to attendees and panelists.
                    /// 
                    /// * `false`: Do not send reminder email to attendees and panelists.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to attendees.
                public struct FollowUpAttendeesEmailNotification: Encodable {
                    /// * `true`: Send follow-up email to attendees.
                    /// 
                    /// * `false`: Do not send follow-up email to attendees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to absentees.
                public struct FollowUpAbsenteesEmailNotification: Encodable {
                    /// * `true`: Send follow-up email to absentees.
                    /// 
                    /// * `false`: Do not send follow-up email to absentees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public struct LanguageInterpretation: Encodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
                    public var enable: Bool?
                    /// Information about the webinar's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Encodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, registrantsRestrictNumber: Int? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isPanelistsVideo = isPanelistsVideo
                    self.isPracticeSession = isPracticeSession ?? false
                    self.isHdVideo = isHdVideo ?? false
                    self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
                    self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.enforceLogin = enforceLogin
                    self.enforceLoginDomains = enforceLoginDomains
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.isOnDemand = isOnDemand ?? false
                    self.globalDialInCountries = globalDialInCountries
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.registrantsRestrictNumber = registrantsRestrictNumber
                    self.isPostWebinarSurvey = isPostWebinarSurvey
                    self.surveyURL = surveyURL
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.questionAndAnswer = questionAndAnswer
                    self.emailLanguage = emailLanguage
                    self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
                    self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
                    self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
                    self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
                    self.languageInterpretation = languageInterpretation
                }

                private enum CodingKeys: String, CodingKey {
                    case isHostVideo = "host_video"
                    case isPanelistsVideo = "panelists_video"
                    case isPracticeSession = "practice_session"
                    case isHdVideo = "hd_video"
                    case isHdVideoForAttendees = "hd_video_for_attendees"
                    case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
                    case approvalType = "approval_type"
                    case registrationType = "registration_type"
                    case audio
                    case autoRecording = "auto_recording"
                    case enforceLogin = "enforce_login"
                    case enforceLoginDomains = "enforce_login_domains"
                    case alternativeHosts = "alternative_hosts"
                    case isCloseRegistration = "close_registration"
                    case isShowShareButton = "show_share_button"
                    case allowMultipleDevices = "allow_multiple_devices"
                    case isOnDemand = "on_demand"
                    case globalDialInCountries = "global_dial_in_countries"
                    case contactName = "contact_name"
                    case contactEmail = "contact_email"
                    case registrantsRestrictNumber = "registrants_restrict_number"
                    case isPostWebinarSurvey = "post_webinar_survey"
                    case surveyURL = "survey_url"
                    case isRegistrantsEmailNotification = "registrants_email_notification"
                    case isMeetingAuthentication = "meeting_authentication"
                    case authenticationOption = "authentication_option"
                    case authenticationDomains = "authentication_domains"
                    case questionAndAnswer = "question_and_answer"
                    case emailLanguage = "email_language"
                    case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
                    case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
                    case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
                    case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
                    case languageInterpretation = "language_interpretation"
                }
            }

            public init(topic: String? = nil, type: Int? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil, templateID: String? = nil) {
                self.topic = topic
                self.type = type
                self.startTime = startTime
                self.duration = duration
                self.timezone = timezone
                self.password = password
                self.agenda = agenda
                self.trackingFields = trackingFields
                self.recurrence = recurrence
                self.settings = settings
                self.templateID = templateID
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(topic, forKey: "topic")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(startTime, forKey: "start_time")
                try values.encodeIfPresent(duration, forKey: "duration")
                try values.encodeIfPresent(timezone, forKey: "timezone")
                try values.encodeIfPresent(password, forKey: "password")
                try values.encodeIfPresent(agenda, forKey: "agenda")
                try values.encodeIfPresent(trackingFields, forKey: "tracking_fields")
                try values.encodeIfPresent(recurrence, forKey: "recurrence")
                try values.encodeIfPresent(settings, forKey: "settings")
                try values.encodeIfPresent(templateID, forKey: "template_id")
            }
        }
    }
}

extension Paths {
    public static var webinars: Webinars {
        Webinars(path: "/webinars")
    }

    public struct Webinars {
        /// Path: `/webinars`
        public let path: String
    }
}

extension Paths.Webinars {
    public func webinarID(_ webinarID: String) -> WithWebinarID {
        WithWebinarID(path: "\(path)/\(webinarID)")
    }

    public struct WithWebinarID {
        /// Path: `/webinars/{webinarId}`
        public let path: String

        /// Get a webinar
        ///
        /// Zoom users with a [Webinar Plan](https://zoom.us/webinar) have access to creating and managing Webinars. Webinar allows a host to broadcast a Zoom meeting to up to 10,000 attendees.<br>Use this API to get details of a scheduled webinar.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>**Prerequisites:**
        /// * Pro or higher plan with a Webinar Add-on.
        public func get(occurrenceID: String? = nil, isShowPreviousOccurrences: Bool? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(occurrenceID, isShowPreviousOccurrences))
        }

        public struct GetResponse: Decodable {
            /// Webinar agenda.
            public var agenda: String?
            /// Create time.
            public var createdAt: Date?
            /// Webinar duration.
            public var duration: Int?
            /// Email address of the meeting host.
            public var hostEmail: String?
            /// ID of the user set as host of webinar.
            public var hostID: String?
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// URL to join the Webinar. This URL should only be shared with the users who should be invited to the Webinar.
            public var joinURL: String?
            /// Array of occurrence objects.
            public var occurrences: [Occurrence]?
            /// Webinar passcode. 
            /// 
            /// If "Require a passcode when scheduling new meetings" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
            /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API.
            public var password: String?
            /// Recurrence Webinar
            ///
            /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
            public var recurrence: Recurrence?
            /// Webinar settings.
            public var settings: Settings?
            /// Webinar start time in GMT/UTC.
            public var startTime: Date?
            /// <br><aside>The <code>start_url</code> of a Webinar is a URL using which a host or an alternative host can start the Webinar. This URL should only be used by the host of the meeting and should not be shared with anyone other than the host of the Webinar. 
            /// 
            /// The expiration time for the <code>start_url</code> field listed in the response of [Create a Webinar API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinarcreate) is two hours for all regular users. 
            /// 	
            /// For users created using the <code>custCreate</code> option via the [Create Users](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usercreate) API, the expiration time of the <code>start_url</code> field is 90 days.
            /// 	
            /// For security reasons, to retrieve the latest value for the <code>start_url</code> field programmatically (after expiry), you must call the [Retrieve a Webinar API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinar) and refer to the value of the <code>start_url</code> field in the response.</aside><br><br><br>
            public var startURL: String?
            /// Time zone to format start_time.
            public var timezone: String?
            /// Webinar topic.
            public var topic: String?
            /// Tracking fields
            public var trackingFields: [TrackingField]?
            /// Webinar Types:<br>`5` - Webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
            public var type: Int?
            /// Unique Webinar ID. Each Webinar instance will generate its own Webinar UUID (i.e., after a Webinar ends, a new UUID will be generated for the next instance of the Webinar). You can retrieve a list of UUIDs from past Webinar instances using [this API](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/pastwebinars). Please double encode your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
            public var uuid: String?

            /// Occurrence object. This object is only returned for Recurring Webinars.
            public struct Occurrence: Decodable {
                /// Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
                public var occurrenceID: String?
                /// Start time.
                public var startTime: Date?
                /// Duration.
                public var duration: Int?
                /// Occurrence status.
                public var status: String?

                public init(occurrenceID: String? = nil, startTime: Date? = nil, duration: Int? = nil, status: String? = nil) {
                    self.occurrenceID = occurrenceID
                    self.startTime = startTime
                    self.duration = duration
                    self.status = status
                }

                private enum CodingKeys: String, CodingKey {
                    case occurrenceID = "occurrence_id"
                    case startTime = "start_time"
                    case duration
                    case status
                }
            }

            /// Recurrence Webinar
            ///
            /// Recurrence object. Use this object only for a webinar of type `9` i.e., a recurring webinar with fixed time.
            public struct Recurrence: Decodable {
                /// Recurrence webinar types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the webinar should recur. For instance, if you would like to schedule a Webinar that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily webinar, the maximum interval you can set is `90` days. For a weekly webinar, the maximum interval that you can set is `12` weeks. For a monthly webinar, the maximum interval that you can set is `3` months.
                public var repeatInterval: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `2` to state which day(s) of the week the webinar should repeat. <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the Webinar should recur on Sunday, provide `"1"` as the value of this field.  <br><br> **Note:** If you would like the webinar to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the Webinar should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                /// <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: String?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state which day in a month, the webinar should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the webinar to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the webinar to recur once every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state the week of the month when the webinar should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the webinar should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring webinar of type** `3` to state a specific day in a week when the monthly webinar should recur. To use this field, you must also use the `monthly_week` field. <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the webinar will recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select a date when the webinar will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: String? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            /// Webinar settings.
            public struct Settings: Decodable {
                /// Start video when host joins webinar.
                public var isHostVideo: Bool?
                /// Start video when panelists join webinar.
                public var isPanelistsVideo: Bool?
                /// Enable practice session.
                public var isPracticeSession: Bool
                /// Default to HD video.
                public var isHdVideo: Bool
                /// Whether HD video for attendees is enabled. This value defaults to `false`.
                public var isHdVideoForAttendees: Bool
                /// Whether to always send 1080p video to attendees. This value defaults to `false`.
                public var isSend1080pVideoToAttendees: Bool
                /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                public var approvalType: Int?
                /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
                public var registrationType: Int?
                /// Determine how participants can join the audio portion of the webinar.
                public var audio: Audio?
                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public var autoRecording: AutoRecording?
                /// Only signed in users can join this meeting.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
                public var enforceLogin: Bool?
                /// Only signed in users with specified domains can join meetings.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
                public var enforceLoginDomains: String?
                /// Alternative host emails or IDs. Multiple values separated by comma.
                public var alternativeHosts: String?
                /// Close registration after event date.
                public var isCloseRegistration: Bool?
                /// Show social share buttons on the registration page.
                public var isShowShareButton: Bool?
                /// Allow attendees to join from multiple devices.
                public var allowMultipleDevices: Bool?
                /// Make the webinar on-demand
                public var isOnDemand: Bool
                /// List of global dial-in countries
                public var globalDialInCountries: [String]?
                /// Contact name for registration
                public var contactName: String?
                /// Contact email for registration
                public var contactEmail: String?
                /// Send confirmation email to registrants
                public var isRegistrantsConfirmationEmail: Bool?
                /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
                public var registrantsRestrictNumber: Int?
                /// Send notification email to registrants when the host updates a webinar.
                public var isNotifyRegistrants: Bool?
                /// Zoom will open a survey page in attendees' browsers after leaving the webinar
                public var isPostWebinarSurvey: Bool?
                /// Survey url for post webinar survey
                public var surveyURL: String?
                /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
                public var isRegistrantsEmailNotification: Bool?
                /// `true`- Only authenticated users can join Webinar.
                public var isMeetingAuthentication: Bool?
                /// Webinar authentication option id.
                public var authenticationOption: String?
                /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
                public var authenticationDomains: String?
                /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
                public var authenticationName: String?
                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public var questionAndAnswer: QuestionAndAnswer?
                /// Set the email language to one of the following:
                /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
                public var emailLanguage: String?
                /// * `true`: Send invitation email to panelists.
                /// 
                /// * `false`: Do not send invitation email to panelists.
                public var isPanelistsInvitationEmailNotification: Bool?
                /// Send reminder email to attendees and panelists.
                public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
                /// Send follow-up email to attendees.
                public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
                /// Send follow-up email to absentees.
                public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public var languageInterpretation: LanguageInterpretation?

                /// Determine how participants can join the audio portion of the webinar.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public struct QuestionAndAnswer: Decodable {
                    /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                    /// 
                    /// * `false`: Disable Q&A for webinar.
                    public var enable: Bool?
                    /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
                    /// 
                    /// * `false`: Do not allow anonymous questions.
                    public var allowAnonymousQuestions: Bool?
                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public var answerQuestions: AnswerQuestions?
                    /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
                    /// 
                    /// * `false`: Attendees can not click the thumbs up button on questions.
                    public var attendeesCanUpvote: Bool?
                    /// * `true`: Attendees can answer questions or leave a comment in the question thread.
                    /// 
                    /// * `false`: Attendees can not answer questions or leave a comment in the question thread
                    public var attendeesCanComment: Bool?

                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public enum AnswerQuestions: String, Codable, CaseIterable {
                        case only
                        case all
                    }

                    public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                        self.enable = enable
                        self.allowAnonymousQuestions = allowAnonymousQuestions
                        self.answerQuestions = answerQuestions
                        self.attendeesCanUpvote = attendeesCanUpvote
                        self.attendeesCanComment = attendeesCanComment
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case allowAnonymousQuestions = "allow_anonymous_questions"
                        case answerQuestions = "answer_questions"
                        case attendeesCanUpvote = "attendees_can_upvote"
                        case attendeesCanComment = "attendees_can_comment"
                    }
                }

                /// Send reminder email to attendees and panelists.
                public struct AttendeesAndPanelistsReminderEmailNotification: Decodable {
                    /// * `true`: Send reminder email to attendees and panelists.
                    /// 
                    /// * `false`: Do not send reminder email to attendees and panelists.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to attendees.
                public struct FollowUpAttendeesEmailNotification: Decodable {
                    /// * `true`: Send follow-up email to attendees.
                    /// 
                    /// * `false`: Do not send follow-up email to attendees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to absentees.
                public struct FollowUpAbsenteesEmailNotification: Decodable {
                    /// * `true`: Send follow-up email to absentees.
                    /// 
                    /// * `false`: Do not send follow-up email to absentees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public struct LanguageInterpretation: Decodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
                    public var enable: Bool?
                    /// Information about the webinar's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Decodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isPanelistsVideo = isPanelistsVideo
                    self.isPracticeSession = isPracticeSession ?? false
                    self.isHdVideo = isHdVideo ?? false
                    self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
                    self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.enforceLogin = enforceLogin
                    self.enforceLoginDomains = enforceLoginDomains
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.isOnDemand = isOnDemand ?? false
                    self.globalDialInCountries = globalDialInCountries
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                    self.registrantsRestrictNumber = registrantsRestrictNumber
                    self.isNotifyRegistrants = isNotifyRegistrants
                    self.isPostWebinarSurvey = isPostWebinarSurvey
                    self.surveyURL = surveyURL
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.authenticationName = authenticationName
                    self.questionAndAnswer = questionAndAnswer
                    self.emailLanguage = emailLanguage
                    self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
                    self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
                    self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
                    self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
                    self.languageInterpretation = languageInterpretation
                }

                private enum CodingKeys: String, CodingKey {
                    case isHostVideo = "host_video"
                    case isPanelistsVideo = "panelists_video"
                    case isPracticeSession = "practice_session"
                    case isHdVideo = "hd_video"
                    case isHdVideoForAttendees = "hd_video_for_attendees"
                    case isSend1080pVideoToAttendees = "send_1080p_video_to_attendees"
                    case approvalType = "approval_type"
                    case registrationType = "registration_type"
                    case audio
                    case autoRecording = "auto_recording"
                    case enforceLogin = "enforce_login"
                    case enforceLoginDomains = "enforce_login_domains"
                    case alternativeHosts = "alternative_hosts"
                    case isCloseRegistration = "close_registration"
                    case isShowShareButton = "show_share_button"
                    case allowMultipleDevices = "allow_multiple_devices"
                    case isOnDemand = "on_demand"
                    case globalDialInCountries = "global_dial_in_countries"
                    case contactName = "contact_name"
                    case contactEmail = "contact_email"
                    case isRegistrantsConfirmationEmail = "registrants_confirmation_email"
                    case registrantsRestrictNumber = "registrants_restrict_number"
                    case isNotifyRegistrants = "notify_registrants"
                    case isPostWebinarSurvey = "post_webinar_survey"
                    case surveyURL = "survey_url"
                    case isRegistrantsEmailNotification = "registrants_email_notification"
                    case isMeetingAuthentication = "meeting_authentication"
                    case authenticationOption = "authentication_option"
                    case authenticationDomains = "authentication_domains"
                    case authenticationName = "authentication_name"
                    case questionAndAnswer = "question_and_answer"
                    case emailLanguage = "email_language"
                    case isPanelistsInvitationEmailNotification = "panelists_invitation_email_notification"
                    case attendeesAndPanelistsReminderEmailNotification = "attendees_and_panelists_reminder_email_notification"
                    case followUpAttendeesEmailNotification = "follow_up_attendees_email_notification"
                    case followUpAbsenteesEmailNotification = "follow_up_absentees_email_notification"
                    case languageInterpretation = "language_interpretation"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isHostVideo = try values.decodeIfPresent(Bool.self, forKey: .isHostVideo)
                    self.isPanelistsVideo = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsVideo)
                    self.isPracticeSession = try values.decodeIfPresent(Bool.self, forKey: .isPracticeSession) ?? false
                    self.isHdVideo = try values.decodeIfPresent(Bool.self, forKey: .isHdVideo) ?? false
                    self.isHdVideoForAttendees = try values.decodeIfPresent(Bool.self, forKey: .isHdVideoForAttendees) ?? false
                    self.isSend1080pVideoToAttendees = try values.decodeIfPresent(Bool.self, forKey: .isSend1080pVideoToAttendees) ?? false
                    self.approvalType = try values.decodeIfPresent(Int.self, forKey: .approvalType)
                    self.registrationType = try values.decodeIfPresent(Int.self, forKey: .registrationType)
                    self.audio = try values.decodeIfPresent(Audio.self, forKey: .audio)
                    self.autoRecording = try values.decodeIfPresent(AutoRecording.self, forKey: .autoRecording)
                    self.enforceLogin = try values.decodeIfPresent(Bool.self, forKey: .enforceLogin)
                    self.enforceLoginDomains = try values.decodeIfPresent(String.self, forKey: .enforceLoginDomains)
                    self.alternativeHosts = try values.decodeIfPresent(String.self, forKey: .alternativeHosts)
                    self.isCloseRegistration = try values.decodeIfPresent(Bool.self, forKey: .isCloseRegistration)
                    self.isShowShareButton = try values.decodeIfPresent(Bool.self, forKey: .isShowShareButton)
                    self.allowMultipleDevices = try values.decodeIfPresent(Bool.self, forKey: .allowMultipleDevices)
                    self.isOnDemand = try values.decodeIfPresent(Bool.self, forKey: .isOnDemand) ?? false
                    self.globalDialInCountries = try values.decodeIfPresent([String].self, forKey: .globalDialInCountries)
                    self.contactName = try values.decodeIfPresent(String.self, forKey: .contactName)
                    self.contactEmail = try values.decodeIfPresent(String.self, forKey: .contactEmail)
                    self.isRegistrantsConfirmationEmail = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsConfirmationEmail)
                    self.registrantsRestrictNumber = try values.decodeIfPresent(Int.self, forKey: .registrantsRestrictNumber)
                    self.isNotifyRegistrants = try values.decodeIfPresent(Bool.self, forKey: .isNotifyRegistrants)
                    self.isPostWebinarSurvey = try values.decodeIfPresent(Bool.self, forKey: .isPostWebinarSurvey)
                    self.surveyURL = try values.decodeIfPresent(String.self, forKey: .surveyURL)
                    self.isRegistrantsEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isRegistrantsEmailNotification)
                    self.isMeetingAuthentication = try values.decodeIfPresent(Bool.self, forKey: .isMeetingAuthentication)
                    self.authenticationOption = try values.decodeIfPresent(String.self, forKey: .authenticationOption)
                    self.authenticationDomains = try values.decodeIfPresent(String.self, forKey: .authenticationDomains)
                    self.authenticationName = try values.decodeIfPresent(String.self, forKey: .authenticationName)
                    self.questionAndAnswer = try values.decodeIfPresent(QuestionAndAnswer.self, forKey: .questionAndAnswer)
                    self.emailLanguage = try values.decodeIfPresent(String.self, forKey: .emailLanguage)
                    self.isPanelistsInvitationEmailNotification = try values.decodeIfPresent(Bool.self, forKey: .isPanelistsInvitationEmailNotification)
                    self.attendeesAndPanelistsReminderEmailNotification = try values.decodeIfPresent(AttendeesAndPanelistsReminderEmailNotification.self, forKey: .attendeesAndPanelistsReminderEmailNotification)
                    self.followUpAttendeesEmailNotification = try values.decodeIfPresent(FollowUpAttendeesEmailNotification.self, forKey: .followUpAttendeesEmailNotification)
                    self.followUpAbsenteesEmailNotification = try values.decodeIfPresent(FollowUpAbsenteesEmailNotification.self, forKey: .followUpAbsenteesEmailNotification)
                    self.languageInterpretation = try values.decodeIfPresent(LanguageInterpretation.self, forKey: .languageInterpretation)
                }
            }

            public struct TrackingField: Decodable {
                /// Tracking fields type
                public var field: String?
                /// Tracking fields value
                public var value: String?

                public init(field: String? = nil, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            public init(agenda: String? = nil, createdAt: Date? = nil, duration: Int? = nil, hostEmail: String? = nil, hostID: String? = nil, id: Int? = nil, joinURL: String? = nil, occurrences: [Occurrence]? = nil, password: String? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil, startTime: Date? = nil, startURL: String? = nil, timezone: String? = nil, topic: String? = nil, trackingFields: [TrackingField]? = nil, type: Int? = nil, uuid: String? = nil) {
                self.agenda = agenda
                self.createdAt = createdAt
                self.duration = duration
                self.hostEmail = hostEmail
                self.hostID = hostID
                self.id = id
                self.joinURL = joinURL
                self.occurrences = occurrences
                self.password = password
                self.recurrence = recurrence
                self.settings = settings
                self.startTime = startTime
                self.startURL = startURL
                self.timezone = timezone
                self.topic = topic
                self.trackingFields = trackingFields
                self.type = type
                self.uuid = uuid
            }

            private enum CodingKeys: String, CodingKey {
                case agenda
                case createdAt = "created_at"
                case duration
                case hostEmail = "host_email"
                case hostID = "host_id"
                case id
                case joinURL = "join_url"
                case occurrences
                case password
                case recurrence
                case settings
                case startTime = "start_time"
                case startURL = "start_url"
                case timezone
                case topic
                case trackingFields = "tracking_fields"
                case type
                case uuid
            }
        }

        private func makeGetQuery(_ occurrenceID: String?, _ isShowPreviousOccurrences: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            encoder.encode(isShowPreviousOccurrences, forKey: "show_previous_occurrences")
            return encoder.items
        }

        /// Update a webinar
        ///
        /// Use this API to make updates to a scheduled webinar. 
        /// 
        /// **Scopes:** `webinar:write:admin`, `webinar:write` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// * This API has a daily rate limit of **100 requests per day**. The rate limit is applied to the `userId` of the **webinar host** used to make the request. 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan with a Webinar add-on.
        public func patch(occurrenceID: String? = nil, _ body: PatchRequest) -> Request<Void> {
            .patch(path, query: makePatchQuery(occurrenceID), body: body)
        }

        private func makePatchQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }

        /// Webinar object
        public struct PatchRequest: Encodable {
            /// Webinar topic.
            public var topic: String?
            /// Webinar Types:<br>`5` - webinar.<br>`6` - Recurring webinar with no fixed time.<br>`9` - Recurring webinar with a fixed time.
            public var type: Int?
            /// Webinar start time, in the format "yyyy-MM-dd'T'HH:mm:ss'Z'." Should be in GMT time. In the format "yyyy-MM-dd'T'HH:mm:ss." This should be in local time and the timezone should be specified. Only used for scheduled webinars and recurring webinars with a fixed time.
            public var startTime: Date?
            /// Webinar duration (minutes). Used for scheduled webinar only.
            public var duration: Int?
            /// Time zone to format start_time. For example, "America/Los_Angeles". For scheduled meetings only. Please reference our [time zone](#timezones) list for supported time zones and their formats.
            public var timezone: String?
            /// [Webinar passcode](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords). By default, passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ * !] and can have a maximum of 10 characters.
            /// 
            /// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements. <br><br>If the requirements are enabled, you can view those requirements by calling either the [Get User Settings API](https://marketplace.zoom.us/docs/api-reference/zoom-api/users/usersettings) or the  [Get Account Settings](https://marketplace.zoom.us/docs/api-reference/zoom-api/accounts/accountsettings) API. 
            /// 
            /// If "**Require a passcode when scheduling new meetings**" setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the passcode field will be autogenerated for the Webinar in the response even if it is not provided in the API request. <br><br>
            public var password: String?
            /// Webinar description.
            public var agenda: String?
            /// Tracking fields
            public var trackingFields: [TrackingField]?
            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public var recurrence: Recurrence?
            public var settings: Settings?

            public struct TrackingField: Encodable {
                /// Tracking fields type
                public var field: String?
                /// Tracking fields value
                public var value: String?

                public init(field: String? = nil, value: String? = nil) {
                    self.field = field
                    self.value = value
                }
            }

            /// Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
            public struct Recurrence: Encodable {
                /// Recurrence meeting types:<br>`1` - Daily.<br>`2` - Weekly.<br>`3` - Monthly.
                public var type: Int
                /// Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`. 
                /// 
                /// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
                public var repeatInterval: Int?
                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var weeklyDays: WeeklyDays?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
                /// 
                /// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
                public var monthlyDay: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.** <br>`-1` - Last week of the month.<br>`1` - First week of the month.<br>`2` - Second week of the month.<br>`3` - Third week of the month.<br>`4` - Fourth week of the month.
                public var monthlyWeek: Int?
                /// Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field. 
                /// 
                /// <br>`1` - Sunday.<br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` - Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public var monthlyWeekDay: Int?
                /// Select how many times the meeting should recur before it is canceled. (Cannot be used with "end_date_time".)
                public var endTimes: Int?
                /// Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with "end_times".)
                public var endDateTime: Date?

                /// This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat. <br> <br> The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `"1"` as the value of this field.<br><br> **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `"1,3"` as the value of this field.
                /// 
                ///  <br>`1`  - Sunday. <br>`2` - Monday.<br>`3` - Tuesday.<br>`4` -  Wednesday.<br>`5` -  Thursday.<br>`6` - Friday.<br>`7` - Saturday.
                public enum WeeklyDays: String, Codable, CaseIterable {
                    case _1 = "1"
                    case _2 = "2"
                    case _3 = "3"
                    case _4 = "4"
                    case _5 = "5"
                    case _6 = "6"
                    case _7 = "7"
                }

                public init(type: Int, repeatInterval: Int? = nil, weeklyDays: WeeklyDays? = nil, monthlyDay: Int? = nil, monthlyWeek: Int? = nil, monthlyWeekDay: Int? = nil, endTimes: Int? = nil, endDateTime: Date? = nil) {
                    self.type = type
                    self.repeatInterval = repeatInterval
                    self.weeklyDays = weeklyDays
                    self.monthlyDay = monthlyDay
                    self.monthlyWeek = monthlyWeek
                    self.monthlyWeekDay = monthlyWeekDay
                    self.endTimes = endTimes
                    self.endDateTime = endDateTime
                }

                private enum CodingKeys: String, CodingKey {
                    case type
                    case repeatInterval = "repeat_interval"
                    case weeklyDays = "weekly_days"
                    case monthlyDay = "monthly_day"
                    case monthlyWeek = "monthly_week"
                    case monthlyWeekDay = "monthly_week_day"
                    case endTimes = "end_times"
                    case endDateTime = "end_date_time"
                }
            }

            public struct Settings: Encodable {
                /// Start video when host joins webinar.
                public var isHostVideo: Bool?
                /// Start video when panelists join webinar.
                public var isPanelistsVideo: Bool?
                /// Enable practice session.
                public var isPracticeSession: Bool
                /// Default to HD video.
                public var isHdVideo: Bool
                /// Whether HD video for attendees is enabled. This value defaults to `false`.
                public var isHdVideoForAttendees: Bool
                /// Whether to always send 1080p video to attendees. This value defaults to `false`.
                public var isSend1080pVideoToAttendees: Bool
                /// `0` - Automatically approve.<br>`1` - Manually approve.<br>`2` - No registration required.
                public var approvalType: Int?
                /// Registration types. Only used for recurring webinars with a fixed time.<br>`1` - Attendees register once and can attend any of the webinar sessions.<br>`2` - Attendees need to register for each session in order to attend.<br>`3` - Attendees register once and can choose one or more sessions to attend.
                public var registrationType: Int?
                /// Determine how participants can join the audio portion of the webinar.
                public var audio: Audio?
                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public var autoRecording: AutoRecording?
                /// Only signed in users can join this meeting.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
                public var enforceLogin: Bool?
                /// Only signed in users with specified domains can join meetings.
                /// 
                /// **This field is deprecated and will not be supported in the future.**  <br><br>As an alternative, use the "meeting_authentication", "authentication_option" and "authentication_domains" fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the Webinar.
                public var enforceLoginDomains: String?
                /// Alternative host emails or IDs. Multiple values separated by comma.
                public var alternativeHosts: String?
                /// Close registration after event date.
                public var isCloseRegistration: Bool?
                /// Show social share buttons on the registration page.
                public var isShowShareButton: Bool?
                /// Allow attendees to join from multiple devices.
                public var allowMultipleDevices: Bool?
                /// Make the webinar on-demand
                public var isOnDemand: Bool
                /// List of global dial-in countries
                public var globalDialInCountries: [String]?
                /// Contact name for registration
                public var contactName: String?
                /// Contact email for registration
                public var contactEmail: String?
                /// Send confirmation email to registrants
                public var isRegistrantsConfirmationEmail: Bool?
                /// Restrict number of registrants for a webinar. By default, it is set to `0`. A `0` value means that the restriction option is disabled. Provide a number higher than 0 to restrict the webinar registrants by the that number.
                public var registrantsRestrictNumber: Int?
                /// Send notification email to registrants when the host updates a webinar.
                public var isNotifyRegistrants: Bool?
                /// Zoom will open a survey page in attendees' browsers after leaving the webinar
                public var isPostWebinarSurvey: Bool?
                /// Survey url for post webinar survey
                public var surveyURL: String?
                /// Send email notifications to registrants about approval, cancellation, denial of the registration. The value of this field must be set to true in order to use the `registrants_confirmation_email` field.
                public var isRegistrantsEmailNotification: Bool?
                /// `true`- Only authenticated users can join Webinar.
                public var isMeetingAuthentication: Bool?
                /// Webinar authentication option id.
                public var authenticationOption: String?
                /// If user has configured ["Sign Into Zoom with Specified Domains"](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
                public var authenticationDomains: String?
                /// Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
                public var authenticationName: String?
                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public var questionAndAnswer: QuestionAndAnswer?
                /// Set the email language to one of the following:
                /// `en-US`,`de-DE`,`es-ES`,`fr-FR`,`jp-JP`,`pt-PT`,`ru-RU`,`zh-CN`, `zh-TW`, `ko-KO`, `it-IT`, `vi-VN`.
                public var emailLanguage: String?
                /// * `true`: Send invitation email to panelists.
                /// 
                /// * `false`: Do not send invitation email to panelists.
                public var isPanelistsInvitationEmailNotification: Bool?
                /// Send reminder email to attendees and panelists.
                public var attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification?
                /// Send follow-up email to attendees.
                public var followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification?
                /// Send follow-up email to absentees.
                public var followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification?
                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public var languageInterpretation: LanguageInterpretation?

                /// Determine how participants can join the audio portion of the webinar.
                public enum Audio: String, Codable, CaseIterable {
                    case both
                    case telephony
                    case voip
                }

                /// Automatic recording:<br>`local` - Record on local.<br>`cloud` -  Record on cloud.<br>`none` - Disabled.
                public enum AutoRecording: String, Codable, CaseIterable {
                    case local
                    case cloud
                    case `none`
                }

                /// [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                public struct QuestionAndAnswer: Encodable {
                    /// * `true`: Enable [Q&A](https://support.zoom.us/hc/en-us/articles/203686015-Using-Q-A-as-the-webinar-host#:~:text=Overview,and%20upvote%20each%20other's%20questions.) for webinar.
                    /// 
                    /// * `false`: Disable Q&A for webinar.
                    public var enable: Bool?
                    /// * `true`: Allow participants to send questions without providing their name to the host, co-host, and panelists..
                    /// 
                    /// * `false`: Do not allow anonymous questions.
                    public var allowAnonymousQuestions: Bool?
                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public var answerQuestions: AnswerQuestions?
                    /// * `true`: Attendees can click the thumbs up button to bring popular questions to the top of the Q&A window.
                    /// 
                    /// * `false`: Attendees can not click the thumbs up button on questions.
                    public var attendeesCanUpvote: Bool?
                    /// * `true`: Attendees can answer questions or leave a comment in the question thread.
                    /// 
                    /// * `false`: Attendees can not answer questions or leave a comment in the question thread
                    public var attendeesCanComment: Bool?

                    /// Indicate whether you want attendees to be able to view answered questions only or view all questions.
                    /// 
                    /// * `only`: Attendees are able to view answered questions only.
                    /// 
                    /// *  `all`: Attendees are able to view all questions submitted in the Q&A.
                    public enum AnswerQuestions: String, Codable, CaseIterable {
                        case only
                        case all
                    }

                    public init(enable: Bool? = nil, allowAnonymousQuestions: Bool? = nil, answerQuestions: AnswerQuestions? = nil, attendeesCanUpvote: Bool? = nil, attendeesCanComment: Bool? = nil) {
                        self.enable = enable
                        self.allowAnonymousQuestions = allowAnonymousQuestions
                        self.answerQuestions = answerQuestions
                        self.attendeesCanUpvote = attendeesCanUpvote
                        self.attendeesCanComment = attendeesCanComment
                    }

                    private enum CodingKeys: String, CodingKey {
                        case enable
                        case allowAnonymousQuestions = "allow_anonymous_questions"
                        case answerQuestions = "answer_questions"
                        case attendeesCanUpvote = "attendees_can_upvote"
                        case attendeesCanComment = "attendees_can_comment"
                    }
                }

                /// Send reminder email to attendees and panelists.
                public struct AttendeesAndPanelistsReminderEmailNotification: Encodable {
                    /// * `true`: Send reminder email to attendees and panelists.
                    /// 
                    /// * `false`: Do not send reminder email to attendees and panelists.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 hour before webinar.<br>`2` - Send 1 day before webinar.<br>`3` - Send 1 hour and 1 day before webinar.<br>`4` - Send 1 week before webinar.<br>`5` - Send 1 hour and 1 week before webinar.<br>`6` - Send 1 day and 1 week before webinar.<br>`7` - Send 1 hour, 1 day and 1 week before webinar.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to attendees.
                public struct FollowUpAttendeesEmailNotification: Encodable {
                    /// * `true`: Send follow-up email to attendees.
                    /// 
                    /// * `false`: Do not send follow-up email to attendees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 day after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// Send follow-up email to absentees.
                public struct FollowUpAbsenteesEmailNotification: Encodable {
                    /// * `true`: Send follow-up email to absentees.
                    /// 
                    /// * `false`: Do not send follow-up email to absentees.
                    public var enable: Bool?
                    /// `0` - No plan.<br>`1` - Send 1 days after the scheduled end date.<br>`2` - Send 2 days after the scheduled end date.<br>`3` - Send 3 days after the scheduled end date.<br>`4` - Send 4 days after the scheduled end date.<br>`5` - Send 5 days after the scheduled end date.<br>`6` - Send 6 days after the scheduled end date.<br>`7` - Send 7 days after the scheduled end date.
                    public var type: Int?

                    public init(enable: Bool? = nil, type: Int? = nil) {
                        self.enable = enable
                        self.type = type
                    }
                }

                /// The webinar's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). 
                /// 
                /// **Note:** This feature is only available for certain Webinar add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the webinar.
                public struct LanguageInterpretation: Encodable {
                    /// Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the webinar.
                    public var enable: Bool?
                    /// Information about the webinar's language interpreters.
                    public var interpreters: [Interpreter]?

                    public struct Interpreter: Encodable {
                        /// The interpreter's email address.
                        public var email: String?
                        /// A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). 
                        /// 
                        /// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
                        public var languages: String?

                        public init(email: String? = nil, languages: String? = nil) {
                            self.email = email
                            self.languages = languages
                        }
                    }

                    public init(enable: Bool? = nil, interpreters: [Interpreter]? = nil) {
                        self.enable = enable
                        self.interpreters = interpreters
                    }
                }

                public init(isHostVideo: Bool? = nil, isPanelistsVideo: Bool? = nil, isPracticeSession: Bool? = nil, isHdVideo: Bool? = nil, isHdVideoForAttendees: Bool? = nil, isSend1080pVideoToAttendees: Bool? = nil, approvalType: Int? = nil, registrationType: Int? = nil, audio: Audio? = nil, autoRecording: AutoRecording? = nil, enforceLogin: Bool? = nil, enforceLoginDomains: String? = nil, alternativeHosts: String? = nil, isCloseRegistration: Bool? = nil, isShowShareButton: Bool? = nil, allowMultipleDevices: Bool? = nil, isOnDemand: Bool? = nil, globalDialInCountries: [String]? = nil, contactName: String? = nil, contactEmail: String? = nil, isRegistrantsConfirmationEmail: Bool? = nil, registrantsRestrictNumber: Int? = nil, isNotifyRegistrants: Bool? = nil, isPostWebinarSurvey: Bool? = nil, surveyURL: String? = nil, isRegistrantsEmailNotification: Bool? = nil, isMeetingAuthentication: Bool? = nil, authenticationOption: String? = nil, authenticationDomains: String? = nil, authenticationName: String? = nil, questionAndAnswer: QuestionAndAnswer? = nil, emailLanguage: String? = nil, isPanelistsInvitationEmailNotification: Bool? = nil, attendeesAndPanelistsReminderEmailNotification: AttendeesAndPanelistsReminderEmailNotification? = nil, followUpAttendeesEmailNotification: FollowUpAttendeesEmailNotification? = nil, followUpAbsenteesEmailNotification: FollowUpAbsenteesEmailNotification? = nil, languageInterpretation: LanguageInterpretation? = nil) {
                    self.isHostVideo = isHostVideo
                    self.isPanelistsVideo = isPanelistsVideo
                    self.isPracticeSession = isPracticeSession ?? false
                    self.isHdVideo = isHdVideo ?? false
                    self.isHdVideoForAttendees = isHdVideoForAttendees ?? false
                    self.isSend1080pVideoToAttendees = isSend1080pVideoToAttendees ?? false
                    self.approvalType = approvalType
                    self.registrationType = registrationType
                    self.audio = audio
                    self.autoRecording = autoRecording
                    self.enforceLogin = enforceLogin
                    self.enforceLoginDomains = enforceLoginDomains
                    self.alternativeHosts = alternativeHosts
                    self.isCloseRegistration = isCloseRegistration
                    self.isShowShareButton = isShowShareButton
                    self.allowMultipleDevices = allowMultipleDevices
                    self.isOnDemand = isOnDemand ?? false
                    self.globalDialInCountries = globalDialInCountries
                    self.contactName = contactName
                    self.contactEmail = contactEmail
                    self.isRegistrantsConfirmationEmail = isRegistrantsConfirmationEmail
                    self.registrantsRestrictNumber = registrantsRestrictNumber
                    self.isNotifyRegistrants = isNotifyRegistrants
                    self.isPostWebinarSurvey = isPostWebinarSurvey
                    self.surveyURL = surveyURL
                    self.isRegistrantsEmailNotification = isRegistrantsEmailNotification
                    self.isMeetingAuthentication = isMeetingAuthentication
                    self.authenticationOption = authenticationOption
                    self.authenticationDomains = authenticationDomains
                    self.authenticationName = authenticationName
                    self.questionAndAnswer = questionAndAnswer
                    self.emailLanguage = emailLanguage
                    self.isPanelistsInvitationEmailNotification = isPanelistsInvitationEmailNotification
                    self.attendeesAndPanelistsReminderEmailNotification = attendeesAndPanelistsReminderEmailNotification
                    self.followUpAttendeesEmailNotification = followUpAttendeesEmailNotification
                    self.followUpAbsenteesEmailNotification = followUpAbsenteesEmailNotification
                    self.languageInterpretation = languageInterpretation
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(isHostVideo, forKey: "host_video")
                    try values.encodeIfPresent(isPanelistsVideo, forKey: "panelists_video")
                    try values.encodeIfPresent(isPracticeSession, forKey: "practice_session")
                    try values.encodeIfPresent(isHdVideo, forKey: "hd_video")
                    try values.encodeIfPresent(isHdVideoForAttendees, forKey: "hd_video_for_attendees")
                    try values.encodeIfPresent(isSend1080pVideoToAttendees, forKey: "send_1080p_video_to_attendees")
                    try values.encodeIfPresent(approvalType, forKey: "approval_type")
                    try values.encodeIfPresent(registrationType, forKey: "registration_type")
                    try values.encodeIfPresent(audio, forKey: "audio")
                    try values.encodeIfPresent(autoRecording, forKey: "auto_recording")
                    try values.encodeIfPresent(enforceLogin, forKey: "enforce_login")
                    try values.encodeIfPresent(enforceLoginDomains, forKey: "enforce_login_domains")
                    try values.encodeIfPresent(alternativeHosts, forKey: "alternative_hosts")
                    try values.encodeIfPresent(isCloseRegistration, forKey: "close_registration")
                    try values.encodeIfPresent(isShowShareButton, forKey: "show_share_button")
                    try values.encodeIfPresent(allowMultipleDevices, forKey: "allow_multiple_devices")
                    try values.encodeIfPresent(isOnDemand, forKey: "on_demand")
                    try values.encodeIfPresent(globalDialInCountries, forKey: "global_dial_in_countries")
                    try values.encodeIfPresent(contactName, forKey: "contact_name")
                    try values.encodeIfPresent(contactEmail, forKey: "contact_email")
                    try values.encodeIfPresent(isRegistrantsConfirmationEmail, forKey: "registrants_confirmation_email")
                    try values.encodeIfPresent(registrantsRestrictNumber, forKey: "registrants_restrict_number")
                    try values.encodeIfPresent(isNotifyRegistrants, forKey: "notify_registrants")
                    try values.encodeIfPresent(isPostWebinarSurvey, forKey: "post_webinar_survey")
                    try values.encodeIfPresent(surveyURL, forKey: "survey_url")
                    try values.encodeIfPresent(isRegistrantsEmailNotification, forKey: "registrants_email_notification")
                    try values.encodeIfPresent(isMeetingAuthentication, forKey: "meeting_authentication")
                    try values.encodeIfPresent(authenticationOption, forKey: "authentication_option")
                    try values.encodeIfPresent(authenticationDomains, forKey: "authentication_domains")
                    try values.encodeIfPresent(authenticationName, forKey: "authentication_name")
                    try values.encodeIfPresent(questionAndAnswer, forKey: "question_and_answer")
                    try values.encodeIfPresent(emailLanguage, forKey: "email_language")
                    try values.encodeIfPresent(isPanelistsInvitationEmailNotification, forKey: "panelists_invitation_email_notification")
                    try values.encodeIfPresent(attendeesAndPanelistsReminderEmailNotification, forKey: "attendees_and_panelists_reminder_email_notification")
                    try values.encodeIfPresent(followUpAttendeesEmailNotification, forKey: "follow_up_attendees_email_notification")
                    try values.encodeIfPresent(followUpAbsenteesEmailNotification, forKey: "follow_up_absentees_email_notification")
                    try values.encodeIfPresent(languageInterpretation, forKey: "language_interpretation")
                }
            }

            public init(topic: String? = nil, type: Int? = nil, startTime: Date? = nil, duration: Int? = nil, timezone: String? = nil, password: String? = nil, agenda: String? = nil, trackingFields: [TrackingField]? = nil, recurrence: Recurrence? = nil, settings: Settings? = nil) {
                self.topic = topic
                self.type = type
                self.startTime = startTime
                self.duration = duration
                self.timezone = timezone
                self.password = password
                self.agenda = agenda
                self.trackingFields = trackingFields
                self.recurrence = recurrence
                self.settings = settings
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(topic, forKey: "topic")
                try values.encodeIfPresent(type, forKey: "type")
                try values.encodeIfPresent(startTime, forKey: "start_time")
                try values.encodeIfPresent(duration, forKey: "duration")
                try values.encodeIfPresent(timezone, forKey: "timezone")
                try values.encodeIfPresent(password, forKey: "password")
                try values.encodeIfPresent(agenda, forKey: "agenda")
                try values.encodeIfPresent(trackingFields, forKey: "tracking_fields")
                try values.encodeIfPresent(recurrence, forKey: "recurrence")
                try values.encodeIfPresent(settings, forKey: "settings")
            }
        }

        /// Delete a webinar
        ///
        /// Delete a Webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan with a Webinar Add-on.
        public func delete(occurrenceID: String? = nil, cancelWebinarReminder: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(occurrenceID, cancelWebinarReminder))
        }

        private func makeDeleteQuery(_ occurrenceID: String?, _ cancelWebinarReminder: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            encoder.encode(cancelWebinarReminder, forKey: "cancel_webinar_reminder")
            return encoder.items
        }
    }
}

extension Paths.PastWebinars.WithWebinarID {
    public var participants: Participants {
        Participants(path: path + "/participants")
    }

    public struct Participants {
        /// Path: `/past_webinars/{webinarId}/participants`
        public let path: String

        /// List webinar participants
        ///
        /// Use this API to list all the participants who attended a webinar hosted in the past. 
        /// 
        /// **Scopes:** `webinar:read:admin`, `webinar:read` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium` 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or higher plan with a Webinar add-on.
        public func get(pageSize: Int? = nil, nextPageToken: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(pageSize, nextPageToken))
        }

        public struct GetResponse: Decodable {
            /// The number of pages returned for this request.
            public var pageCount: Int?
            /// The total number of records returned from a single API call.
            public var pageSize: Int?
            /// The total number of records available across all pages.
            public var totalRecords: Int?
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            public var participants: [Participant]?

            public struct Participant: Decodable {
                /// Unique identifier of the participant.
                public var id: String?
                /// Name of the participant.
                public var name: String?
                /// Email address of the participant.
                public var userEmail: String?

                public init(id: String? = nil, name: String? = nil, userEmail: String? = nil) {
                    self.id = id
                    self.name = name
                    self.userEmail = userEmail
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case name
                    case userEmail = "user_email"
                }
            }

            public init(pageCount: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil, nextPageToken: String? = nil, participants: [Participant]? = nil) {
                self.pageCount = pageCount
                self.pageSize = pageSize
                self.totalRecords = totalRecords
                self.nextPageToken = nextPageToken
                self.participants = participants
            }

            private enum CodingKeys: String, CodingKey {
                case pageCount = "page_count"
                case pageSize = "page_size"
                case totalRecords = "total_records"
                case nextPageToken = "next_page_token"
                case participants
            }
        }

        private func makeGetQuery(_ pageSize: Int?, _ nextPageToken: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(pageSize, forKey: "page_size")
            encoder.encode(nextPageToken, forKey: "next_page_token")
            return encoder.items
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/webinars/{webinarId}/status`
        public let path: String

        /// Update webinar status
        ///
        /// Update a webinar's status. Use this API to end an ongoing webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites:**<br>
        /// * The account must hold a valid [Webinar plan](https://zoom.us/webinar).
        public func put(action: PutRequest.Action? = nil) -> Request<Void> {
            .put(path, body: PutRequest(action: action))
        }

        public struct PutRequest: Encodable {
            public var action: Action?

            public enum Action: String, Codable, CaseIterable {
                case end
            }

            public init(action: Action? = nil) {
                self.action = action
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var panelists: Panelists {
        Panelists(path: path + "/panelists")
    }

    public struct Panelists {
        /// Path: `/webinars/{webinarId}/panelists`
        public let path: String

        /// List panelists
        ///
        /// Panelists in a Webinar can view and send video, screen share, annotate, etc and do much more compared to attendees in a Webinar. 
        /// 
        /// Use this API to list all the panelists of a Webinar.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Webinar Add-on](https://zoom.us/webinar).<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        /// Webinar panelist.
        public struct GetResponse: Decodable {
            /// List of panelist objects.
            public var panelists: [Panelist]?
            /// Total records.
            public var totalRecords: Int?

            public struct Panelist: Decodable {
                /// Panelist's ID.
                public var id: String?
                /// The panelist's full name.
                /// 
                /// **Note:** This value cannot exceed more than 12 Chinese characters.
                public var name: String?
                /// Panelist's email.
                public var email: String?
                /// Join URL.
                public var joinURL: String?

                public init(id: String? = nil, name: String? = nil, email: String? = nil, joinURL: String? = nil) {
                    self.id = id
                    self.name = name
                    self.email = email
                    self.joinURL = joinURL
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: StringCodingKey.self)
                    self.id = try values.decodeIfPresent(String.self, forKey: "id")
                    self.name = try values.decodeIfPresent(String.self, forKey: "name")
                    self.email = try values.decodeIfPresent(String.self, forKey: "email")
                    self.joinURL = try values.decodeIfPresent(String.self, forKey: "join_url")
                }
            }

            public init(panelists: [Panelist]? = nil, totalRecords: Int? = nil) {
                self.panelists = panelists
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case panelists
                case totalRecords = "total_records"
            }
        }

        /// Add panelists
        ///
        /// Panelists in a Webinar can view and send video, screen share, annotate, etc and do much more compared to attendees in a webinar.<br>Use this API to [add panelists](https://support.zoom.us/hc/en-us/articles/115005657826-Inviting-Panelists-to-a-Webinar#h_7550d59e-23f5-4703-9e22-e76bded1ed70) to a scheduled webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// 
        /// 
        /// **Prerequisites:**
        /// * Pro or a higher plan with [Webinar Add-on](https://zoom.us/webinar).<br>
        public func post(panelists: [PostRequest.Panelist]? = nil) -> Request<Void> {
            .post(path, body: PostRequest(panelists: panelists))
        }

        /// Webinar panelist.
        public struct PostRequest: Encodable {
            /// List of panelist objects.
            public var panelists: [Panelist]?

            public struct Panelist: Encodable {
                /// The panelist's full name.
                /// 
                /// **Note:** This value cannot exceed more than 12 Chinese characters.
                public var name: String?
                /// Panelist's email.
                public var email: String?

                public init(name: String? = nil, email: String? = nil) {
                    self.name = name
                    self.email = email
                }

                public func encode(to encoder: Encoder) throws {
                    var values = encoder.container(keyedBy: StringCodingKey.self)
                    try values.encodeIfPresent(name, forKey: "name")
                    try values.encodeIfPresent(email, forKey: "email")
                }
            }

            public init(panelists: [Panelist]? = nil) {
                self.panelists = panelists
            }
        }

        /// Remove panelists
        ///
        /// Remove all the panelists from a Webinar.<br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Webinar Add-on](https://zoom.us/webinar).<br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Webinars.WithWebinarID.Panelists {
    public func panelistID(_ panelistID: Int) -> WithPanelistID {
        WithPanelistID(path: "\(path)/\(panelistID)")
    }

    public struct WithPanelistID {
        /// Path: `/webinars/{webinarId}/panelists/{panelistId}`
        public let path: String

        /// Remove a panelist
        ///
        /// [Remove](https://support.zoom.us/hc/en-us/articles/115005657826-Inviting-Panelists-to-a-Webinar#h_de31f237-a91c-4fb2-912b-ecfba8ec5ffb) a single panelist from a webinar.<br> You can retrieve the `panelistId` by calling **List Panelists API**.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// 
        /// 
        /// **Prerequisites:**<br>
        /// * Pro or a higher plan with [Webinar Add-on](https://zoom.us/webinar).<br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var registrants: Registrants {
        Registrants(path: path + "/registrants")
    }

    public struct Registrants {
        /// Path: `/webinars/{webinarId}/registrants`
        public let path: String

        /// List webinar registrants
        ///
        /// Zoom users with a [Webinar Plan](https://zoom.us/webinar) have access to creating and managing Webinars. Webinar allows a host to broadcast a Zoom meeting to up to 10,000 attendees. Scheduling a [Webinar with registration](https://support.zoom.us/hc/en-us/articles/204619915-Scheduling-a-Webinar-with-Registration) requires your registrants to complete a brief form before receiving the link to join the Webinar.<br>
        /// Use this API to list all the users that have registered for a webinar.<br><br>
        /// **Prerequisites:**
        /// * Pro or higher plan with a Webinar Add-on.<br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br> 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Registration List
        ///
        /// List of users.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var occurrenceID: String?
            public var status: Status?
            public var trackingSourceID: String?
            public var pageSize: Int?
            public var pageNumber: Int?
            public var nextPageToken: String?

            public enum Status: String, Codable, CaseIterable {
                case pending
                case approved
                case denied
            }

            public init(occurrenceID: String? = nil, status: Status? = nil, trackingSourceID: String? = nil, pageSize: Int? = nil, pageNumber: Int? = nil, nextPageToken: String? = nil) {
                self.occurrenceID = occurrenceID
                self.status = status
                self.trackingSourceID = trackingSourceID
                self.pageSize = pageSize
                self.pageNumber = pageNumber
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(occurrenceID, forKey: "occurrence_id")
                encoder.encode(status, forKey: "status")
                encoder.encode(trackingSourceID, forKey: "tracking_source_id")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(pageNumber, forKey: "page_number")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }

        /// Add a webinar registrant
        ///
        /// Zoom users with a [Webinar Plan](https://zoom.us/webinar) have access to creating and managing Webinars. Webinar allows a host to broadcast a Zoom meeting to up to 10,000 attendees. Scheduling a [Webinar with registration](https://support.zoom.us/hc/en-us/articles/204619915-Scheduling-a-Webinar-with-Registration) requires your registrants to complete a brief form before receiving the link to join the Webinar.<br>Use this API to create and submit the registration of a user for a webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites:**
        /// * Pro or higher plan with a Webinar Add-on.
        public func post(occurrenceIDs: String? = nil, _ body: PostRequest) -> Request<PostResponse> {
            .post(path, query: makePostQuery(occurrenceIDs), body: body)
        }

        public struct PostResponse: Decodable {
            /// Registrant ID
            public var registrantID: String?
            /// Webinar ID
            public var id: String?
            /// Topic
            public var topic: String?
            /// Start time
            public var startTime: Date?
            /// Unique URL for this registrant to join the Webinar. This URL should only be shared with the registrant for whom the API request was made.
            public var joinURL: String?

            public init(registrantID: String? = nil, id: String? = nil, topic: String? = nil, startTime: Date? = nil, joinURL: String? = nil) {
                self.registrantID = registrantID
                self.id = id
                self.topic = topic
                self.startTime = startTime
                self.joinURL = joinURL
            }

            private enum CodingKeys: String, CodingKey {
                case registrantID = "registrant_id"
                case id
                case topic
                case startTime = "start_time"
                case joinURL = "join_url"
            }
        }

        private func makePostQuery(_ occurrenceIDs: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceIDs, forKey: "occurrence_ids")
            return encoder.items
        }

        /// Webinar registrant.
        public struct PostRequest: Encodable {
            /// The registrant's email address.
            public var email: String
            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// The registrant's ZIP or postal code.
            public var zip: String?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's questions and comments.
            public var comments: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?

            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// Information about custom questions.
            public struct CustomQuestion: Encodable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            public init(email: String, status: Status? = nil, firstName: String, lastName: String? = nil, address: String? = nil, city: String? = nil, country: String? = nil, zip: String? = nil, state: String? = nil, phone: String? = nil, industry: String? = nil, org: String? = nil, jobTitle: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, noOfEmployees: NoOfEmployees? = nil, comments: String? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.email = email
                self.status = status
                self.firstName = firstName
                self.lastName = lastName
                self.address = address
                self.city = city
                self.country = country
                self.zip = zip
                self.state = state
                self.phone = phone
                self.industry = industry
                self.org = org
                self.jobTitle = jobTitle
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.noOfEmployees = noOfEmployees
                self.comments = comments
                self.customQuestions = customQuestions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encode(email, forKey: "email")
                try values.encodeIfPresent(status, forKey: "status")
                try values.encode(firstName, forKey: "first_name")
                try values.encodeIfPresent(lastName, forKey: "last_name")
                try values.encodeIfPresent(address, forKey: "address")
                try values.encodeIfPresent(city, forKey: "city")
                try values.encodeIfPresent(country, forKey: "country")
                try values.encodeIfPresent(zip, forKey: "zip")
                try values.encodeIfPresent(state, forKey: "state")
                try values.encodeIfPresent(phone, forKey: "phone")
                try values.encodeIfPresent(industry, forKey: "industry")
                try values.encodeIfPresent(org, forKey: "org")
                try values.encodeIfPresent(jobTitle, forKey: "job_title")
                try values.encodeIfPresent(purchasingTimeFrame, forKey: "purchasing_time_frame")
                try values.encodeIfPresent(roleInPurchaseProcess, forKey: "role_in_purchase_process")
                try values.encodeIfPresent(noOfEmployees, forKey: "no_of_employees")
                try values.encodeIfPresent(comments, forKey: "comments")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var batchRegistrants: BatchRegistrants {
        BatchRegistrants(path: path + "/batch_registrants")
    }

    public struct BatchRegistrants {
        /// Path: `/webinars/{webinarId}/batch_registrants`
        public let path: String

        /// Perform batch registration
        ///
        /// Use this API to register up to 30 registrants at once for a scheduled webinar that requires [registration](https://support.zoom.us/hc/en-us/articles/204619915-Scheduling-a-webinar-with-registration). <br>
        /// 
        /// **Prerequisites:**<br>
        /// * The webinar host must be a Licensed user.
        /// * The webinar should be of type `5`, i.e., it should be a scheduled webinar. Other types of webinars are not supported by this API.<br><br>
        /// **Scope:** `webinar:write`, `webinar:write:admin`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`<br>
        public func post(_ body: PostRequest? = nil) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public struct PostResponse: Decodable {
            public var registrants: [Registrant]?

            public struct Registrant: Decodable {
                /// Unique identifier of the registrant.
                public var registrantID: String?
                /// Email address of the registrant.
                public var email: String?
                /// Unique URL using which registrant can join the webinar.
                public var joinURL: String?

                public init(registrantID: String? = nil, email: String? = nil, joinURL: String? = nil) {
                    self.registrantID = registrantID
                    self.email = email
                    self.joinURL = joinURL
                }

                private enum CodingKeys: String, CodingKey {
                    case registrantID = "registrant_id"
                    case email
                    case joinURL = "join_url"
                }
            }

            public init(registrants: [Registrant]? = nil) {
                self.registrants = registrants
            }
        }

        public struct PostRequest: Encodable {
            /// If a meeting was scheduled with approval_type `1` (manual approval), but you would like to automatically approve the registrants that are added via this API, you can set the value of this field to `true`. 
            /// 
            /// You **cannot** use this field to change approval setting for a meeting  that was originally scheduled with approval_type `0` (automatic approval).
            public var isAutoApprove: Bool?
            public var registrants: [Registrant]?

            public struct Registrant: Encodable {
                /// First name of the registrant.
                public var firstName: String
                /// Last name of the registrant.
                public var lastName: String?
                /// Email address of the registrant.
                public var email: String

                public init(firstName: String, lastName: String? = nil, email: String) {
                    self.firstName = firstName
                    self.lastName = lastName
                    self.email = email
                }

                private enum CodingKeys: String, CodingKey {
                    case firstName = "first_name"
                    case lastName = "last_name"
                    case email
                }
            }

            public init(isAutoApprove: Bool? = nil, registrants: [Registrant]? = nil) {
                self.isAutoApprove = isAutoApprove
                self.registrants = registrants
            }

            private enum CodingKeys: String, CodingKey {
                case isAutoApprove = "auto_approve"
                case registrants
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID.Registrants {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/webinars/{webinarId}/registrants/status`
        public let path: String

        /// Update registrant's status
        ///
        /// Use this API to update webinar registrants' registration status. You can approve or deny a registrant, or revoke a registrant's approval. 
        /// 
        /// **Scopes:** `webinar:write:admin`, `webinar:write` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public func put(occurrenceID: String? = nil, _ body: PutRequest) -> Request<Void> {
            .put(path, query: makePutQuery(occurrenceID), body: body)
        }

        private func makePutQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }

        public struct PutRequest: Encodable {
            /// The registration action to perform: 
            /// * `approve`  Approve the registrant. 
            /// * `deny`  Reject the registrant. 
            /// * `cancel`  Cancel the registrant's approval.
            public var action: Action
            /// The registrant information.
            public var registrants: [Registrant]?

            /// The registration action to perform: 
            /// * `approve`  Approve the registrant. 
            /// * `deny`  Reject the registrant. 
            /// * `cancel`  Cancel the registrant's approval.
            public enum Action: String, Codable, CaseIterable {
                case approve
                case deny
                case cancel
            }

            public struct Registrant: Encodable {
                /// The registrant's ID.
                public var id: String?
                /// The registrant's email address.
                public var email: String?

                public init(id: String? = nil, email: String? = nil) {
                    self.id = id
                    self.email = email
                }
            }

            public init(action: Action, registrants: [Registrant]? = nil) {
                self.action = action
                self.registrants = registrants
            }
        }
    }
}

extension Paths.PastWebinars.WithWebinarID {
    public var instances: Instances {
        Instances(path: path + "/instances")
    }

    public struct Instances {
        /// Path: `/past_webinars/{webinarId}/instances`
        public let path: String

        /// List past webinar instances
        ///
        /// List past webinar instances.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var get: Request<[String: AnyJSON]> {
            .get(path)
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var polls: Polls {
        Polls(path: path + "/polls")
    }

    public struct Polls {
        /// Path: `/webinars/{webinarId}/polls`
        public let path: String

        /// List a webinar's polls
        ///
        /// List all the [polls](https://support.zoom.us/hc/en-us/articles/203749865-Polling-for-Webinars) of a Webinar.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func get(isAnonymous: Bool? = nil) -> Request<[String: AnyJSON]> {
            .get(path, query: makeGetQuery(isAnonymous))
        }

        private func makeGetQuery(_ isAnonymous: Bool?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(isAnonymous, forKey: "anonymous")
            return encoder.items
        }

        /// Create a webinar's poll
        ///
        /// Create a [poll](https://support.zoom.us/hc/en-us/articles/203749865-Polling-for-Webinars) for a webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// Location of created Webinar Poll
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Webinar Poll ID
            public var id: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Information about the poll's questions.
            public var questions: [Question]?
            /// Status of the Webinar Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public var status: Status?
            /// The poll's title, up to 64 characters.
            public var title: String?

            public struct Question: Decodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Decodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.name = try values.decodeIfPresent(String.self, forKey: .name)
                    self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                    self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                    self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                    self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                    self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
                    self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
                    self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                    self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                    self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
                    self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                    self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                    self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                    self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                }
            }

            /// Status of the Webinar Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public enum Status: String, Codable, CaseIterable {
                case notstart
                case started
                case ended
                case sharing
            }

            public init(isAnonymous: Bool? = nil, id: String? = nil, pollType: Int? = nil, questions: [Question]? = nil, status: Status? = nil, title: String? = nil) {
                self.isAnonymous = isAnonymous ?? false
                self.id = id
                self.pollType = pollType
                self.questions = questions
                self.status = status
                self.title = title
            }

            private enum CodingKeys: String, CodingKey {
                case isAnonymous = "anonymous"
                case id
                case pollType = "poll_type"
                case questions
                case status
                case title
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
                self.id = try values.decodeIfPresent(String.self, forKey: .id)
                self.pollType = try values.decodeIfPresent(Int.self, forKey: .pollType)
                self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
                self.status = try values.decodeIfPresent(Status.self, forKey: .status)
                self.title = try values.decodeIfPresent(String.self, forKey: .title)
            }
        }

        public struct PostRequest: Encodable {
            /// The poll's title, up to 64 characters.
            public var title: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Information about the poll's questions.
            public var questions: [Question]?

            public struct Question: Encodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Encodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }
            }

            public init(title: String? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                self.title = title
                self.pollType = pollType
                self.isAnonymous = isAnonymous ?? false
                self.questions = questions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(title, forKey: "title")
                try values.encodeIfPresent(pollType, forKey: "poll_type")
                try values.encodeIfPresent(isAnonymous, forKey: "anonymous")
                try values.encodeIfPresent(questions, forKey: "questions")
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID.Polls {
    public func pollID(_ pollID: String) -> WithPollID {
        WithPollID(path: "\(path)/\(pollID)")
    }

    public struct WithPollID {
        /// Path: `/webinars/{webinarId}/polls/{pollId}`
        public let path: String

        /// Get a webinar poll
        ///
        /// Get a webinar's [poll](https://support.zoom.us/hc/en-us/articles/203749865-Polling-for-Webinars) details.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Webinar Poll ID
            public var id: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Information about the poll's questions.
            public var questions: [Question]?
            /// Status of the Webinar Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public var status: Status?
            /// The poll's title, up to 64 characters.
            public var title: String?

            public struct Question: Decodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Decodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.name = try values.decodeIfPresent(String.self, forKey: .name)
                    self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                    self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                    self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                    self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                    self.rightAnswers = try values.decodeIfPresent([String].self, forKey: .rightAnswers)
                    self.prompts = try values.decodeIfPresent([Prompt].self, forKey: .prompts)
                    self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                    self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                    self.isCaseSensitive = try values.decodeIfPresent(Bool.self, forKey: .isCaseSensitive) ?? false
                    self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                    self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                    self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                    self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                }
            }

            /// Status of the Webinar Poll:<br>`notstart` - Poll not started<br>`started` - Poll started<br>`ended` - Poll ended<br>`sharing` - Sharing poll results
            public enum Status: String, Codable, CaseIterable {
                case notstart
                case started
                case ended
                case sharing
            }

            public init(isAnonymous: Bool? = nil, id: String? = nil, pollType: Int? = nil, questions: [Question]? = nil, status: Status? = nil, title: String? = nil) {
                self.isAnonymous = isAnonymous ?? false
                self.id = id
                self.pollType = pollType
                self.questions = questions
                self.status = status
                self.title = title
            }

            private enum CodingKeys: String, CodingKey {
                case isAnonymous = "anonymous"
                case id
                case pollType = "poll_type"
                case questions
                case status
                case title
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
                self.id = try values.decodeIfPresent(String.self, forKey: .id)
                self.pollType = try values.decodeIfPresent(Int.self, forKey: .pollType)
                self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
                self.status = try values.decodeIfPresent(Status.self, forKey: .status)
                self.title = try values.decodeIfPresent(String.self, forKey: .title)
            }
        }

        /// Update a webinar poll
        ///
        /// Update a webinar's [poll](https://support.zoom.us/hc/en-us/articles/203749865-Polling-for-Webinars).<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public func put(_ body: PutRequest) -> Request<Void> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// The poll's title, up to 64 characters.
            public var title: String?
            /// The type of poll: 
            /// * `1`  Poll. 
            /// * `2`  Advanced Poll. This feature must be enabled in your Zoom account. 
            /// * `3`  Quiz. This feature must be enabled in your Zoom account. 
            /// 
            ///  This value defaults to `1`.
            public var pollType: Int?
            /// Whether to allow meeting participants to answer poll questions anonymously: 
            /// * `true`  Anonymous polls enabled. 
            /// * `false`  Participants cannot answer poll questions anonymously. 
            /// 
            /// This value defaults to `false`.
            public var isAnonymous: Bool
            /// Information about the poll's questions.
            public var questions: [Question]?

            public struct Question: Encodable {
                /// The poll question, up to 255 characters. 
                /// 
                /// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
                public var name: String?
                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public var type: `Type`?
                /// Whether to display the radio selection as a drop-down box: 
                /// * `true`  Show as a drop-down box. 
                /// * `false`  Do not show as a drop-down box. 
                /// 
                /// This value defaults to `false`.
                public var isShowAsDropdown: Bool
                /// Whether participants must answer the question: 
                /// * `true`  The participant must answer the question. 
                /// * `false`  The participant does not need to answer the question. 
                /// 
                /// **Note:** 
                /// * When the poll's `type` value is `1` (Poll), this value defaults to `true`. 
                /// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
                public var isAnswerRequired: Bool
                /// The poll question's available answers. This field requires a **minimum** of two answers. 
                /// 
                /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                public var answers: [String]?
                /// The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz). 
                /// 
                ///  For `single` and `matching` polls, this field only accepts one answer.
                public var rightAnswers: [String]?
                /// Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
                public var prompts: [Prompt]?
                /// The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
                public var answerMinCharacter: Int?
                /// The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls: 
                /// * For `short_answer` polls, a maximum of 500 characters. 
                /// * For `long_answer` polls, a maximum of 2,000 characters.
                public var answerMaxCharacter: Int?
                /// Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls: 
                /// * `true`  The answer is case-sensitive. 
                /// * `false`  The answer is not case-sensitive. 
                /// 
                /// This value defaults to `false`.
                public var isCaseSensitive: Bool
                /// The rating scale's minimum value. This value cannot be less than zero. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinValue: Int?
                /// The rating scale's maximum value, up to a maximum value of 10. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxValue: Int?
                /// The low score label used for the `rating_min_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMinLabel: String?
                /// The high score label used for the `rating_max_value` field. 
                /// 
                /// This field only applies to the `rating_scale` poll.
                public var ratingMaxLabel: String?

                /// The poll's question and answer type: 
                /// * `single`  Single choice. 
                /// * `multiple`  Multiple choice. 
                /// * `matching`  Matching. 
                /// * `rank_order`  Rank order. 
                /// * `short_answer`  Short answer. 
                /// * `long_answer`  Long answer. 
                /// * `fill_in_the_blank`  Fill in the blank. 
                /// * `rating_scale`  Rating scale.
                public enum `Type`: String, Codable, CaseIterable {
                    case single
                    case multiple
                    case matching
                    case rankOrder = "rank_order"
                    case shortAnswer = "short_answer"
                    case longAnswer = "long_answer"
                    case fillInTheBlank = "fill_in_the_blank"
                    case ratingScale = "rating_scale"
                }

                public struct Prompt: Encodable {
                    /// The question prompt's title.
                    public var promptQuestion: String?
                    /// The question prompt's correct answers: 
                    /// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers. 
                    /// * For `rank_order` polls, you can only provide one correct answer.
                    public var promptRightAnswers: [String]?

                    public init(promptQuestion: String? = nil, promptRightAnswers: [String]? = nil) {
                        self.promptQuestion = promptQuestion
                        self.promptRightAnswers = promptRightAnswers
                    }

                    private enum CodingKeys: String, CodingKey {
                        case promptQuestion = "prompt_question"
                        case promptRightAnswers = "prompt_right_answers"
                    }
                }

                public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, rightAnswers: [String]? = nil, prompts: [Prompt]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, isCaseSensitive: Bool? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                    self.name = name
                    self.type = type
                    self.isShowAsDropdown = isShowAsDropdown ?? false
                    self.isAnswerRequired = isAnswerRequired ?? false
                    self.answers = answers
                    self.rightAnswers = rightAnswers
                    self.prompts = prompts
                    self.answerMinCharacter = answerMinCharacter
                    self.answerMaxCharacter = answerMaxCharacter
                    self.isCaseSensitive = isCaseSensitive ?? false
                    self.ratingMinValue = ratingMinValue
                    self.ratingMaxValue = ratingMaxValue
                    self.ratingMinLabel = ratingMinLabel
                    self.ratingMaxLabel = ratingMaxLabel
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case type
                    case isShowAsDropdown = "show_as_dropdown"
                    case isAnswerRequired = "answer_required"
                    case answers
                    case rightAnswers = "right_answers"
                    case prompts
                    case answerMinCharacter = "answer_min_character"
                    case answerMaxCharacter = "answer_max_character"
                    case isCaseSensitive = "case_sensitive"
                    case ratingMinValue = "rating_min_value"
                    case ratingMaxValue = "rating_max_value"
                    case ratingMinLabel = "rating_min_label"
                    case ratingMaxLabel = "rating_max_label"
                }
            }

            public init(title: String? = nil, pollType: Int? = nil, isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                self.title = title
                self.pollType = pollType
                self.isAnonymous = isAnonymous ?? false
                self.questions = questions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(title, forKey: "title")
                try values.encodeIfPresent(pollType, forKey: "poll_type")
                try values.encodeIfPresent(isAnonymous, forKey: "anonymous")
                try values.encodeIfPresent(questions, forKey: "questions")
            }
        }

        /// Delete a webinar poll
        ///
        /// Delete a webinar's [poll](https://support.zoom.us/hc/en-us/articles/203749865-Polling-for-Webinars).<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

extension Paths.Webinars.WithWebinarID.Registrants {
    public var questions: Questions {
        Questions(path: path + "/questions")
    }

    public struct Questions {
        /// Path: `/webinars/{webinarId}/registrants/questions`
        public let path: String

        /// List registration questions
        ///
        /// Scheduling a [Webinar with registration](https://support.zoom.us/hc/en-us/articles/204619915-Scheduling-a-Webinar-with-Registration) requires your registrants to complete a brief form with fields and questions before they can receive the link to join the Webinar.<br>Use this API to list registration questions and fields that are to be answered by users while registering for a Webinar.<br>
        /// **Prerequisites:**<br>  
        /// * Pro or higher plan with a Webinar Add-on.
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Array of Registrant Custom Questions.
            public var customQuestions: [CustomQuestion]?
            /// Array of registration fields whose values should be provided by registrants during registration.
            public var questions: [Question]?

            public struct CustomQuestion: Decodable {
                /// Custom question.
                public var title: String?
                /// The question-answer type.
                public var type: `Type`?
                /// State whether or not the custom question is required to be answered by a registrant.
                public var isRequired: Bool?
                /// An array of answer choices. Can't be used for short answer type.
                public var answers: [String]?

                /// The question-answer type.
                public enum `Type`: String, Codable, CaseIterable {
                    case short
                    case singleRadio = "single_radio"
                    case singleDropdown = "single_dropdown"
                    case multiple
                }

                public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
                    self.title = title
                    self.type = type
                    self.isRequired = isRequired
                    self.answers = answers
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case type
                    case isRequired = "required"
                    case answers
                }
            }

            public struct Question: Decodable {
                /// Field name
                public var fieldName: FieldName?
                /// State whether the selected fields are required or optional.
                public var isRequired: Bool?

                /// Field name
                public enum FieldName: String, Codable, CaseIterable {
                    case lastName = "last_name"
                    case address
                    case city
                    case country
                    case zip
                    case state
                    case phone
                    case industry
                    case org
                    case jobTitle = "job_title"
                    case purchasingTimeFrame = "purchasing_time_frame"
                    case roleInPurchaseProcess = "role_in_purchase_process"
                    case noOfEmployees = "no_of_employees"
                    case comments
                }

                public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
                    self.fieldName = fieldName
                    self.isRequired = isRequired
                }

                private enum CodingKeys: String, CodingKey {
                    case fieldName = "field_name"
                    case isRequired = "required"
                }
            }

            public init(customQuestions: [CustomQuestion]? = nil, questions: [Question]? = nil) {
                self.customQuestions = customQuestions
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case customQuestions = "custom_questions"
                case questions
            }
        }

        /// Update registration questions
        ///
        /// Scheduling a [Webinar with registration](https://support.zoom.us/hc/en-us/articles/204619915-Scheduling-a-Webinar-with-Registration) requires your registrants to complete a brief form with fields and questions before they can receive the link to join the Webinar.<br>Use this API to update registration questions and fields of a scheduled Webinar that are to be answered by users while registering for a Webinar.<br><br>
        /// **Prerequisites:**<br>  
        /// * Pro or higher plan with a Webinar Add-on.
        /// * Registration option for Webinar should be set as required to use this API. 
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// Array of registration fields whose values should be provided by registrants during registration.
            public var questions: [Question]?
            /// Array of Registrant Custom Questions.
            public var customQuestions: [CustomQuestion]?

            public struct Question: Encodable {
                /// Field name
                public var fieldName: FieldName?
                /// State whether the selected fields are required or optional.
                public var isRequired: Bool?

                /// Field name
                public enum FieldName: String, Codable, CaseIterable {
                    case lastName = "last_name"
                    case address
                    case city
                    case country
                    case zip
                    case state
                    case phone
                    case industry
                    case org
                    case jobTitle = "job_title"
                    case purchasingTimeFrame = "purchasing_time_frame"
                    case roleInPurchaseProcess = "role_in_purchase_process"
                    case noOfEmployees = "no_of_employees"
                    case comments
                }

                public init(fieldName: FieldName? = nil, isRequired: Bool? = nil) {
                    self.fieldName = fieldName
                    self.isRequired = isRequired
                }

                private enum CodingKeys: String, CodingKey {
                    case fieldName = "field_name"
                    case isRequired = "required"
                }
            }

            public struct CustomQuestion: Encodable {
                /// Custom question.
                public var title: String?
                /// The question-answer type.
                public var type: `Type`?
                /// State whether or not the custom question is required to be answered by a registrant.
                public var isRequired: Bool?
                /// An array of answer choices. Can't be used for short answer type.
                public var answers: [String]?

                /// The question-answer type.
                public enum `Type`: String, Codable, CaseIterable {
                    case short
                    case singleRadio = "single_radio"
                    case singleDropdown = "single_dropdown"
                    case multiple
                }

                public init(title: String? = nil, type: `Type`? = nil, isRequired: Bool? = nil, answers: [String]? = nil) {
                    self.title = title
                    self.type = type
                    self.isRequired = isRequired
                    self.answers = answers
                }

                private enum CodingKeys: String, CodingKey {
                    case title
                    case type
                    case isRequired = "required"
                    case answers
                }
            }

            public init(questions: [Question]? = nil, customQuestions: [CustomQuestion]? = nil) {
                self.questions = questions
                self.customQuestions = customQuestions
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(questions, forKey: "questions")
                try values.encodeIfPresent(customQuestions, forKey: "custom_questions")
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID.Registrants {
    public func registrantID(_ registrantID: String) -> WithRegistrantID {
        WithRegistrantID(path: "\(path)/\(registrantID)")
    }

    public struct WithRegistrantID {
        /// Path: `/webinars/{webinarId}/registrants/{registrantId}`
        public let path: String

        /// Get a webinar registrant
        ///
        /// Zoom users with a [Webinar Plan](https://zoom.us/webinar) have access to creating and managing Webinars. Webinar allows a host to broadcast a Zoom meeting to up to 10,000 attendees. Scheduling a [Webinar with registration](https://support.zoom.us/hc/en-us/articles/204619915-Scheduling-a-Webinar-with-Registration) requires your registrants to complete a brief form before receiving the link to join the Webinar.<br>Use this API to get details on a specific user who has registered for the Webinar.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`<br>
        /// **Prerequisites:**<br>
        /// * The account must have a Webinar plan.
        public func get(occurrenceID: String? = nil) -> Request<GetResponse> {
            .get(path, query: makeGetQuery(occurrenceID))
        }

        /// Webianr Registrant
        public struct GetResponse: Decodable {
            /// The registrant's address.
            public var address: String?
            /// The registrant's city.
            public var city: String?
            /// The registrant's questions and comments.
            public var comments: String?
            /// The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
            public var country: String?
            /// Information about custom questions.
            public var customQuestions: [CustomQuestion]?
            /// The registrant's email address.
            public var email: String
            /// The registrant's first name.
            public var firstName: String
            /// The registrant's industry.
            public var industry: String?
            /// The registrant's job title.
            public var jobTitle: String?
            /// The registrant's last name.
            public var lastName: String?
            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public var noOfEmployees: NoOfEmployees?
            /// The registrant's organization.
            public var org: String?
            /// The registrant's phone number.
            public var phone: String?
            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public var purchasingTimeFrame: PurchasingTimeFrame?
            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public var roleInPurchaseProcess: RoleInPurchaseProcess?
            /// The registrant's state or province.
            public var state: String?
            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public var status: Status?
            /// The registrant's ZIP or postal code.
            public var zip: String?

            /// Information about custom questions.
            public struct CustomQuestion: Decodable {
                /// The title of the custom question.
                public var title: String?
                /// The custom question's response value. This has a limit of 128 characters.
                public var value: String?

                public init(title: String? = nil, value: String? = nil) {
                    self.title = title
                    self.value = value
                }
            }

            /// The registrant's number of employees: 
            /// * `1-20` 
            /// * `21-50` 
            /// * `51-100` 
            /// * `101-500` 
            /// * `500-1,000` 
            /// * `1,001-5,000` 
            /// * `5,001-10,000` 
            /// * `More than 10,000`
            public enum NoOfEmployees: String, Codable, CaseIterable {
                case empty = ""
                case _120 = "1-20"
                case _2150 = "21-50"
                case _51100 = "51-100"
                case _101500 = "101-500"
                case _5001000 = "500-1,000"
                case _10015000 = "1,001-5,000"
                case _500110000 = "5,001-10,000"
                case moreThan10000 = "More than 10,000"
            }

            /// The registrant's purchasing time frame: 
            /// * `Within a month` 
            /// * `1-3 months` 
            /// * `4-6 months` 
            /// * `More than 6 months` 
            /// * `No timeframe`
            public enum PurchasingTimeFrame: String, Codable, CaseIterable {
                case empty = ""
                case withinAMonth = "Within a month"
                case _13Months = "1-3 months"
                case _46Months = "4-6 months"
                case moreThan6Months = "More than 6 months"
                case noTimeframe = "No timeframe"
            }

            /// The registrant's role in the purchase process: 
            /// * `Decision Maker` 
            /// * `Evaluator/Recommender` 
            /// * `Influencer` 
            /// * `Not involved`
            public enum RoleInPurchaseProcess: String, Codable, CaseIterable {
                case empty = ""
                case decisionMaker = "Decision Maker"
                case evaluatorRecommender = "Evaluator/Recommender"
                case influencer = "Influencer"
                case notInvolved = "Not involved"
            }

            /// The registrant's status: 
            /// * `approved`  Registrant is approved. 
            /// * `denied`  Registrant is denied. 
            /// * `pending`  Registrant is waiting for approval.
            public enum Status: String, Codable, CaseIterable {
                case approved
                case denied
                case pending
            }

            public init(address: String? = nil, city: String? = nil, comments: String? = nil, country: String? = nil, customQuestions: [CustomQuestion]? = nil, email: String, firstName: String, industry: String? = nil, jobTitle: String? = nil, lastName: String? = nil, noOfEmployees: NoOfEmployees? = nil, org: String? = nil, phone: String? = nil, purchasingTimeFrame: PurchasingTimeFrame? = nil, roleInPurchaseProcess: RoleInPurchaseProcess? = nil, state: String? = nil, status: Status? = nil, zip: String? = nil) {
                self.address = address
                self.city = city
                self.comments = comments
                self.country = country
                self.customQuestions = customQuestions
                self.email = email
                self.firstName = firstName
                self.industry = industry
                self.jobTitle = jobTitle
                self.lastName = lastName
                self.noOfEmployees = noOfEmployees
                self.org = org
                self.phone = phone
                self.purchasingTimeFrame = purchasingTimeFrame
                self.roleInPurchaseProcess = roleInPurchaseProcess
                self.state = state
                self.status = status
                self.zip = zip
            }

            private enum CodingKeys: String, CodingKey {
                case address
                case city
                case comments
                case country
                case customQuestions = "custom_questions"
                case email
                case firstName = "first_name"
                case industry
                case jobTitle = "job_title"
                case lastName = "last_name"
                case noOfEmployees = "no_of_employees"
                case org
                case phone
                case purchasingTimeFrame = "purchasing_time_frame"
                case roleInPurchaseProcess = "role_in_purchase_process"
                case state
                case status
                case zip
            }
        }

        private func makeGetQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }

        /// Delete a webinar registrant
        ///
        /// Delete a webinar registrant.<br><br>
        /// **Scopes**: `webinar:write:admin` `webinar:write`<br>
        ///  <br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func delete(occurrenceID: String? = nil) -> Request<Void> {
            .delete(path, query: makeDeleteQuery(occurrenceID))
        }

        private func makeDeleteQuery(_ occurrenceID: String?) -> [(String, String?)] {
            let encoder = URLQueryEncoder()
            encoder.encode(occurrenceID, forKey: "occurrence_id")
            return encoder.items
        }
    }
}

extension Paths.PastWebinars {
    public func webinarUUID(_ webinarUUID: String) -> WithWebinarUUID {
        WithWebinarUUID(path: "\(path)/\(webinarUUID)")
    }

    public struct WithWebinarUUID {
        /// Path: `/past_webinars/{WebinarUUID}`
        public let path: String
    }
}

extension Paths.PastWebinars.WithWebinarUUID {
    public var absentees: Absentees {
        Absentees(path: path + "/absentees")
    }

    public struct Absentees {
        /// Path: `/past_webinars/{WebinarUUID}/absentees`
        public let path: String

        /// Get webinar absentees
        ///
        /// List absentees of a webinar.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Heavy`
        public func get(parameters: GetParameters? = nil) -> Request<GetResponse> {
            .get(path, query: parameters?.asQuery)
        }

        /// Registration List
        ///
        /// List of users.
        public struct GetResponse: Decodable {
            /// The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
            public var nextPageToken: String?
            /// The number of pages returned for the request made.
            public var pageCount: Int?
            /// **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
            public var pageNumber: Int?
            /// The number of records returned with a single API call.
            public var pageSize: Int?
            /// The total number of all the records available across pages.
            public var totalRecords: Int?

            public init(nextPageToken: String? = nil, pageCount: Int? = nil, pageNumber: Int? = nil, pageSize: Int? = nil, totalRecords: Int? = nil) {
                self.nextPageToken = nextPageToken
                self.pageCount = pageCount
                self.pageNumber = pageNumber
                self.pageSize = pageSize
                self.totalRecords = totalRecords
            }

            private enum CodingKeys: String, CodingKey {
                case nextPageToken = "next_page_token"
                case pageCount = "page_count"
                case pageNumber = "page_number"
                case pageSize = "page_size"
                case totalRecords = "total_records"
            }
        }

        public struct GetParameters {
            public var occurrenceID: String?
            public var pageSize: Int?
            public var nextPageToken: String?

            public init(occurrenceID: String? = nil, pageSize: Int? = nil, nextPageToken: String? = nil) {
                self.occurrenceID = occurrenceID
                self.pageSize = pageSize
                self.nextPageToken = nextPageToken
            }

            public var asQuery: [(String, String?)] {
                let encoder = URLQueryEncoder()
                encoder.encode(occurrenceID, forKey: "occurrence_id")
                encoder.encode(pageSize, forKey: "page_size")
                encoder.encode(nextPageToken, forKey: "next_page_token")
                return encoder.items
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var trackingSources: TrackingSources {
        TrackingSources(path: path + "/tracking_sources")
    }

    public struct TrackingSources {
        /// Path: `/webinars/{webinarId}/tracking_sources`
        public let path: String

        /// Get webinar tracking sources
        ///
        /// [Webinar Registration Tracking Sources](https://support.zoom.us/hc/en-us/articles/360000315683-Webinar-Registration-Source-Tracking) allow you to see where your registrants are coming from if you share the webinar registration page in multiple platforms. You can then use the source tracking to see the number of registrants generated from each platform.<br> Use this API to list information on all the tracking sources of a Webinar.<br>
        /// **Scopes:** `webinar:read:admin`, `webinar:read`<br>
        ///  
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`<br>
        /// **Prerequisites**:<br>
        /// * [Webinar license](https://zoom.us/webinar).
        /// * Registration must be required for the Webinar.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The total number of registration records for this Webinar.
            public var totalRecords: Int?
            /// Tracking Sources object.
            public var trackingSources: [TrackingSource]?

            public struct TrackingSource: Decodable {
                /// Unique Identifier of the tracking source.
                public var id: String?
                /// Name of the source (platform) where the registration URL was shared.
                public var sourceName: String?
                /// Tracking URL. The URL that was shared for the registration.
                public var trackingURL: String?
                /// Number of registrations made from this source.
                public var registrationCount: Int?
                /// Number of visitors who visited the registration page from this source.
                public var visitorCount: Int?

                public init(id: String? = nil, sourceName: String? = nil, trackingURL: String? = nil, registrationCount: Int? = nil, visitorCount: Int? = nil) {
                    self.id = id
                    self.sourceName = sourceName
                    self.trackingURL = trackingURL
                    self.registrationCount = registrationCount
                    self.visitorCount = visitorCount
                }

                private enum CodingKeys: String, CodingKey {
                    case id
                    case sourceName = "source_name"
                    case trackingURL = "tracking_url"
                    case registrationCount = "registration_count"
                    case visitorCount = "visitor_count"
                }
            }

            public init(totalRecords: Int? = nil, trackingSources: [TrackingSource]? = nil) {
                self.totalRecords = totalRecords
                self.trackingSources = trackingSources
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case trackingSources = "tracking_sources"
            }
        }
    }
}

extension Paths.PastWebinars.WithWebinarID {
    public var polls: Polls {
        Polls(path: path + "/polls")
    }

    public struct Polls {
        /// Path: `/past_webinars/{webinarId}/polls`
        public let path: String

        /// List past webinar poll results
        ///
        /// The polling feature for webinar allows you to create single choice or multiple choice polling questions for your webinars. Use this API to retrieve the results for Webinar Polls of a specific Webinar.
        /// 
        /// **Prerequisites:**<br>
        /// * [Webinar license](https://zoom.us/webinar)<br>
        /// **Scopes**: `webinar:read:admin`, `webinar:read`<br>
        /// **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// Webinar UUID.
            public var uuid: String?
            /// The start time of the Webinar.
            public var startTime: Date?
            public var questions: [Question]?

            public struct Question: Decodable {
                /// Name of the user who submitted answers to the poll. If "anonymous" option is enabled for a poll, the participant's polling information will be kept anonymous and the value of `name` field will be "Anonymous Attendee".
                public var name: String?
                /// Email address of the user who submitted answers to the poll.
                public var email: String?
                public var questionDetails: [QuestionDetail]?

                public struct QuestionDetail: Decodable {
                    /// Question asked during the poll.
                    public var question: String?
                    /// Answer submitted by the user.
                    public var answer: String?
                    /// Unique identifier of the poll.
                    public var pollingID: String?
                    /// Date and time at which the answer to the poll was submitted.
                    public var dateTime: Date?

                    public init(question: String? = nil, answer: String? = nil, pollingID: String? = nil, dateTime: Date? = nil) {
                        self.question = question
                        self.answer = answer
                        self.pollingID = pollingID
                        self.dateTime = dateTime
                    }

                    private enum CodingKeys: String, CodingKey {
                        case question
                        case answer
                        case pollingID = "polling_id"
                        case dateTime = "date_time"
                    }
                }

                public init(name: String? = nil, email: String? = nil, questionDetails: [QuestionDetail]? = nil) {
                    self.name = name
                    self.email = email
                    self.questionDetails = questionDetails
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case email
                    case questionDetails = "question_details"
                }
            }

            public init(id: Int? = nil, uuid: String? = nil, startTime: Date? = nil, questions: [Question]? = nil) {
                self.id = id
                self.uuid = uuid
                self.startTime = startTime
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case uuid
                case startTime = "start_time"
                case questions
            }
        }
    }
}

extension Paths.PastWebinars.WithWebinarID {
    public var qa: Qa {
        Qa(path: path + "/qa")
    }

    public struct Qa {
        /// Path: `/past_webinars/{webinarId}/qa`
        public let path: String

        /// List Q&A of past webinar
        ///
        /// The [Question & Answer (Q&A)](https://support.zoom.us/hc/en-us/articles/203686015-Getting-Started-with-Question-Answer) feature for Webinars allows attendees to ask questions during the Webinar and for the panelists, co-hosts and host to answer their questions.<br>
        /// Use this API to list Q&A of a specific Webinar.
        /// 
        /// **Prerequisites:**<br>
        /// * [Webinar license](https://zoom.us/webinar)<br>
        /// **Scopes**: `webinar:read:admin`, `webinar:read`<br>
        ///  <br>
        /// 
        /// 
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Medium`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Webinar ID in "**long**" format(represented as int64 data type in JSON), also known as the webinar number.
            public var id: Int?
            /// Webinar UUID.
            public var uuid: String?
            /// The start time of the Webinar.
            public var startTime: Date?
            public var questions: [Question]?

            public struct Question: Decodable {
                /// Name of the user. If "anonymous" option is enabled for the Q&A, the participant's  information will be kept anonymous and the value of `name` field will be "Anonymous Attendee".
                public var name: String?
                /// Email address of the user.
                public var email: String?
                public var questionDetails: [QuestionDetail]?

                public struct QuestionDetail: Decodable {
                    /// Question asked during the Q&A.
                    public var question: String?
                    /// Answer submitted for the question.
                    public var answer: String?

                    public init(question: String? = nil, answer: String? = nil) {
                        self.question = question
                        self.answer = answer
                    }
                }

                public init(name: String? = nil, email: String? = nil, questionDetails: [QuestionDetail]? = nil) {
                    self.name = name
                    self.email = email
                    self.questionDetails = questionDetails
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case email
                    case questionDetails = "question_details"
                }
            }

            public init(id: Int? = nil, uuid: String? = nil, startTime: Date? = nil, questions: [Question]? = nil) {
                self.id = id
                self.uuid = uuid
                self.startTime = startTime
                self.questions = questions
            }

            private enum CodingKeys: String, CodingKey {
                case id
                case uuid
                case startTime = "start_time"
                case questions
            }
        }
    }
}

extension Paths.Users.WithUserID {
    public var webinarTemplates: WebinarTemplates {
        WebinarTemplates(path: path + "/webinar_templates")
    }

    public struct WebinarTemplates {
        /// Path: `/users/{userId}/webinar_templates`
        public let path: String

        /// List webinar templates
        ///
        /// Use this API to list a user's [webinar templates](https://support.zoom.us/hc/en-us/articles/115001079746-Webinar-Templates). For user-level apps, pass [the `me` value](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#mekeyword) instead of the `userId` parameter. 
        /// 
        /// When you schedule a webinar, you can save the settings for that webinar as a template for scheduling future webinars.  To use a template when scheduling a webinar, use the `id` value in this API response in the `template_id` field of the [**Create a webinar**](https://marketplace.zoom.us/docs/api-reference/zoom-api/webinars/webinarcreate) API. 
        /// 
        /// **Scopes:** `webinar:read`, `webinar:read:admin` 
        /// 
        /// **Prerequisites:** 
        /// * A Pro or a higher account with the [Zoom Webinar plan](https://zoom.us/pricing/webinar).
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// The total number of records returned.
            public var totalRecords: Int?
            /// Information about the webinar templates.
            public var templates: [Template]?

            public struct Template: Decodable {
                /// The webinar template's ID.
                public var id: String?
                /// The webinar template's name.
                public var name: String?

                public init(id: String? = nil, name: String? = nil) {
                    self.id = id
                    self.name = name
                }
            }

            public init(totalRecords: Int? = nil, templates: [Template]? = nil) {
                self.totalRecords = totalRecords
                self.templates = templates
            }

            private enum CodingKeys: String, CodingKey {
                case totalRecords = "total_records"
                case templates
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var livestream: Livestream {
        Livestream(path: path + "/livestream")
    }

    public struct Livestream {
        /// Path: `/webinars/{webinarId}/livestream`
        public let path: String

        /// Get live stream details
        ///
        /// Zoom allows users to [live stream a webinar](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service) to a custom platform. Use this API to get a webinar's live stream configuration details such as Stream URL, Stream Key and Page URL.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan with a Webinar Add-on.<br>
        /// * Live streaming details must have been [configured](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service#h_01589a6f-a40a-4e18-a448-cb746e52ebc5) for the webinar.<br><br>
        /// **Scopes:** `webinar:read:admin` `webinar:read`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Stream URL.
            public var streamURL: String?
            /// Stream Key.
            public var streamKey: String?
            /// Live streaming page URL. This is the URL using which anyone can view the live stream of the webinar.
            public var pageURL: String?

            public init(streamURL: String? = nil, streamKey: String? = nil, pageURL: String? = nil) {
                self.streamURL = streamURL
                self.streamKey = streamKey
                self.pageURL = pageURL
            }

            private enum CodingKeys: String, CodingKey {
                case streamURL = "stream_url"
                case streamKey = "stream_key"
                case pageURL = "page_url"
            }
        }

        /// Update a live stream
        ///
        /// Zoom allows users to [live stream a webinar](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service) to a custom platform. Use this API to update a webinar's live stream information.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan with a Webinar Add-on.<br>
        /// * Live streaming details must have been [configured](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service#h_01589a6f-a40a-4e18-a448-cb746e52ebc5) for the webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Webinar live stream.
        public struct PatchRequest: Encodable {
            /// The webinar live stream URL.
            public var streamURL: String
            /// The webinar live stream name and key.
            public var streamKey: String
            /// The webinar live stream page's URL.
            public var pageURL: URL

            public init(streamURL: String, streamKey: String, pageURL: URL) {
                self.streamURL = streamURL
                self.streamKey = streamKey
                self.pageURL = pageURL
            }

            private enum CodingKeys: String, CodingKey {
                case streamURL = "stream_url"
                case streamKey = "stream_key"
                case pageURL = "page_url"
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID.Livestream {
    public var status: Status {
        Status(path: path + "/status")
    }

    public struct Status {
        /// Path: `/webinars/{webinarId}/livestream/status`
        public let path: String

        /// Update Live Stream Status
        ///
        /// Zoom allows users to [live stream a webinar](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service) to a custom platform. Use this API to update the status of a webinar's live stream.<br><br>
        /// **Prerequisites:**<br>
        /// * Pro or higher plan with a Webinar Add-on.<br>
        /// * Live streaming details must have been [configured](https://support.zoom.us/hc/en-us/articles/115001777826-Live-Streaming-Meetings-or-Webinars-Using-a-Custom-Service#h_01589a6f-a40a-4e18-a448-cb746e52ebc5) for the webinar.<br><br>
        /// **Scopes:** `webinar:write:admin` `webinar:write`<br>
        ///  **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        /// Webinar live stream status.
        public struct PatchRequest: Encodable {
            /// Update the status of a live stream. This value can be one of the following:
            /// 
            /// * `start`  Start a webinar live stream.
            /// 
            /// * `stop`  Stop an ongoing webinar live stream.
            public var action: Action?
            /// Update the live stream session's settings. You can **only** update settings for a stopped live stream.
            public var settings: Settings?

            /// Update the status of a live stream. This value can be one of the following:
            /// 
            /// * `start`  Start a webinar live stream.
            /// 
            /// * `stop`  Stop an ongoing webinar live stream.
            public enum Action: String, Codable, CaseIterable {
                case start
                case stop
            }

            /// Update the live stream session's settings. You can **only** update settings for a stopped live stream.
            public struct Settings: Encodable {
                /// Display the name of the active speaker during a live stream.
                public var isActiveSpeakerName: Bool?
                /// Display the name of the live stream.
                public var displayName: String?

                public init(isActiveSpeakerName: Bool? = nil, displayName: String? = nil) {
                    self.isActiveSpeakerName = isActiveSpeakerName
                    self.displayName = displayName
                }

                private enum CodingKeys: String, CodingKey {
                    case isActiveSpeakerName = "active_speaker_name"
                    case displayName = "display_name"
                }
            }

            public init(action: Action? = nil, settings: Settings? = nil) {
                self.action = action
                self.settings = settings
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var inviteLinks: InviteLinks {
        InviteLinks(path: path + "/invite_links")
    }

    public struct InviteLinks {
        /// Path: `/webinars/{webinarId}/invite_links`
        public let path: String

        /// Create webinar's invite links
        ///
        /// Use this API to create a batch of invitation links for a webinar.
        /// 
        /// **Scopes**: `webinar:write:admin`, `webinar:write`</br>**[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light`
        /// 
        /// **Prerequisites:**
        /// 
        /// * Business, Education or API Plan with Webinar add-on.
        public func post(_ body: PostRequest) -> Request<PostResponse> {
            .post(path, body: body)
        }

        public enum PostResponseHeaders {
            /// The location of the created webinar invite links.
            public static let contentLocation = HTTPHeader<String>(field: "Content-Location")
        }

        public struct PostResponse: Decodable {
            /// The attendee list.
            public var attendees: [Attendee]?

            public struct Attendee: Decodable {
                /// The user's display name.
                public var name: String?
                /// The URL to join the meeting.
                public var joinURL: String?

                public init(name: String? = nil, joinURL: String? = nil) {
                    self.name = name
                    self.joinURL = joinURL
                }

                private enum CodingKeys: String, CodingKey {
                    case name
                    case joinURL = "join_url"
                }
            }

            public init(attendees: [Attendee]? = nil) {
                self.attendees = attendees
            }
        }

        public struct PostRequest: Encodable {
            /// The invite link's expiration time, in seconds. 
            /// 
            /// This value defaults to `7200`.
            public var ttl: Int?
            /// The attendees list.
            public var attendees: [Attendee]?

            public struct Attendee: Encodable {
                /// User display name.
                public var name: String

                public init(name: String) {
                    self.name = name
                }
            }

            public init(ttl: Int? = nil, attendees: [Attendee]? = nil) {
                self.ttl = ttl
                self.attendees = attendees
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(ttl, forKey: "ttl")
                try values.encodeIfPresent(attendees, forKey: "attendees")
            }
        }
    }
}

extension Paths.Webinars.WithWebinarID {
    public var survey: Survey {
        Survey(path: path + "/survey")
    }

    public struct Survey {
        /// Path: `/webinars/{webinarId}/survey`
        public let path: String

        /// Get a webinar survey
        ///
        /// Use this API to return information about a [webinar survey](https://support.zoom.us/hc/en-us/articles/360048745651). 
        /// 
        ///  **Scopes:** `webinar:read`, `webinar:read:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Prerequisites:** 
        /// * A Pro or higher plan with the Webinar add-on. 
        /// * The [**Webinar Survey**](https://support.zoom.us/hc/en-us/articles/360061293191-Enabling-webinar-survey) feature enabled in the host's account.
        public var get: Request<GetResponse> {
            .get(path)
        }

        public struct GetResponse: Decodable {
            /// Information about the customized webinar survey.
            public var customSurvey: CustomSurvey?
            /// Whether the **Show in the browser when the webinar ends** option is enabled: 
            /// * `true`  Enabled. 
            /// * `false`  Disabled. 
            /// 
            ///  This value defaults to `true`.
            public var isShowInTheBrowser: Bool
            /// Whether the **Show the link on the follow-up email** option is enabled: 
            /// * `true`  Enabled. 
            /// * `false`  Disabled. 
            /// 
            ///  This value defaults to `false`.
            public var isShowInTheFollowUpEmail: Bool
            /// The link to the third party webinar survey.
            public var thirdPartySurvey: String?

            /// Information about the customized webinar survey.
            public struct CustomSurvey: Decodable {
                /// Whether to allow participants to anonymously answer survey questions: 
                /// * `true`  Anonymous survey enabled. 
                /// * `false`  Participants cannot answer survey questions anonymously. 
                /// 
                ///  This value defaults to `true`.
                public var isAnonymous: Bool
                /// Information about the webinar survey's questions.
                public var questions: [Question]?

                public struct Question: Decodable {
                    /// The survey question, up to 255 characters.
                    public var name: String?
                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public var type: `Type`?
                    /// Whether to display the radio selection as a drop-down box: 
                    /// * `true`  Show as a drop-down box. 
                    /// * `false`  Do not show as a drop-down box. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isShowAsDropdown: Bool
                    /// Whether participants must answer the question: 
                    /// * `true`  The participant must answer the question. 
                    /// * `false`  The participant does not need to answer the question. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isAnswerRequired: Bool
                    /// The survey question's available answers. This field requires a **minimum** of two answers. 
                    /// 
                    /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                    /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                    /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                    public var answers: [String]?
                    /// The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
                    public var answerMinCharacter: Int?
                    /// The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
                    public var answerMaxCharacter: Int?
                    /// The rating scale's minimum value. This value cannot be less than zero. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMinValue: Int?
                    /// The rating scale's maximum value, up to a maximum value of 10. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxValue: Int?
                    /// The low score label used for the `rating_min_value` field. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMinLabel: String?
                    /// The high score label used for the `rating_max_value` field. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxLabel: String?

                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public enum `Type`: String, Codable, CaseIterable {
                        case single
                        case multiple
                        case ratingScale = "rating_scale"
                        case longAnswer = "long_answer"
                    }

                    public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                        self.name = name
                        self.type = type
                        self.isShowAsDropdown = isShowAsDropdown ?? false
                        self.isAnswerRequired = isAnswerRequired ?? false
                        self.answers = answers
                        self.answerMinCharacter = answerMinCharacter
                        self.answerMaxCharacter = answerMaxCharacter
                        self.ratingMinValue = ratingMinValue
                        self.ratingMaxValue = ratingMaxValue
                        self.ratingMinLabel = ratingMinLabel
                        self.ratingMaxLabel = ratingMaxLabel
                    }

                    private enum CodingKeys: String, CodingKey {
                        case name
                        case type
                        case isShowAsDropdown = "show_as_dropdown"
                        case isAnswerRequired = "answer_required"
                        case answers
                        case answerMinCharacter = "answer_min_character"
                        case answerMaxCharacter = "answer_max_character"
                        case ratingMinValue = "rating_min_value"
                        case ratingMaxValue = "rating_max_value"
                        case ratingMinLabel = "rating_min_label"
                        case ratingMaxLabel = "rating_max_label"
                    }

                    public init(from decoder: Decoder) throws {
                        let values = try decoder.container(keyedBy: CodingKeys.self)
                        self.name = try values.decodeIfPresent(String.self, forKey: .name)
                        self.type = try values.decodeIfPresent(`Type`.self, forKey: .type)
                        self.isShowAsDropdown = try values.decodeIfPresent(Bool.self, forKey: .isShowAsDropdown) ?? false
                        self.isAnswerRequired = try values.decodeIfPresent(Bool.self, forKey: .isAnswerRequired) ?? false
                        self.answers = try values.decodeIfPresent([String].self, forKey: .answers)
                        self.answerMinCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMinCharacter)
                        self.answerMaxCharacter = try values.decodeIfPresent(Int.self, forKey: .answerMaxCharacter)
                        self.ratingMinValue = try values.decodeIfPresent(Int.self, forKey: .ratingMinValue)
                        self.ratingMaxValue = try values.decodeIfPresent(Int.self, forKey: .ratingMaxValue)
                        self.ratingMinLabel = try values.decodeIfPresent(String.self, forKey: .ratingMinLabel)
                        self.ratingMaxLabel = try values.decodeIfPresent(String.self, forKey: .ratingMaxLabel)
                    }
                }

                public init(isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                    self.isAnonymous = isAnonymous ?? false
                    self.questions = questions
                }

                private enum CodingKeys: String, CodingKey {
                    case isAnonymous = "anonymous"
                    case questions
                }

                public init(from decoder: Decoder) throws {
                    let values = try decoder.container(keyedBy: CodingKeys.self)
                    self.isAnonymous = try values.decodeIfPresent(Bool.self, forKey: .isAnonymous) ?? false
                    self.questions = try values.decodeIfPresent([Question].self, forKey: .questions)
                }
            }

            public init(customSurvey: CustomSurvey? = nil, isShowInTheBrowser: Bool? = nil, isShowInTheFollowUpEmail: Bool? = nil, thirdPartySurvey: String? = nil) {
                self.customSurvey = customSurvey
                self.isShowInTheBrowser = isShowInTheBrowser ?? true
                self.isShowInTheFollowUpEmail = isShowInTheFollowUpEmail ?? false
                self.thirdPartySurvey = thirdPartySurvey
            }

            private enum CodingKeys: String, CodingKey {
                case customSurvey = "custom_survey"
                case isShowInTheBrowser = "show_in_the_browser"
                case isShowInTheFollowUpEmail = "show_in_the_follow_up_email"
                case thirdPartySurvey = "third_party_survey"
            }

            public init(from decoder: Decoder) throws {
                let values = try decoder.container(keyedBy: CodingKeys.self)
                self.customSurvey = try values.decodeIfPresent(CustomSurvey.self, forKey: .customSurvey)
                self.isShowInTheBrowser = try values.decodeIfPresent(Bool.self, forKey: .isShowInTheBrowser) ?? true
                self.isShowInTheFollowUpEmail = try values.decodeIfPresent(Bool.self, forKey: .isShowInTheFollowUpEmail) ?? false
                self.thirdPartySurvey = try values.decodeIfPresent(String.self, forKey: .thirdPartySurvey)
            }
        }

        /// Update a webinar survey
        ///
        /// Use this API to update a [webinar survey](https://support.zoom.us/hc/en-us/articles/360048745651). 
        /// 
        ///  **Scopes:** `webinar:write`, `webinar:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Prerequisites:** 
        /// * A Pro or higher plan with the Webinar add-on. 
        /// * The [**Webinar Survey**](https://support.zoom.us/hc/en-us/articles/360061293191-Enabling-webinar-survey) feature enabled in the host's account.
        public func patch(_ body: PatchRequest) -> Request<Void> {
            .patch(path, body: body)
        }

        public struct PatchRequest: Encodable {
            /// The link to the third party webinar survey.
            public var thirdPartySurvey: String?
            /// Information about the customized webinar survey.
            public var customSurvey: CustomSurvey?
            /// Whether the **Show the link on the follow-up email** option is enabled: 
            /// * `true`  Enabled. 
            /// * `false`  Disabled. 
            /// 
            ///  This value defaults to `false`.
            public var isShowInTheFollowUpEmail: Bool
            /// Whether the **Show in the browser when the webinar ends** option is enabled: 
            /// * `true`  Enabled. 
            /// * `false`  Disabled. 
            /// 
            ///  This value defaults to `true`.
            public var isShowInTheBrowser: Bool

            /// Information about the customized webinar survey.
            public struct CustomSurvey: Encodable {
                /// Whether to allow participants to anonymously answer survey questions: 
                /// * `true`  Anonymous survey enabled. 
                /// * `false`  Participants cannot answer survey questions anonymously. 
                /// 
                ///  This value defaults to `true`.
                public var isAnonymous: Bool
                /// Information about the webinar survey's questions.
                public var questions: [Question]?

                public struct Question: Encodable {
                    /// The survey question, up to 255 characters.
                    public var name: String?
                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public var type: `Type`?
                    /// Whether to display the radio selection as a drop-down box: 
                    /// * `true`  Show as a drop-down box. 
                    /// * `false`  Do not show as a drop-down box. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isShowAsDropdown: Bool
                    /// Whether participants must answer the question: 
                    /// * `true`  The participant must answer the question. 
                    /// * `false`  The participant does not need to answer the question. 
                    /// 
                    ///  This value defaults to `false`.
                    public var isAnswerRequired: Bool
                    /// The survey question's available answers. This field requires a **minimum** of two answers. 
                    /// 
                    /// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers. 
                    /// * For `matching` polls, you can only provide a maximum of 16 answers. 
                    /// * For `rank_order` polls, you can only provide a maximum of seven answers.
                    public var answers: [String]?
                    /// The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
                    public var answerMinCharacter: Int?
                    /// The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
                    public var answerMaxCharacter: Int?
                    /// The rating scale's minimum value. This value cannot be less than zero. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMinValue: Int?
                    /// The rating scale's maximum value, up to a maximum value of 10. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxValue: Int?
                    /// The low score label used for the `rating_min_value` field. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMinLabel: String?
                    /// The high score label used for the `rating_max_value` field. 
                    /// 
                    ///  This field only applies to the `rating_scale` survey.
                    public var ratingMaxLabel: String?

                    /// The survey's question and answer type: 
                    /// * `single`  Single choice. 
                    /// * `mutliple`  Multiple choice. 
                    /// * `rating_scale`  Rating scale. 
                    /// * `long_answer`  Long answer.
                    public enum `Type`: String, Codable, CaseIterable {
                        case single
                        case multiple
                        case ratingScale = "rating_scale"
                        case longAnswer = "long_answer"
                    }

                    public init(name: String? = nil, type: `Type`? = nil, isShowAsDropdown: Bool? = nil, isAnswerRequired: Bool? = nil, answers: [String]? = nil, answerMinCharacter: Int? = nil, answerMaxCharacter: Int? = nil, ratingMinValue: Int? = nil, ratingMaxValue: Int? = nil, ratingMinLabel: String? = nil, ratingMaxLabel: String? = nil) {
                        self.name = name
                        self.type = type
                        self.isShowAsDropdown = isShowAsDropdown ?? false
                        self.isAnswerRequired = isAnswerRequired ?? false
                        self.answers = answers
                        self.answerMinCharacter = answerMinCharacter
                        self.answerMaxCharacter = answerMaxCharacter
                        self.ratingMinValue = ratingMinValue
                        self.ratingMaxValue = ratingMaxValue
                        self.ratingMinLabel = ratingMinLabel
                        self.ratingMaxLabel = ratingMaxLabel
                    }

                    private enum CodingKeys: String, CodingKey {
                        case name
                        case type
                        case isShowAsDropdown = "show_as_dropdown"
                        case isAnswerRequired = "answer_required"
                        case answers
                        case answerMinCharacter = "answer_min_character"
                        case answerMaxCharacter = "answer_max_character"
                        case ratingMinValue = "rating_min_value"
                        case ratingMaxValue = "rating_max_value"
                        case ratingMinLabel = "rating_min_label"
                        case ratingMaxLabel = "rating_max_label"
                    }
                }

                public init(isAnonymous: Bool? = nil, questions: [Question]? = nil) {
                    self.isAnonymous = isAnonymous ?? false
                    self.questions = questions
                }

                private enum CodingKeys: String, CodingKey {
                    case isAnonymous = "anonymous"
                    case questions
                }
            }

            public init(thirdPartySurvey: String? = nil, customSurvey: CustomSurvey? = nil, isShowInTheFollowUpEmail: Bool? = nil, isShowInTheBrowser: Bool? = nil) {
                self.thirdPartySurvey = thirdPartySurvey
                self.customSurvey = customSurvey
                self.isShowInTheFollowUpEmail = isShowInTheFollowUpEmail ?? false
                self.isShowInTheBrowser = isShowInTheBrowser ?? true
            }

            public func encode(to encoder: Encoder) throws {
                var values = encoder.container(keyedBy: StringCodingKey.self)
                try values.encodeIfPresent(thirdPartySurvey, forKey: "third_party_survey")
                try values.encodeIfPresent(customSurvey, forKey: "custom_survey")
                try values.encodeIfPresent(isShowInTheFollowUpEmail, forKey: "show_in_the_follow_up_email")
                try values.encodeIfPresent(isShowInTheBrowser, forKey: "show_in_the_browser")
            }
        }

        /// Delete a webinar survey
        ///
        /// Use this API to delete a [webinar survey](https://support.zoom.us/hc/en-us/articles/360048745651). 
        /// 
        ///  **Scopes:** `webinar:write`, `webinar:write:admin` <br> **[Rate Limit Label](https://marketplace.zoom.us/docs/api-reference/rate-limits#rate-limits):** `Light` 
        /// 
        ///  **Prerequisites:** 
        /// * A Pro or higher plan with the Webinar Add-on. 
        /// * The [**Webinar Survey**](https://support.zoom.us/hc/en-us/articles/360061293191-Enabling-webinar-survey) feature enabled in the host's account.
        public var delete: Request<Void> {
            .delete(path)
        }
    }
}

public enum Paths {}
