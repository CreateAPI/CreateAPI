// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation

/// An open port on a container
///
/// Example:
///
/// {
///   "PrivatePort" : 8080,
///   "PublicPort" : 80,
///   "Type" : "tcp"
/// }
public struct Port: Codable {
    public var ip: String?
    /// Port on the container
    public var privatePort: Int
    /// Port exposed on the host
    public var publicPort: Int?
    public var type: `Type`

    public enum `Type`: String, Codable, CaseIterable {
        case tcp
        case udp
    }

    public init(ip: String? = nil, privatePort: Int, publicPort: Int? = nil, type: `Type`) {
        self.ip = ip
        self.privatePort = privatePort
        self.publicPort = publicPort
        self.type = type
    }

    private enum CodingKeys: String, CodingKey {
        case ip = "IP"
        case privatePort = "PrivatePort"
        case publicPort = "PublicPort"
        case type = "Type"
    }
}

/// A mount point inside a container
public struct MountPoint: Codable {
    public var type: String?
    public var name: String?
    public var source: String?
    public var destination: String?
    public var driver: String?
    public var mode: String?
    public var isRw: Bool?
    public var propagation: String?

    public init(type: String? = nil, name: String? = nil, source: String? = nil, destination: String? = nil, driver: String? = nil, mode: String? = nil, isRw: Bool? = nil, propagation: String? = nil) {
        self.type = type
        self.name = name
        self.source = source
        self.destination = destination
        self.driver = driver
        self.mode = mode
        self.isRw = isRw
        self.propagation = propagation
    }

    private enum CodingKeys: String, CodingKey {
        case type = "Type"
        case name = "Name"
        case source = "Source"
        case destination = "Destination"
        case driver = "Driver"
        case mode = "Mode"
        case isRw = "RW"
        case propagation = "Propagation"
    }
}

/// A device mapping between the host and container
///
/// Example:
///
/// {
///   "CgroupPermissions" : "mrw",
///   "PathInContainer" : "\/dev\/deviceName",
///   "PathOnHost" : "\/dev\/deviceName"
/// }
public struct DeviceMapping: Codable {
    public var pathOnHost: String?
    public var pathInContainer: String?
    public var cgroupPermissions: String?

    public init(pathOnHost: String? = nil, pathInContainer: String? = nil, cgroupPermissions: String? = nil) {
        self.pathOnHost = pathOnHost
        self.pathInContainer = pathInContainer
        self.cgroupPermissions = cgroupPermissions
    }

    private enum CodingKeys: String, CodingKey {
        case pathOnHost = "PathOnHost"
        case pathInContainer = "PathInContainer"
        case cgroupPermissions = "CgroupPermissions"
    }
}

public struct ThrottleDevice: Codable {
    /// Device path
    public var path: String?
    /// Rate
    public var rate: Int?

    public init(path: String? = nil, rate: Int? = nil) {
        self.path = path
        self.rate = rate
    }

    private enum CodingKeys: String, CodingKey {
        case path = "Path"
        case rate = "Rate"
    }
}

public struct Mount: Codable {
    /// Container path.
    public var target: String?
    /// Mount source (e.g. a volume name, a host path).
    public var source: String?
    /// The mount type. Available types:
    /// 
    /// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
    /// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
    /// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
    public var type: `Type`?
    /// Whether the mount should be read-only.
    public var isReadOnly: Bool?
    /// The consistency requirement for the mount: `default`, `consistent`, `cached`, or `delegated`.
    public var consistency: String?
    /// Optional configuration for the `bind` type.
    public var bindOptions: BindOptions?
    /// Optional configuration for the `volume` type.
    public var volumeOptions: VolumeOptions?
    /// Optional configuration for the `tmpfs` type.
    public var tmpfsOptions: TmpfsOptions?

    /// The mount type. Available types:
    /// 
    /// - `bind` Mounts a file or directory from the host into the container. Must exist prior to creating the container.
    /// - `volume` Creates a volume with the given name and options (or uses a pre-existing volume with the same name and options). These are **not** removed when the container is removed.
    /// - `tmpfs` Create a tmpfs with the given options. The mount source cannot be specified for tmpfs.
    public enum `Type`: String, Codable, CaseIterable {
        case bind
        case volume
        case tmpfs
    }

    /// Optional configuration for the `bind` type.
    public struct BindOptions: Codable {
        /// A propagation mode with the value `[r]private`, `[r]shared`, or `[r]slave`.
        public var propagation: [String: AnyJSON]?

        public init(propagation: [String: AnyJSON]? = nil) {
            self.propagation = propagation
        }

        private enum CodingKeys: String, CodingKey {
            case propagation = "Propagation"
        }
    }

    /// Optional configuration for the `volume` type.
    public struct VolumeOptions: Codable {
        /// Populate volume with data from the target.
        public var isNoCopy: Bool
        /// User-defined key/value metadata.
        public var labels: [String: String]?
        /// Map of driver specific options
        public var driverConfig: DriverConfig?

        /// Map of driver specific options
        public struct DriverConfig: Codable {
            /// Name of the driver to use to create the volume.
            public var name: String?
            /// Key/value map of driver specific options.
            public var options: [String: String]?

            public init(name: String? = nil, options: [String: String]? = nil) {
                self.name = name
                self.options = options
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case options = "Options"
            }
        }

        public init(isNoCopy: Bool? = nil, labels: [String: String]? = nil, driverConfig: DriverConfig? = nil) {
            self.isNoCopy = isNoCopy ?? false
            self.labels = labels
            self.driverConfig = driverConfig
        }

        private enum CodingKeys: String, CodingKey {
            case isNoCopy = "NoCopy"
            case labels = "Labels"
            case driverConfig = "DriverConfig"
        }

        public init(from decoder: Decoder) throws {
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.isNoCopy = try values.decodeIfPresent(Bool.self, forKey: .isNoCopy) ?? false
            self.labels = try values.decodeIfPresent([String: String].self, forKey: .labels)
            self.driverConfig = try values.decodeIfPresent(DriverConfig.self, forKey: .driverConfig)
        }
    }

    /// Optional configuration for the `tmpfs` type.
    public struct TmpfsOptions: Codable {
        /// The size for the tmpfs mount in bytes.
        public var sizeBytes: Int?
        /// The permission mode for the tmpfs mount in an integer.
        public var mode: Int?

        public init(sizeBytes: Int? = nil, mode: Int? = nil) {
            self.sizeBytes = sizeBytes
            self.mode = mode
        }

        private enum CodingKeys: String, CodingKey {
            case sizeBytes = "SizeBytes"
            case mode = "Mode"
        }
    }

    public init(target: String? = nil, source: String? = nil, type: `Type`? = nil, isReadOnly: Bool? = nil, consistency: String? = nil, bindOptions: BindOptions? = nil, volumeOptions: VolumeOptions? = nil, tmpfsOptions: TmpfsOptions? = nil) {
        self.target = target
        self.source = source
        self.type = type
        self.isReadOnly = isReadOnly
        self.consistency = consistency
        self.bindOptions = bindOptions
        self.volumeOptions = volumeOptions
        self.tmpfsOptions = tmpfsOptions
    }

    private enum CodingKeys: String, CodingKey {
        case target = "Target"
        case source = "Source"
        case type = "Type"
        case isReadOnly = "ReadOnly"
        case consistency = "Consistency"
        case bindOptions = "BindOptions"
        case volumeOptions = "VolumeOptions"
        case tmpfsOptions = "TmpfsOptions"
    }
}

/// The behavior to apply when the container exits. The default is not to restart.
/// 
/// An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server.
public struct RestartPolicy: Codable {
    /// - Empty string means not to restart
    /// - `always` Always restart
    /// - `unless-stopped` Restart always except when the user has manually stopped the container
    /// - `on-failure` Restart only when the container exit code is non-zero
    public var name: Name?
    /// If `on-failure` is used, the number of times to retry before giving up
    public var maximumRetryCount: Int?

    /// - Empty string means not to restart
    /// - `always` Always restart
    /// - `unless-stopped` Restart always except when the user has manually stopped the container
    /// - `on-failure` Restart only when the container exit code is non-zero
    public enum Name: String, Codable, CaseIterable {
        case empty = ""
        case always
        case unlessStopped = "unless-stopped"
        case onFailure = "on-failure"
    }

    public init(name: Name? = nil, maximumRetryCount: Int? = nil) {
        self.name = name
        self.maximumRetryCount = maximumRetryCount
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case maximumRetryCount = "MaximumRetryCount"
    }
}

/// A container's resources (cgroups config, ulimits, etc)
public struct Resources: Codable {
    /// An integer value representing this container's relative CPU weight versus other containers.
    public var cpuShares: Int?
    /// Memory limit in bytes.
    public var memory: Int?
    /// Path to `cgroups` under which the container's `cgroup` is created. If the path is not absolute, the path is considered to be relative to the `cgroups` path of the init process. Cgroups are created if they do not already exist.
    public var cgroupParent: String?
    /// Block IO weight (relative weight).
    public var blkioWeight: Int?
    /// Block IO weight (relative device weight) in the form `[{"Path": "device_path", "Weight": weight}]`.
    public var blkioWeightDevice: [BlkioWeightDeviceItem]?
    /// Limit read rate (bytes per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
    public var blkioDeviceReadBps: [ThrottleDevice]?
    /// Limit write rate (bytes per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
    public var blkioDeviceWriteBps: [ThrottleDevice]?
    /// Limit read rate (IO per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
    public var blkioDeviceReadIOps: [ThrottleDevice]?
    /// Limit write rate (IO per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
    public var blkioDeviceWriteIOps: [ThrottleDevice]?
    /// The length of a CPU period in microseconds.
    public var cpuPeriod: Int?
    /// Microseconds of CPU time that the container can get in a CPU period.
    public var cpuQuota: Int?
    /// The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
    public var cpuRealtimePeriod: Int?
    /// The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks.
    public var cpuRealtimeRuntime: Int?
    /// CPUs in which to allow execution (e.g., `0-3`, `0,1`)
    ///
    /// Example: -3
    public var cpusetCpus: String?
    /// Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems.
    public var cpusetMems: String?
    /// A list of devices to add to the container.
    public var devices: [DeviceMapping]?
    /// A list of cgroup rules to apply to the container
    public var deviceCgroupRules: [String]?
    /// Disk limit (in bytes).
    public var diskQuota: Int?
    /// Kernel memory limit in bytes.
    public var kernelMemory: Int?
    /// Memory soft limit in bytes.
    public var memoryReservation: Int?
    /// Total memory limit (memory + swap). Set as `-1` to enable unlimited swap.
    public var memorySwap: Int?
    /// Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100.
    public var memorySwappiness: Int?
    /// CPU quota in units of 10<sup>-9</sup> CPUs.
    public var nanoCPUs: Int?
    /// Disable OOM Killer for the container.
    public var isOomKillDisable: Bool?
    /// Tune a container's pids limit. Set -1 for unlimited.
    public var pidsLimit: Int?
    /// A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"
    public var ulimits: [Ulimit]?
    /// The number of usable CPUs (Windows only).
    /// 
    /// On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.
    public var cpuCount: Int?
    /// The usable percentage of the available CPUs (Windows only).
    /// 
    /// On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.
    public var cpuPercent: Int?
    /// Maximum IOps for the container system drive (Windows only)
    public var iOMaximumIOps: Int?
    /// Maximum IO in bytes per second for the container system drive (Windows only)
    public var iOMaximumBandwidth: Int?

    public struct BlkioWeightDeviceItem: Codable {
        public var path: String?
        public var weight: Int?

        public init(path: String? = nil, weight: Int? = nil) {
            self.path = path
            self.weight = weight
        }

        private enum CodingKeys: String, CodingKey {
            case path = "Path"
            case weight = "Weight"
        }
    }

    public struct Ulimit: Codable {
        /// Name of ulimit
        public var name: String?
        /// Soft limit
        public var soft: Int?
        /// Hard limit
        public var hard: Int?

        public init(name: String? = nil, soft: Int? = nil, hard: Int? = nil) {
            self.name = name
            self.soft = soft
            self.hard = hard
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case soft = "Soft"
            case hard = "Hard"
        }
    }

    public init(cpuShares: Int? = nil, memory: Int? = nil, cgroupParent: String? = nil, blkioWeight: Int? = nil, blkioWeightDevice: [BlkioWeightDeviceItem]? = nil, blkioDeviceReadBps: [ThrottleDevice]? = nil, blkioDeviceWriteBps: [ThrottleDevice]? = nil, blkioDeviceReadIOps: [ThrottleDevice]? = nil, blkioDeviceWriteIOps: [ThrottleDevice]? = nil, cpuPeriod: Int? = nil, cpuQuota: Int? = nil, cpuRealtimePeriod: Int? = nil, cpuRealtimeRuntime: Int? = nil, cpusetCpus: String? = nil, cpusetMems: String? = nil, devices: [DeviceMapping]? = nil, deviceCgroupRules: [String]? = nil, diskQuota: Int? = nil, kernelMemory: Int? = nil, memoryReservation: Int? = nil, memorySwap: Int? = nil, memorySwappiness: Int? = nil, nanoCPUs: Int? = nil, isOomKillDisable: Bool? = nil, pidsLimit: Int? = nil, ulimits: [Ulimit]? = nil, cpuCount: Int? = nil, cpuPercent: Int? = nil, iOMaximumIOps: Int? = nil, iOMaximumBandwidth: Int? = nil) {
        self.cpuShares = cpuShares
        self.memory = memory
        self.cgroupParent = cgroupParent
        self.blkioWeight = blkioWeight
        self.blkioWeightDevice = blkioWeightDevice
        self.blkioDeviceReadBps = blkioDeviceReadBps
        self.blkioDeviceWriteBps = blkioDeviceWriteBps
        self.blkioDeviceReadIOps = blkioDeviceReadIOps
        self.blkioDeviceWriteIOps = blkioDeviceWriteIOps
        self.cpuPeriod = cpuPeriod
        self.cpuQuota = cpuQuota
        self.cpuRealtimePeriod = cpuRealtimePeriod
        self.cpuRealtimeRuntime = cpuRealtimeRuntime
        self.cpusetCpus = cpusetCpus
        self.cpusetMems = cpusetMems
        self.devices = devices
        self.deviceCgroupRules = deviceCgroupRules
        self.diskQuota = diskQuota
        self.kernelMemory = kernelMemory
        self.memoryReservation = memoryReservation
        self.memorySwap = memorySwap
        self.memorySwappiness = memorySwappiness
        self.nanoCPUs = nanoCPUs
        self.isOomKillDisable = isOomKillDisable
        self.pidsLimit = pidsLimit
        self.ulimits = ulimits
        self.cpuCount = cpuCount
        self.cpuPercent = cpuPercent
        self.iOMaximumIOps = iOMaximumIOps
        self.iOMaximumBandwidth = iOMaximumBandwidth
    }

    private enum CodingKeys: String, CodingKey {
        case cpuShares = "CpuShares"
        case memory = "Memory"
        case cgroupParent = "CgroupParent"
        case blkioWeight = "BlkioWeight"
        case blkioWeightDevice = "BlkioWeightDevice"
        case blkioDeviceReadBps = "BlkioDeviceReadBps"
        case blkioDeviceWriteBps = "BlkioDeviceWriteBps"
        case blkioDeviceReadIOps = "BlkioDeviceReadIOps"
        case blkioDeviceWriteIOps = "BlkioDeviceWriteIOps"
        case cpuPeriod = "CpuPeriod"
        case cpuQuota = "CpuQuota"
        case cpuRealtimePeriod = "CpuRealtimePeriod"
        case cpuRealtimeRuntime = "CpuRealtimeRuntime"
        case cpusetCpus = "CpusetCpus"
        case cpusetMems = "CpusetMems"
        case devices = "Devices"
        case deviceCgroupRules = "DeviceCgroupRules"
        case diskQuota = "DiskQuota"
        case kernelMemory = "KernelMemory"
        case memoryReservation = "MemoryReservation"
        case memorySwap = "MemorySwap"
        case memorySwappiness = "MemorySwappiness"
        case nanoCPUs = "NanoCPUs"
        case isOomKillDisable = "OomKillDisable"
        case pidsLimit = "PidsLimit"
        case ulimits = "Ulimits"
        case cpuCount = "CpuCount"
        case cpuPercent = "CpuPercent"
        case iOMaximumIOps = "IOMaximumIOps"
        case iOMaximumBandwidth = "IOMaximumBandwidth"
    }
}

/// An object describing the resources which can be advertised by a node and requested by a task
public struct ResourceObject: Codable {
    /// Example: 4000000000
    public var nanoCPUs: Int?
    /// Example: 8272408576
    public var memoryBytes: Int?
    /// User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, `GPU=UUID1`)
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "DiscreteResourceSpec" : {
    ///       "Kind" : "SSD",
    ///       "Value" : 3
    ///     }
    ///   },
    ///   {
    ///     "NamedResourceSpec" : {
    ///       "Kind" : "GPU",
    ///       "Value" : "UUID1"
    ///     }
    ///   },
    ///   {
    ///     "NamedResourceSpec" : {
    ///       "Kind" : "GPU",
    ///       "Value" : "UUID2"
    ///     }
    ///   }
    /// ]
    public var genericResources: [GenericResource]?

    public init(nanoCPUs: Int? = nil, memoryBytes: Int? = nil, genericResources: [GenericResource]? = nil) {
        self.nanoCPUs = nanoCPUs
        self.memoryBytes = memoryBytes
        self.genericResources = genericResources
    }

    private enum CodingKeys: String, CodingKey {
        case nanoCPUs = "NanoCPUs"
        case memoryBytes = "MemoryBytes"
        case genericResources = "GenericResources"
    }
}

public struct GenericResource: Codable {
    public var namedResourceSpec: NamedResourceSpec?
    public var discreteResourceSpec: DiscreteResourceSpec?

    public struct NamedResourceSpec: Codable {
        public var kind: String?
        public var value: String?

        public init(kind: String? = nil, value: String? = nil) {
            self.kind = kind
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case kind = "Kind"
            case value = "Value"
        }
    }

    public struct DiscreteResourceSpec: Codable {
        public var kind: String?
        public var value: Int?

        public init(kind: String? = nil, value: Int? = nil) {
            self.kind = kind
            self.value = value
        }

        private enum CodingKeys: String, CodingKey {
            case kind = "Kind"
            case value = "Value"
        }
    }

    public init(namedResourceSpec: NamedResourceSpec? = nil, discreteResourceSpec: DiscreteResourceSpec? = nil) {
        self.namedResourceSpec = namedResourceSpec
        self.discreteResourceSpec = discreteResourceSpec
    }

    private enum CodingKeys: String, CodingKey {
        case namedResourceSpec = "NamedResourceSpec"
        case discreteResourceSpec = "DiscreteResourceSpec"
    }
}

/// A test to perform to check that the container is healthy.
public struct HealthConfig: Codable {
    /// The test to perform. Possible values are:
    /// 
    /// - `[]` inherit healthcheck from image or parent image
    /// - `["NONE"]` disable healthcheck
    /// - `["CMD", args...]` exec arguments directly
    /// - `["CMD-SHELL", command]` run command with system's default shell
    public var test: [String]?
    /// The time to wait between checks in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
    public var interval: Int?
    /// The time to wait before considering the check to have hung. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
    public var timeout: Int?
    /// The number of consecutive failures needed to consider a container as unhealthy. 0 means inherit.
    public var retries: Int?
    /// Start period for the container to initialize before starting health-retries countdown in nanoseconds. It should be 0 or at least 1000000 (1 ms). 0 means inherit.
    public var startPeriod: Int?

    public init(test: [String]? = nil, interval: Int? = nil, timeout: Int? = nil, retries: Int? = nil, startPeriod: Int? = nil) {
        self.test = test
        self.interval = interval
        self.timeout = timeout
        self.retries = retries
        self.startPeriod = startPeriod
    }

    private enum CodingKeys: String, CodingKey {
        case test = "Test"
        case interval = "Interval"
        case timeout = "Timeout"
        case retries = "Retries"
        case startPeriod = "StartPeriod"
    }
}

/// Container configuration that depends on the host we are running on
public struct HostConfig: Codable {
    /// A container's resources (cgroups config, ulimits, etc)
    public var resources: Resources
    /// A list of volume bindings for this container. Each volume binding is a string in one of these forms:
    /// 
    /// - `host-src:container-dest` to bind-mount a host path into the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
    /// - `host-src:container-dest:ro` to make the bind mount read-only inside the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
    /// - `volume-name:container-dest` to bind-mount a volume managed by a volume driver into the container. `container-dest` must be an _absolute_ path.
    /// - `volume-name:container-dest:ro` to mount the volume read-only inside the container.  `container-dest` must be an _absolute_ path.
    public var binds: [String]?
    /// Path to a file where the container ID is written
    public var containerIDFile: String?
    /// The logging configuration for this container
    public var logConfig: LogConfig?
    /// Network mode to use for this container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to.
    public var networkMode: String?
    /// A map of exposed container ports and the host port they should map to.
    public var portBindings: [String: PortBinding]?
    /// The behavior to apply when the container exits. The default is not to restart.
    /// 
    /// An ever increasing delay (double the previous delay, starting at 100ms) is added before each restart to prevent flooding the server.
    public var restartPolicy: RestartPolicy?
    /// Automatically remove the container when the container's process exits. This has no effect if `RestartPolicy` is set.
    public var isAutoRemove: Bool?
    /// Driver that this container uses to mount volumes.
    public var volumeDriver: String?
    /// A list of volumes to inherit from another container, specified in the form `<container name>[:<ro|rw>]`.
    public var volumesFrom: [String]?
    /// Specification for mounts to be added to the container.
    public var mounts: [Mount]?
    /// A list of kernel capabilities to add to the container.
    public var capAdd: [String]?
    /// A list of kernel capabilities to drop from the container.
    public var capDrop: [String]?
    /// A list of DNS servers for the container to use.
    public var dns: [String]?
    /// A list of DNS options.
    public var dnsOptions: [String]?
    /// A list of DNS search domains.
    public var dnsSearch: [String]?
    /// A list of hostnames/IP mappings to add to the container's `/etc/hosts` file. Specified in the form `["hostname:IP"]`.
    public var extraHosts: [String]?
    /// A list of additional groups that the container process will run as.
    public var groupAdd: [String]?
    /// IPC sharing mode for the container. Possible values are:
    /// 
    /// - `"none"`: own private IPC namespace, with /dev/shm not mounted
    /// - `"private"`: own private IPC namespace
    /// - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
    /// - `"container:<name|id>"`: join another (shareable) container's IPC namespace
    /// - `"host"`: use the host system's IPC namespace
    /// 
    /// If not specified, daemon default is used, which can either be `"private"`
    /// or `"shareable"`, depending on daemon version and configuration.
    public var ipcMode: String?
    /// Cgroup to use for the container.
    public var cgroup: String?
    /// A list of links for the container in the form `container_name:alias`.
    public var links: [String]?
    /// An integer value containing the score given to the container in order to tune OOM killer preferences.
    ///
    /// Example: 500
    public var oomScoreAdj: Int?
    /// Set the PID (Process) Namespace mode for the container. It can be either:
    /// 
    /// - `"container:<name|id>"`: joins another container's PID namespace
    /// - `"host"`: use the host's PID namespace inside the container
    public var pidMode: String?
    /// Gives the container full access to the host.
    public var isPrivileged: Bool?
    /// Allocates a random host port for all of a container's exposed ports.
    public var isPublishAllPorts: Bool?
    /// Mount the container's root filesystem as read only.
    public var isReadonlyRootfs: Bool?
    /// A list of string values to customize labels for MLS systems, such as SELinux.
    public var securityOpt: [String]?
    /// Storage driver options for this container, in the form `{"size": "120G"}`.
    public var storageOpt: [String: String]?
    /// A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: `{ "/run": "rw,noexec,nosuid,size=65536k" }`.
    public var tmpfs: [String: String]?
    /// UTS namespace to use for the container.
    public var uTSMode: String?
    /// Sets the usernamespace mode for the container when usernamespace remapping option is enabled.
    public var usernsMode: String?
    /// Size of `/dev/shm` in bytes. If omitted, the system uses 64MB.
    public var shmSize: Int?
    /// A list of kernel parameters (sysctls) to set in the container. For example: `{"net.ipv4.ip_forward": "1"}`
    public var sysctls: [String: String]?
    /// Runtime to use with this container.
    public var runtime: String?
    /// Initial console size, as an `[height, width]` array. (Windows only)
    public var consoleSize: [Int]?
    /// Isolation technology of the container. (Windows only)
    public var isolation: Isolation?

    /// The logging configuration for this container
    public struct LogConfig: Codable {
        public var type: `Type`?
        public var config: [String: String]?

        public enum `Type`: String, Codable, CaseIterable {
            case jsonFile = "json-file"
            case syslog
            case journald
            case gelf
            case fluentd
            case awslogs
            case splunk
            case etwlogs
            case `none`
        }

        public init(type: `Type`? = nil, config: [String: String]? = nil) {
            self.type = type
            self.config = config
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case config = "Config"
        }
    }

    public struct PortBinding: Codable {
        /// The host IP address
        public var hostIp: String?
        /// The host port number, as a string
        public var hostPort: String?

        public init(hostIp: String? = nil, hostPort: String? = nil) {
            self.hostIp = hostIp
            self.hostPort = hostPort
        }

        private enum CodingKeys: String, CodingKey {
            case hostIp = "HostIp"
            case hostPort = "HostPort"
        }
    }

    /// Isolation technology of the container. (Windows only)
    public enum Isolation: String, Codable, CaseIterable {
        case `default`
        case process
        case hyperv
    }

    public init(resources: Resources, binds: [String]? = nil, containerIDFile: String? = nil, logConfig: LogConfig? = nil, networkMode: String? = nil, portBindings: [String: PortBinding]? = nil, restartPolicy: RestartPolicy? = nil, isAutoRemove: Bool? = nil, volumeDriver: String? = nil, volumesFrom: [String]? = nil, mounts: [Mount]? = nil, capAdd: [String]? = nil, capDrop: [String]? = nil, dns: [String]? = nil, dnsOptions: [String]? = nil, dnsSearch: [String]? = nil, extraHosts: [String]? = nil, groupAdd: [String]? = nil, ipcMode: String? = nil, cgroup: String? = nil, links: [String]? = nil, oomScoreAdj: Int? = nil, pidMode: String? = nil, isPrivileged: Bool? = nil, isPublishAllPorts: Bool? = nil, isReadonlyRootfs: Bool? = nil, securityOpt: [String]? = nil, storageOpt: [String: String]? = nil, tmpfs: [String: String]? = nil, uTSMode: String? = nil, usernsMode: String? = nil, shmSize: Int? = nil, sysctls: [String: String]? = nil, runtime: String? = nil, consoleSize: [Int]? = nil, isolation: Isolation? = nil) {
        self.resources = resources
        self.binds = binds
        self.containerIDFile = containerIDFile
        self.logConfig = logConfig
        self.networkMode = networkMode
        self.portBindings = portBindings
        self.restartPolicy = restartPolicy
        self.isAutoRemove = isAutoRemove
        self.volumeDriver = volumeDriver
        self.volumesFrom = volumesFrom
        self.mounts = mounts
        self.capAdd = capAdd
        self.capDrop = capDrop
        self.dns = dns
        self.dnsOptions = dnsOptions
        self.dnsSearch = dnsSearch
        self.extraHosts = extraHosts
        self.groupAdd = groupAdd
        self.ipcMode = ipcMode
        self.cgroup = cgroup
        self.links = links
        self.oomScoreAdj = oomScoreAdj
        self.pidMode = pidMode
        self.isPrivileged = isPrivileged
        self.isPublishAllPorts = isPublishAllPorts
        self.isReadonlyRootfs = isReadonlyRootfs
        self.securityOpt = securityOpt
        self.storageOpt = storageOpt
        self.tmpfs = tmpfs
        self.uTSMode = uTSMode
        self.usernsMode = usernsMode
        self.shmSize = shmSize
        self.sysctls = sysctls
        self.runtime = runtime
        self.consoleSize = consoleSize
        self.isolation = isolation
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: StringCodingKey.self)
        self.resources = try Resources(from: decoder)
        self.binds = try values.decodeIfPresent([String].self, forKey: "Binds")
        self.containerIDFile = try values.decodeIfPresent(String.self, forKey: "ContainerIDFile")
        self.logConfig = try LogConfig(from: decoder)
        self.networkMode = try values.decodeIfPresent(String.self, forKey: "NetworkMode")
        self.portBindings = try values.decodeIfPresent([String: PortBinding].self, forKey: "PortBindings")
        self.restartPolicy = try RestartPolicy(from: decoder)
        self.isAutoRemove = try values.decodeIfPresent(Bool.self, forKey: "AutoRemove")
        self.volumeDriver = try values.decodeIfPresent(String.self, forKey: "VolumeDriver")
        self.volumesFrom = try values.decodeIfPresent([String].self, forKey: "VolumesFrom")
        self.mounts = try values.decodeIfPresent([Mount].self, forKey: "Mounts")
        self.capAdd = try values.decodeIfPresent([String].self, forKey: "CapAdd")
        self.capDrop = try values.decodeIfPresent([String].self, forKey: "CapDrop")
        self.dns = try values.decodeIfPresent([String].self, forKey: "Dns")
        self.dnsOptions = try values.decodeIfPresent([String].self, forKey: "DnsOptions")
        self.dnsSearch = try values.decodeIfPresent([String].self, forKey: "DnsSearch")
        self.extraHosts = try values.decodeIfPresent([String].self, forKey: "ExtraHosts")
        self.groupAdd = try values.decodeIfPresent([String].self, forKey: "GroupAdd")
        self.ipcMode = try values.decodeIfPresent(String.self, forKey: "IpcMode")
        self.cgroup = try values.decodeIfPresent(String.self, forKey: "Cgroup")
        self.links = try values.decodeIfPresent([String].self, forKey: "Links")
        self.oomScoreAdj = try values.decodeIfPresent(Int.self, forKey: "OomScoreAdj")
        self.pidMode = try values.decodeIfPresent(String.self, forKey: "PidMode")
        self.isPrivileged = try values.decodeIfPresent(Bool.self, forKey: "Privileged")
        self.isPublishAllPorts = try values.decodeIfPresent(Bool.self, forKey: "PublishAllPorts")
        self.isReadonlyRootfs = try values.decodeIfPresent(Bool.self, forKey: "ReadonlyRootfs")
        self.securityOpt = try values.decodeIfPresent([String].self, forKey: "SecurityOpt")
        self.storageOpt = try values.decodeIfPresent([String: String].self, forKey: "StorageOpt")
        self.tmpfs = try values.decodeIfPresent([String: String].self, forKey: "Tmpfs")
        self.uTSMode = try values.decodeIfPresent(String.self, forKey: "UTSMode")
        self.usernsMode = try values.decodeIfPresent(String.self, forKey: "UsernsMode")
        self.shmSize = try values.decodeIfPresent(Int.self, forKey: "ShmSize")
        self.sysctls = try values.decodeIfPresent([String: String].self, forKey: "Sysctls")
        self.runtime = try values.decodeIfPresent(String.self, forKey: "Runtime")
        self.consoleSize = try values.decodeIfPresent([Int].self, forKey: "ConsoleSize")
        self.isolation = try Isolation(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encode(resources, forKey: "resources")
        try values.encodeIfPresent(binds, forKey: "Binds")
        try values.encodeIfPresent(containerIDFile, forKey: "ContainerIDFile")
        try values.encodeIfPresent(logConfig, forKey: "LogConfig")
        try values.encodeIfPresent(networkMode, forKey: "NetworkMode")
        try values.encodeIfPresent(portBindings, forKey: "PortBindings")
        try values.encodeIfPresent(restartPolicy, forKey: "RestartPolicy")
        try values.encodeIfPresent(isAutoRemove, forKey: "AutoRemove")
        try values.encodeIfPresent(volumeDriver, forKey: "VolumeDriver")
        try values.encodeIfPresent(volumesFrom, forKey: "VolumesFrom")
        try values.encodeIfPresent(mounts, forKey: "Mounts")
        try values.encodeIfPresent(capAdd, forKey: "CapAdd")
        try values.encodeIfPresent(capDrop, forKey: "CapDrop")
        try values.encodeIfPresent(dns, forKey: "Dns")
        try values.encodeIfPresent(dnsOptions, forKey: "DnsOptions")
        try values.encodeIfPresent(dnsSearch, forKey: "DnsSearch")
        try values.encodeIfPresent(extraHosts, forKey: "ExtraHosts")
        try values.encodeIfPresent(groupAdd, forKey: "GroupAdd")
        try values.encodeIfPresent(ipcMode, forKey: "IpcMode")
        try values.encodeIfPresent(cgroup, forKey: "Cgroup")
        try values.encodeIfPresent(links, forKey: "Links")
        try values.encodeIfPresent(oomScoreAdj, forKey: "OomScoreAdj")
        try values.encodeIfPresent(pidMode, forKey: "PidMode")
        try values.encodeIfPresent(isPrivileged, forKey: "Privileged")
        try values.encodeIfPresent(isPublishAllPorts, forKey: "PublishAllPorts")
        try values.encodeIfPresent(isReadonlyRootfs, forKey: "ReadonlyRootfs")
        try values.encodeIfPresent(securityOpt, forKey: "SecurityOpt")
        try values.encodeIfPresent(storageOpt, forKey: "StorageOpt")
        try values.encodeIfPresent(tmpfs, forKey: "Tmpfs")
        try values.encodeIfPresent(uTSMode, forKey: "UTSMode")
        try values.encodeIfPresent(usernsMode, forKey: "UsernsMode")
        try values.encodeIfPresent(shmSize, forKey: "ShmSize")
        try values.encodeIfPresent(sysctls, forKey: "Sysctls")
        try values.encodeIfPresent(runtime, forKey: "Runtime")
        try values.encodeIfPresent(consoleSize, forKey: "ConsoleSize")
        try values.encodeIfPresent(isolation, forKey: "Isolation")
    }
}

/// Configuration for a container that is portable between hosts
public struct ContainerConfig: Codable {
    /// The hostname to use for the container, as a valid RFC 1123 hostname.
    public var hostname: String?
    /// The domain name to use for the container.
    public var domainname: String?
    /// The user that commands are run as inside the container.
    public var user: String?
    /// Whether to attach to `stdin`.
    public var isAttachStdin: Bool
    /// Whether to attach to `stdout`.
    public var isAttachStdout: Bool
    /// Whether to attach to `stderr`.
    public var isAttachStderr: Bool
    /// An object mapping ports to an empty object in the form:
    /// 
    /// `{"<port>/<tcp|udp>": {}}`
    public var exposedPorts: [String: [String: AnyJSON]]?
    /// Attach standard streams to a TTY, including `stdin` if it is not closed.
    public var isTty: Bool
    /// Open `stdin`
    public var isOpenStdin: Bool
    /// Close `stdin` after one attached client disconnects
    public var isStdinOnce: Bool
    /// A list of environment variables to set inside the container in the form `["VAR=value", ...]`. A variable without `=` is removed from the environment, rather than to have an empty value.
    public var env: [String]?
    /// A test to perform to check that the container is healthy.
    public var healthcheck: HealthConfig?
    /// Command is already escaped (Windows only)
    public var isArgsEscaped: Bool?
    /// The name of the image to use when creating the container
    public var image: String?
    /// An object mapping mount point paths inside the container to empty objects.
    public var volumes: Volumes?
    /// The working directory for commands to run in.
    public var workingDir: String?
    /// Disable networking for the container.
    public var isNetworkDisabled: Bool?
    /// MAC address of the container.
    public var macAddress: String?
    /// `ONBUILD` metadata that were defined in the image's `Dockerfile`.
    public var onBuild: [String]?
    /// User-defined key/value metadata.
    public var labels: [String: String]?
    /// Signal to stop a container as a string or unsigned integer.
    public var stopSignal: String?
    /// Timeout to stop a container in seconds.
    public var stopTimeout: Int?
    /// Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell.
    public var shell: [String]?

    /// An object mapping mount point paths inside the container to empty objects.
    public struct Volumes: Codable {
        public var additionalProperties: [String: AnyJSON]?

        public init(additionalProperties: [String: AnyJSON]? = nil) {
            self.additionalProperties = additionalProperties
        }
    }

    public init(hostname: String? = nil, domainname: String? = nil, user: String? = nil, isAttachStdin: Bool? = nil, isAttachStdout: Bool? = nil, isAttachStderr: Bool? = nil, exposedPorts: [String: [String: AnyJSON]]? = nil, isTty: Bool? = nil, isOpenStdin: Bool? = nil, isStdinOnce: Bool? = nil, env: [String]? = nil, healthcheck: HealthConfig? = nil, isArgsEscaped: Bool? = nil, image: String? = nil, volumes: Volumes? = nil, workingDir: String? = nil, isNetworkDisabled: Bool? = nil, macAddress: String? = nil, onBuild: [String]? = nil, labels: [String: String]? = nil, stopSignal: String? = nil, stopTimeout: Int? = nil, shell: [String]? = nil) {
        self.hostname = hostname
        self.domainname = domainname
        self.user = user
        self.isAttachStdin = isAttachStdin ?? false
        self.isAttachStdout = isAttachStdout ?? true
        self.isAttachStderr = isAttachStderr ?? true
        self.exposedPorts = exposedPorts
        self.isTty = isTty ?? false
        self.isOpenStdin = isOpenStdin ?? false
        self.isStdinOnce = isStdinOnce ?? false
        self.env = env
        self.healthcheck = healthcheck
        self.isArgsEscaped = isArgsEscaped
        self.image = image
        self.volumes = volumes
        self.workingDir = workingDir
        self.isNetworkDisabled = isNetworkDisabled
        self.macAddress = macAddress
        self.onBuild = onBuild
        self.labels = labels
        self.stopSignal = stopSignal
        self.stopTimeout = stopTimeout
        self.shell = shell
    }

    private enum CodingKeys: String, CodingKey {
        case hostname = "Hostname"
        case domainname = "Domainname"
        case user = "User"
        case isAttachStdin = "AttachStdin"
        case isAttachStdout = "AttachStdout"
        case isAttachStderr = "AttachStderr"
        case exposedPorts = "ExposedPorts"
        case isTty = "Tty"
        case isOpenStdin = "OpenStdin"
        case isStdinOnce = "StdinOnce"
        case env = "Env"
        case healthcheck = "Healthcheck"
        case isArgsEscaped = "ArgsEscaped"
        case image = "Image"
        case volumes = "Volumes"
        case workingDir = "WorkingDir"
        case isNetworkDisabled = "NetworkDisabled"
        case macAddress = "MacAddress"
        case onBuild = "OnBuild"
        case labels = "Labels"
        case stopSignal = "StopSignal"
        case stopTimeout = "StopTimeout"
        case shell = "Shell"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.hostname = try values.decodeIfPresent(String.self, forKey: .hostname)
        self.domainname = try values.decodeIfPresent(String.self, forKey: .domainname)
        self.user = try values.decodeIfPresent(String.self, forKey: .user)
        self.isAttachStdin = try values.decodeIfPresent(Bool.self, forKey: .isAttachStdin) ?? false
        self.isAttachStdout = try values.decodeIfPresent(Bool.self, forKey: .isAttachStdout) ?? true
        self.isAttachStderr = try values.decodeIfPresent(Bool.self, forKey: .isAttachStderr) ?? true
        self.exposedPorts = try values.decodeIfPresent([String: [String: AnyJSON]].self, forKey: .exposedPorts)
        self.isTty = try values.decodeIfPresent(Bool.self, forKey: .isTty) ?? false
        self.isOpenStdin = try values.decodeIfPresent(Bool.self, forKey: .isOpenStdin) ?? false
        self.isStdinOnce = try values.decodeIfPresent(Bool.self, forKey: .isStdinOnce) ?? false
        self.env = try values.decodeIfPresent([String].self, forKey: .env)
        self.healthcheck = try values.decodeIfPresent(HealthConfig.self, forKey: .healthcheck)
        self.isArgsEscaped = try values.decodeIfPresent(Bool.self, forKey: .isArgsEscaped)
        self.image = try values.decodeIfPresent(String.self, forKey: .image)
        self.volumes = try values.decodeIfPresent(Volumes.self, forKey: .volumes)
        self.workingDir = try values.decodeIfPresent(String.self, forKey: .workingDir)
        self.isNetworkDisabled = try values.decodeIfPresent(Bool.self, forKey: .isNetworkDisabled)
        self.macAddress = try values.decodeIfPresent(String.self, forKey: .macAddress)
        self.onBuild = try values.decodeIfPresent([String].self, forKey: .onBuild)
        self.labels = try values.decodeIfPresent([String: String].self, forKey: .labels)
        self.stopSignal = try values.decodeIfPresent(String.self, forKey: .stopSignal)
        self.stopTimeout = try values.decodeIfPresent(Int.self, forKey: .stopTimeout)
        self.shell = try values.decodeIfPresent([String].self, forKey: .shell)
    }
}

/// NetworkSettings exposes the network settings in the API
public struct NetworkSettings: Codable {
    /// Name of the network'a bridge (for example, `docker0`).
    ///
    /// Example: "docker0"
    public var bridge: String?
    /// SandboxID uniquely represents a container's network stack.
    ///
    /// Example: "9d12daf2c33f5959c8bf90aa513e4f65b561738661003029ec84830cd503a0c3"
    public var sandboxID: String?
    /// Indicates if hairpin NAT should be enabled on the virtual interface.
    ///
    /// Example: false
    public var isHairpinMode: Bool?
    /// IPv6 unicast address using the link-local prefix.
    ///
    /// Example: "fe80::42:acff:fe11:1"
    public var linkLocalIPv6Address: String?
    /// Prefix length of the IPv6 unicast address.
    ///
    /// Example: 64
    public var linkLocalIPv6PrefixLen: Int?
    /// PortMap describes the mapping of container ports to host ports, using the
    /// container's port-number and protocol as key in the format `<port>/<protocol>`,
    /// for example, `80/udp`.
    /// 
    /// If a container's port is mapped for both `tcp` and `udp`, two separate
    /// entries are added to the mapping table.
    ///
    /// Example:
    ///
    /// {
    ///   "53\/udp" : [
    ///     {
    ///       "HostIp" : "0.0.0.0",
    ///       "HostPort" : "53"
    ///     }
    ///   ],
    ///   "80\/tcp" : [
    ///     {
    ///       "HostIp" : "0.0.0.0",
    ///       "HostPort" : "80"
    ///     },
    ///     {
    ///       "HostIp" : "0.0.0.0",
    ///       "HostPort" : "8080"
    ///     }
    ///   ],
    ///   "80\/udp" : [
    ///     {
    ///       "HostIp" : "0.0.0.0",
    ///       "HostPort" : "80"
    ///     }
    ///   ],
    ///   "443\/tcp" : [
    ///     {
    ///       "HostIp" : "127.0.0.1",
    ///       "HostPort" : "4443"
    ///     }
    ///   ]
    /// }
    public var ports: [String: [PortBinding]]?
    /// SandboxKey identifies the sandbox
    ///
    /// Example: "/var/run/docker/netns/8ab54b426c38"
    public var sandboxKey: String?
    public var secondaryIPAddresses: [Address]?
    public var secondaryIPv6Addresses: [Address]?
    /// EndpointID uniquely represents a service endpoint in a Sandbox.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: "b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b"
    public var endpointID: String?
    /// Gateway address for the default "bridge" network.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: "172.17.0.1"
    public var gateway: String?
    /// Global IPv6 address for the default "bridge" network.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: "2001:db8::5689"
    public var globalIPv6Address: String?
    /// Mask length of the global IPv6 address.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: 64
    public var globalIPv6PrefixLen: Int?
    /// IPv4 address for the default "bridge" network.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: "172.17.0.4"
    public var iPAddress: String?
    /// Mask length of the IPv4 address.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: 16
    public var iPPrefixLen: Int?
    /// IPv6 gateway address for this network.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: "2001:db8:2::100"
    public var iPv6Gateway: String?
    /// MAC address for the container on the default "bridge" network.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Deprecated**: This field is only propagated when attached to the
    /// > default "bridge" network. Use the information from the "bridge"
    /// > network inside the `Networks` map instead, which contains the same
    /// > information. This field was deprecated in Docker 1.9 and is scheduled
    /// > to be removed in Docker 17.12.0
    ///
    /// Example: "02:42:ac:11:00:04"
    public var macAddress: String?
    /// Information about all networks that the container is connected to.
    public var networks: [String: EndpointSettings]?

    public init(bridge: String? = nil, sandboxID: String? = nil, isHairpinMode: Bool? = nil, linkLocalIPv6Address: String? = nil, linkLocalIPv6PrefixLen: Int? = nil, ports: [String: [PortBinding]]? = nil, sandboxKey: String? = nil, secondaryIPAddresses: [Address]? = nil, secondaryIPv6Addresses: [Address]? = nil, endpointID: String? = nil, gateway: String? = nil, globalIPv6Address: String? = nil, globalIPv6PrefixLen: Int? = nil, iPAddress: String? = nil, iPPrefixLen: Int? = nil, iPv6Gateway: String? = nil, macAddress: String? = nil, networks: [String: EndpointSettings]? = nil) {
        self.bridge = bridge
        self.sandboxID = sandboxID
        self.isHairpinMode = isHairpinMode
        self.linkLocalIPv6Address = linkLocalIPv6Address
        self.linkLocalIPv6PrefixLen = linkLocalIPv6PrefixLen
        self.ports = ports
        self.sandboxKey = sandboxKey
        self.secondaryIPAddresses = secondaryIPAddresses
        self.secondaryIPv6Addresses = secondaryIPv6Addresses
        self.endpointID = endpointID
        self.gateway = gateway
        self.globalIPv6Address = globalIPv6Address
        self.globalIPv6PrefixLen = globalIPv6PrefixLen
        self.iPAddress = iPAddress
        self.iPPrefixLen = iPPrefixLen
        self.iPv6Gateway = iPv6Gateway
        self.macAddress = macAddress
        self.networks = networks
    }

    private enum CodingKeys: String, CodingKey {
        case bridge = "Bridge"
        case sandboxID = "SandboxID"
        case isHairpinMode = "HairpinMode"
        case linkLocalIPv6Address = "LinkLocalIPv6Address"
        case linkLocalIPv6PrefixLen = "LinkLocalIPv6PrefixLen"
        case ports = "Ports"
        case sandboxKey = "SandboxKey"
        case secondaryIPAddresses = "SecondaryIPAddresses"
        case secondaryIPv6Addresses = "SecondaryIPv6Addresses"
        case endpointID = "EndpointID"
        case gateway = "Gateway"
        case globalIPv6Address = "GlobalIPv6Address"
        case globalIPv6PrefixLen = "GlobalIPv6PrefixLen"
        case iPAddress = "IPAddress"
        case iPPrefixLen = "IPPrefixLen"
        case iPv6Gateway = "IPv6Gateway"
        case macAddress = "MacAddress"
        case networks = "Networks"
    }
}

/// Address represents an IPv4 or IPv6 IP address.
public struct Address: Codable {
    /// IP address.
    public var addr: String?
    /// Mask length of the IP address.
    public var prefixLen: Int?

    public init(addr: String? = nil, prefixLen: Int? = nil) {
        self.addr = addr
        self.prefixLen = prefixLen
    }

    private enum CodingKeys: String, CodingKey {
        case addr = "Addr"
        case prefixLen = "PrefixLen"
    }
}

/// PortBinding represents a binding between a host IP address and a host
/// port.
public struct PortBinding: Codable {
    /// Host IP address that the container's port is mapped to.
    ///
    /// Example: "127.0.0.1"
    public var hostIp: String?
    /// Host port number that the container's port is mapped to.
    ///
    /// Example: "4443"
    public var hostPort: String?

    public init(hostIp: String? = nil, hostPort: String? = nil) {
        self.hostIp = hostIp
        self.hostPort = hostPort
    }

    private enum CodingKeys: String, CodingKey {
        case hostIp = "HostIp"
        case hostPort = "HostPort"
    }
}

/// Information about a container's graph driver.
public struct GraphDriverData: Codable {
    public var name: String
    public var data: [String: String]

    public init(name: String, data: [String: String]) {
        self.name = name
        self.data = data
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case data = "Data"
    }
}

public struct Image: Codable {
    public var id: String
    public var repoTags: [String]?
    public var repoDigests: [String]?
    public var parent: String
    public var comment: String
    public var created: String
    public var container: String
    /// Configuration for a container that is portable between hosts
    public var containerConfig: ContainerConfig?
    public var dockerVersion: String
    public var author: String
    /// Configuration for a container that is portable between hosts
    public var config: ContainerConfig?
    public var architecture: String
    public var os: String
    public var osVersion: String?
    public var size: Int
    public var virtualSize: Int
    /// Information about a container's graph driver.
    public var graphDriver: GraphDriverData
    public var rootFS: RootFS
    public var metadata: Metadata?

    public struct RootFS: Codable {
        public var type: String
        public var layers: [String]?
        public var baseLayer: String?

        public init(type: String, layers: [String]? = nil, baseLayer: String? = nil) {
            self.type = type
            self.layers = layers
            self.baseLayer = baseLayer
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case layers = "Layers"
            case baseLayer = "BaseLayer"
        }
    }

    public struct Metadata: Codable {
        public var lastTagTime: String?

        public init(lastTagTime: String? = nil) {
            self.lastTagTime = lastTagTime
        }

        private enum CodingKeys: String, CodingKey {
            case lastTagTime = "LastTagTime"
        }
    }

    public init(id: String, repoTags: [String]? = nil, repoDigests: [String]? = nil, parent: String, comment: String, created: String, container: String, containerConfig: ContainerConfig? = nil, dockerVersion: String, author: String, config: ContainerConfig? = nil, architecture: String, os: String, osVersion: String? = nil, size: Int, virtualSize: Int, graphDriver: GraphDriverData, rootFS: RootFS, metadata: Metadata? = nil) {
        self.id = id
        self.repoTags = repoTags
        self.repoDigests = repoDigests
        self.parent = parent
        self.comment = comment
        self.created = created
        self.container = container
        self.containerConfig = containerConfig
        self.dockerVersion = dockerVersion
        self.author = author
        self.config = config
        self.architecture = architecture
        self.os = os
        self.osVersion = osVersion
        self.size = size
        self.virtualSize = virtualSize
        self.graphDriver = graphDriver
        self.rootFS = rootFS
        self.metadata = metadata
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case repoTags = "RepoTags"
        case repoDigests = "RepoDigests"
        case parent = "Parent"
        case comment = "Comment"
        case created = "Created"
        case container = "Container"
        case containerConfig = "ContainerConfig"
        case dockerVersion = "DockerVersion"
        case author = "Author"
        case config = "Config"
        case architecture = "Architecture"
        case os = "Os"
        case osVersion = "OsVersion"
        case size = "Size"
        case virtualSize = "VirtualSize"
        case graphDriver = "GraphDriver"
        case rootFS = "RootFS"
        case metadata = "Metadata"
    }
}

public struct ImageSummary: Codable {
    public var id: String
    public var parentID: String
    public var repoTags: [String]
    public var repoDigests: [String]
    public var created: Int
    public var size: Int
    public var sharedSize: Int
    public var virtualSize: Int
    public var labels: [String: String]
    public var containers: Int

    public init(id: String, parentID: String, repoTags: [String], repoDigests: [String], created: Int, size: Int, sharedSize: Int, virtualSize: Int, labels: [String: String], containers: Int) {
        self.id = id
        self.parentID = parentID
        self.repoTags = repoTags
        self.repoDigests = repoDigests
        self.created = created
        self.size = size
        self.sharedSize = sharedSize
        self.virtualSize = virtualSize
        self.labels = labels
        self.containers = containers
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case parentID = "ParentId"
        case repoTags = "RepoTags"
        case repoDigests = "RepoDigests"
        case created = "Created"
        case size = "Size"
        case sharedSize = "SharedSize"
        case virtualSize = "VirtualSize"
        case labels = "Labels"
        case containers = "Containers"
    }
}

/// Example:
///
/// {
///   "password" : "xxxx",
///   "serveraddress" : "https:\/\/index.docker.io\/v1\/",
///   "username" : "hannibal"
/// }
public struct AuthConfig: Codable {
    public var username: String?
    public var password: String?
    public var email: String?
    public var serveraddress: String?

    public init(username: String? = nil, password: String? = nil, email: String? = nil, serveraddress: String? = nil) {
        self.username = username
        self.password = password
        self.email = email
        self.serveraddress = serveraddress
    }
}

public struct ProcessConfig: Codable {
    public var isPrivileged: Bool?
    public var user: String?
    public var isTty: Bool?
    public var entrypoint: String?
    public var arguments: [String]?

    public init(isPrivileged: Bool? = nil, user: String? = nil, isTty: Bool? = nil, entrypoint: String? = nil, arguments: [String]? = nil) {
        self.isPrivileged = isPrivileged
        self.user = user
        self.isTty = isTty
        self.entrypoint = entrypoint
        self.arguments = arguments
    }

    private enum CodingKeys: String, CodingKey {
        case isPrivileged = "privileged"
        case user
        case isTty = "tty"
        case entrypoint
        case arguments
    }
}

/// Example:
///
/// {
///   "CreatedAt" : "2016-06-07T20:31:11.853781916Z",
///   "Driver" : "custom",
///   "Labels" : {
///     "com.example.some-label" : "some-value",
///     "com.example.some-other-label" : "some-other-value"
///   },
///   "Mountpoint" : "\/var\/lib\/docker\/volumes\/tardis",
///   "Name" : "tardis",
///   "Scope" : "local",
///   "Status" : {
///     "hello" : "world"
///   }
/// }
public struct Volume: Codable {
    /// Name of the volume.
    public var name: String
    /// Name of the volume driver used by the volume.
    public var driver: String
    /// Mount path of the volume on the host.
    public var mountpoint: String
    /// Date/Time the volume was created.
    public var createdAt: String?
    /// Low-level details about the volume, provided by the volume driver.
    /// Details are returned as a map with key/value pairs:
    /// `{"key":"value","key2":"value2"}`.
    /// 
    /// The `Status` field is optional, and is omitted if the volume driver
    /// does not support this feature.
    public var status: [String: [String: AnyJSON]]?
    /// User-defined key/value metadata.
    public var labels: [String: String]
    /// The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
    public var scope: Scope
    /// The driver specific options used when creating the volume.
    public var options: [String: String]
    /// Usage details about the volume. This information is used by the
    /// `GET /system/df` endpoint, and omitted in other endpoints.
    public var usageData: UsageData?

    /// The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
    public enum Scope: String, Codable, CaseIterable {
        case local
        case global
    }

    /// Usage details about the volume. This information is used by the
    /// `GET /system/df` endpoint, and omitted in other endpoints.
    public struct UsageData: Codable {
        /// Amount of disk space used by the volume (in bytes). This information
        /// is only available for volumes created with the `"local"` volume
        /// driver. For volumes created with other volume drivers, this field
        /// is set to `-1` ("not available")
        public var size: Int
        /// The number of containers referencing this volume. This field
        /// is set to `-1` if the reference-count is not available.
        public var refCount: Int

        public init(size: Int, refCount: Int) {
            self.size = size
            self.refCount = refCount
        }

        private enum CodingKeys: String, CodingKey {
            case size = "Size"
            case refCount = "RefCount"
        }
    }

    public init(name: String, driver: String, mountpoint: String, createdAt: String? = nil, status: [String: [String: AnyJSON]]? = nil, labels: [String: String], scope: Scope, options: [String: String], usageData: UsageData? = nil) {
        self.name = name
        self.driver = driver
        self.mountpoint = mountpoint
        self.createdAt = createdAt
        self.status = status
        self.labels = labels
        self.scope = scope
        self.options = options
        self.usageData = usageData
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case driver = "Driver"
        case mountpoint = "Mountpoint"
        case createdAt = "CreatedAt"
        case status = "Status"
        case labels = "Labels"
        case scope = "Scope"
        case options = "Options"
        case usageData = "UsageData"
    }
}

/// Example:
///
/// {
///   "Attachable" : false,
///   "Containers" : {
///     "19a4d5d687db25203351ed79d478946f861258f018fe384f229f2efa4b23513c" : {
///       "EndpointID" : "628cadb8bcb92de107b2a1e516cbffe463e321f548feb37697cce00ad694f21a",
///       "IPv4Address" : "172.19.0.2\/16",
///       "IPv6Address" : null,
///       "MacAddress" : "02:42:ac:13:00:02",
///       "Name" : "test"
///     }
///   },
///   "Created" : "2016-10-19T04:33:30.360899459Z",
///   "Driver" : "bridge",
///   "EnableIPv6" : false,
///   "Id" : "7d86d31b1478e7cca9ebed7e73aa0fdeec46c5ca29497431d3007d2d9e15ed99",
///   "Ingress" : false,
///   "Internal" : false,
///   "IPAM" : {
///     "Config" : [
///       {
///         "Gateway" : "172.19.0.1",
///         "Subnet" : "172.19.0.0\/16"
///       }
///     ],
///     "Driver" : "default",
///     "Options" : {
///       "foo" : "bar"
///     }
///   },
///   "Labels" : {
///     "com.example.some-label" : "some-value",
///     "com.example.some-other-label" : "some-other-value"
///   },
///   "Name" : "net01",
///   "Options" : {
///     "com.docker.network.bridge.default_bridge" : true,
///     "com.docker.network.bridge.enable_icc" : true,
///     "com.docker.network.bridge.enable_ip_masquerade" : true,
///     "com.docker.network.bridge.host_binding_ipv4" : "0.0.0.0",
///     "com.docker.network.bridge.name" : "docker0",
///     "com.docker.network.driver.mtu" : "1500"
///   },
///   "Scope" : "local"
/// }
public struct Network: Codable {
    public var name: String?
    public var id: String?
    public var created: String?
    public var scope: String?
    public var driver: String?
    public var enableIPv6: Bool?
    public var ipam: Ipam?
    public var isInternal: Bool?
    public var isAttachable: Bool?
    public var isIngress: Bool?
    public var containers: [String: NetworkContainer]?
    public var options: [String: String]?
    public var labels: [String: String]?

    public init(name: String? = nil, id: String? = nil, created: String? = nil, scope: String? = nil, driver: String? = nil, enableIPv6: Bool? = nil, ipam: Ipam? = nil, isInternal: Bool? = nil, isAttachable: Bool? = nil, isIngress: Bool? = nil, containers: [String: NetworkContainer]? = nil, options: [String: String]? = nil, labels: [String: String]? = nil) {
        self.name = name
        self.id = id
        self.created = created
        self.scope = scope
        self.driver = driver
        self.enableIPv6 = enableIPv6
        self.ipam = ipam
        self.isInternal = isInternal
        self.isAttachable = isAttachable
        self.isIngress = isIngress
        self.containers = containers
        self.options = options
        self.labels = labels
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case id = "Id"
        case created = "Created"
        case scope = "Scope"
        case driver = "Driver"
        case enableIPv6 = "EnableIPv6"
        case ipam = "IPAM"
        case isInternal = "Internal"
        case isAttachable = "Attachable"
        case isIngress = "Ingress"
        case containers = "Containers"
        case options = "Options"
        case labels = "Labels"
    }
}

public struct Ipam: Codable {
    /// Name of the IPAM driver to use.
    public var driver: String?
    /// List of IPAM configuration options, specified as a map: `{"Subnet": <CIDR>, "IPRange": <CIDR>, "Gateway": <IP address>, "AuxAddress": <device_name:IP address>}`
    public var config: [[String: String]]?
    /// Driver-specific options, specified as a map.
    public var options: [[String: String]]?

    public init(driver: String? = nil, config: [[String: String]]? = nil, options: [[String: String]]? = nil) {
        self.driver = driver
        self.config = config
        self.options = options
    }

    private enum CodingKeys: String, CodingKey {
        case driver = "Driver"
        case config = "Config"
        case options = "Options"
    }
}

public struct NetworkContainer: Codable {
    public var name: String?
    public var endpointID: String?
    public var macAddress: String?
    public var iPv4Address: String?
    public var iPv6Address: String?

    public init(name: String? = nil, endpointID: String? = nil, macAddress: String? = nil, iPv4Address: String? = nil, iPv6Address: String? = nil) {
        self.name = name
        self.endpointID = endpointID
        self.macAddress = macAddress
        self.iPv4Address = iPv4Address
        self.iPv6Address = iPv6Address
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case endpointID = "EndpointID"
        case macAddress = "MacAddress"
        case iPv4Address = "IPv4Address"
        case iPv6Address = "IPv6Address"
    }
}

public struct BuildInfo: Codable {
    public var id: String?
    public var stream: String?
    public var error: String?
    public var errorDetail: ErrorDetail?
    public var status: String?
    public var progress: String?
    public var progressDetail: ProgressDetail?

    public init(id: String? = nil, stream: String? = nil, error: String? = nil, errorDetail: ErrorDetail? = nil, status: String? = nil, progress: String? = nil, progressDetail: ProgressDetail? = nil) {
        self.id = id
        self.stream = stream
        self.error = error
        self.errorDetail = errorDetail
        self.status = status
        self.progress = progress
        self.progressDetail = progressDetail
    }
}

public struct CreateImageInfo: Codable {
    public var error: String?
    public var status: String?
    public var progress: String?
    public var progressDetail: ProgressDetail?

    public init(error: String? = nil, status: String? = nil, progress: String? = nil, progressDetail: ProgressDetail? = nil) {
        self.error = error
        self.status = status
        self.progress = progress
        self.progressDetail = progressDetail
    }
}

public struct PushImageInfo: Codable {
    public var error: String?
    public var status: String?
    public var progress: String?
    public var progressDetail: ProgressDetail?

    public init(error: String? = nil, status: String? = nil, progress: String? = nil, progressDetail: ProgressDetail? = nil) {
        self.error = error
        self.status = status
        self.progress = progress
        self.progressDetail = progressDetail
    }
}

public struct ErrorDetail: Codable {
    public var code: Int?
    public var message: String?

    public init(code: Int? = nil, message: String? = nil) {
        self.code = code
        self.message = message
    }
}

public struct ProgressDetail: Codable {
    public var code: Int?
    public var message: Int?

    public init(code: Int? = nil, message: Int? = nil) {
        self.code = code
        self.message = message
    }
}

/// Represents an error.
///
/// Example:
///
/// {
///   "message" : "Something went wrong."
/// }
public struct ErrorResponse: Codable {
    /// The error message.
    public var message: String

    public init(message: String) {
        self.message = message
    }
}

/// Response to an API call that returns just an Id
public struct IDResponse: Codable {
    /// The id of the newly created object.
    public var id: String

    public init(id: String) {
        self.id = id
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
    }
}

/// Configuration for a network endpoint.
public struct EndpointSettings: Codable {
    /// EndpointIPAMConfig represents an endpoint's IPAM configuration.
    public var iPAMConfig: EndpointIPAMConfig?
    /// Example: ["container_1", "container_2"]
    public var links: [String]?
    /// Example: ["server_x", "server_y"]
    public var aliases: [String]?
    /// Unique ID of the network.
    ///
    /// Example: "08754567f1f40222263eab4102e1c733ae697e8e354aa9cd6e18d7402835292a"
    public var networkID: String?
    /// Unique ID for the service endpoint in a Sandbox.
    ///
    /// Example: "b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b"
    public var endpointID: String?
    /// Gateway address for this network.
    ///
    /// Example: "172.17.0.1"
    public var gateway: String?
    /// IPv4 address.
    ///
    /// Example: "172.17.0.4"
    public var iPAddress: String?
    /// Mask length of the IPv4 address.
    ///
    /// Example: 16
    public var iPPrefixLen: Int?
    /// IPv6 gateway address.
    ///
    /// Example: "2001:db8:2::100"
    public var iPv6Gateway: String?
    /// Global IPv6 address.
    ///
    /// Example: "2001:db8::5689"
    public var globalIPv6Address: String?
    /// Mask length of the global IPv6 address.
    ///
    /// Example: 64
    public var globalIPv6PrefixLen: Int?
    /// MAC address for the endpoint on this network.
    ///
    /// Example: "02:42:ac:11:00:04"
    public var macAddress: String?
    /// DriverOpts is a mapping of driver options and values. These options
    /// are passed directly to the driver and are driver specific.
    ///
    /// Example:
    ///
    /// {
    ///   "com.example.some-label" : "some-value",
    ///   "com.example.some-other-label" : "some-other-value"
    /// }
    public var driverOpts: [String: String]?

    public init(iPAMConfig: EndpointIPAMConfig? = nil, links: [String]? = nil, aliases: [String]? = nil, networkID: String? = nil, endpointID: String? = nil, gateway: String? = nil, iPAddress: String? = nil, iPPrefixLen: Int? = nil, iPv6Gateway: String? = nil, globalIPv6Address: String? = nil, globalIPv6PrefixLen: Int? = nil, macAddress: String? = nil, driverOpts: [String: String]? = nil) {
        self.iPAMConfig = iPAMConfig
        self.links = links
        self.aliases = aliases
        self.networkID = networkID
        self.endpointID = endpointID
        self.gateway = gateway
        self.iPAddress = iPAddress
        self.iPPrefixLen = iPPrefixLen
        self.iPv6Gateway = iPv6Gateway
        self.globalIPv6Address = globalIPv6Address
        self.globalIPv6PrefixLen = globalIPv6PrefixLen
        self.macAddress = macAddress
        self.driverOpts = driverOpts
    }

    private enum CodingKeys: String, CodingKey {
        case iPAMConfig = "IPAMConfig"
        case links = "Links"
        case aliases = "Aliases"
        case networkID = "NetworkID"
        case endpointID = "EndpointID"
        case gateway = "Gateway"
        case iPAddress = "IPAddress"
        case iPPrefixLen = "IPPrefixLen"
        case iPv6Gateway = "IPv6Gateway"
        case globalIPv6Address = "GlobalIPv6Address"
        case globalIPv6PrefixLen = "GlobalIPv6PrefixLen"
        case macAddress = "MacAddress"
        case driverOpts = "DriverOpts"
    }
}

/// EndpointIPAMConfig represents an endpoint's IPAM configuration.
public struct EndpointIPAMConfig: Codable {
    /// Example: "172.20.30.33"
    public var iPv4Address: String?
    /// Example: "2001:db8:abcd::3033"
    public var iPv6Address: String?
    /// Example: ["169.254.34.68", "fe80::3468"]
    public var linkLocalIPs: [String]?

    public init(iPv4Address: String? = nil, iPv6Address: String? = nil, linkLocalIPs: [String]? = nil) {
        self.iPv4Address = iPv4Address
        self.iPv6Address = iPv6Address
        self.linkLocalIPs = linkLocalIPs
    }

    private enum CodingKeys: String, CodingKey {
        case iPv4Address = "IPv4Address"
        case iPv6Address = "IPv6Address"
        case linkLocalIPs = "LinkLocalIPs"
    }
}

public struct PluginMount: Codable {
    /// Example: "some-mount"
    public var name: String
    /// Example: "This is a mount that's used by the plugin."
    public var description: String
    public var settable: [String]
    /// Example: "/var/lib/docker/plugins/"
    public var source: String
    /// Example: "/mnt/state"
    public var destination: String
    /// Example: "bind"
    public var type: String
    /// Example: ["rbind", "rw"]
    public var options: [String]

    public init(name: String, description: String, settable: [String], source: String, destination: String, type: String, options: [String]) {
        self.name = name
        self.description = description
        self.settable = settable
        self.source = source
        self.destination = destination
        self.type = type
        self.options = options
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case description = "Description"
        case settable = "Settable"
        case source = "Source"
        case destination = "Destination"
        case type = "Type"
        case options = "Options"
    }
}

public struct PluginDevice: Codable {
    public var name: String
    public var description: String
    public var settable: [String]
    /// Example: "/dev/fuse"
    public var path: String

    public init(name: String, description: String, settable: [String], path: String) {
        self.name = name
        self.description = description
        self.settable = settable
        self.path = path
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case description = "Description"
        case settable = "Settable"
        case path = "Path"
    }
}

public struct PluginEnv: Codable {
    public var name: String
    public var description: String
    public var settable: [String]
    public var value: String

    public init(name: String, description: String, settable: [String], value: String) {
        self.name = name
        self.description = description
        self.settable = settable
        self.value = value
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case description = "Description"
        case settable = "Settable"
        case value = "Value"
    }
}

public struct PluginInterfaceType: Codable {
    public var prefix: String
    public var capability: String
    public var version: String

    public init(prefix: String, capability: String, version: String) {
        self.prefix = prefix
        self.capability = capability
        self.version = version
    }

    private enum CodingKeys: String, CodingKey {
        case prefix = "Prefix"
        case capability = "Capability"
        case version = "Version"
    }
}

/// A plugin for the Engine API
public struct Plugin: Codable {
    /// Example: "5724e2c8652da337ab2eedd19fc6fc0ec908e4bd907c7421bf6a8dfc70c4c078"
    public var id: String?
    /// Example: "tiborvass/sample-volume-plugin"
    public var name: String
    /// True if the plugin is running. False if the plugin is not running, only installed.
    ///
    /// Example: true
    public var isEnabled: Bool
    /// Settings that can be modified by users.
    public var settings: Settings
    /// Plugin remote reference used to push/pull the plugin
    ///
    /// Example: "localhost:5000/tiborvass/sample-volume-plugin:latest"
    public var pluginReference: String?
    /// The config of a plugin.
    public var config: Config

    /// Settings that can be modified by users.
    public struct Settings: Codable {
        public var mounts: [PluginMount]
        /// Example: ["DEBUG=0"]
        public var env: [String]
        public var args: [String]
        public var devices: [PluginDevice]

        public init(mounts: [PluginMount], env: [String], args: [String], devices: [PluginDevice]) {
            self.mounts = mounts
            self.env = env
            self.args = args
            self.devices = devices
        }

        private enum CodingKeys: String, CodingKey {
            case mounts = "Mounts"
            case env = "Env"
            case args = "Args"
            case devices = "Devices"
        }
    }

    /// The config of a plugin.
    public struct Config: Codable {
        /// Docker Version used to create the plugin
        ///
        /// Example: "17.06.0-ce"
        public var dockerVersion: String?
        /// Example: "A sample volume plugin for Docker"
        public var description: String
        /// Example: "https://docs.docker.com/engine/extend/plugins/"
        public var documentation: String
        /// The interface between Docker and the plugin
        public var interface: Interface
        /// Example: ["/usr/bin/sample-volume-plugin", "/data"]
        public var entrypoint: [String]
        /// Example: "/bin/"
        public var workDir: String
        public var user: User?
        public var network: Network
        public var linux: Linux
        /// Example: "/mnt/volumes"
        public var propagatedMount: String
        /// Example: false
        public var isIpcHost: Bool
        /// Example: false
        public var isPidHost: Bool
        public var mounts: [PluginMount]
        /// Example:
        ///
        /// [
        ///   {
        ///     "Description" : "If set, prints debug messages",
        ///     "Name" : "DEBUG",
        ///     "Value" : "0"
        ///   }
        /// ]
        public var env: [PluginEnv]
        public var args: Args
        public var rootfs: Rootfs?

        /// The interface between Docker and the plugin
        public struct Interface: Codable {
            /// Example: ["docker.volumedriver/1.0"]
            public var types: [PluginInterfaceType]
            /// Example: "plugins.sock"
            public var socket: String

            public init(types: [PluginInterfaceType], socket: String) {
                self.types = types
                self.socket = socket
            }

            private enum CodingKeys: String, CodingKey {
                case types = "Types"
                case socket = "Socket"
            }
        }

        public struct User: Codable {
            /// Example: 1000
            public var uid: Int?
            /// Example: 1000
            public var gid: Int?

            public init(uid: Int? = nil, gid: Int? = nil) {
                self.uid = uid
                self.gid = gid
            }

            private enum CodingKeys: String, CodingKey {
                case uid = "UID"
                case gid = "GID"
            }
        }

        public struct Network: Codable {
            /// Example: "host"
            public var type: String

            public init(type: String) {
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case type = "Type"
            }
        }

        public struct Linux: Codable {
            /// Example: ["CAP_SYS_ADMIN", "CAP_SYSLOG"]
            public var capabilities: [String]
            /// Example: false
            public var allowAllDevices: Bool
            public var devices: [PluginDevice]

            public init(capabilities: [String], allowAllDevices: Bool, devices: [PluginDevice]) {
                self.capabilities = capabilities
                self.allowAllDevices = allowAllDevices
                self.devices = devices
            }

            private enum CodingKeys: String, CodingKey {
                case capabilities = "Capabilities"
                case allowAllDevices = "AllowAllDevices"
                case devices = "Devices"
            }
        }

        public struct Args: Codable {
            /// Example: "args"
            public var name: String
            /// Example: "command line arguments"
            public var description: String
            public var settable: [String]
            public var value: [String]

            public init(name: String, description: String, settable: [String], value: [String]) {
                self.name = name
                self.description = description
                self.settable = settable
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case description = "Description"
                case settable = "Settable"
                case value = "Value"
            }
        }

        public struct Rootfs: Codable {
            /// Example: "layers"
            public var type: String?
            /// Example: ["sha256:675532206fbf3030b8458f88d6e26d4eb1577688a25efec97154c94e8b6b4887", "sha256:e216a057b1cb1efc11f8a268f37ef62083e70b1b38323ba252e25ac88904a7e8"]
            public var diffIDs: [String]?

            public init(type: String? = nil, diffIDs: [String]? = nil) {
                self.type = type
                self.diffIDs = diffIDs
            }

            private enum CodingKeys: String, CodingKey {
                case type
                case diffIDs = "diff_ids"
            }
        }

        public init(dockerVersion: String? = nil, description: String, documentation: String, interface: Interface, entrypoint: [String], workDir: String, user: User? = nil, network: Network, linux: Linux, propagatedMount: String, isIpcHost: Bool, isPidHost: Bool, mounts: [PluginMount], env: [PluginEnv], args: Args, rootfs: Rootfs? = nil) {
            self.dockerVersion = dockerVersion
            self.description = description
            self.documentation = documentation
            self.interface = interface
            self.entrypoint = entrypoint
            self.workDir = workDir
            self.user = user
            self.network = network
            self.linux = linux
            self.propagatedMount = propagatedMount
            self.isIpcHost = isIpcHost
            self.isPidHost = isPidHost
            self.mounts = mounts
            self.env = env
            self.args = args
            self.rootfs = rootfs
        }

        private enum CodingKeys: String, CodingKey {
            case dockerVersion = "DockerVersion"
            case description = "Description"
            case documentation = "Documentation"
            case interface = "Interface"
            case entrypoint = "Entrypoint"
            case workDir = "WorkDir"
            case user = "User"
            case network = "Network"
            case linux = "Linux"
            case propagatedMount = "PropagatedMount"
            case isIpcHost = "IpcHost"
            case isPidHost = "PidHost"
            case mounts = "Mounts"
            case env = "Env"
            case args = "Args"
            case rootfs
        }
    }

    public init(id: String? = nil, name: String, isEnabled: Bool, settings: Settings, pluginReference: String? = nil, config: Config) {
        self.id = id
        self.name = name
        self.isEnabled = isEnabled
        self.settings = settings
        self.pluginReference = pluginReference
        self.config = config
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case name = "Name"
        case isEnabled = "Enabled"
        case settings = "Settings"
        case pluginReference = "PluginReference"
        case config = "Config"
    }
}

/// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
/// The client must send the version number along with the modified specification when updating these objects.
/// This approach ensures safe concurrency and determinism in that the change on the object
/// may not be applied if the version number has changed from the last read. In other words,
/// if two update requests specify the same base version, only one of the requests can succeed.
/// As a result, two separate update requests that happen at the same time will not
/// unintentionally overwrite each other.
public struct ObjectVersion: Codable {
    /// Example: 373531
    public var index: Int?

    public init(index: Int? = nil) {
        self.index = index
    }

    private enum CodingKeys: String, CodingKey {
        case index = "Index"
    }
}

/// Example:
///
/// {
///   "Availability" : "active",
///   "Labels" : {
///     "foo" : "bar"
///   },
///   "Name" : "node-name",
///   "Role" : "manager"
/// }
public struct NodeSpec: Codable {
    /// Name for the node.
    ///
    /// Example: "my-node"
    public var name: String?
    /// User-defined key/value metadata.
    public var labels: [String: String]?
    /// Role of the node.
    ///
    /// Example: "manager"
    public var role: Role?
    /// Availability of the node.
    ///
    /// Example: "active"
    public var availability: Availability?

    /// Role of the node.
    ///
    /// Example: "manager"
    public enum Role: String, Codable, CaseIterable {
        case worker
        case manager
    }

    /// Availability of the node.
    ///
    /// Example: "active"
    public enum Availability: String, Codable, CaseIterable {
        case active
        case pause
        case drain
    }

    public init(name: String? = nil, labels: [String: String]? = nil, role: Role? = nil, availability: Availability? = nil) {
        self.name = name
        self.labels = labels
        self.role = role
        self.availability = availability
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case labels = "Labels"
        case role = "Role"
        case availability = "Availability"
    }
}

public struct Node: Codable {
    /// Example: "24ifsmvkjbyhk"
    public var id: String?
    /// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
    /// The client must send the version number along with the modified specification when updating these objects.
    /// This approach ensures safe concurrency and determinism in that the change on the object
    /// may not be applied if the version number has changed from the last read. In other words,
    /// if two update requests specify the same base version, only one of the requests can succeed.
    /// As a result, two separate update requests that happen at the same time will not
    /// unintentionally overwrite each other.
    public var version: ObjectVersion?
    /// Date and time at which the node was added to the swarm in
    /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
    ///
    /// Example: "2016-08-18T10:44:24.496525531Z"
    public var createdAt: String?
    /// Date and time at which the node was last updated in
    /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
    ///
    /// Example: "2017-08-09T07:09:37.632105588Z"
    public var updatedAt: String?
    /// Example:
    ///
    /// {
    ///   "Availability" : "active",
    ///   "Labels" : {
    ///     "foo" : "bar"
    ///   },
    ///   "Name" : "node-name",
    ///   "Role" : "manager"
    /// }
    public var spec: NodeSpec?
    /// NodeDescription encapsulates the properties of the Node as reported by the
    /// agent.
    public var description: NodeDescription?
    /// NodeStatus represents the status of a node.
    /// 
    /// It provides the current status of the node, as seen by the manager.
    public var status: NodeStatus?
    /// ManagerStatus represents the status of a manager.
    /// 
    /// It provides the current status of a node's manager component, if the node
    /// is a manager.
    public var managerStatus: ManagerStatus?

    public init(id: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, spec: NodeSpec? = nil, description: NodeDescription? = nil, status: NodeStatus? = nil, managerStatus: ManagerStatus? = nil) {
        self.id = id
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.spec = spec
        self.description = description
        self.status = status
        self.managerStatus = managerStatus
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case spec = "Spec"
        case description = "Description"
        case status = "Status"
        case managerStatus = "ManagerStatus"
    }
}

/// NodeDescription encapsulates the properties of the Node as reported by the
/// agent.
public struct NodeDescription: Codable {
    /// Example: "bf3067039e47"
    public var hostname: String?
    /// Platform represents the platform (Arch/OS).
    public var platform: Platform?
    /// An object describing the resources which can be advertised by a node and requested by a task
    public var resources: ResourceObject?
    /// EngineDescription provides information about an engine.
    public var engine: EngineDescription?
    /// Information about the issuer of leaf TLS certificates and the trusted root CA certificate
    ///
    /// Example:
    ///
    /// {
    ///   "CertIssuerPublicKey" : "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEmT9XIw9h1qoNclv9VeHmf\/Vi6\/uI2vFXdBveXTpcPjqx6i9wNazchk1XWV\/dKTKvSh9xyGKmiIeRcE4OiMnJ1A==",
    ///   "CertIssuerSubject" : "MBMxETAPBgNVBAMTCHN3YXJtLWNh",
    ///   "TrustRoot" : "-----BEGIN CERTIFICATE-----\nMIIBajCCARCgAwIBAgIUbYqrLSOSQHoxD8CwG6Bi2PJi9c8wCgYIKoZIzj0EAwIw\nEzERMA8GA1UEAxMIc3dhcm0tY2EwHhcNMTcwNDI0MjE0MzAwWhcNMzcwNDE5MjE0\nMzAwWjATMREwDwYDVQQDEwhzd2FybS1jYTBZMBMGByqGSM49AgEGCCqGSM49AwEH\nA0IABJk\/VyMPYdaqDXJb\/VXh5n\/1Yuv7iNrxV3Qb3l06XD46seovcDWs3IZNV1lf\n3Skyr0ofcchipoiHkXBODojJydSjQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMB\nAf8EBTADAQH\/MB0GA1UdDgQWBBRUXxuRcnFjDfR\/RIAUQab8ZV\/n4jAKBggqhkjO\nPQQDAgNIADBFAiAy+JTe6Uc3KyLCMiqGl2GyWGQqQDEcO3\/YG36x7om65AIhAJvz\npxv6zFeVEkAEEkqIYi0omA9+CjanB\/6Bz4n1uw8H\n-----END CERTIFICATE-----\n"
    /// }
    public var tlsInfo: TLSInfo?

    public init(hostname: String? = nil, platform: Platform? = nil, resources: ResourceObject? = nil, engine: EngineDescription? = nil, tlsInfo: TLSInfo? = nil) {
        self.hostname = hostname
        self.platform = platform
        self.resources = resources
        self.engine = engine
        self.tlsInfo = tlsInfo
    }

    private enum CodingKeys: String, CodingKey {
        case hostname = "Hostname"
        case platform = "Platform"
        case resources = "Resources"
        case engine = "Engine"
        case tlsInfo = "TLSInfo"
    }
}

/// Platform represents the platform (Arch/OS).
public struct Platform: Codable {
    /// Architecture represents the hardware architecture (for example,
    /// `x86_64`).
    ///
    /// Example: "x86_64"
    public var architecture: String?
    /// OS represents the Operating System (for example, `linux` or `windows`).
    ///
    /// Example: "linux"
    public var os: String?

    public init(architecture: String? = nil, os: String? = nil) {
        self.architecture = architecture
        self.os = os
    }

    private enum CodingKeys: String, CodingKey {
        case architecture = "Architecture"
        case os = "OS"
    }
}

/// EngineDescription provides information about an engine.
public struct EngineDescription: Codable {
    /// Example: "17.06.0"
    public var engineVersion: String?
    /// Example:
    ///
    /// {
    ///   "foo" : "bar"
    /// }
    public var labels: [String: String]?
    /// Example:
    ///
    /// [
    ///   {
    ///     "Name" : "awslogs",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "fluentd",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "gcplogs",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "gelf",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "journald",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "json-file",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "logentries",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "splunk",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "syslog",
    ///     "Type" : "Log"
    ///   },
    ///   {
    ///     "Name" : "bridge",
    ///     "Type" : "Network"
    ///   },
    ///   {
    ///     "Name" : "host",
    ///     "Type" : "Network"
    ///   },
    ///   {
    ///     "Name" : "ipvlan",
    ///     "Type" : "Network"
    ///   },
    ///   {
    ///     "Name" : "macvlan",
    ///     "Type" : "Network"
    ///   },
    ///   {
    ///     "Name" : null,
    ///     "Type" : "Network"
    ///   },
    ///   {
    ///     "Name" : "overlay",
    ///     "Type" : "Network"
    ///   },
    ///   {
    ///     "Name" : "local",
    ///     "Type" : "Volume"
    ///   },
    ///   {
    ///     "Name" : "localhost:5000\/vieux\/sshfs:latest",
    ///     "Type" : "Volume"
    ///   },
    ///   {
    ///     "Name" : "vieux\/sshfs:latest",
    ///     "Type" : "Volume"
    ///   }
    /// ]
    public var plugins: [Plugin]?

    public struct Plugin: Codable {
        public var type: String?
        public var name: String?

        public init(type: String? = nil, name: String? = nil) {
            self.type = type
            self.name = name
        }

        private enum CodingKeys: String, CodingKey {
            case type = "Type"
            case name = "Name"
        }
    }

    public init(engineVersion: String? = nil, labels: [String: String]? = nil, plugins: [Plugin]? = nil) {
        self.engineVersion = engineVersion
        self.labels = labels
        self.plugins = plugins
    }

    private enum CodingKeys: String, CodingKey {
        case engineVersion = "EngineVersion"
        case labels = "Labels"
        case plugins = "Plugins"
    }
}

/// Information about the issuer of leaf TLS certificates and the trusted root CA certificate
///
/// Example:
///
/// {
///   "CertIssuerPublicKey" : "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEmT9XIw9h1qoNclv9VeHmf\/Vi6\/uI2vFXdBveXTpcPjqx6i9wNazchk1XWV\/dKTKvSh9xyGKmiIeRcE4OiMnJ1A==",
///   "CertIssuerSubject" : "MBMxETAPBgNVBAMTCHN3YXJtLWNh",
///   "TrustRoot" : "-----BEGIN CERTIFICATE-----\nMIIBajCCARCgAwIBAgIUbYqrLSOSQHoxD8CwG6Bi2PJi9c8wCgYIKoZIzj0EAwIw\nEzERMA8GA1UEAxMIc3dhcm0tY2EwHhcNMTcwNDI0MjE0MzAwWhcNMzcwNDE5MjE0\nMzAwWjATMREwDwYDVQQDEwhzd2FybS1jYTBZMBMGByqGSM49AgEGCCqGSM49AwEH\nA0IABJk\/VyMPYdaqDXJb\/VXh5n\/1Yuv7iNrxV3Qb3l06XD46seovcDWs3IZNV1lf\n3Skyr0ofcchipoiHkXBODojJydSjQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMB\nAf8EBTADAQH\/MB0GA1UdDgQWBBRUXxuRcnFjDfR\/RIAUQab8ZV\/n4jAKBggqhkjO\nPQQDAgNIADBFAiAy+JTe6Uc3KyLCMiqGl2GyWGQqQDEcO3\/YG36x7om65AIhAJvz\npxv6zFeVEkAEEkqIYi0omA9+CjanB\/6Bz4n1uw8H\n-----END CERTIFICATE-----\n"
/// }
public struct TLSInfo: Codable {
    /// The root CA certificate(s) that are used to validate leaf TLS certificates
    public var trustRoot: String?
    /// The base64-url-safe-encoded raw subject bytes of the issuer
    public var certIssuerSubject: String?
    /// The base64-url-safe-encoded raw public key bytes of the issuer
    public var certIssuerPublicKey: String?

    public init(trustRoot: String? = nil, certIssuerSubject: String? = nil, certIssuerPublicKey: String? = nil) {
        self.trustRoot = trustRoot
        self.certIssuerSubject = certIssuerSubject
        self.certIssuerPublicKey = certIssuerPublicKey
    }

    private enum CodingKeys: String, CodingKey {
        case trustRoot = "TrustRoot"
        case certIssuerSubject = "CertIssuerSubject"
        case certIssuerPublicKey = "CertIssuerPublicKey"
    }
}

/// NodeStatus represents the status of a node.
/// 
/// It provides the current status of the node, as seen by the manager.
public struct NodeStatus: Codable {
    /// NodeState represents the state of a node.
    ///
    /// Example: "ready"
    public var state: NodeState?
    public var message: String?
    /// IP address of the node.
    ///
    /// Example: "172.17.0.2"
    public var addr: String?

    public init(state: NodeState? = nil, message: String? = nil, addr: String? = nil) {
        self.state = state
        self.message = message
        self.addr = addr
    }

    private enum CodingKeys: String, CodingKey {
        case state = "State"
        case message = "Message"
        case addr = "Addr"
    }
}

/// NodeState represents the state of a node.
///
/// Example: "ready"
public enum NodeState: String, Codable, CaseIterable {
    case unknown
    case down
    case ready
    case disconnected
}

/// ManagerStatus represents the status of a manager.
/// 
/// It provides the current status of a node's manager component, if the node
/// is a manager.
public struct ManagerStatus: Codable {
    /// Example: true
    public var isLeader: Bool
    /// Reachability represents the reachability of a node.
    ///
    /// Example: "reachable"
    public var reachability: Reachability?
    /// The IP address and port at which the manager is reachable.
    ///
    /// Example: "10.0.0.46:2377"
    public var addr: String?

    public init(isLeader: Bool? = nil, reachability: Reachability? = nil, addr: String? = nil) {
        self.isLeader = isLeader ?? false
        self.reachability = reachability
        self.addr = addr
    }

    private enum CodingKeys: String, CodingKey {
        case isLeader = "Leader"
        case reachability = "Reachability"
        case addr = "Addr"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.isLeader = try values.decodeIfPresent(Bool.self, forKey: .isLeader) ?? false
        self.reachability = try values.decodeIfPresent(Reachability.self, forKey: .reachability)
        self.addr = try values.decodeIfPresent(String.self, forKey: .addr)
    }
}

/// Reachability represents the reachability of a node.
///
/// Example: "reachable"
public enum Reachability: String, Codable, CaseIterable {
    case unknown
    case unreachable
    case reachable
}

/// User modifiable swarm configuration.
public struct SwarmSpec: Codable {
    /// Name of the swarm.
    ///
    /// Example: "default"
    public var name: String?
    /// User-defined key/value metadata.
    ///
    /// Example:
    ///
    /// {
    ///   "com.example.corp.department" : "engineering",
    ///   "com.example.corp.type" : "production"
    /// }
    public var labels: [String: String]?
    /// Orchestration configuration.
    public var orchestration: Orchestration?
    /// Raft configuration.
    public var raft: Raft?
    /// Dispatcher configuration.
    public var dispatcher: Dispatcher?
    /// CA configuration.
    public var cAConfig: CAConfig?
    /// Parameters related to encryption-at-rest.
    public var encryptionConfig: EncryptionConfig?
    /// Defaults for creating tasks in this cluster.
    public var taskDefaults: TaskDefaults?

    /// Orchestration configuration.
    public struct Orchestration: Codable {
        /// The number of historic tasks to keep per instance or node. If negative, never remove completed or failed tasks.
        ///
        /// Example: 10
        public var taskHistoryRetentionLimit: Int?

        public init(taskHistoryRetentionLimit: Int? = nil) {
            self.taskHistoryRetentionLimit = taskHistoryRetentionLimit
        }

        private enum CodingKeys: String, CodingKey {
            case taskHistoryRetentionLimit = "TaskHistoryRetentionLimit"
        }
    }

    /// Raft configuration.
    public struct Raft: Codable {
        /// The number of log entries between snapshots.
        ///
        /// Example: 10000
        public var snapshotInterval: Int?
        /// The number of snapshots to keep beyond the current snapshot.
        public var keepOldSnapshots: Int?
        /// The number of log entries to keep around to sync up slow followers after a snapshot is created.
        ///
        /// Example: 500
        public var logEntriesForSlowFollowers: Int?
        /// The number of ticks that a follower will wait for a message from the leader before becoming a candidate and starting an election. `ElectionTick` must be greater than `HeartbeatTick`.
        /// 
        /// A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed.
        public var electionTick: Int?
        /// The number of ticks between heartbeats. Every HeartbeatTick ticks, the leader will send a heartbeat to the followers.
        /// 
        /// A tick currently defaults to one second, so these translate directly to seconds currently, but this is NOT guaranteed.
        public var heartbeatTick: Int?

        public init(snapshotInterval: Int? = nil, keepOldSnapshots: Int? = nil, logEntriesForSlowFollowers: Int? = nil, electionTick: Int? = nil, heartbeatTick: Int? = nil) {
            self.snapshotInterval = snapshotInterval
            self.keepOldSnapshots = keepOldSnapshots
            self.logEntriesForSlowFollowers = logEntriesForSlowFollowers
            self.electionTick = electionTick
            self.heartbeatTick = heartbeatTick
        }

        private enum CodingKeys: String, CodingKey {
            case snapshotInterval = "SnapshotInterval"
            case keepOldSnapshots = "KeepOldSnapshots"
            case logEntriesForSlowFollowers = "LogEntriesForSlowFollowers"
            case electionTick = "ElectionTick"
            case heartbeatTick = "HeartbeatTick"
        }
    }

    /// Dispatcher configuration.
    public struct Dispatcher: Codable {
        /// The delay for an agent to send a heartbeat to the dispatcher.
        ///
        /// Example: 5000000000
        public var heartbeatPeriod: Int?

        public init(heartbeatPeriod: Int? = nil) {
            self.heartbeatPeriod = heartbeatPeriod
        }

        private enum CodingKeys: String, CodingKey {
            case heartbeatPeriod = "HeartbeatPeriod"
        }
    }

    /// CA configuration.
    public struct CAConfig: Codable {
        /// The duration node certificates are issued for.
        ///
        /// Example: 7776000000000000
        public var nodeCertExpiry: Int?
        /// Configuration for forwarding signing requests to an external certificate authority.
        public var externalCAs: [ExternalCA]?
        /// The desired signing CA certificate for all swarm node TLS leaf certificates, in PEM format.
        public var signingCACert: String?
        /// The desired signing CA key for all swarm node TLS leaf certificates, in PEM format.
        public var signingCAKey: String?
        /// An integer whose purpose is to force swarm to generate a new signing CA certificate and key, if none have been specified in `SigningCACert` and `SigningCAKey`
        public var forceRotate: Int?

        public struct ExternalCA: Codable {
            /// Protocol for communication with the external CA (currently only `cfssl` is supported).
            public var `protocol`: `Protocol`?
            /// URL where certificate signing requests should be sent.
            public var url: String?
            /// An object with key/value pairs that are interpreted as protocol-specific options for the external CA driver.
            public var options: [String: String]?
            /// The root CA certificate (in PEM format) this external CA uses to issue TLS certificates (assumed to be to the current swarm root CA certificate if not provided).
            public var cACert: String?

            /// Protocol for communication with the external CA (currently only `cfssl` is supported).
            public enum `Protocol`: String, Codable, CaseIterable {
                case cfssl
            }

            public init(`protocol`: `Protocol`? = nil, url: String? = nil, options: [String: String]? = nil, cACert: String? = nil) {
                self.protocol = `protocol`
                self.url = url
                self.options = options
                self.cACert = cACert
            }

            private enum CodingKeys: String, CodingKey {
                case `protocol` = "Protocol"
                case url = "URL"
                case options = "Options"
                case cACert = "CACert"
            }
        }

        public init(nodeCertExpiry: Int? = nil, externalCAs: [ExternalCA]? = nil, signingCACert: String? = nil, signingCAKey: String? = nil, forceRotate: Int? = nil) {
            self.nodeCertExpiry = nodeCertExpiry
            self.externalCAs = externalCAs
            self.signingCACert = signingCACert
            self.signingCAKey = signingCAKey
            self.forceRotate = forceRotate
        }

        private enum CodingKeys: String, CodingKey {
            case nodeCertExpiry = "NodeCertExpiry"
            case externalCAs = "ExternalCAs"
            case signingCACert = "SigningCACert"
            case signingCAKey = "SigningCAKey"
            case forceRotate = "ForceRotate"
        }
    }

    /// Parameters related to encryption-at-rest.
    public struct EncryptionConfig: Codable {
        /// If set, generate a key and use it to lock data stored on the managers.
        ///
        /// Example: false
        public var autoLockManagers: Bool?

        public init(autoLockManagers: Bool? = nil) {
            self.autoLockManagers = autoLockManagers
        }

        private enum CodingKeys: String, CodingKey {
            case autoLockManagers = "AutoLockManagers"
        }
    }

    /// Defaults for creating tasks in this cluster.
    public struct TaskDefaults: Codable {
        /// The log driver to use for tasks created in the orchestrator if
        /// unspecified by a service.
        /// 
        /// Updating this value only affects new tasks. Existing tasks continue
        /// to use their previously configured log driver until recreated.
        public var logDriver: LogDriver?

        /// The log driver to use for tasks created in the orchestrator if
        /// unspecified by a service.
        /// 
        /// Updating this value only affects new tasks. Existing tasks continue
        /// to use their previously configured log driver until recreated.
        public struct LogDriver: Codable {
            /// The log driver to use as a default for new tasks.
            ///
            /// Example: "json-file"
            public var name: String?
            /// Driver-specific options for the selectd log driver, specified
            /// as key/value pairs.
            ///
            /// Example:
            ///
            /// {
            ///   "max-file" : "10",
            ///   "max-size" : "100m"
            /// }
            public var options: [String: String]?

            public init(name: String? = nil, options: [String: String]? = nil) {
                self.name = name
                self.options = options
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case options = "Options"
            }
        }

        public init(logDriver: LogDriver? = nil) {
            self.logDriver = logDriver
        }

        private enum CodingKeys: String, CodingKey {
            case logDriver = "LogDriver"
        }
    }

    public init(name: String? = nil, labels: [String: String]? = nil, orchestration: Orchestration? = nil, raft: Raft? = nil, dispatcher: Dispatcher? = nil, cAConfig: CAConfig? = nil, encryptionConfig: EncryptionConfig? = nil, taskDefaults: TaskDefaults? = nil) {
        self.name = name
        self.labels = labels
        self.orchestration = orchestration
        self.raft = raft
        self.dispatcher = dispatcher
        self.cAConfig = cAConfig
        self.encryptionConfig = encryptionConfig
        self.taskDefaults = taskDefaults
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case labels = "Labels"
        case orchestration = "Orchestration"
        case raft = "Raft"
        case dispatcher = "Dispatcher"
        case cAConfig = "CAConfig"
        case encryptionConfig = "EncryptionConfig"
        case taskDefaults = "TaskDefaults"
    }
}

/// ClusterInfo represents information about the swarm as is returned by the
/// "/info" endpoint. Join-tokens are not included.
public struct ClusterInfo: Codable {
    /// The ID of the swarm.
    ///
    /// Example: "abajmipo7b4xz5ip2nrla6b11"
    public var id: String?
    /// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
    /// The client must send the version number along with the modified specification when updating these objects.
    /// This approach ensures safe concurrency and determinism in that the change on the object
    /// may not be applied if the version number has changed from the last read. In other words,
    /// if two update requests specify the same base version, only one of the requests can succeed.
    /// As a result, two separate update requests that happen at the same time will not
    /// unintentionally overwrite each other.
    public var version: ObjectVersion?
    /// Date and time at which the swarm was initialised in
    /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
    ///
    /// Example: "2016-08-18T10:44:24.496525531Z"
    public var createdAt: String?
    /// Date and time at which the swarm was last updated in
    /// [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format with nano-seconds.
    ///
    /// Example: "2017-08-09T07:09:37.632105588Z"
    public var updatedAt: String?
    /// User modifiable swarm configuration.
    public var spec: SwarmSpec?
    /// Information about the issuer of leaf TLS certificates and the trusted root CA certificate
    ///
    /// Example:
    ///
    /// {
    ///   "CertIssuerPublicKey" : "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEmT9XIw9h1qoNclv9VeHmf\/Vi6\/uI2vFXdBveXTpcPjqx6i9wNazchk1XWV\/dKTKvSh9xyGKmiIeRcE4OiMnJ1A==",
    ///   "CertIssuerSubject" : "MBMxETAPBgNVBAMTCHN3YXJtLWNh",
    ///   "TrustRoot" : "-----BEGIN CERTIFICATE-----\nMIIBajCCARCgAwIBAgIUbYqrLSOSQHoxD8CwG6Bi2PJi9c8wCgYIKoZIzj0EAwIw\nEzERMA8GA1UEAxMIc3dhcm0tY2EwHhcNMTcwNDI0MjE0MzAwWhcNMzcwNDE5MjE0\nMzAwWjATMREwDwYDVQQDEwhzd2FybS1jYTBZMBMGByqGSM49AgEGCCqGSM49AwEH\nA0IABJk\/VyMPYdaqDXJb\/VXh5n\/1Yuv7iNrxV3Qb3l06XD46seovcDWs3IZNV1lf\n3Skyr0ofcchipoiHkXBODojJydSjQjBAMA4GA1UdDwEB\/wQEAwIBBjAPBgNVHRMB\nAf8EBTADAQH\/MB0GA1UdDgQWBBRUXxuRcnFjDfR\/RIAUQab8ZV\/n4jAKBggqhkjO\nPQQDAgNIADBFAiAy+JTe6Uc3KyLCMiqGl2GyWGQqQDEcO3\/YG36x7om65AIhAJvz\npxv6zFeVEkAEEkqIYi0omA9+CjanB\/6Bz4n1uw8H\n-----END CERTIFICATE-----\n"
    /// }
    public var tlsInfo: TLSInfo?
    /// Whether there is currently a root CA rotation in progress for the swarm
    ///
    /// Example: false
    public var isRootRotationInProgress: Bool?

    public init(id: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, spec: SwarmSpec? = nil, tlsInfo: TLSInfo? = nil, isRootRotationInProgress: Bool? = nil) {
        self.id = id
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.spec = spec
        self.tlsInfo = tlsInfo
        self.isRootRotationInProgress = isRootRotationInProgress
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case spec = "Spec"
        case tlsInfo = "TLSInfo"
        case isRootRotationInProgress = "RootRotationInProgress"
    }
}

/// JoinTokens contains the tokens workers and managers need to join the swarm.
public struct JoinTokens: Codable {
    /// The token workers can use to join the swarm.
    ///
    /// Example: "SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-1awxwuwd3z9j1z3puu7rcgdbx"
    public var worker: String?
    /// The token managers can use to join the swarm.
    ///
    /// Example: "SWMTKN-1-3pu6hszjas19xyp7ghgosyx9k8atbfcr8p2is99znpy26u2lkl-7p73s1dx5in4tatdymyhg9hu2"
    public var manager: String?

    public init(worker: String? = nil, manager: String? = nil) {
        self.worker = worker
        self.manager = manager
    }

    private enum CodingKeys: String, CodingKey {
        case worker = "Worker"
        case manager = "Manager"
    }
}

public struct Swarm: Codable {
    /// ClusterInfo represents information about the swarm as is returned by the
    /// "/info" endpoint. Join-tokens are not included.
    public var clusterInfo: ClusterInfo?
    /// JoinTokens contains the tokens workers and managers need to join the swarm.
    public var joinTokens: JoinTokens?

    public init(clusterInfo: ClusterInfo? = nil, joinTokens: JoinTokens? = nil) {
        self.clusterInfo = clusterInfo
        self.joinTokens = joinTokens
    }

    public init(from decoder: Decoder) throws {
        self.clusterInfo = try ClusterInfo(from: decoder)
        self.joinTokens = try JoinTokens(from: decoder)
    }

    public func encode(to encoder: Encoder) throws {
        var values = encoder.container(keyedBy: StringCodingKey.self)
        try values.encodeIfPresent(clusterInfo, forKey: "clusterInfo")
        try values.encodeIfPresent(joinTokens, forKey: "JoinTokens")
    }
}

/// User modifiable task configuration.
public struct TaskSpec: Codable {
    /// Invalid when specified with `ContainerSpec`. *(Experimental release only.)*
    public var pluginSpec: PluginSpec?
    /// Invalid when specified with `PluginSpec`.
    public var containerSpec: ContainerSpec?
    /// Resource requirements which apply to each individual container created as part of the service.
    public var resources: Resources?
    /// Specification for the restart policy which applies to containers created as part of this service.
    public var restartPolicy: RestartPolicy?
    public var placement: Placement?
    /// A counter that triggers an update even if no relevant parameters have been changed.
    public var forceUpdate: Int?
    /// Runtime is the type of runtime specified for the task executor.
    public var runtime: String?
    public var networks: [Network]?
    /// Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
    public var logDriver: LogDriver?

    /// Invalid when specified with `ContainerSpec`. *(Experimental release only.)*
    public struct PluginSpec: Codable {
        /// The name or 'alias' to use for the plugin.
        public var name: String?
        /// The plugin image reference to use.
        public var remote: String?
        /// Disable the plugin once scheduled.
        public var isDisabled: Bool?
        public var pluginPrivilege: [PluginPrivilegeItem]?

        /// Describes a permission accepted by the user upon installing the plugin.
        public struct PluginPrivilegeItem: Codable {
            public var name: String?
            public var description: String?
            public var value: [String]?

            public init(name: String? = nil, description: String? = nil, value: [String]? = nil) {
                self.name = name
                self.description = description
                self.value = value
            }

            private enum CodingKeys: String, CodingKey {
                case name = "Name"
                case description = "Description"
                case value = "Value"
            }
        }

        public init(name: String? = nil, remote: String? = nil, isDisabled: Bool? = nil, pluginPrivilege: [PluginPrivilegeItem]? = nil) {
            self.name = name
            self.remote = remote
            self.isDisabled = isDisabled
            self.pluginPrivilege = pluginPrivilege
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case remote = "Remote"
            case isDisabled = "Disabled"
            case pluginPrivilege = "PluginPrivilege"
        }
    }

    /// Invalid when specified with `PluginSpec`.
    public struct ContainerSpec: Codable {
        /// The image name to use for the container
        public var image: String?
        /// User-defined key/value data.
        public var labels: [String: String]?
        /// The command to be run in the image.
        public var command: [String]?
        /// Arguments to the command.
        public var args: [String]?
        /// The hostname to use for the container, as a valid RFC 1123 hostname.
        public var hostname: String?
        /// A list of environment variables in the form `VAR=value`.
        public var env: [String]?
        /// The working directory for commands to run in.
        public var dir: String?
        /// The user inside the container.
        public var user: String?
        /// A list of additional groups that the container process will run as.
        public var groups: [String]?
        /// Security options for the container
        public var privileges: Privileges?
        /// Whether a pseudo-TTY should be allocated.
        public var isTty: Bool?
        /// Open `stdin`
        public var isOpenStdin: Bool?
        /// Mount the container's root filesystem as read only.
        public var isReadOnly: Bool?
        /// Specification for mounts to be added to containers created as part of the service.
        public var mounts: [Mount]?
        /// Signal to stop the container.
        public var stopSignal: String?
        /// Amount of time to wait for the container to terminate before forcefully killing it.
        public var stopGracePeriod: Int?
        /// A test to perform to check that the container is healthy.
        public var healthCheck: HealthConfig?
        /// A list of hostname/IP mappings to add to the container's `hosts`
        /// file. The format of extra hosts is specified in the
        /// [hosts(5)](http://man7.org/linux/man-pages/man5/hosts.5.html)
        /// man page:
        /// 
        ///     IP_address canonical_hostname [aliases...]
        public var hosts: [String]?
        /// Specification for DNS related configurations in resolver configuration file (`resolv.conf`).
        public var dnsConfig: DNSConfig?
        /// Secrets contains references to zero or more secrets that will be exposed to the service.
        public var secrets: [Secret]?
        /// Configs contains references to zero or more configs that will be exposed to the service.
        public var configs: [Config]?

        /// Security options for the container
        public struct Privileges: Codable {
            /// CredentialSpec for managed service account (Windows only)
            public var credentialSpec: CredentialSpec?
            /// SELinux labels of the container
            public var sELinuxContext: SELinuxContext?

            /// CredentialSpec for managed service account (Windows only)
            public struct CredentialSpec: Codable {
                /// Load credential spec from this file. The file is read by the daemon, and must be present in the
                /// `CredentialSpecs` subdirectory in the docker data directory, which defaults to
                /// `C:\ProgramData\Docker\` on Windows.
                /// 
                /// For example, specifying `spec.json` loads `C:\ProgramData\Docker\CredentialSpecs\spec.json`.
                /// 
                /// <p><br /></p>
                /// 
                /// > **Note**: `CredentialSpec.File` and `CredentialSpec.Registry` are mutually exclusive.
                public var file: String?
                /// Load credential spec from this value in the Windows registry. The specified registry value must be
                /// located in:
                /// 
                /// `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Virtualization\Containers\CredentialSpecs`
                /// 
                /// <p><br /></p>
                /// 
                /// 
                /// > **Note**: `CredentialSpec.File` and `CredentialSpec.Registry` are mutually exclusive.
                public var registry: String?

                public init(file: String? = nil, registry: String? = nil) {
                    self.file = file
                    self.registry = registry
                }

                private enum CodingKeys: String, CodingKey {
                    case file = "File"
                    case registry = "Registry"
                }
            }

            /// SELinux labels of the container
            public struct SELinuxContext: Codable {
                /// Disable SELinux
                public var isDisable: Bool?
                /// SELinux user label
                public var user: String?
                /// SELinux role label
                public var role: String?
                /// SELinux type label
                public var type: String?
                /// SELinux level label
                public var level: String?

                public init(isDisable: Bool? = nil, user: String? = nil, role: String? = nil, type: String? = nil, level: String? = nil) {
                    self.isDisable = isDisable
                    self.user = user
                    self.role = role
                    self.type = type
                    self.level = level
                }

                private enum CodingKeys: String, CodingKey {
                    case isDisable = "Disable"
                    case user = "User"
                    case role = "Role"
                    case type = "Type"
                    case level = "Level"
                }
            }

            public init(credentialSpec: CredentialSpec? = nil, sELinuxContext: SELinuxContext? = nil) {
                self.credentialSpec = credentialSpec
                self.sELinuxContext = sELinuxContext
            }

            private enum CodingKeys: String, CodingKey {
                case credentialSpec = "CredentialSpec"
                case sELinuxContext = "SELinuxContext"
            }
        }

        /// Specification for DNS related configurations in resolver configuration file (`resolv.conf`).
        public struct DNSConfig: Codable {
            /// The IP addresses of the name servers.
            public var nameservers: [String]?
            /// A search list for host-name lookup.
            public var search: [String]?
            /// A list of internal resolver variables to be modified (e.g., `debug`, `ndots:3`, etc.).
            public var options: [String]?

            public init(nameservers: [String]? = nil, search: [String]? = nil, options: [String]? = nil) {
                self.nameservers = nameservers
                self.search = search
                self.options = options
            }

            private enum CodingKeys: String, CodingKey {
                case nameservers = "Nameservers"
                case search = "Search"
                case options = "Options"
            }
        }

        public struct Secret: Codable {
            /// File represents a specific target that is backed by a file.
            public var file: File?
            /// SecretID represents the ID of the specific secret that we're referencing.
            public var secretID: String?
            /// SecretName is the name of the secret that this references, but this is just provided for
            /// lookup/display purposes. The secret in the reference will be identified by its ID.
            public var secretName: String?

            /// File represents a specific target that is backed by a file.
            public struct File: Codable {
                /// Name represents the final filename in the filesystem.
                public var name: String?
                /// UID represents the file UID.
                public var uid: String?
                /// GID represents the file GID.
                public var gid: String?
                /// Mode represents the FileMode of the file.
                public var mode: Int?

                public init(name: String? = nil, uid: String? = nil, gid: String? = nil, mode: Int? = nil) {
                    self.name = name
                    self.uid = uid
                    self.gid = gid
                    self.mode = mode
                }

                private enum CodingKeys: String, CodingKey {
                    case name = "Name"
                    case uid = "UID"
                    case gid = "GID"
                    case mode = "Mode"
                }
            }

            public init(file: File? = nil, secretID: String? = nil, secretName: String? = nil) {
                self.file = file
                self.secretID = secretID
                self.secretName = secretName
            }

            private enum CodingKeys: String, CodingKey {
                case file = "File"
                case secretID = "SecretID"
                case secretName = "SecretName"
            }
        }

        public struct Config: Codable {
            /// File represents a specific target that is backed by a file.
            public var file: File?
            /// ConfigID represents the ID of the specific config that we're referencing.
            public var configID: String?
            /// ConfigName is the name of the config that this references, but this is just provided for
            /// lookup/display purposes. The config in the reference will be identified by its ID.
            public var configName: String?

            /// File represents a specific target that is backed by a file.
            public struct File: Codable {
                /// Name represents the final filename in the filesystem.
                public var name: String?
                /// UID represents the file UID.
                public var uid: String?
                /// GID represents the file GID.
                public var gid: String?
                /// Mode represents the FileMode of the file.
                public var mode: Int?

                public init(name: String? = nil, uid: String? = nil, gid: String? = nil, mode: Int? = nil) {
                    self.name = name
                    self.uid = uid
                    self.gid = gid
                    self.mode = mode
                }

                private enum CodingKeys: String, CodingKey {
                    case name = "Name"
                    case uid = "UID"
                    case gid = "GID"
                    case mode = "Mode"
                }
            }

            public init(file: File? = nil, configID: String? = nil, configName: String? = nil) {
                self.file = file
                self.configID = configID
                self.configName = configName
            }

            private enum CodingKeys: String, CodingKey {
                case file = "File"
                case configID = "ConfigID"
                case configName = "ConfigName"
            }
        }

        public init(image: String? = nil, labels: [String: String]? = nil, command: [String]? = nil, args: [String]? = nil, hostname: String? = nil, env: [String]? = nil, dir: String? = nil, user: String? = nil, groups: [String]? = nil, privileges: Privileges? = nil, isTty: Bool? = nil, isOpenStdin: Bool? = nil, isReadOnly: Bool? = nil, mounts: [Mount]? = nil, stopSignal: String? = nil, stopGracePeriod: Int? = nil, healthCheck: HealthConfig? = nil, hosts: [String]? = nil, dnsConfig: DNSConfig? = nil, secrets: [Secret]? = nil, configs: [Config]? = nil) {
            self.image = image
            self.labels = labels
            self.command = command
            self.args = args
            self.hostname = hostname
            self.env = env
            self.dir = dir
            self.user = user
            self.groups = groups
            self.privileges = privileges
            self.isTty = isTty
            self.isOpenStdin = isOpenStdin
            self.isReadOnly = isReadOnly
            self.mounts = mounts
            self.stopSignal = stopSignal
            self.stopGracePeriod = stopGracePeriod
            self.healthCheck = healthCheck
            self.hosts = hosts
            self.dnsConfig = dnsConfig
            self.secrets = secrets
            self.configs = configs
        }

        private enum CodingKeys: String, CodingKey {
            case image = "Image"
            case labels = "Labels"
            case command = "Command"
            case args = "Args"
            case hostname = "Hostname"
            case env = "Env"
            case dir = "Dir"
            case user = "User"
            case groups = "Groups"
            case privileges = "Privileges"
            case isTty = "TTY"
            case isOpenStdin = "OpenStdin"
            case isReadOnly = "ReadOnly"
            case mounts = "Mounts"
            case stopSignal = "StopSignal"
            case stopGracePeriod = "StopGracePeriod"
            case healthCheck = "HealthCheck"
            case hosts = "Hosts"
            case dnsConfig = "DNSConfig"
            case secrets = "Secrets"
            case configs = "Configs"
        }
    }

    /// Resource requirements which apply to each individual container created as part of the service.
    public struct Resources: Codable {
        /// An object describing the resources which can be advertised by a node and requested by a task
        public var limits: ResourceObject?
        /// An object describing the resources which can be advertised by a node and requested by a task
        public var reservation: ResourceObject?

        public init(limits: ResourceObject? = nil, reservation: ResourceObject? = nil) {
            self.limits = limits
            self.reservation = reservation
        }

        private enum CodingKeys: String, CodingKey {
            case limits = "Limits"
            case reservation = "Reservation"
        }
    }

    /// Specification for the restart policy which applies to containers created as part of this service.
    public struct RestartPolicy: Codable {
        /// Condition for restart.
        public var condition: Condition?
        /// Delay between restart attempts.
        public var delay: Int?
        /// Maximum attempts to restart a given container before giving up (default value is 0, which is ignored).
        public var maxAttempts: Int?
        /// Windows is the time window used to evaluate the restart policy (default value is 0, which is unbounded).
        public var window: Int?

        /// Condition for restart.
        public enum Condition: String, Codable, CaseIterable {
            case `none`
            case onFailure = "on-failure"
            case any
        }

        public init(condition: Condition? = nil, delay: Int? = nil, maxAttempts: Int? = nil, window: Int? = nil) {
            self.condition = condition
            self.delay = delay
            self.maxAttempts = maxAttempts
            self.window = window
        }

        private enum CodingKeys: String, CodingKey {
            case condition = "Condition"
            case delay = "Delay"
            case maxAttempts = "MaxAttempts"
            case window = "Window"
        }
    }

    public struct Placement: Codable {
        /// An array of constraints.
        ///
        /// Example: ["node.hostname!=node3.corp.example.com", "node.role!=manager", "node.labels.type==production"]
        public var constraints: [String]?
        /// Preferences provide a way to make the scheduler aware of factors such as topology. They are provided in order from highest to lowest precedence.
        ///
        /// Example:
        ///
        /// [
        ///   {
        ///     "Spread" : {
        ///       "SpreadDescriptor" : "node.labels.datacenter"
        ///     }
        ///   },
        ///   {
        ///     "Spread" : {
        ///       "SpreadDescriptor" : "node.labels.rack"
        ///     }
        ///   }
        /// ]
        public var preferences: [Preference]?
        /// Platforms stores all the platforms that the service's image can
        /// run on. This field is used in the platform filter for scheduling.
        /// If empty, then the platform filter is off, meaning there are no
        /// scheduling restrictions.
        public var platforms: [Platform]?

        public struct Preference: Codable {
            public var spread: Spread?

            public struct Spread: Codable {
                /// Label descriptor, such as engine.labels.az
                public var spreadDescriptor: String?

                public init(spreadDescriptor: String? = nil) {
                    self.spreadDescriptor = spreadDescriptor
                }

                private enum CodingKeys: String, CodingKey {
                    case spreadDescriptor = "SpreadDescriptor"
                }
            }

            public init(spread: Spread? = nil) {
                self.spread = spread
            }

            private enum CodingKeys: String, CodingKey {
                case spread = "Spread"
            }
        }

        public init(constraints: [String]? = nil, preferences: [Preference]? = nil, platforms: [Platform]? = nil) {
            self.constraints = constraints
            self.preferences = preferences
            self.platforms = platforms
        }

        private enum CodingKeys: String, CodingKey {
            case constraints = "Constraints"
            case preferences = "Preferences"
            case platforms = "Platforms"
        }
    }

    public struct Network: Codable {
        public var target: String?
        public var aliases: [String]?

        public init(target: String? = nil, aliases: [String]? = nil) {
            self.target = target
            self.aliases = aliases
        }

        private enum CodingKeys: String, CodingKey {
            case target = "Target"
            case aliases = "Aliases"
        }
    }

    /// Specifies the log driver to use for tasks created from this spec. If not present, the default one for the swarm will be used, finally falling back to the engine default if not specified.
    public struct LogDriver: Codable {
        public var name: String?
        public var options: [String: String]?

        public init(name: String? = nil, options: [String: String]? = nil) {
            self.name = name
            self.options = options
        }

        private enum CodingKeys: String, CodingKey {
            case name = "Name"
            case options = "Options"
        }
    }

    public init(pluginSpec: PluginSpec? = nil, containerSpec: ContainerSpec? = nil, resources: Resources? = nil, restartPolicy: RestartPolicy? = nil, placement: Placement? = nil, forceUpdate: Int? = nil, runtime: String? = nil, networks: [Network]? = nil, logDriver: LogDriver? = nil) {
        self.pluginSpec = pluginSpec
        self.containerSpec = containerSpec
        self.resources = resources
        self.restartPolicy = restartPolicy
        self.placement = placement
        self.forceUpdate = forceUpdate
        self.runtime = runtime
        self.networks = networks
        self.logDriver = logDriver
    }

    private enum CodingKeys: String, CodingKey {
        case pluginSpec = "PluginSpec"
        case containerSpec = "ContainerSpec"
        case resources = "Resources"
        case restartPolicy = "RestartPolicy"
        case placement = "Placement"
        case forceUpdate = "ForceUpdate"
        case runtime = "Runtime"
        case networks = "Networks"
        case logDriver = "LogDriver"
    }
}

public enum TaskState: String, Codable, CaseIterable {
    case new
    case allocated
    case pending
    case assigned
    case accepted
    case preparing
    case ready
    case starting
    case running
    case complete
    case shutdown
    case failed
    case rejected
}

/// Example:
///
/// {
///   "AssignedGenericResources" : [
///     {
///       "DiscreteResourceSpec" : {
///         "Kind" : "SSD",
///         "Value" : 3
///       }
///     },
///     {
///       "NamedResourceSpec" : {
///         "Kind" : "GPU",
///         "Value" : "UUID1"
///       }
///     },
///     {
///       "NamedResourceSpec" : {
///         "Kind" : "GPU",
///         "Value" : "UUID2"
///       }
///     }
///   ],
///   "CreatedAt" : "2016-06-07T21:07:31.171892745Z",
///   "DesiredState" : "running",
///   "ID" : "0kzzo1i0y4jz6027t0k7aezc7",
///   "NetworksAttachments" : [
///     {
///       "Addresses" : [
///         "10.255.0.10\/16"
///       ],
///       "Network" : {
///         "CreatedAt" : "2016-06-07T20:31:11.912919752Z",
///         "DriverState" : {
///           "Name" : "overlay",
///           "Options" : {
///             "com.docker.network.driver.overlay.vxlanid_list" : "256"
///           }
///         },
///         "ID" : "4qvuz4ko70xaltuqbt8956gd1",
///         "IPAMOptions" : {
///           "Configs" : [
///             {
///               "Gateway" : "10.255.0.1",
///               "Subnet" : "10.255.0.0\/16"
///             }
///           ],
///           "Driver" : {
///             "Name" : "default"
///           }
///         },
///         "Spec" : {
///           "DriverConfiguration" : {
/// 
///           },
///           "IPAMOptions" : {
///             "Configs" : [
///               {
///                 "Gateway" : "10.255.0.1",
///                 "Subnet" : "10.255.0.0\/16"
///               }
///             ],
///             "Driver" : {
/// 
///             }
///           },
///           "Labels" : {
///             "com.docker.swarm.internal" : true
///           },
///           "Name" : "ingress"
///         },
///         "UpdatedAt" : "2016-06-07T21:07:29.955277358Z",
///         "Version" : {
///           "Index" : 18
///         }
///       }
///     }
///   ],
///   "NodeID" : "60gvrl6tm78dmak4yl7srz94v",
///   "ServiceID" : "9mnpnzenvg8p8tdbtq4wvbkcz",
///   "Slot" : 1,
///   "Spec" : {
///     "ContainerSpec" : {
///       "Image" : "redis"
///     },
///     "Placement" : {
/// 
///     },
///     "Resources" : {
///       "Limits" : {
/// 
///       },
///       "Reservations" : {
/// 
///       }
///     },
///     "RestartPolicy" : {
///       "Condition" : "any",
///       "MaxAttempts" : 0
///     }
///   },
///   "Status" : {
///     "ContainerStatus" : {
///       "ContainerID" : "e5d62702a1b48d01c3e02ca1e0212a250801fa8d67caca0b6f35919ebc12f035",
///       "PID" : 677
///     },
///     "Message" : "started",
///     "State" : "running",
///     "Timestamp" : "2016-06-07T21:07:31.290032978Z"
///   },
///   "UpdatedAt" : "2016-06-07T21:07:31.376370513Z",
///   "Version" : {
///     "Index" : 71
///   }
/// }
public struct Task: Codable {
    /// The ID of the task.
    public var id: String?
    /// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
    /// The client must send the version number along with the modified specification when updating these objects.
    /// This approach ensures safe concurrency and determinism in that the change on the object
    /// may not be applied if the version number has changed from the last read. In other words,
    /// if two update requests specify the same base version, only one of the requests can succeed.
    /// As a result, two separate update requests that happen at the same time will not
    /// unintentionally overwrite each other.
    public var version: ObjectVersion?
    public var createdAt: String?
    public var updatedAt: String?
    /// Name of the task.
    public var name: String?
    /// User-defined key/value metadata.
    public var labels: [String: String]?
    /// User modifiable task configuration.
    public var spec: TaskSpec?
    /// The ID of the service this task is part of.
    public var serviceID: String?
    public var slot: Int?
    /// The ID of the node that this task is on.
    public var nodeID: String?
    /// User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, `GPU=UUID1`)
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "DiscreteResourceSpec" : {
    ///       "Kind" : "SSD",
    ///       "Value" : 3
    ///     }
    ///   },
    ///   {
    ///     "NamedResourceSpec" : {
    ///       "Kind" : "GPU",
    ///       "Value" : "UUID1"
    ///     }
    ///   },
    ///   {
    ///     "NamedResourceSpec" : {
    ///       "Kind" : "GPU",
    ///       "Value" : "UUID2"
    ///     }
    ///   }
    /// ]
    public var assignedGenericResources: [GenericResource]?
    public var status: Status?
    public var desiredState: TaskState?

    public struct Status: Codable {
        public var timestamp: String?
        public var state: TaskState?
        public var message: String?
        public var err: String?
        public var containerStatus: ContainerStatus?

        public struct ContainerStatus: Codable {
            public var containerID: String?
            public var pid: Int?
            public var exitCode: Int?

            public init(containerID: String? = nil, pid: Int? = nil, exitCode: Int? = nil) {
                self.containerID = containerID
                self.pid = pid
                self.exitCode = exitCode
            }

            private enum CodingKeys: String, CodingKey {
                case containerID = "ContainerID"
                case pid = "PID"
                case exitCode = "ExitCode"
            }
        }

        public init(timestamp: String? = nil, state: TaskState? = nil, message: String? = nil, err: String? = nil, containerStatus: ContainerStatus? = nil) {
            self.timestamp = timestamp
            self.state = state
            self.message = message
            self.err = err
            self.containerStatus = containerStatus
        }

        private enum CodingKeys: String, CodingKey {
            case timestamp = "Timestamp"
            case state = "State"
            case message = "Message"
            case err = "Err"
            case containerStatus = "ContainerStatus"
        }
    }

    public init(id: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, name: String? = nil, labels: [String: String]? = nil, spec: TaskSpec? = nil, serviceID: String? = nil, slot: Int? = nil, nodeID: String? = nil, assignedGenericResources: [GenericResource]? = nil, status: Status? = nil, desiredState: TaskState? = nil) {
        self.id = id
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.name = name
        self.labels = labels
        self.spec = spec
        self.serviceID = serviceID
        self.slot = slot
        self.nodeID = nodeID
        self.assignedGenericResources = assignedGenericResources
        self.status = status
        self.desiredState = desiredState
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case name = "Name"
        case labels = "Labels"
        case spec = "Spec"
        case serviceID = "ServiceID"
        case slot = "Slot"
        case nodeID = "NodeID"
        case assignedGenericResources = "AssignedGenericResources"
        case status = "Status"
        case desiredState = "DesiredState"
    }
}

/// User modifiable configuration for a service.
public struct ServiceSpec: Codable {
    /// Name of the service.
    public var name: String?
    /// User-defined key/value metadata.
    public var labels: [String: String]?
    /// User modifiable task configuration.
    public var taskTemplate: TaskSpec?
    /// Scheduling mode for the service.
    public var mode: Mode?
    /// Specification for the update strategy of the service.
    public var updateConfig: UpdateConfig?
    /// Specification for the rollback strategy of the service.
    public var rollbackConfig: RollbackConfig?
    /// Array of network names or IDs to attach the service to.
    public var networks: [Network]?
    /// Properties that can be configured to access and load balance a service.
    public var endpointSpec: EndpointSpec?

    /// Scheduling mode for the service.
    public struct Mode: Codable {
        public var replicated: Replicated?
        public var global: [String: AnyJSON]?

        public struct Replicated: Codable {
            public var replicas: Int?

            public init(replicas: Int? = nil) {
                self.replicas = replicas
            }

            private enum CodingKeys: String, CodingKey {
                case replicas = "Replicas"
            }
        }

        public init(replicated: Replicated? = nil, global: [String: AnyJSON]? = nil) {
            self.replicated = replicated
            self.global = global
        }

        private enum CodingKeys: String, CodingKey {
            case replicated = "Replicated"
            case global = "Global"
        }
    }

    /// Specification for the update strategy of the service.
    public struct UpdateConfig: Codable {
        /// Maximum number of tasks to be updated in one iteration (0 means unlimited parallelism).
        public var parallelism: Int?
        /// Amount of time between updates, in nanoseconds.
        public var delay: Int?
        /// Action to take if an updated task fails to run, or stops running during the update.
        public var failureAction: FailureAction?
        /// Amount of time to monitor each updated task for failures, in nanoseconds.
        public var monitor: Int?
        /// The fraction of tasks that may fail during an update before the failure action is invoked, specified as a floating point number between 0 and 1.
        public var maxFailureRatio: Double?
        /// The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
        public var order: Order?

        /// Action to take if an updated task fails to run, or stops running during the update.
        public enum FailureAction: String, Codable, CaseIterable {
            case `continue`
            case pause
            case rollback
        }

        /// The order of operations when rolling out an updated task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
        public enum Order: String, Codable, CaseIterable {
            case stopFirst = "stop-first"
            case startFirst = "start-first"
        }

        public init(parallelism: Int? = nil, delay: Int? = nil, failureAction: FailureAction? = nil, monitor: Int? = nil, maxFailureRatio: Double? = nil, order: Order? = nil) {
            self.parallelism = parallelism
            self.delay = delay
            self.failureAction = failureAction
            self.monitor = monitor
            self.maxFailureRatio = maxFailureRatio
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case parallelism = "Parallelism"
            case delay = "Delay"
            case failureAction = "FailureAction"
            case monitor = "Monitor"
            case maxFailureRatio = "MaxFailureRatio"
            case order = "Order"
        }
    }

    /// Specification for the rollback strategy of the service.
    public struct RollbackConfig: Codable {
        /// Maximum number of tasks to be rolled back in one iteration (0 means unlimited parallelism).
        public var parallelism: Int?
        /// Amount of time between rollback iterations, in nanoseconds.
        public var delay: Int?
        /// Action to take if an rolled back task fails to run, or stops running during the rollback.
        public var failureAction: FailureAction?
        /// Amount of time to monitor each rolled back task for failures, in nanoseconds.
        public var monitor: Int?
        /// The fraction of tasks that may fail during a rollback before the failure action is invoked, specified as a floating point number between 0 and 1.
        public var maxFailureRatio: Double?
        /// The order of operations when rolling back a task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
        public var order: Order?

        /// Action to take if an rolled back task fails to run, or stops running during the rollback.
        public enum FailureAction: String, Codable, CaseIterable {
            case `continue`
            case pause
        }

        /// The order of operations when rolling back a task. Either the old task is shut down before the new task is started, or the new task is started before the old task is shut down.
        public enum Order: String, Codable, CaseIterable {
            case stopFirst = "stop-first"
            case startFirst = "start-first"
        }

        public init(parallelism: Int? = nil, delay: Int? = nil, failureAction: FailureAction? = nil, monitor: Int? = nil, maxFailureRatio: Double? = nil, order: Order? = nil) {
            self.parallelism = parallelism
            self.delay = delay
            self.failureAction = failureAction
            self.monitor = monitor
            self.maxFailureRatio = maxFailureRatio
            self.order = order
        }

        private enum CodingKeys: String, CodingKey {
            case parallelism = "Parallelism"
            case delay = "Delay"
            case failureAction = "FailureAction"
            case monitor = "Monitor"
            case maxFailureRatio = "MaxFailureRatio"
            case order = "Order"
        }
    }

    public struct Network: Codable {
        public var target: String?
        public var aliases: [String]?

        public init(target: String? = nil, aliases: [String]? = nil) {
            self.target = target
            self.aliases = aliases
        }

        private enum CodingKeys: String, CodingKey {
            case target = "Target"
            case aliases = "Aliases"
        }
    }

    public init(name: String? = nil, labels: [String: String]? = nil, taskTemplate: TaskSpec? = nil, mode: Mode? = nil, updateConfig: UpdateConfig? = nil, rollbackConfig: RollbackConfig? = nil, networks: [Network]? = nil, endpointSpec: EndpointSpec? = nil) {
        self.name = name
        self.labels = labels
        self.taskTemplate = taskTemplate
        self.mode = mode
        self.updateConfig = updateConfig
        self.rollbackConfig = rollbackConfig
        self.networks = networks
        self.endpointSpec = endpointSpec
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case labels = "Labels"
        case taskTemplate = "TaskTemplate"
        case mode = "Mode"
        case updateConfig = "UpdateConfig"
        case rollbackConfig = "RollbackConfig"
        case networks = "Networks"
        case endpointSpec = "EndpointSpec"
    }
}

public struct EndpointPortConfig: Codable {
    public var name: String?
    public var `protocol`: `Protocol`?
    /// The port inside the container.
    public var targetPort: Int?
    /// The port on the swarm hosts.
    public var publishedPort: Int?

    public enum `Protocol`: String, Codable, CaseIterable {
        case tcp
        case udp
    }

    public init(name: String? = nil, `protocol`: `Protocol`? = nil, targetPort: Int? = nil, publishedPort: Int? = nil) {
        self.name = name
        self.protocol = `protocol`
        self.targetPort = targetPort
        self.publishedPort = publishedPort
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case `protocol` = "Protocol"
        case targetPort = "TargetPort"
        case publishedPort = "PublishedPort"
    }
}

/// Properties that can be configured to access and load balance a service.
public struct EndpointSpec: Codable {
    /// The mode of resolution to use for internal load balancing between tasks.
    public var mode: Mode?
    /// List of exposed ports that this service is accessible on from the outside. Ports can only be provided if `vip` resolution mode is used.
    public var ports: [EndpointPortConfig]?

    /// The mode of resolution to use for internal load balancing between tasks.
    public enum Mode: String, Codable, CaseIterable {
        case vip
        case dnsrr
    }

    public init(mode: Mode? = nil, ports: [EndpointPortConfig]? = nil) {
        self.mode = mode
        self.ports = ports
    }

    private enum CodingKeys: String, CodingKey {
        case mode = "Mode"
        case ports = "Ports"
    }
}

/// Example:
///
/// {
///   "CreatedAt" : "2016-06-07T21:05:51.880065305Z",
///   "Endpoint" : {
///     "Ports" : [
///       {
///         "Protocol" : "tcp",
///         "PublishedPort" : 30001,
///         "TargetPort" : 6379
///       }
///     ],
///     "Spec" : {
///       "Mode" : "vip",
///       "Ports" : [
///         {
///           "Protocol" : "tcp",
///           "PublishedPort" : 30001,
///           "TargetPort" : 6379
///         }
///       ]
///     },
///     "VirtualIPs" : [
///       {
///         "Addr" : "10.255.0.2\/16",
///         "NetworkID" : "4qvuz4ko70xaltuqbt8956gd1"
///       },
///       {
///         "Addr" : "10.255.0.3\/16",
///         "NetworkID" : "4qvuz4ko70xaltuqbt8956gd1"
///       }
///     ]
///   },
///   "ID" : "9mnpnzenvg8p8tdbtq4wvbkcz",
///   "Spec" : {
///     "EndpointSpec" : {
///       "Mode" : "vip",
///       "Ports" : [
///         {
///           "Protocol" : "tcp",
///           "PublishedPort" : 30001,
///           "TargetPort" : 6379
///         }
///       ]
///     },
///     "Mode" : {
///       "Replicated" : {
///         "Replicas" : 1
///       }
///     },
///     "Name" : "hopeful_cori",
///     "RollbackConfig" : {
///       "Delay" : 1000000000,
///       "FailureAction" : "pause",
///       "MaxFailureRatio" : 0.14999999999999999,
///       "Monitor" : 15000000000,
///       "Parallelism" : 1
///     },
///     "TaskTemplate" : {
///       "ContainerSpec" : {
///         "Image" : "redis"
///       },
///       "ForceUpdate" : 0,
///       "Placement" : {
/// 
///       },
///       "Resources" : {
///         "Limits" : {
/// 
///         },
///         "Reservations" : {
/// 
///         }
///       },
///       "RestartPolicy" : {
///         "Condition" : "any",
///         "MaxAttempts" : 0
///       }
///     },
///     "UpdateConfig" : {
///       "Delay" : 1000000000,
///       "FailureAction" : "pause",
///       "MaxFailureRatio" : 0.14999999999999999,
///       "Monitor" : 15000000000,
///       "Parallelism" : 1
///     }
///   },
///   "UpdatedAt" : "2016-06-07T21:07:29.962229872Z",
///   "Version" : {
///     "Index" : 19
///   }
/// }
public struct Service: Codable {
    public var id: String?
    /// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
    /// The client must send the version number along with the modified specification when updating these objects.
    /// This approach ensures safe concurrency and determinism in that the change on the object
    /// may not be applied if the version number has changed from the last read. In other words,
    /// if two update requests specify the same base version, only one of the requests can succeed.
    /// As a result, two separate update requests that happen at the same time will not
    /// unintentionally overwrite each other.
    public var version: ObjectVersion?
    public var createdAt: String?
    public var updatedAt: String?
    /// User modifiable configuration for a service.
    public var spec: ServiceSpec?
    public var endpoint: Endpoint?
    /// The status of a service update.
    public var updateStatus: UpdateStatus?

    public struct Endpoint: Codable {
        /// Properties that can be configured to access and load balance a service.
        public var spec: EndpointSpec?
        public var ports: [EndpointPortConfig]?
        public var virtualIPs: [VirtualIP]?

        public struct VirtualIP: Codable {
            public var networkID: String?
            public var addr: String?

            public init(networkID: String? = nil, addr: String? = nil) {
                self.networkID = networkID
                self.addr = addr
            }

            private enum CodingKeys: String, CodingKey {
                case networkID = "NetworkID"
                case addr = "Addr"
            }
        }

        public init(spec: EndpointSpec? = nil, ports: [EndpointPortConfig]? = nil, virtualIPs: [VirtualIP]? = nil) {
            self.spec = spec
            self.ports = ports
            self.virtualIPs = virtualIPs
        }

        private enum CodingKeys: String, CodingKey {
            case spec = "Spec"
            case ports = "Ports"
            case virtualIPs = "VirtualIPs"
        }
    }

    /// The status of a service update.
    public struct UpdateStatus: Codable {
        public var state: State?
        public var startedAt: String?
        public var completedAt: String?
        public var message: String?

        public enum State: String, Codable, CaseIterable {
            case updating
            case paused
            case completed
        }

        public init(state: State? = nil, startedAt: String? = nil, completedAt: String? = nil, message: String? = nil) {
            self.state = state
            self.startedAt = startedAt
            self.completedAt = completedAt
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case state = "State"
            case startedAt = "StartedAt"
            case completedAt = "CompletedAt"
            case message = "Message"
        }
    }

    public init(id: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, spec: ServiceSpec? = nil, endpoint: Endpoint? = nil, updateStatus: UpdateStatus? = nil) {
        self.id = id
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.spec = spec
        self.endpoint = endpoint
        self.updateStatus = updateStatus
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case spec = "Spec"
        case endpoint = "Endpoint"
        case updateStatus = "UpdateStatus"
    }
}

public struct ImageDeleteResponseItem: Codable {
    /// The image ID of an image that was untagged
    public var untagged: String?
    /// The image ID of an image that was deleted
    public var deleted: String?

    public init(untagged: String? = nil, deleted: String? = nil) {
        self.untagged = untagged
        self.deleted = deleted
    }

    private enum CodingKeys: String, CodingKey {
        case untagged = "Untagged"
        case deleted = "Deleted"
    }
}

/// Example:
///
/// {
///   "Warning" : "unable to pin image doesnotexist:latest to digest: image library\/doesnotexist:latest not found"
/// }
public struct ServiceUpdateResponse: Codable {
    /// Optional warning messages
    public var warnings: [String]?

    public init(warnings: [String]? = nil) {
        self.warnings = warnings
    }

    private enum CodingKeys: String, CodingKey {
        case warnings = "Warnings"
    }
}

public struct ContainerSummaryItem: Codable {
    /// The ID of this container
    public var id: String?
    /// The names that this container has been given
    public var names: [String]?
    /// The name of the image used when creating this container
    public var image: String?
    /// The ID of the image that this container was created from
    public var imageID: String?
    /// Command to run when starting the container
    public var command: String?
    /// When the container was created
    public var created: Int?
    /// The ports exposed by this container
    public var ports: [Port]?
    /// The size of files that have been created or changed by this container
    public var sizeRw: Int?
    /// The total size of all the files in this container
    public var sizeRootFs: Int?
    /// User-defined key/value metadata.
    public var labels: [String: String]?
    /// The state of this container (e.g. `Exited`)
    public var state: String?
    /// Additional human-readable status of this container (e.g. `Exit 0`)
    public var status: String?
    public var hostConfig: HostConfig?
    /// A summary of the container's network settings
    public var networkSettings: NetworkSettings?
    public var mounts: [Mount]?

    public struct HostConfig: Codable {
        public var networkMode: String?

        public init(networkMode: String? = nil) {
            self.networkMode = networkMode
        }

        private enum CodingKeys: String, CodingKey {
            case networkMode = "NetworkMode"
        }
    }

    /// A summary of the container's network settings
    public struct NetworkSettings: Codable {
        public var networks: [String: EndpointSettings]?

        public init(networks: [String: EndpointSettings]? = nil) {
            self.networks = networks
        }

        private enum CodingKeys: String, CodingKey {
            case networks = "Networks"
        }
    }

    public init(id: String? = nil, names: [String]? = nil, image: String? = nil, imageID: String? = nil, command: String? = nil, created: Int? = nil, ports: [Port]? = nil, sizeRw: Int? = nil, sizeRootFs: Int? = nil, labels: [String: String]? = nil, state: String? = nil, status: String? = nil, hostConfig: HostConfig? = nil, networkSettings: NetworkSettings? = nil, mounts: [Mount]? = nil) {
        self.id = id
        self.names = names
        self.image = image
        self.imageID = imageID
        self.command = command
        self.created = created
        self.ports = ports
        self.sizeRw = sizeRw
        self.sizeRootFs = sizeRootFs
        self.labels = labels
        self.state = state
        self.status = status
        self.hostConfig = hostConfig
        self.networkSettings = networkSettings
        self.mounts = mounts
    }

    private enum CodingKeys: String, CodingKey {
        case id = "Id"
        case names = "Names"
        case image = "Image"
        case imageID = "ImageID"
        case command = "Command"
        case created = "Created"
        case ports = "Ports"
        case sizeRw = "SizeRw"
        case sizeRootFs = "SizeRootFs"
        case labels = "Labels"
        case state = "State"
        case status = "Status"
        case hostConfig = "HostConfig"
        case networkSettings = "NetworkSettings"
        case mounts = "Mounts"
    }
}

/// Driver represents a driver (network, logging, secrets).
public struct Driver: Codable {
    /// Name of the driver.
    ///
    /// Example: "some-driver"
    public var name: String
    /// Key/value map of driver-specific options.
    ///
    /// Example:
    ///
    /// {
    ///   "OptionA" : "value for driver-specific option A",
    ///   "OptionB" : "value for driver-specific option B"
    /// }
    public var options: [String: String]?

    public init(name: String, options: [String: String]? = nil) {
        self.name = name
        self.options = options
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case options = "Options"
    }
}

public struct SecretSpec: Codable {
    /// User-defined name of the secret.
    public var name: String?
    /// User-defined key/value metadata.
    ///
    /// Example:
    ///
    /// {
    ///   "com.example.some-label" : "some-value",
    ///   "com.example.some-other-label" : "some-other-value"
    /// }
    public var labels: [String: String]?
    /// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2))
    /// data to store as secret.
    /// 
    /// This field is only used to _create_ a secret, and is not returned by
    /// other endpoints.
    public var data: String?
    /// Driver represents a driver (network, logging, secrets).
    public var driver: Driver?

    public init(name: String? = nil, labels: [String: String]? = nil, data: String? = nil, driver: Driver? = nil) {
        self.name = name
        self.labels = labels
        self.data = data
        self.driver = driver
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case labels = "Labels"
        case data = "Data"
        case driver = "Driver"
    }
}

public struct Secret: Codable {
    /// Example: "blt1owaxmitz71s9v5zh81zun"
    public var id: String?
    /// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
    /// The client must send the version number along with the modified specification when updating these objects.
    /// This approach ensures safe concurrency and determinism in that the change on the object
    /// may not be applied if the version number has changed from the last read. In other words,
    /// if two update requests specify the same base version, only one of the requests can succeed.
    /// As a result, two separate update requests that happen at the same time will not
    /// unintentionally overwrite each other.
    public var version: ObjectVersion?
    /// Example: "2017-07-20T13:55:28.678958722Z"
    public var createdAt: String?
    /// Example: "2017-07-20T13:55:28.678958722Z"
    public var updatedAt: String?
    public var spec: SecretSpec?

    public init(id: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, spec: SecretSpec? = nil) {
        self.id = id
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.spec = spec
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case spec = "Spec"
    }
}

public struct ConfigSpec: Codable {
    /// User-defined name of the config.
    public var name: String?
    /// User-defined key/value metadata.
    public var labels: [String: String]?
    /// Base64-url-safe-encoded ([RFC 4648](https://tools.ietf.org/html/rfc4648#section-3.2))
    /// config data.
    public var data: String?

    public init(name: String? = nil, labels: [String: String]? = nil, data: String? = nil) {
        self.name = name
        self.labels = labels
        self.data = data
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case labels = "Labels"
        case data = "Data"
    }
}

public struct Config: Codable {
    public var id: String?
    /// The version number of the object such as node, service, etc. This is needed to avoid conflicting writes.
    /// The client must send the version number along with the modified specification when updating these objects.
    /// This approach ensures safe concurrency and determinism in that the change on the object
    /// may not be applied if the version number has changed from the last read. In other words,
    /// if two update requests specify the same base version, only one of the requests can succeed.
    /// As a result, two separate update requests that happen at the same time will not
    /// unintentionally overwrite each other.
    public var version: ObjectVersion?
    public var createdAt: String?
    public var updatedAt: String?
    public var spec: ConfigSpec?

    public init(id: String? = nil, version: ObjectVersion? = nil, createdAt: String? = nil, updatedAt: String? = nil, spec: ConfigSpec? = nil) {
        self.id = id
        self.version = version
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.spec = spec
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case version = "Version"
        case createdAt = "CreatedAt"
        case updatedAt = "UpdatedAt"
        case spec = "Spec"
    }
}

public struct SystemInfo: Codable {
    /// Unique identifier of the daemon.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: The format of the ID itself is not part of the API, and
    /// > should not be considered stable.
    ///
    /// Example: "7TRN:IPZB:QYBB:VPBQ:UMPP:KARE:6ZNR:XE6T:7EWV:PKF4:ZOJD:TPYS"
    public var id: String?
    /// Total number of containers on the host.
    ///
    /// Example: 14
    public var containers: Int?
    /// Number of containers with status `"running"`.
    public var containersRunning: Int?
    /// Number of containers with status `"paused"`.
    public var containersPaused: Int?
    /// Number of containers with status `"stopped"`.
    ///
    /// Example: 10
    public var containersStopped: Int?
    /// Total number of images on the host.
    /// 
    /// Both _tagged_ and _untagged_ (dangling) images are counted.
    ///
    /// Example: 508
    public var images: Int?
    /// Name of the storage driver in use.
    ///
    /// Example: "overlay2"
    public var driver: String?
    /// Information specific to the storage driver, provided as
    /// "label" / "value" pairs.
    /// 
    /// This information is provided by the storage driver, and formatted
    /// in a way consistent with the output of `docker info` on the command
    /// line.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: The information returned in this field, including the
    /// > formatting of values and labels, should not be considered stable,
    /// > and may change without notice.
    ///
    /// Example:
    ///
    /// [
    ///   [
    ///     "Backing Filesystem",
    ///     "extfs"
    ///   ],
    ///   [
    ///     "Supports d_type",
    ///     true
    ///   ],
    ///   [
    ///     "Native Overlay Diff",
    ///     true
    ///   ]
    /// ]
    public var driverStatus: [[String]]?
    /// Root directory of persistent Docker state.
    /// 
    /// Defaults to `/var/lib/docker` on Linux, and `C:\ProgramData\docker`
    /// on Windows.
    ///
    /// Example: "/var/lib/docker"
    public var dockerRootDir: String?
    /// Status information about this node (standalone Swarm API).
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: The information returned in this field is only propagated
    /// > by the Swarm standalone API, and is empty (`null`) when using
    /// > built-in swarm mode.
    ///
    /// Example:
    ///
    /// [
    ///   [
    ///     "Role",
    ///     "primary"
    ///   ],
    ///   [
    ///     "State",
    ///     "Healthy"
    ///   ],
    ///   [
    ///     "Strategy",
    ///     "spread"
    ///   ],
    ///   [
    ///     "Filters",
    ///     "health, port, containerslots, dependency, affinity, constraint, whitelist"
    ///   ],
    ///   [
    ///     "Nodes",
    ///     "2"
    ///   ],
    ///   [
    ///     " swarm-agent-00",
    ///     "192.168.99.102:2376"
    ///   ],
    ///   [
    ///     "   ID",
    ///     "5CT6:FBGO:RVGO:CZL4:PB2K:WCYN:2JSV:KSHH:GGFW:QOPG:6J5Q:IOZ2|192.168.99.102:2376"
    ///   ],
    ///   [
    ///     "   Status",
    ///     "Healthy"
    ///   ],
    ///   [
    ///     "   Containers",
    ///     "1 (1 Running, 0 Paused, 0 Stopped)"
    ///   ],
    ///   [
    ///     "   Reserved CPUs",
    ///     "0 \/ 1"
    ///   ],
    ///   [
    ///     "   Reserved Memory",
    ///     "0 B \/ 1.021 GiB"
    ///   ],
    ///   [
    ///     "   Labels",
    ///     "kernelversion=4.4.74-boot2docker, operatingsystem=Boot2Docker 17.06.0-ce (TCL 7.2); HEAD : 0672754 - Thu Jun 29 00:06:31 UTC 2017, ostype=linux, provider=virtualbox, storagedriver=aufs"
    ///   ],
    ///   [
    ///     "   UpdatedAt",
    ///     "2017-08-09T10:03:46Z"
    ///   ],
    ///   [
    ///     "   ServerVersion",
    ///     "17.06.0-ce"
    ///   ],
    ///   [
    ///     " swarm-manager",
    ///     "192.168.99.101:2376"
    ///   ],
    ///   [
    ///     "   ID",
    ///     "TAMD:7LL3:SEF7:LW2W:4Q2X:WVFH:RTXX:JSYS:XY2P:JEHL:ZMJK:JGIW|192.168.99.101:2376"
    ///   ],
    ///   [
    ///     "   Status",
    ///     "Healthy"
    ///   ],
    ///   [
    ///     "   Containers",
    ///     "2 (2 Running, 0 Paused, 0 Stopped)"
    ///   ],
    ///   [
    ///     "   Reserved CPUs",
    ///     "0 \/ 1"
    ///   ],
    ///   [
    ///     "   Reserved Memory",
    ///     "0 B \/ 1.021 GiB"
    ///   ],
    ///   [
    ///     "   Labels",
    ///     "kernelversion=4.4.74-boot2docker, operatingsystem=Boot2Docker 17.06.0-ce (TCL 7.2); HEAD : 0672754 - Thu Jun 29 00:06:31 UTC 2017, ostype=linux, provider=virtualbox, storagedriver=aufs"
    ///   ],
    ///   [
    ///     "   UpdatedAt",
    ///     "2017-08-09T10:04:11Z"
    ///   ],
    ///   [
    ///     "   ServerVersion",
    ///     "17.06.0-ce"
    ///   ]
    /// ]
    public var systemStatus: [[String]]?
    /// Available plugins per type.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: Only unmanaged (V1) plugins are included in this list.
    /// > V1 plugins are "lazily" loaded, and are not returned in this list
    /// > if there is no resource using the plugin.
    public var plugins: PluginsInfo?
    /// Indicates if the host has memory limit support enabled.
    ///
    /// Example: true
    public var isMemoryLimit: Bool?
    /// Indicates if the host has memory swap limit support enabled.
    ///
    /// Example: true
    public var isSwapLimit: Bool?
    /// Indicates if the host has kernel memory limit support enabled.
    ///
    /// Example: true
    public var isKernelMemory: Bool?
    /// Indicates if CPU CFS(Completely Fair Scheduler) period is supported by the host.
    ///
    /// Example: true
    public var isCpuCfsPeriod: Bool?
    /// Indicates if CPU CFS(Completely Fair Scheduler) quota is supported by the host.
    ///
    /// Example: true
    public var isCpuCfsQuota: Bool?
    /// Indicates if CPU Shares limiting is supported by the host.
    ///
    /// Example: true
    public var isCPUShares: Bool?
    /// Indicates if CPUsets (cpuset.cpus, cpuset.mems) are supported by the host.
    /// 
    /// See [cpuset(7)](https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt)
    ///
    /// Example: true
    public var isCPUSet: Bool?
    /// Indicates if OOM killer disable is supported on the host.
    public var isOomKillDisable: Bool?
    /// Indicates IPv4 forwarding is enabled.
    ///
    /// Example: true
    public var isIPv4Forwarding: Bool?
    /// Indicates if `bridge-nf-call-iptables` is available on the host.
    ///
    /// Example: true
    public var isBridgeNfIptables: Bool?
    /// Indicates if `bridge-nf-call-ip6tables` is available on the host.
    ///
    /// Example: true
    public var isBridgeNfIp6tables: Bool?
    /// Indicates if the daemon is running in debug-mode / with debug-level logging enabled.
    ///
    /// Example: true
    public var isDebug: Bool?
    /// The total number of file Descriptors in use by the daemon process.
    /// 
    /// This information is only returned if debug-mode is enabled.
    ///
    /// Example: 64
    public var nFd: Int?
    /// The  number of goroutines that currently exist.
    /// 
    /// This information is only returned if debug-mode is enabled.
    ///
    /// Example: 174
    public var nGoroutines: Int?
    /// Current system-time in [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt)
    /// format with nano-seconds.
    ///
    /// Example: "2017-08-08T20:28:29.06202363Z"
    public var systemTime: String?
    /// The logging driver to use as a default for new containers.
    public var loggingDriver: String?
    /// The driver to use for managing cgroups.
    ///
    /// Example: "cgroupfs"
    public var cgroupDriver: CgroupDriver?
    /// Number of event listeners subscribed.
    ///
    /// Example: 30
    public var nEventsListener: Int?
    /// Kernel version of the host.
    /// 
    /// On Linux, this information obtained from `uname`. On Windows this
    /// information is queried from the <kbd>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\</kbd>
    /// registry value, for example _"10.0 14393 (14393.1198.amd64fre.rs1_release_sec.170427-1353)"_.
    ///
    /// Example: "4.9.38-moby"
    public var kernelVersion: String?
    /// Name of the host's operating system, for example: "Ubuntu 16.04.2 LTS"
    /// or "Windows Server 2016 Datacenter"
    ///
    /// Example: "Alpine Linux v3.5"
    public var operatingSystem: String?
    /// Generic type of the operating system of the host, as returned by the
    /// Go runtime (`GOOS`).
    /// 
    /// Currently returned values are "linux" and "windows". A full list of
    /// possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
    ///
    /// Example: "linux"
    public var oSType: String?
    /// Hardware architecture of the host, as returned by the Go runtime
    /// (`GOARCH`).
    /// 
    /// A full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
    ///
    /// Example: "x86_64"
    public var architecture: String?
    /// The number of logical CPUs usable by the daemon.
    /// 
    /// The number of available CPUs is checked by querying the operating
    /// system when the daemon starts. Changes to operating system CPU
    /// allocation after the daemon is started are not reflected.
    public var ncpu: Int?
    /// Total amount of physical memory available on the host, in kilobytes (kB).
    ///
    /// Example: 2095882240
    public var memTotal: Int?
    /// Address / URL of the index server that is used for image search,
    /// and as a default for user authentication for Docker Hub and Docker Cloud.
    ///
    /// Example: "https://index.docker.io/v1/"
    public var indexServerAddress: String?
    /// RegistryServiceConfig stores daemon registry services configuration.
    public var registryConfig: RegistryServiceConfig?
    /// User-defined resources can be either Integer resources (e.g, `SSD=3`) or String resources (e.g, `GPU=UUID1`)
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "DiscreteResourceSpec" : {
    ///       "Kind" : "SSD",
    ///       "Value" : 3
    ///     }
    ///   },
    ///   {
    ///     "NamedResourceSpec" : {
    ///       "Kind" : "GPU",
    ///       "Value" : "UUID1"
    ///     }
    ///   },
    ///   {
    ///     "NamedResourceSpec" : {
    ///       "Kind" : "GPU",
    ///       "Value" : "UUID2"
    ///     }
    ///   }
    /// ]
    public var genericResources: [GenericResource]?
    /// HTTP-proxy configured for the daemon. This value is obtained from the
    /// [`HTTP_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
    /// 
    /// Containers do not automatically inherit this configuration.
    ///
    /// Example: "http://user:pass@proxy.corp.example.com:8080"
    public var httpProxy: String?
    /// HTTPS-proxy configured for the daemon. This value is obtained from the
    /// [`HTTPS_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
    /// 
    /// Containers do not automatically inherit this configuration.
    ///
    /// Example: "https://user:pass@proxy.corp.example.com:4443"
    public var httpsProxy: String?
    /// Comma-separated list of domain extensions for which no proxy should be
    /// used. This value is obtained from the [`NO_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html)
    /// environment variable.
    /// 
    /// Containers do not automatically inherit this configuration.
    ///
    /// Example: "*.local, 169.254/16"
    public var noProxy: String?
    /// Hostname of the host.
    ///
    /// Example: "node5.corp.example.com"
    public var name: String?
    /// User-defined labels (key/value metadata) as set on the daemon.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: When part of a Swarm, nodes can both have _daemon_ labels,
    /// > set through the daemon configuration, and _node_ labels, set from a
    /// > manager node in the Swarm. Node labels are not included in this
    /// > field. Node labels can be retrieved using the `/nodes/(id)` endpoint
    /// > on a manager node in the Swarm.
    ///
    /// Example: ["storage=ssd", "production"]
    public var labels: [String]?
    /// Indicates if experimental features are enabled on the daemon.
    ///
    /// Example: true
    public var isExperimentalBuild: Bool?
    /// Version string of the daemon.
    /// 
    /// > **Note**: the [standalone Swarm API](https://docs.docker.com/swarm/swarm-api/)
    /// > returns the Swarm version instead of the daemon  version, for example
    /// > `swarm/1.2.8`.
    ///
    /// Example: "17.06.0-ce"
    public var serverVersion: String?
    /// URL of the distributed storage backend.
    /// 
    /// 
    /// The storage backend is used for multihost networking (to store
    /// network and endpoint information) and by the node discovery mechanism.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: This field is only propagated when using standalone Swarm
    /// > mode, and overlay networking using an external k/v store. Overlay
    /// > networks with Swarm mode enabled use the built-in raft store, and
    /// > this field will be empty.
    ///
    /// Example: "consul://consul.corp.example.com:8600/some/path"
    public var clusterStore: String?
    /// The network endpoint that the Engine advertises for the purpose of
    /// node discovery. ClusterAdvertise is a `host:port` combination on which
    /// the daemon is reachable by other hosts.
    /// 
    /// <p><br /></p>
    /// 
    /// > **Note**: This field is only propagated when using standalone Swarm
    /// > mode, and overlay networking using an external k/v store. Overlay
    /// > networks with Swarm mode enabled use the built-in raft store, and
    /// > this field will be empty.
    ///
    /// Example: "node5.corp.example.com:8000"
    public var clusterAdvertise: String?
    /// List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
    /// runtimes configured on the daemon. Keys hold the "name" used to
    /// reference the runtime.
    /// 
    /// The Docker daemon relies on an OCI compliant runtime (invoked via the
    /// `containerd` daemon) as its interface to the Linux kernel namespaces,
    /// cgroups, and SELinux.
    /// 
    /// The default runtime is `runc`, and automatically configured. Additional
    /// runtimes can be configured by the user and will be listed here.
    ///
    /// Example:
    ///
    /// {
    ///   "custom" : {
    ///     "path" : "\/usr\/local\/bin\/my-oci-runtime",
    ///     "runtimeArgs" : [
    ///       "--debug",
    ///       "--systemd-cgroup=false"
    ///     ]
    ///   },
    ///   "runc" : {
    ///     "path" : "docker-runc"
    ///   },
    ///   "runc-master" : {
    ///     "path" : "\/go\/bin\/runc"
    ///   }
    /// }
    public var runtimes: [String: Runtime]?
    /// Name of the default OCI runtime that is used when starting containers.
    /// 
    /// The default can be overridden per-container at create time.
    ///
    /// Example: "runc"
    public var defaultRuntime: String?
    /// Represents generic information about swarm.
    public var swarm: SwarmInfo?
    /// Indicates if live restore is enabled.
    /// 
    /// If enabled, containers are kept running when the daemon is shutdown
    /// or upon daemon start if running containers are detected.
    ///
    /// Example: false
    public var isLiveRestoreEnabled: Bool
    /// Represents the isolation technology to use as a default for containers.
    /// The supported values are platform-specific.
    /// 
    /// If no isolation value is specified on daemon start, on Windows client,
    /// the default is `hyperv`, and on Windows server, the default is `process`.
    /// 
    /// This option is currently not used on other platforms.
    public var isolation: Isolation?
    /// Name and, optional, path of the the `docker-init` binary.
    /// 
    /// If the path is omitted, the daemon searches the host's `$PATH` for the
    /// binary and uses the first result.
    ///
    /// Example: "docker-init"
    public var initBinary: String?
    /// Commit holds the Git-commit (SHA1) that a binary was built from, as
    /// reported in the version-string of external tools, such as `containerd`,
    /// or `runC`.
    public var containerdCommit: Commit?
    /// Commit holds the Git-commit (SHA1) that a binary was built from, as
    /// reported in the version-string of external tools, such as `containerd`,
    /// or `runC`.
    public var runcCommit: Commit?
    /// Commit holds the Git-commit (SHA1) that a binary was built from, as
    /// reported in the version-string of external tools, such as `containerd`,
    /// or `runC`.
    public var initCommit: Commit?
    /// List of security features that are enabled on the daemon, such as
    /// apparmor, seccomp, SELinux, and user-namespaces (userns).
    /// 
    /// Additional configuration options for each security feature may
    /// be present, and are included as a comma-separated list of key/value
    /// pairs.
    ///
    /// Example: ["name=apparmor", "name=seccomp,profile=default", "name=selinux", "name=userns"]
    public var securityOptions: [String]?

    /// The driver to use for managing cgroups.
    ///
    /// Example: "cgroupfs"
    public enum CgroupDriver: String, Codable, CaseIterable {
        case cgroupfs
        case systemd
    }

    /// Represents the isolation technology to use as a default for containers.
    /// The supported values are platform-specific.
    /// 
    /// If no isolation value is specified on daemon start, on Windows client,
    /// the default is `hyperv`, and on Windows server, the default is `process`.
    /// 
    /// This option is currently not used on other platforms.
    public enum Isolation: String, Codable, CaseIterable {
        case `default`
        case hyperv
        case process
    }

    public init(id: String? = nil, containers: Int? = nil, containersRunning: Int? = nil, containersPaused: Int? = nil, containersStopped: Int? = nil, images: Int? = nil, driver: String? = nil, driverStatus: [[String]]? = nil, dockerRootDir: String? = nil, systemStatus: [[String]]? = nil, plugins: PluginsInfo? = nil, isMemoryLimit: Bool? = nil, isSwapLimit: Bool? = nil, isKernelMemory: Bool? = nil, isCpuCfsPeriod: Bool? = nil, isCpuCfsQuota: Bool? = nil, isCPUShares: Bool? = nil, isCPUSet: Bool? = nil, isOomKillDisable: Bool? = nil, isIPv4Forwarding: Bool? = nil, isBridgeNfIptables: Bool? = nil, isBridgeNfIp6tables: Bool? = nil, isDebug: Bool? = nil, nFd: Int? = nil, nGoroutines: Int? = nil, systemTime: String? = nil, loggingDriver: String? = nil, cgroupDriver: CgroupDriver? = nil, nEventsListener: Int? = nil, kernelVersion: String? = nil, operatingSystem: String? = nil, oSType: String? = nil, architecture: String? = nil, ncpu: Int? = nil, memTotal: Int? = nil, indexServerAddress: String? = nil, registryConfig: RegistryServiceConfig? = nil, genericResources: [GenericResource]? = nil, httpProxy: String? = nil, httpsProxy: String? = nil, noProxy: String? = nil, name: String? = nil, labels: [String]? = nil, isExperimentalBuild: Bool? = nil, serverVersion: String? = nil, clusterStore: String? = nil, clusterAdvertise: String? = nil, runtimes: [String: Runtime]? = nil, defaultRuntime: String? = nil, swarm: SwarmInfo? = nil, isLiveRestoreEnabled: Bool? = nil, isolation: Isolation? = nil, initBinary: String? = nil, containerdCommit: Commit? = nil, runcCommit: Commit? = nil, initCommit: Commit? = nil, securityOptions: [String]? = nil) {
        self.id = id
        self.containers = containers
        self.containersRunning = containersRunning
        self.containersPaused = containersPaused
        self.containersStopped = containersStopped
        self.images = images
        self.driver = driver
        self.driverStatus = driverStatus
        self.dockerRootDir = dockerRootDir
        self.systemStatus = systemStatus
        self.plugins = plugins
        self.isMemoryLimit = isMemoryLimit
        self.isSwapLimit = isSwapLimit
        self.isKernelMemory = isKernelMemory
        self.isCpuCfsPeriod = isCpuCfsPeriod
        self.isCpuCfsQuota = isCpuCfsQuota
        self.isCPUShares = isCPUShares
        self.isCPUSet = isCPUSet
        self.isOomKillDisable = isOomKillDisable
        self.isIPv4Forwarding = isIPv4Forwarding
        self.isBridgeNfIptables = isBridgeNfIptables
        self.isBridgeNfIp6tables = isBridgeNfIp6tables
        self.isDebug = isDebug
        self.nFd = nFd
        self.nGoroutines = nGoroutines
        self.systemTime = systemTime
        self.loggingDriver = loggingDriver
        self.cgroupDriver = cgroupDriver
        self.nEventsListener = nEventsListener
        self.kernelVersion = kernelVersion
        self.operatingSystem = operatingSystem
        self.oSType = oSType
        self.architecture = architecture
        self.ncpu = ncpu
        self.memTotal = memTotal
        self.indexServerAddress = indexServerAddress
        self.registryConfig = registryConfig
        self.genericResources = genericResources
        self.httpProxy = httpProxy
        self.httpsProxy = httpsProxy
        self.noProxy = noProxy
        self.name = name
        self.labels = labels
        self.isExperimentalBuild = isExperimentalBuild
        self.serverVersion = serverVersion
        self.clusterStore = clusterStore
        self.clusterAdvertise = clusterAdvertise
        self.runtimes = runtimes
        self.defaultRuntime = defaultRuntime
        self.swarm = swarm
        self.isLiveRestoreEnabled = isLiveRestoreEnabled ?? false
        self.isolation = isolation
        self.initBinary = initBinary
        self.containerdCommit = containerdCommit
        self.runcCommit = runcCommit
        self.initCommit = initCommit
        self.securityOptions = securityOptions
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case containers = "Containers"
        case containersRunning = "ContainersRunning"
        case containersPaused = "ContainersPaused"
        case containersStopped = "ContainersStopped"
        case images = "Images"
        case driver = "Driver"
        case driverStatus = "DriverStatus"
        case dockerRootDir = "DockerRootDir"
        case systemStatus = "SystemStatus"
        case plugins = "Plugins"
        case isMemoryLimit = "MemoryLimit"
        case isSwapLimit = "SwapLimit"
        case isKernelMemory = "KernelMemory"
        case isCpuCfsPeriod = "CpuCfsPeriod"
        case isCpuCfsQuota = "CpuCfsQuota"
        case isCPUShares = "CPUShares"
        case isCPUSet = "CPUSet"
        case isOomKillDisable = "OomKillDisable"
        case isIPv4Forwarding = "IPv4Forwarding"
        case isBridgeNfIptables = "BridgeNfIptables"
        case isBridgeNfIp6tables = "BridgeNfIp6tables"
        case isDebug = "Debug"
        case nFd = "NFd"
        case nGoroutines = "NGoroutines"
        case systemTime = "SystemTime"
        case loggingDriver = "LoggingDriver"
        case cgroupDriver = "CgroupDriver"
        case nEventsListener = "NEventsListener"
        case kernelVersion = "KernelVersion"
        case operatingSystem = "OperatingSystem"
        case oSType = "OSType"
        case architecture = "Architecture"
        case ncpu = "NCPU"
        case memTotal = "MemTotal"
        case indexServerAddress = "IndexServerAddress"
        case registryConfig = "RegistryConfig"
        case genericResources = "GenericResources"
        case httpProxy = "HttpProxy"
        case httpsProxy = "HttpsProxy"
        case noProxy = "NoProxy"
        case name = "Name"
        case labels = "Labels"
        case isExperimentalBuild = "ExperimentalBuild"
        case serverVersion = "ServerVersion"
        case clusterStore = "ClusterStore"
        case clusterAdvertise = "ClusterAdvertise"
        case runtimes = "Runtimes"
        case defaultRuntime = "DefaultRuntime"
        case swarm = "Swarm"
        case isLiveRestoreEnabled = "LiveRestoreEnabled"
        case isolation = "Isolation"
        case initBinary = "InitBinary"
        case containerdCommit = "ContainerdCommit"
        case runcCommit = "RuncCommit"
        case initCommit = "InitCommit"
        case securityOptions = "SecurityOptions"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try values.decodeIfPresent(String.self, forKey: .id)
        self.containers = try values.decodeIfPresent(Int.self, forKey: .containers)
        self.containersRunning = try values.decodeIfPresent(Int.self, forKey: .containersRunning)
        self.containersPaused = try values.decodeIfPresent(Int.self, forKey: .containersPaused)
        self.containersStopped = try values.decodeIfPresent(Int.self, forKey: .containersStopped)
        self.images = try values.decodeIfPresent(Int.self, forKey: .images)
        self.driver = try values.decodeIfPresent(String.self, forKey: .driver)
        self.driverStatus = try values.decodeIfPresent([[String]].self, forKey: .driverStatus)
        self.dockerRootDir = try values.decodeIfPresent(String.self, forKey: .dockerRootDir)
        self.systemStatus = try values.decodeIfPresent([[String]].self, forKey: .systemStatus)
        self.plugins = try values.decodeIfPresent(PluginsInfo.self, forKey: .plugins)
        self.isMemoryLimit = try values.decodeIfPresent(Bool.self, forKey: .isMemoryLimit)
        self.isSwapLimit = try values.decodeIfPresent(Bool.self, forKey: .isSwapLimit)
        self.isKernelMemory = try values.decodeIfPresent(Bool.self, forKey: .isKernelMemory)
        self.isCpuCfsPeriod = try values.decodeIfPresent(Bool.self, forKey: .isCpuCfsPeriod)
        self.isCpuCfsQuota = try values.decodeIfPresent(Bool.self, forKey: .isCpuCfsQuota)
        self.isCPUShares = try values.decodeIfPresent(Bool.self, forKey: .isCPUShares)
        self.isCPUSet = try values.decodeIfPresent(Bool.self, forKey: .isCPUSet)
        self.isOomKillDisable = try values.decodeIfPresent(Bool.self, forKey: .isOomKillDisable)
        self.isIPv4Forwarding = try values.decodeIfPresent(Bool.self, forKey: .isIPv4Forwarding)
        self.isBridgeNfIptables = try values.decodeIfPresent(Bool.self, forKey: .isBridgeNfIptables)
        self.isBridgeNfIp6tables = try values.decodeIfPresent(Bool.self, forKey: .isBridgeNfIp6tables)
        self.isDebug = try values.decodeIfPresent(Bool.self, forKey: .isDebug)
        self.nFd = try values.decodeIfPresent(Int.self, forKey: .nFd)
        self.nGoroutines = try values.decodeIfPresent(Int.self, forKey: .nGoroutines)
        self.systemTime = try values.decodeIfPresent(String.self, forKey: .systemTime)
        self.loggingDriver = try values.decodeIfPresent(String.self, forKey: .loggingDriver)
        self.cgroupDriver = try values.decodeIfPresent(CgroupDriver.self, forKey: .cgroupDriver)
        self.nEventsListener = try values.decodeIfPresent(Int.self, forKey: .nEventsListener)
        self.kernelVersion = try values.decodeIfPresent(String.self, forKey: .kernelVersion)
        self.operatingSystem = try values.decodeIfPresent(String.self, forKey: .operatingSystem)
        self.oSType = try values.decodeIfPresent(String.self, forKey: .oSType)
        self.architecture = try values.decodeIfPresent(String.self, forKey: .architecture)
        self.ncpu = try values.decodeIfPresent(Int.self, forKey: .ncpu)
        self.memTotal = try values.decodeIfPresent(Int.self, forKey: .memTotal)
        self.indexServerAddress = try values.decodeIfPresent(String.self, forKey: .indexServerAddress)
        self.registryConfig = try values.decodeIfPresent(RegistryServiceConfig.self, forKey: .registryConfig)
        self.genericResources = try values.decodeIfPresent([GenericResource].self, forKey: .genericResources)
        self.httpProxy = try values.decodeIfPresent(String.self, forKey: .httpProxy)
        self.httpsProxy = try values.decodeIfPresent(String.self, forKey: .httpsProxy)
        self.noProxy = try values.decodeIfPresent(String.self, forKey: .noProxy)
        self.name = try values.decodeIfPresent(String.self, forKey: .name)
        self.labels = try values.decodeIfPresent([String].self, forKey: .labels)
        self.isExperimentalBuild = try values.decodeIfPresent(Bool.self, forKey: .isExperimentalBuild)
        self.serverVersion = try values.decodeIfPresent(String.self, forKey: .serverVersion)
        self.clusterStore = try values.decodeIfPresent(String.self, forKey: .clusterStore)
        self.clusterAdvertise = try values.decodeIfPresent(String.self, forKey: .clusterAdvertise)
        self.runtimes = try values.decodeIfPresent([String: Runtime].self, forKey: .runtimes)
        self.defaultRuntime = try values.decodeIfPresent(String.self, forKey: .defaultRuntime)
        self.swarm = try values.decodeIfPresent(SwarmInfo.self, forKey: .swarm)
        self.isLiveRestoreEnabled = try values.decodeIfPresent(Bool.self, forKey: .isLiveRestoreEnabled) ?? false
        self.isolation = try values.decodeIfPresent(Isolation.self, forKey: .isolation)
        self.initBinary = try values.decodeIfPresent(String.self, forKey: .initBinary)
        self.containerdCommit = try values.decodeIfPresent(Commit.self, forKey: .containerdCommit)
        self.runcCommit = try values.decodeIfPresent(Commit.self, forKey: .runcCommit)
        self.initCommit = try values.decodeIfPresent(Commit.self, forKey: .initCommit)
        self.securityOptions = try values.decodeIfPresent([String].self, forKey: .securityOptions)
    }
}

/// Available plugins per type.
/// 
/// <p><br /></p>
/// 
/// > **Note**: Only unmanaged (V1) plugins are included in this list.
/// > V1 plugins are "lazily" loaded, and are not returned in this list
/// > if there is no resource using the plugin.
public struct PluginsInfo: Codable {
    /// Names of available volume-drivers, and network-driver plugins.
    ///
    /// Example: ["local"]
    public var volume: [String]?
    /// Names of available network-drivers, and network-driver plugins.
    ///
    /// Example:
    ///
    /// [
    ///   "bridge",
    ///   "host",
    ///   "ipvlan",
    ///   "macvlan",
    ///   null,
    ///   "overlay"
    /// ]
    public var network: [String]?
    /// Names of available authorization plugins.
    ///
    /// Example: ["img-authz-plugin", "hbm"]
    public var authorization: [String]?
    /// Names of available logging-drivers, and logging-driver plugins.
    ///
    /// Example: ["awslogs", "fluentd", "gcplogs", "gelf", "journald", "json-file", "logentries", "splunk", "syslog"]
    public var log: [String]?

    public init(volume: [String]? = nil, network: [String]? = nil, authorization: [String]? = nil, log: [String]? = nil) {
        self.volume = volume
        self.network = network
        self.authorization = authorization
        self.log = log
    }

    private enum CodingKeys: String, CodingKey {
        case volume = "Volume"
        case network = "Network"
        case authorization = "Authorization"
        case log = "Log"
    }
}

/// RegistryServiceConfig stores daemon registry services configuration.
public struct RegistryServiceConfig: Codable {
    /// List of IP ranges to which nondistributable artifacts can be pushed,
    /// using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).
    /// 
    /// Some images (for example, Windows base images) contain artifacts
    /// whose distribution is restricted by license. When these images are
    /// pushed to a registry, restricted artifacts are not included.
    /// 
    /// This configuration override this behavior, and enables the daemon to
    /// push nondistributable artifacts to all registries whose resolved IP
    /// address is within the subnet described by the CIDR syntax.
    /// 
    /// This option is useful when pushing images containing
    /// nondistributable artifacts to a registry on an air-gapped network so
    /// hosts on that network can pull the images without connecting to
    /// another server.
    /// 
    /// > **Warning**: Nondistributable artifacts typically have restrictions
    /// > on how and where they can be distributed and shared. Only use this
    /// > feature to push artifacts to private registries and ensure that you
    /// > are in compliance with any terms that cover redistributing
    /// > nondistributable artifacts.
    ///
    /// Example: ["::1/128", "127.0.0.0/8"]
    public var allowNondistributableArtifactsCIDRs: [String]?
    /// List of registry hostnames to which nondistributable artifacts can be
    /// pushed, using the format `<hostname>[:<port>]` or `<IP address>[:<port>]`.
    /// 
    /// Some images (for example, Windows base images) contain artifacts
    /// whose distribution is restricted by license. When these images are
    /// pushed to a registry, restricted artifacts are not included.
    /// 
    /// This configuration override this behavior for the specified
    /// registries.
    /// 
    /// This option is useful when pushing images containing
    /// nondistributable artifacts to a registry on an air-gapped network so
    /// hosts on that network can pull the images without connecting to
    /// another server.
    /// 
    /// > **Warning**: Nondistributable artifacts typically have restrictions
    /// > on how and where they can be distributed and shared. Only use this
    /// > feature to push artifacts to private registries and ensure that you
    /// > are in compliance with any terms that cover redistributing
    /// > nondistributable artifacts.
    ///
    /// Example: ["registry.internal.corp.example.com:3000", "[2001:db8:a0b:12f0::1]:443"]
    public var allowNondistributableArtifactsHostnames: [String]?
    /// List of IP ranges of insecure registries, using the CIDR syntax
    /// ([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries
    /// accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates
    /// from unknown CAs) communication.
    /// 
    /// By default, local registries (`127.0.0.0/8`) are configured as
    /// insecure. All other registries are secure. Communicating with an
    /// insecure registry is not possible if the daemon assumes that registry
    /// is secure.
    /// 
    /// This configuration override this behavior, insecure communication with
    /// registries whose resolved IP address is within the subnet described by
    /// the CIDR syntax.
    /// 
    /// Registries can also be marked insecure by hostname. Those registries
    /// are listed under `IndexConfigs` and have their `Secure` field set to
    /// `false`.
    /// 
    /// > **Warning**: Using this option can be useful when running a local
    /// > registry, but introduces security vulnerabilities. This option
    /// > should therefore ONLY be used for testing purposes. For increased
    /// > security, users should add their CA to their system's list of trusted
    /// > CAs instead of enabling this option.
    ///
    /// Example: ["::1/128", "127.0.0.0/8"]
    public var insecureRegistryCIDRs: [String]?
    /// Example:
    ///
    /// {
    ///   "[2001:db8:a0b:12f0::1]:80" : {
    ///     "Mirrors" : [
    /// 
    ///     ],
    ///     "Name" : "[2001:db8:a0b:12f0::1]:80",
    ///     "Official" : false,
    ///     "Secure" : false
    ///   },
    ///   "127.0.0.1:5000" : {
    ///     "Mirrors" : [
    /// 
    ///     ],
    ///     "Name" : "127.0.0.1:5000",
    ///     "Official" : false,
    ///     "Secure" : false
    ///   },
    ///   "docker.io" : {
    ///     "Mirrors" : [
    ///       "https:\/\/hub-mirror.corp.example.com:5000\/"
    ///     ],
    ///     "Name" : "docker.io",
    ///     "Official" : true,
    ///     "Secure" : true
    ///   },
    ///   "registry.internal.corp.example.com:3000" : {
    ///     "Mirrors" : [
    /// 
    ///     ],
    ///     "Name" : "registry.internal.corp.example.com:3000",
    ///     "Official" : false,
    ///     "Secure" : false
    ///   }
    /// }
    public var indexConfigs: [String: IndexInfo]?
    /// List of registry URLs that act as a mirror for the official
    /// (`docker.io`) registry.
    ///
    /// Example: ["https://hub-mirror.corp.example.com:5000/", "https://[2001:db8:a0b:12f0::1]/"]
    public var mirrors: [String]?

    public init(allowNondistributableArtifactsCIDRs: [String]? = nil, allowNondistributableArtifactsHostnames: [String]? = nil, insecureRegistryCIDRs: [String]? = nil, indexConfigs: [String: IndexInfo]? = nil, mirrors: [String]? = nil) {
        self.allowNondistributableArtifactsCIDRs = allowNondistributableArtifactsCIDRs
        self.allowNondistributableArtifactsHostnames = allowNondistributableArtifactsHostnames
        self.insecureRegistryCIDRs = insecureRegistryCIDRs
        self.indexConfigs = indexConfigs
        self.mirrors = mirrors
    }

    private enum CodingKeys: String, CodingKey {
        case allowNondistributableArtifactsCIDRs = "AllowNondistributableArtifactsCIDRs"
        case allowNondistributableArtifactsHostnames = "AllowNondistributableArtifactsHostnames"
        case insecureRegistryCIDRs = "InsecureRegistryCIDRs"
        case indexConfigs = "IndexConfigs"
        case mirrors = "Mirrors"
    }
}

/// IndexInfo contains information about a registry.
public struct IndexInfo: Codable {
    /// Name of the registry, such as "docker.io".
    ///
    /// Example: "docker.io"
    public var name: String?
    /// List of mirrors, expressed as URIs.
    ///
    /// Example: ["https://hub-mirror.corp.example.com:5000/", "https://registry-2.docker.io/", "https://registry-3.docker.io/"]
    public var mirrors: [String]?
    /// Indicates if the the registry is part of the list of insecure
    /// registries.
    /// 
    /// If `false`, the registry is insecure. Insecure registries accept
    /// un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from
    /// unknown CAs) communication.
    /// 
    /// > **Warning**: Insecure registries can be useful when running a local
    /// > registry. However, because its use creates security vulnerabilities
    /// > it should ONLY be enabled for testing purposes. For increased
    /// > security, users should add their CA to their system's list of
    /// > trusted CAs instead of enabling this option.
    ///
    /// Example: true
    public var isSecure: Bool?
    /// Indicates whether this is an official registry (i.e., Docker Hub / docker.io)
    ///
    /// Example: true
    public var isOfficial: Bool?

    public init(name: String? = nil, mirrors: [String]? = nil, isSecure: Bool? = nil, isOfficial: Bool? = nil) {
        self.name = name
        self.mirrors = mirrors
        self.isSecure = isSecure
        self.isOfficial = isOfficial
    }

    private enum CodingKeys: String, CodingKey {
        case name = "Name"
        case mirrors = "Mirrors"
        case isSecure = "Secure"
        case isOfficial = "Official"
    }
}

/// Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec)
/// runtime.
/// 
/// The runtime is invoked by the daemon via the `containerd` daemon. OCI
/// runtimes act as an interface to the Linux kernel namespaces, cgroups,
/// and SELinux.
public struct Runtime: Codable {
    /// Name and, optional, path, of the OCI executable binary.
    /// 
    /// If the path is omitted, the daemon searches the host's `$PATH` for the
    /// binary and uses the first result.
    ///
    /// Example: "/usr/local/bin/my-oci-runtime"
    public var path: String?
    /// List of command-line arguments to pass to the runtime when invoked.
    ///
    /// Example: ["--debug", "--systemd-cgroup=false"]
    public var runtimeArgs: [String]?

    public init(path: String? = nil, runtimeArgs: [String]? = nil) {
        self.path = path
        self.runtimeArgs = runtimeArgs
    }
}

/// Commit holds the Git-commit (SHA1) that a binary was built from, as
/// reported in the version-string of external tools, such as `containerd`,
/// or `runC`.
public struct Commit: Codable {
    /// Actual commit ID of external tool.
    ///
    /// Example: "cfb82a876ecc11b5ca0977d1733adbe58599088a"
    public var id: String?
    /// Commit ID of external tool expected by dockerd as set at build time.
    ///
    /// Example: "2d41c047c83e09a6d61d464906feb2a2f3c52aa4"
    public var expected: String?

    public init(id: String? = nil, expected: String? = nil) {
        self.id = id
        self.expected = expected
    }

    private enum CodingKeys: String, CodingKey {
        case id = "ID"
        case expected = "Expected"
    }
}

/// Represents generic information about swarm.
public struct SwarmInfo: Codable {
    /// Unique identifier of for this node in the swarm.
    ///
    /// Example: "k67qz4598weg5unwwffg6z1m1"
    public var nodeID: String?
    /// IP address at which this node can be reached by other nodes in the
    /// swarm.
    ///
    /// Example: "10.0.0.46"
    public var nodeAddr: String?
    /// Current local status of this node.
    ///
    /// Example: "active"
    public var localNodeState: LocalNodeState?
    /// Example: true
    public var isControlAvailable: Bool
    public var error: String?
    /// List of ID's and addresses of other managers in the swarm.
    ///
    /// Example:
    ///
    /// [
    ///   {
    ///     "Addr" : "10.0.0.158:2377",
    ///     "NodeID" : "71izy0goik036k48jg985xnds"
    ///   },
    ///   {
    ///     "Addr" : "10.0.0.159:2377",
    ///     "NodeID" : "79y6h1o4gv8n120drcprv5nmc"
    ///   },
    ///   {
    ///     "Addr" : "10.0.0.46:2377",
    ///     "NodeID" : "k67qz4598weg5unwwffg6z1m1"
    ///   }
    /// ]
    public var remoteManagers: [PeerNode]?
    /// Total number of nodes in the swarm.
    public var nodes: Int?
    /// Total number of managers in the swarm.
    public var managers: Int?
    /// ClusterInfo represents information about the swarm as is returned by the
    /// "/info" endpoint. Join-tokens are not included.
    public var cluster: ClusterInfo?

    public init(nodeID: String? = nil, nodeAddr: String? = nil, localNodeState: LocalNodeState? = nil, isControlAvailable: Bool? = nil, error: String? = nil, remoteManagers: [PeerNode]? = nil, nodes: Int? = nil, managers: Int? = nil, cluster: ClusterInfo? = nil) {
        self.nodeID = nodeID
        self.nodeAddr = nodeAddr
        self.localNodeState = localNodeState
        self.isControlAvailable = isControlAvailable ?? false
        self.error = error
        self.remoteManagers = remoteManagers
        self.nodes = nodes
        self.managers = managers
        self.cluster = cluster
    }

    private enum CodingKeys: String, CodingKey {
        case nodeID = "NodeID"
        case nodeAddr = "NodeAddr"
        case localNodeState = "LocalNodeState"
        case isControlAvailable = "ControlAvailable"
        case error = "Error"
        case remoteManagers = "RemoteManagers"
        case nodes = "Nodes"
        case managers = "Managers"
        case cluster = "Cluster"
    }

    public init(from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        self.nodeID = try values.decodeIfPresent(String.self, forKey: .nodeID)
        self.nodeAddr = try values.decodeIfPresent(String.self, forKey: .nodeAddr)
        self.localNodeState = try values.decodeIfPresent(LocalNodeState.self, forKey: .localNodeState)
        self.isControlAvailable = try values.decodeIfPresent(Bool.self, forKey: .isControlAvailable) ?? false
        self.error = try values.decodeIfPresent(String.self, forKey: .error)
        self.remoteManagers = try values.decodeIfPresent([PeerNode].self, forKey: .remoteManagers)
        self.nodes = try values.decodeIfPresent(Int.self, forKey: .nodes)
        self.managers = try values.decodeIfPresent(Int.self, forKey: .managers)
        self.cluster = try values.decodeIfPresent(ClusterInfo.self, forKey: .cluster)
    }
}

/// Current local status of this node.
///
/// Example: "active"
public enum LocalNodeState: String, Codable, CaseIterable {
    case empty = ""
    case inactive
    case pending
    case active
    case error
    case locked
}

/// Represents a peer-node in the swarm
public struct PeerNode: Codable {
    /// Unique identifier of for this node in the swarm.
    public var nodeID: String?
    /// IP address and ports at which this node can be reached.
    public var addr: String?

    public init(nodeID: String? = nil, addr: String? = nil) {
        self.nodeID = nodeID
        self.addr = addr
    }

    private enum CodingKeys: String, CodingKey {
        case nodeID = "NodeID"
        case addr = "Addr"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
