// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import NaiveDate

/// The transaction status is filled with codes of the ISO 20022 data table:
/// - 'ACCC': 'AcceptedSettlementCompleted' -
///   Settlement on the creditor's account has been completed.
/// - 'ACCP': 'AcceptedCustomerProfile' -
///   Preceding check of technical validation was successful.
///   Customer profile check was also successful.
/// - 'ACSC': 'AcceptedSettlementCompleted' -
///   Settlement on the debtoro?=s account has been completed.
/// 
///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
/// 
///   **Warning:** this status is provided for transaction status reasons, not for financial information.
///   It can only be used after bilateral agreement.
/// - 'ACSP': 'AcceptedSettlementInProcess' -
///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
/// - 'ACTC': 'AcceptedTechnicalValidation' -
///   Authentication and syntactical and semantical validation are successful.
/// - 'ACWC': 'AcceptedWithChange' -
///   Instruction is accepted but a change will be made, such as date or remittance not sent.
/// - 'ACWP': 'AcceptedWithoutPosting' -
///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
/// - 'RCVD': 'Received' -
///   Payment initiation has been received by the receiving agent.
/// - 'PDNG': 'Pending' -
///   Payment initiation or individual transaction included in the payment initiation is pending.
///   Further checks and status update will be performed.
/// - 'RJCT': 'Rejected' -
///   Payment initiation or individual transaction included in the payment initiation has been rejected.
/// - 'CANC': 'Cancelled'
///   Payment initiation has been cancelled before execution
///   Remark: This codeis accepted as new code by ISO20022.
/// - 'ACFC': 'AcceptedFundsChecked' -
///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
///   Remark: This code is accepted as new code by ISO20022.
/// - 'PATC': 'PartiallyAcceptedTechnical'
///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
///   Remark: This code is accepted as new code by ISO20022.
/// - 'PART': 'PartiallyAccepted' -
///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
///
/// Example: "ACCP"
public enum TransactionStatus: String, Codable, CaseIterable {
    case accc = "ACCC"
    case accp = "ACCP"
    case acsc = "ACSC"
    case acsp = "ACSP"
    case actc = "ACTC"
    case acwc = "ACWC"
    case acwp = "ACWP"
    case rcvd = "RCVD"
    case pdng = "PDNG"
    case rjct = "RJCT"
    case canc = "CANC"
    case acfc = "ACFC"
    case patc = "PATC"
    case part = "PART"
}

/// The transaction status is filled with codes of the ISO 20022 data table.
/// Only the codes RCVD, PATC, ACTC, ACWC and RJCT are used:
/// - 'ACSP': 'AcceptedSettlementInProcess' -
///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
/// - 'ACTC': 'AcceptedTechnicalValidation' -
///   Authentication and syntactical and semantical validation are successful.
/// - 'ACWC': 'AcceptedWithChange' -
///   Instruction is accepted but a change will be made, such as date or remittance not sent.
/// - 'RCVD': 'Received' -
///   Payment initiation has been received by the receiving agent.
/// - 'RJCT': 'Rejected' -
///   Payment initiation or individual transaction included in the payment initiation has been rejected.
///
/// Example: "RCVD"
public enum TransactionStatusSBS: String, Codable, CaseIterable {
    case acsc = "ACSC"
    case actc = "ACTC"
    case patc = "PATC"
    case rcvd = "RCVD"
    case rjct = "RJCT"
    case canc = "CANC"
}

/// This data element is containing information about the status of the SCA method applied.
/// 
/// The following codes are defined for this data type.
/// 
///   * 'received':
///     An authorisation or cancellation-authorisation resource has been created successfully.
///   * 'psuIdentified':
///     The PSU related to the authorisation or cancellation-authorisation resource has been identified.
///   * 'psuAuthenticated':
///     The PSU related to the authorisation or cancellation-authorisation resource has been identified and authenticated e.g. by a password or by an access token.
///   * 'scaMethodSelected':
///     The PSU/TPP has selected the related SCA routine.
///     If the SCA method is chosen implicitly since only one SCA method is available,
///     then this is the first status to be reported instead of 'received'.
///   * 'unconfirmed':
///     SCA is technically successfully finalised by the PSU, but the authorisation resource needs a confirmation command by the TPP yet.
///   * 'started':
///     The addressed SCA routine has been started.
///   * 'finalised':
///     The SCA routine has been finalised successfully (including a potential confirmation command).
///     This is a final status of the authorisation resource.
///   * 'failed':
///     The SCA routine failed.
///     This is a final status of the authorisation resource.
///   * 'exempted':
///     SCA was exempted for the related transaction, the related authorisation is successful.
///     This is a final status of the authorisation resource.
///
/// Example: "psuAuthenticated"
public enum ScaStatus: String, Codable, CaseIterable {
    case received
    case psuIdentified
    case psuAuthenticated
    case scaMethodSelected
    case started
    case unconfirmed
    case finalised
    case failed
    case exempted
}

/// This data element is containing information about the status of the SCA method in an authorisation confirmation response.
/// 
/// The following codes are defined for this data type.
/// 
///   * 'finalised': if the transaction authorisation and confirmation was successfule.
///   * 'failed': if the transaction authorisation or confirmation was not successful.
public enum ScaStatusAuthorisationConfirmation: String, Codable, CaseIterable {
    case finalised
    case failed
}

/// This is the overall lifecycle status of the consent.
/// 
/// Valid values are:
///   - 'received': The consent data have been received and are technically correct.
///     The data is not authorised yet.
///   - 'rejected': The consent data have been rejected e.g. since no successful authorisation has taken place.
///   - 'valid': The consent is accepted and valid for GET account data calls and others as specified in the consent object.
///   - 'revokedByPsu': The consent has been revoked by the PSU towards the ASPSP.
///   - 'expired': The consent expired.
///   - 'terminatedByTpp': The corresponding TPP has terminated the consent by applying the DELETE method to the consent resource.
///   - 'partiallyAuthorised': The consent is due to a multi-level authorisation, some but not all mandated authorisations have been performed yet.
/// 
/// The ASPSP might add further codes. These codes then shall be contained in the ASPSP's documentation of the XS2A interface
/// and has to be added to this API definition as well.
public enum ConsentStatus: String, Codable, CaseIterable {
    case received
    case rejected
    case valid
    case revokedByPsu
    case expired
    case terminatedByTpp
    case partiallyAuthorised
}

public typealias ChosenScaMethod = AuthenticationObject

/// Type of the authentication method.
/// 
/// More authentication types might be added during implementation projects and documented in the ASPSP documentation.
/// 
///   - 'SMS_OTP': An SCA method, where an OTP linked to the transaction to be authorised is sent to the PSU through a SMS channel.
///   - 'CHIP_OTP': An SCA method, where an OTP is generated by a chip card, e.g. a TOP derived from an EMV cryptogram.
///     To contact the card, the PSU normally needs a (handheld) device.
///     With this device, the PSU either reads the challenging data through a visual interface like flickering or
///     the PSU types in the challenge through the device key pad.
///     The device then derives an OTP from the challenge data and displays the OTP to the PSU.
///   - 'PHOTO_OTP': An SCA method, where the challenge is a QR code or similar encoded visual data
///     which can be read in by a consumer device or specific mobile app.
///     The device resp. the specific app than derives an OTP from the visual challenge data and displays
///     the OTP to the PSU.
///   - 'PUSH_OTP': An OTP is pushed to a dedicated authentication APP and displayed to the PSU.
///   - 'SMTP_OTP': An OTP is sent via email to the PSU.
public enum AuthenticationType: String, Codable, CaseIterable {
    case smsOtp = "SMS_OTP"
    case chipOtp = "CHIP_OTP"
    case photoOtp = "PHOTO_OTP"
    case pushOtp = "PUSH_OTP"
    case smtpOtp = "SMTP_OTP"
}

/// Authentication object.
public struct AuthenticationObject: Codable {
    /// Type of the authentication method.
    /// 
    /// More authentication types might be added during implementation projects and documented in the ASPSP documentation.
    /// 
    ///   - 'SMS_OTP': An SCA method, where an OTP linked to the transaction to be authorised is sent to the PSU through a SMS channel.
    ///   - 'CHIP_OTP': An SCA method, where an OTP is generated by a chip card, e.g. a TOP derived from an EMV cryptogram.
    ///     To contact the card, the PSU normally needs a (handheld) device.
    ///     With this device, the PSU either reads the challenging data through a visual interface like flickering or
    ///     the PSU types in the challenge through the device key pad.
    ///     The device then derives an OTP from the challenge data and displays the OTP to the PSU.
    ///   - 'PHOTO_OTP': An SCA method, where the challenge is a QR code or similar encoded visual data
    ///     which can be read in by a consumer device or specific mobile app.
    ///     The device resp. the specific app than derives an OTP from the visual challenge data and displays
    ///     the OTP to the PSU.
    ///   - 'PUSH_OTP': An OTP is pushed to a dedicated authentication APP and displayed to the PSU.
    ///   - 'SMTP_OTP': An OTP is sent via email to the PSU.
    public var authenticationType: AuthenticationType
    /// Depending on the "authenticationType".
    /// This version can be used by differentiating authentication tools used within performing OTP generation in the same authentication type.
    /// This version can be referred to in the ASPSP?s documentation.
    public var authenticationVersion: String?
    /// An identification provided by the ASPSP for the later identification of the authentication method selection.
    ///
    /// Example: "myAuthenticationID"
    public var authenticationMethodID: String
    /// This is the name of the authentication method defined by the PSU in the Online Banking frontend of the ASPSP.
    /// Alternatively this could be a description provided by the ASPSP like "SMS OTP on phone +49160 xxxxx 28".
    /// This name shall be used by the TPP when presenting a list of authentication methods to the PSU, if available.
    ///
    /// Example: "SMS OTP on phone +49160 xxxxx 28"
    public var name: String?
    /// Detailed information about the SCA method for the PSU.
    ///
    /// Example: "Detailed information about the SCA method for the PSU."
    public var explanation: String?

    public init(authenticationType: AuthenticationType, authenticationVersion: String? = nil, authenticationMethodID: String, name: String? = nil, explanation: String? = nil) {
        self.authenticationType = authenticationType
        self.authenticationVersion = authenticationVersion
        self.authenticationMethodID = authenticationMethodID
        self.name = name
        self.explanation = explanation
    }

    private enum CodingKeys: String, CodingKey {
        case authenticationType
        case authenticationVersion
        case authenticationMethodID = "authenticationMethodId"
        case name
        case explanation
    }
}

/// JSON Body of a establish signing basket request.
/// The body shall contain at least one entry.
public struct SigningBasket: Codable {
    /// A list of paymentIds.
    public var paymentIDs: [String]?
    /// A list of consentIds.
    public var consentIDs: [String]?

    public init(paymentIDs: [String]? = nil, consentIDs: [String]? = nil) {
        self.paymentIDs = paymentIDs
        self.consentIDs = consentIDs
    }

    private enum CodingKeys: String, CodingKey {
        case paymentIDs = "paymentIds"
        case consentIDs = "consentIds"
    }
}

/// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
/// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
public struct ChallengeData: Codable {
    /// PNG data (max. 512 kilobyte) to be displayed to the PSU,
    /// Base64 encoding, cp. [RFC4648].
    /// This attribute is used only, when PHOTO_OTP or CHIP_OTP
    /// is the selected SCA method.
    public var image: String?
    /// A collection of strings as challenge data.
    public var data: [String]?
    /// A link where the ASPSP will provides the challenge image for the TPP.
    public var imageLink: String?
    /// The maximal length for the OTP to be typed in by the PSU.
    public var otpMaxLength: Int?
    /// The format type of the OTP to be typed in. The admitted values are "characters" or "integer".
    public var otpFormat: OtpFormat?
    /// Additional explanation for the PSU to explain
    /// e.g. fallback mechanism for the chosen SCA method.
    /// The TPP is obliged to show this to the PSU.
    public var additionalInformation: String?

    /// The format type of the OTP to be typed in. The admitted values are "characters" or "integer".
    public enum OtpFormat: String, Codable, CaseIterable {
        case characters
        case integer
    }

    public init(image: String? = nil, data: [String]? = nil, imageLink: String? = nil, otpMaxLength: Int? = nil, otpFormat: OtpFormat? = nil, additionalInformation: String? = nil) {
        self.image = image
        self.data = data
        self.imageLink = imageLink
        self.otpMaxLength = otpMaxLength
        self.otpFormat = otpFormat
        self.additionalInformation = additionalInformation
    }
}

/// Link to a resource.
public struct HrefType: Codable {
    /// Link to a resource.
    ///
    /// Example: "/v1/payments/swiss-sepa-credit-transfers/1234-wertiq-983"
    public var href: String?

    public init(href: String? = nil) {
        self.href = href
    }
}

/// An array of all authorisationIds.
public struct Authorisations: Codable {
    /// An array of all authorisationIds.
    public var authorisationIDs: [String]

    public init(authorisationIDs: [String]) {
        self.authorisationIDs = authorisationIDs
    }

    private enum CodingKeys: String, CodingKey {
        case authorisationIDs = "authorisationIds"
    }
}

/// Reference to an account by either
///   * IBAN, of a payment accounts, or
///   * otherAccountIdentification, for payment accounts if there is no IBAN
/// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
public struct AccountReference16CH: Codable {
    /// IBAN of an account.
    ///
    /// Example: "FR7612345987650123456789014"
    public var iban: String?
    /// Other payment account Identifier.
    /// adapted from ISO pain.001.001.03.ch.02 GenericAccountIdentification1-CH
    ///
    /// Example: "90-100100-0"
    public var otherAccountIdentification: String?
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var currency: String?
    /// ExternalCashAccountType1Code from ISO 20022.
    public var cashAccountType: String?

    public init(iban: String? = nil, otherAccountIdentification: String? = nil, currency: String? = nil, cashAccountType: String? = nil) {
        self.iban = iban
        self.otherAccountIdentification = otherAccountIdentification
        self.currency = currency
        self.cashAccountType = cashAccountType
    }
}

/// Reference to an debtorAgent by either
///   * BIC, of the debtor bank, or
///   * IID, of the debtor bank
/// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH_BicOrClrId
public struct DebtorAgent7CH: Codable {
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var bic: String?
    /// Institiutional identification of a bank (Clearing System Member ID)
    /// adapted from ISO pain.001.001.03.ch.02 ClearingSystemMemberIdentification2
    public var iid: InstitutionalIdentification2?

    public init(bic: String? = nil, iid: InstitutionalIdentification2? = nil) {
        self.bic = bic
        self.iid = iid
    }
}

/// Institiutional identification of a bank (Clearing System Member ID)
/// adapted from ISO pain.001.001.03.ch.02 ClearingSystemMemberIdentification2
public struct InstitutionalIdentification2: Codable {
    public var clearingSystemIDCode: String
    public var clearingSystemMemberID: String

    public init(clearingSystemIDCode: String, clearingSystemMemberID: String) {
        self.clearingSystemIDCode = clearingSystemIDCode
        self.clearingSystemMemberID = clearingSystemMemberID
    }

    private enum CodingKeys: String, CodingKey {
        case clearingSystemIDCode = "clearingSystemIdCode"
        case clearingSystemMemberID = "clearingSystemMemberId"
    }
}

/// Reference to an creditorAgent by either
///   * BIC, of the creditor bank, or
///   * IID, of the creditor bank, or
///   * IID and optional name and address of the creditor bank or
///   * Name and address of the creditor bank
/// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH
public struct CreditorAgent7CH: Codable {
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var bic: String?
    /// Institiutional identification of a bank (Clearing System Member ID)
    /// adapted from ISO pain.001.001.03.ch.02 ClearingSystemMemberIdentification2
    public var iid: InstitutionalIdentification2?
    public var name: String?
    /// As in ISO pain.001.001.03.ch.02 PostalAddress6
    /// If possible structured. Simultaneous use of the structured elements <StrtNm>/ <BldgNb>/<PstCd>/<TwnNm> and the unstructured element <AdrLine> is not permitted.
    /// as in ISO pain.001.001.03.ch.02 PostalAddress6-CH
    public var address: PostalAddress6CH?

    public init(bic: String? = nil, iid: InstitutionalIdentification2? = nil, name: String? = nil, address: PostalAddress6CH? = nil) {
        self.bic = bic
        self.iid = iid
        self.name = name
        self.address = address
    }
}

/// As in ISO pain.001.001.03.ch.02 PostalAddress6
/// If possible structured. Simultaneous use of the structured elements <StrtNm>/ <BldgNb>/<PstCd>/<TwnNm> and the unstructured element <AdrLine> is not permitted.
/// as in ISO pain.001.001.03.ch.02 PostalAddress6-CH
public struct PostalAddress6CH: Codable {
    public var streetName: String?
    public var buildingNumber: String?
    public var townName: String?
    public var postCode: String?
    /// ISO 3166 ALPHA2 country code.
    ///
    /// Example: "SE"
    public var country: String?
    public var addressLine1: String?
    public var addressLine2: String?

    public init(streetName: String? = nil, buildingNumber: String? = nil, townName: String? = nil, postCode: String? = nil, country: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil) {
        self.streetName = streetName
        self.buildingNumber = buildingNumber
        self.townName = townName
        self.postCode = postCode
        self.country = country
        self.addressLine1 = addressLine1
        self.addressLine2 = addressLine2
    }
}

/// The following balance types are defined:
///   - "closingBooked":
///     Balance of the account at the end of the pre-agreed account reporting period.
///     It is the sum of the opening booked balance at the beginning of the period and all entries booked
///     to the account during the pre-agreed account reporting period.
/// 
///     For card-accounts, this is composed of
/// 
///       - invoiced, but not yet paid entries
/// 
///   - "expected":
///     Balance composed of booked entries and pending items known at the time of calculation,
///     which projects the end of day balance if everything is booked on the account and no other entry is posted.
///     
///     For card accounts, this is composed of:
///       - invoiced, but not yet paid entries
///       - not yet invoiced but already booked entries and
///       - pending items (not yet booked)
///     
///     For card-accounts:
/// 
///     "money to spend with the value of a pre-approved credit limit on the card account"
/// 
///   - "openingBooked":
///     Book balance of the account at the beginning of the account reporting period.
///     It always equals the closing book balance from the previous report.
///   - "interimAvailable":
///     Available balance calculated in the course of the account ?servicer?s business day,
///     at the time specified, and subject to further changes during the business day.
///     The interim balance is calculated on the basis of booked credit and debit items during the calculation
///     time/period specified.
///     
///     For card-accounts, this is composed of:
///       - invoiced, but not yet paid entries
///       - not yet invoiced but already booked entries
///   - "interimBooked":
///     Balance calculated in the course of the account servicer's business day, at the time specified,
///     and subject to further changes during the business day.
///     The interim balance is calculated on the basis of booked credit and debit items during the calculation time/period
///     specified.
///   - "forwardAvailable":
///     Forward available balance of money that is at the disposal of the account owner on the date specified.
///   - "nonInvoiced":
///     Only for card accounts, to be checked yet.
public enum BalanceType: String, Codable, CaseIterable {
    case closingBooked
    case expected
    case openingBooked
    case interimAvailable
    case interimBooked
    case forwardAvailable
    case nonInvoiced
}

/// Requested access services for a consent.
public struct AccountAccess: Codable {
    /// Is asking for detailed account information.
    /// 
    /// If the array is empty in a request, the TPP is asking for an accessible account list.
    /// This may be restricted in a PSU/ASPSP authorization dialogue.
    /// If the array is empty, also the arrays for balances, additionalInformation sub attributes or transactions shall be empty, if used.
    public var accounts: [AccountReference16CH]?
    /// Is asking for balances of the addressed accounts.
    /// 
    /// If the array is empty in the request, the TPP is asking for the balances of all accessible account lists.
    /// This may be restricted in a PSU/ASPSP authorization dialogue.
    /// If the array is empty, also the arrays for accounts, additionalInformation sub attributes or transactions shall be empty, if used.
    public var balances: [AccountReference16CH]?
    /// Is asking for transactions of the addressed accounts.
    /// 
    /// If the array is empty in the request, the TPP is asking for the transactions of all accessible account lists.
    /// This may be restricted in a PSU/ASPSP authorization dialogue.
    /// If the array is empty, also the arrays for accounts, additionalInformation sub attributes or balances shall be empty, if used.
    public var transactions: [AccountReference16CH]?
    /// Optional if supported by API provider.
    /// 
    /// Is asking for additional information as added within this structured object.
    /// The usage of this data element requires at least one of the entries "accounts",
    /// "transactions" or "balances" also to be contained in the object.
    /// If detailed accounts are referenced, it is required in addition that any account addressed within
    /// the additionalInformation attribute is also addressed by at least one of the attributes "accounts",
    /// "transactions" or "balances".
    public var additionalInformation: AdditionalInformationAccess?
    /// Optional if supported by API provider.
    /// 
    /// The values "allAccounts" and "allAccountsWithOwnerName" are admitted.
    /// The support of the "allAccountsWithOwnerName" value by the ASPSP is optional.
    public var availableAccounts: AvailableAccounts?
    /// Optional if supported by API provider.
    /// 
    /// The values "allAccounts" and "allAccountsWithOwnerName" are admitted.
    /// The support of the "allAccountsWithOwnerName" value by the ASPSP is optional.
    public var availableAccountsWithBalance: AvailableAccountsWithBalance?
    /// Optional if supported by API provider.
    /// 
    /// The values "allAccounts" and "allAccountsWithOwnerName" are admitted.
    /// The support of the "allAccountsWithOwnerName" value by the ASPSP is optional.
    public var allPsd2: AllPsd2?
    /// If the TPP requests access to accounts via availableAccounts (List of available accounts), global
    /// or bank driven consents, the TPP may include this element to restrict access to the referred
    /// account types. Absence of the element is interpreted as "no restriction" (therefore access to
    /// accounts of all types is requested). The element may only occur, if each of the elements
    ///   - accounts
    ///   - balances
    ///   - transactions
    /// is either not present or contains an empty array.
    public var restrictedTo: [String]?

    /// Optional if supported by API provider.
    /// 
    /// The values "allAccounts" and "allAccountsWithOwnerName" are admitted.
    /// The support of the "allAccountsWithOwnerName" value by the ASPSP is optional.
    public enum AvailableAccounts: String, Codable, CaseIterable {
        case allAccounts
        case allAccountsWithOwnerName
    }

    /// Optional if supported by API provider.
    /// 
    /// The values "allAccounts" and "allAccountsWithOwnerName" are admitted.
    /// The support of the "allAccountsWithOwnerName" value by the ASPSP is optional.
    public enum AvailableAccountsWithBalance: String, Codable, CaseIterable {
        case allAccounts
        case allAccountsWithOwnerName
    }

    /// Optional if supported by API provider.
    /// 
    /// The values "allAccounts" and "allAccountsWithOwnerName" are admitted.
    /// The support of the "allAccountsWithOwnerName" value by the ASPSP is optional.
    public enum AllPsd2: String, Codable, CaseIterable {
        case allAccounts
        case allAccountsWithOwnerName
    }

    public init(accounts: [AccountReference16CH]? = nil, balances: [AccountReference16CH]? = nil, transactions: [AccountReference16CH]? = nil, additionalInformation: AdditionalInformationAccess? = nil, availableAccounts: AvailableAccounts? = nil, availableAccountsWithBalance: AvailableAccountsWithBalance? = nil, allPsd2: AllPsd2? = nil, restrictedTo: [String]? = nil) {
        self.accounts = accounts
        self.balances = balances
        self.transactions = transactions
        self.additionalInformation = additionalInformation
        self.availableAccounts = availableAccounts
        self.availableAccountsWithBalance = availableAccountsWithBalance
        self.allPsd2 = allPsd2
        self.restrictedTo = restrictedTo
    }
}

/// Account status. The value is one of the following:
///   - "enabled": account is available
///   - "deleted": account is terminated
///   - "blocked": account is blocked e.g. for legal reasons
/// If this field is not used, than the account is available in the sense of this specification.
public enum AccountStatus: String, Codable, CaseIterable {
    case enabled
    case deleted
    case blocked
}

/// The ASPSP shall give at least one of the account reference identifiers:
///   - iban
///   - bban
///   - pan
///   - maskedPan
///   - msisdn
/// If the account is a multicurrency account currency code in "currency" is set to "XXX".
public struct AccountDetails: Codable {
    /// This shall be filled, if addressable resource are created by the ASPSP on the /accounts or /card-accounts endpoint.
    public var resourceID: String?
    /// IBAN of an account.
    ///
    /// Example: "FR7612345987650123456789014"
    public var iban: String?
    /// Basic Bank Account Number (BBAN) Identifier.
    /// 
    /// This data element can be used in the body of the consent request.
    ///   Message for retrieving account access consent from this account. This
    ///   data elements is used for payment accounts which have no IBAN.
    ///   ISO20022: Basic Bank Account Number (BBAN).
    ///   
    ///   Identifier used nationally by financial institutions, i.e., in individual countries,
    ///   generally as part of a National Account Numbering Scheme(s),
    ///   which uniquely identifies the account of a customer.
    ///
    /// Example: "BARC12345612345678"
    public var bban: String?
    /// Mobile phone number.
    ///
    /// Example: "+49 170 1234567"
    public var msisdn: String?
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var currency: String
    /// Name of the account, as assigned by the ASPSP, in agreement with the account owner in order to provide an additional means of identification of the account.
    public var name: String?
    /// Name of the account as defined by the PSU within online channels.
    public var displayName: String?
    /// Product name of the bank for this account, proprietary definition.
    public var product: String?
    /// ExternalCashAccountType1Code from ISO 20022.
    public var cashAccountType: String?
    /// Account status. The value is one of the following:
    ///   - "enabled": account is available
    ///   - "deleted": account is terminated
    ///   - "blocked": account is blocked e.g. for legal reasons
    /// If this field is not used, than the account is available in the sense of this specification.
    public var status: AccountStatus?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var bic: String?
    /// Case of a set of pending card transactions, the APSP will provide the relevant cash account the card is set up on.
    public var linkedAccounts: String?
    /// Specifies the usage of the account:
    ///   * PRIV: private personal account
    ///   * ORGA: professional account
    public var usage: Usage?
    /// Specifications that might be provided by the ASPSP:
    ///   - characteristics of the account
    ///   - characteristics of the relevant card
    public var details: String?
    /// A list of balances regarding this account, e.g. the current balance, the last booked balance.
    /// The list might be restricted to the current balance.
    public var balances: [Balance]?
    /// Links to the account, which can be directly used for retrieving account information from this dedicated account.
    /// 
    /// Links to "balances" and/or "transactions"
    /// 
    /// These links are only supported, when the corresponding consent has been already granted.
    public var links: [String: HrefType]?
    /// Name of the legal account owner.
    /// If there is more than one owner, then e.g. two names might be noted here.
    /// 
    /// For a corporate account, the corporate name is used for this attribute.
    /// Even if supported by the ASPSP, the provision of this field might depend on the fact whether an explicit consent to this specific additional account information has been given by the PSU.
    ///
    /// Example: "John Doe"
    public var ownerName: String?

    /// Specifies the usage of the account:
    ///   * PRIV: private personal account
    ///   * ORGA: professional account
    public enum Usage: String, Codable, CaseIterable {
        case priv = "PRIV"
        case orga = "ORGA"
    }

    public init(resourceID: String? = nil, iban: String? = nil, bban: String? = nil, msisdn: String? = nil, currency: String, name: String? = nil, displayName: String? = nil, product: String? = nil, cashAccountType: String? = nil, status: AccountStatus? = nil, bic: String? = nil, linkedAccounts: String? = nil, usage: Usage? = nil, details: String? = nil, balances: [Balance]? = nil, links: [String: HrefType]? = nil, ownerName: String? = nil) {
        self.resourceID = resourceID
        self.iban = iban
        self.bban = bban
        self.msisdn = msisdn
        self.currency = currency
        self.name = name
        self.displayName = displayName
        self.product = product
        self.cashAccountType = cashAccountType
        self.status = status
        self.bic = bic
        self.linkedAccounts = linkedAccounts
        self.usage = usage
        self.details = details
        self.balances = balances
        self.links = links
        self.ownerName = ownerName
    }

    private enum CodingKeys: String, CodingKey {
        case resourceID = "resourceId"
        case iban
        case bban
        case msisdn
        case currency
        case name
        case displayName
        case product
        case cashAccountType
        case status
        case bic
        case linkedAccounts
        case usage
        case details
        case balances
        case links = "_links"
        case ownerName
    }
}

/// Card account details.
public struct CardAccountDetails: Codable {
    /// This is the data element to be used in the path when retrieving data from a dedicated account.
    /// This shall be filled, if addressable resource are created by the ASPSP on the /card-accounts endpoint.
    public var resourceID: String?
    /// Masked Primary Account Number.
    ///
    /// Example: "123456xxxxxx1234"
    public var maskedPan: String
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var currency: String
    /// Name of the legal account owner.
    /// If there is more than one owner, then e.g. two names might be noted here.
    /// 
    /// For a corporate account, the corporate name is used for this attribute.
    /// Even if supported by the ASPSP, the provision of this field might depend on the fact whether an explicit consent to this specific additional account information has been given by the PSU.
    ///
    /// Example: "John Doe"
    public var ownerName: String?
    /// Name of the account, as assigned by the ASPSP,
    /// in agreement with the account owner in order to provide an additional means of identification of the account.
    public var name: String?
    /// Name of the account as defined by the PSU within online channels.
    public var displayName: String?
    /// Product Name of the Bank for this account, proprietary definition.
    public var product: String?
    /// If true, the amounts of debits on the reports are quoted positive with the related consequence for balances.
    /// If false, the amount of debits on the reports are quoted negative.
    public var isDebitAccounting: Bool?
    /// Account status. The value is one of the following:
    ///   - "enabled": account is available
    ///   - "deleted": account is terminated
    ///   - "blocked": account is blocked e.g. for legal reasons
    /// If this field is not used, than the account is available in the sense of this specification.
    public var status: AccountStatus?
    /// Specifies the usage of the account:
    ///   * PRIV: private personal account
    ///   * ORGA: professional account
    public var usage: Usage?
    /// Specifications that might be provided by the ASPSP:
    ///   - characteristics of the account
    ///   - characteristics of the relevant card
    public var details: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var creditLimit: Amount?
    /// A list of balances regarding this account, e.g. the current balance, the last booked balance.
    /// The list might be restricted to the current balance.
    public var balances: [Balance]?
    /// Links to the account, which can be directly used for retrieving account information from this dedicated account.
    /// 
    /// Links to "balances" and/or "transactions"
    /// 
    /// These links are only supported, when the corresponding consent has been already granted.
    public var links: [String: HrefType]?

    /// Specifies the usage of the account:
    ///   * PRIV: private personal account
    ///   * ORGA: professional account
    public enum Usage: String, Codable, CaseIterable {
        case priv = "PRIV"
        case orga = "ORGA"
    }

    public init(resourceID: String? = nil, maskedPan: String, currency: String, ownerName: String? = nil, name: String? = nil, displayName: String? = nil, product: String? = nil, isDebitAccounting: Bool? = nil, status: AccountStatus? = nil, usage: Usage? = nil, details: String? = nil, creditLimit: Amount? = nil, balances: [Balance]? = nil, links: [String: HrefType]? = nil) {
        self.resourceID = resourceID
        self.maskedPan = maskedPan
        self.currency = currency
        self.ownerName = ownerName
        self.name = name
        self.displayName = displayName
        self.product = product
        self.isDebitAccounting = isDebitAccounting
        self.status = status
        self.usage = usage
        self.details = details
        self.creditLimit = creditLimit
        self.balances = balances
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case resourceID = "resourceId"
        case maskedPan
        case currency
        case ownerName
        case name
        case displayName
        case product
        case isDebitAccounting = "debitAccounting"
        case status
        case usage
        case details
        case creditLimit
        case balances
        case links = "_links"
    }
}

/// List of accounts with details.
public struct AccountList: Codable {
    public var accounts: [AccountDetails]

    public init(accounts: [AccountDetails]) {
        self.accounts = accounts
    }
}

/// List of card accounts with details.
public struct CardAccountList: Codable {
    public var cardAccounts: [CardAccountDetails]

    public init(cardAccounts: [CardAccountDetails]) {
        self.cardAccounts = cardAccounts
    }
}

/// JSON based account report.
/// This account report contains transactions resulting from the query parameters.
/// 
/// 'booked' shall be contained if bookingStatus parameter is set to "booked" or "both".
/// 
/// 'pending' is not contained if the bookingStatus parameter is set to "booked" or "information".
/// 
/// 'information' Only contained if the bookingStatus is set to "information" and if supported by ASPSP.
public struct AccountReport: Codable {
    /// Array of transaction details.
    public var booked: [Transactions]?
    /// Array of transaction details.
    public var pending: [Transactions]?
    /// Array of transaction details.
    public var information: [Transactions]?
    public var links: [String: HrefType]

    public init(booked: [Transactions]? = nil, pending: [Transactions]? = nil, information: [Transactions]? = nil, links: [String: HrefType]) {
        self.booked = booked
        self.pending = pending
        self.information = information
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case booked
        case pending
        case information
        case links = "_links"
    }
}

/// JSON based card account report.
/// 
/// This card account report contains transactions resulting from the query parameters.
public struct CardAccountReport: Codable {
    /// Array of transaction details.
    public var booked: [CardTransaction]
    /// Array of transaction details.
    public var pending: [CardTransaction]?
    public var links: [String: HrefType]

    public init(booked: [CardTransaction], pending: [CardTransaction]? = nil, links: [String: HrefType]) {
        self.booked = booked
        self.pending = pending
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case booked
        case pending
        case links = "_links"
    }
}

/// Transaction details.
public struct TransactionDetailsBody: Codable {
    /// Transaction details.
    public var transactionDetails: Transactions

    public init(transactionDetails: Transactions) {
        self.transactionDetails = transactionDetails
    }
}

/// Transaction details.
public struct Transactions: Codable {
    /// This identification is given by the attribute transactionId of the corresponding entry of a transaction list.
    ///
    /// Example: "3dc3d5b3-7023-4848-9853-f5400a64e80f"
    public var transactionID: String?
    /// Is the identification of the transaction as used e.g. for reference for deltafunction on application level.
    /// The same identification as for example used within camt.05x messages.
    public var entryReference: String?
    /// Unique end to end identity.
    public var endToEndID: String?
    /// If this indicator equals true, then the related entry is a batch entry.
    public var isBatchIndicator: Bool?
    /// Shall be used if and only if the batchIndicator is contained and equals true.
    public var batchNumberOfTransactions: Int?
    /// Identification of Mandates, e.g. a SEPA Mandate ID.
    public var mandateID: String?
    /// Identification of a Cheque.
    public var checkID: String?
    /// Identification of Creditors, e.g. a SEPA Creditor ID.
    ///
    /// Example: "Creditor Id 5678"
    public var creditorID: String?
    /// The date when an entry is posted to an account on the ASPSPs books.
    public var bookingDate: NaiveDate?
    /// The Date at which assets become available to the account owner in case of a credit.
    public var valueDate: NaiveDate?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionAmount: Amount
    /// Array of exchange rates.
    public var currencyExchange: [ReportExchangeRate]?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var creditorAgent: String?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// Debtor name.
    ///
    /// Example: "Debtor Name"
    public var debtorName: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var debtorAgent: String?
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Array of unstructured remittance information.
    ///
    /// Example: ["Ref Number Merchant", "Some Other Text"]
    public var remittanceInformationUnstructuredArray: [String]?
    /// Structured remittance information Max
    public var remittanceInformationStructured: String?
    /// Array of structured remittance information.
    public var remittanceInformationStructuredArray: [RemittanceInformationStructured]?
    /// Might be used by the ASPSP to transport details about transactions within a batch.
    public var entryDetails: [EntryDetailsElement]?
    /// Might be used by the ASPSP to transport additional transaction related information to the PSU
    ///
    /// Example: "Some additional transaction related information."
    public var additionalInformation: String?
    /// Is used if and only if the bookingStatus entry equals "information".
    /// Every active standing order related to the dedicated payment account result into one entry.
    public var additionalInformationStructured: AdditionalInformationStructured?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?
    /// Bank transaction code as used by the ASPSP and using the sub elements of this structured code defined by ISO 20022.
    /// 
    /// This code type is concatenating the three ISO20022 Codes
    ///   * Domain Code,
    ///   * Family Code, and
    ///   * SubFamiliy Code
    /// by hyphens, resulting in 'DomainCode'-'FamilyCode'-'SubFamilyCode'.
    ///
    /// Example: "PMNT-RDDT-ESDD"
    public var bankTransactionCode: String?
    /// Proprietary bank transaction code as used within a community or within an ASPSP e.g.
    /// for MT94x based transaction reports.
    public var proprietaryBankTransactionCode: String?
    /// A single balance element.
    public var balanceAfterTransaction: Balance?
    public var links: [String: HrefType]?

    public init(transactionID: String? = nil, entryReference: String? = nil, endToEndID: String? = nil, isBatchIndicator: Bool? = nil, batchNumberOfTransactions: Int? = nil, mandateID: String? = nil, checkID: String? = nil, creditorID: String? = nil, bookingDate: NaiveDate? = nil, valueDate: NaiveDate? = nil, transactionAmount: Amount, currencyExchange: [ReportExchangeRate]? = nil, creditorName: String? = nil, creditorAccount: AccountReference16CH? = nil, creditorAgent: String? = nil, ultimateCreditor: String? = nil, debtorName: String? = nil, debtorAccount: AccountReference16CH? = nil, debtorAgent: String? = nil, ultimateDebtor: String? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationUnstructuredArray: [String]? = nil, remittanceInformationStructured: String? = nil, remittanceInformationStructuredArray: [RemittanceInformationStructured]? = nil, entryDetails: [EntryDetailsElement]? = nil, additionalInformation: String? = nil, additionalInformationStructured: AdditionalInformationStructured? = nil, purposeCode: PurposeCode? = nil, bankTransactionCode: String? = nil, proprietaryBankTransactionCode: String? = nil, balanceAfterTransaction: Balance? = nil, links: [String: HrefType]? = nil) {
        self.transactionID = transactionID
        self.entryReference = entryReference
        self.endToEndID = endToEndID
        self.isBatchIndicator = isBatchIndicator
        self.batchNumberOfTransactions = batchNumberOfTransactions
        self.mandateID = mandateID
        self.checkID = checkID
        self.creditorID = creditorID
        self.bookingDate = bookingDate
        self.valueDate = valueDate
        self.transactionAmount = transactionAmount
        self.currencyExchange = currencyExchange
        self.creditorName = creditorName
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.ultimateCreditor = ultimateCreditor
        self.debtorName = debtorName
        self.debtorAccount = debtorAccount
        self.debtorAgent = debtorAgent
        self.ultimateDebtor = ultimateDebtor
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationUnstructuredArray = remittanceInformationUnstructuredArray
        self.remittanceInformationStructured = remittanceInformationStructured
        self.remittanceInformationStructuredArray = remittanceInformationStructuredArray
        self.entryDetails = entryDetails
        self.additionalInformation = additionalInformation
        self.additionalInformationStructured = additionalInformationStructured
        self.purposeCode = purposeCode
        self.bankTransactionCode = bankTransactionCode
        self.proprietaryBankTransactionCode = proprietaryBankTransactionCode
        self.balanceAfterTransaction = balanceAfterTransaction
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case transactionID = "transactionId"
        case entryReference
        case endToEndID = "endToEndId"
        case isBatchIndicator = "batchIndicator"
        case batchNumberOfTransactions
        case mandateID = "mandateId"
        case checkID = "checkId"
        case creditorID = "creditorId"
        case bookingDate
        case valueDate
        case transactionAmount
        case currencyExchange
        case creditorName
        case creditorAccount
        case creditorAgent
        case ultimateCreditor
        case debtorName
        case debtorAccount
        case debtorAgent
        case ultimateDebtor
        case remittanceInformationUnstructured
        case remittanceInformationUnstructuredArray
        case remittanceInformationStructured
        case remittanceInformationStructuredArray
        case entryDetails
        case additionalInformation
        case additionalInformationStructured
        case purposeCode
        case bankTransactionCode
        case proprietaryBankTransactionCode
        case balanceAfterTransaction
        case links = "_links"
    }
}

/// Card transaction information.
public struct CardTransaction: Codable {
    /// Unique end to end identity.
    public var cardTransactionID: String?
    /// Identification of the Terminal, where the card has been used.
    public var terminalID: String?
    /// Date of the actual card transaction.
    public var transactionDate: NaiveDate?
    /// Timestamp of the actual card transaction within the acceptance system
    public var acceptorTransactionDateTime: Date?
    /// The date when an entry is posted to an account on the ASPSPs books.
    public var bookingDate: NaiveDate?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionAmount: Amount
    /// Array of exchange rates.
    public var currencyExchange: [ReportExchangeRate]?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var originalAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var markupFee: Amount?
    /// Example: "0.3"
    public var markupFeePercentage: String?
    public var cardAcceptorID: String?
    /// Example:
    ///
    /// {
    ///   "buildingnNumber" : "89",
    ///   "country" : "FR",
    ///   "postCode" : "75000",
    ///   "streetName" : "rue blue",
    ///   "townName" : "Paris"
    /// }
    public var cardAcceptorAddress: Address?
    /// Merchant phone number
    /// It consists of a "+" followed by the country code (from 1 to 3 characters) then a "-" and finally, any
    /// combination of numbers, "(", ")", "+" and "-" (up to 30 characters).
    /// pattern according to ISO20022 \+[0-9]{1,3}-[0-9()+\-]{1,30}
    public var cardAcceptorPhone: String?
    /// Merchant category code.
    public var merchantCategoryCode: String?
    /// Masked Primary Account Number.
    ///
    /// Example: "123456xxxxxx1234"
    public var maskedPAN: String?
    public var transactionDetails: String?
    public var isInvoiced: Bool?
    /// Proprietary bank transaction code as used within a community or within an ASPSP e.g.
    /// for MT94x based transaction reports.
    public var proprietaryBankTransactionCode: String?

    public init(cardTransactionID: String? = nil, terminalID: String? = nil, transactionDate: NaiveDate? = nil, acceptorTransactionDateTime: Date? = nil, bookingDate: NaiveDate? = nil, transactionAmount: Amount, currencyExchange: [ReportExchangeRate]? = nil, originalAmount: Amount? = nil, markupFee: Amount? = nil, markupFeePercentage: String? = nil, cardAcceptorID: String? = nil, cardAcceptorAddress: Address? = nil, cardAcceptorPhone: String? = nil, merchantCategoryCode: String? = nil, maskedPAN: String? = nil, transactionDetails: String? = nil, isInvoiced: Bool? = nil, proprietaryBankTransactionCode: String? = nil) {
        self.cardTransactionID = cardTransactionID
        self.terminalID = terminalID
        self.transactionDate = transactionDate
        self.acceptorTransactionDateTime = acceptorTransactionDateTime
        self.bookingDate = bookingDate
        self.transactionAmount = transactionAmount
        self.currencyExchange = currencyExchange
        self.originalAmount = originalAmount
        self.markupFee = markupFee
        self.markupFeePercentage = markupFeePercentage
        self.cardAcceptorID = cardAcceptorID
        self.cardAcceptorAddress = cardAcceptorAddress
        self.cardAcceptorPhone = cardAcceptorPhone
        self.merchantCategoryCode = merchantCategoryCode
        self.maskedPAN = maskedPAN
        self.transactionDetails = transactionDetails
        self.isInvoiced = isInvoiced
        self.proprietaryBankTransactionCode = proprietaryBankTransactionCode
    }

    private enum CodingKeys: String, CodingKey {
        case cardTransactionID = "cardTransactionId"
        case terminalID = "terminalId"
        case transactionDate
        case acceptorTransactionDateTime
        case bookingDate
        case transactionAmount
        case currencyExchange
        case originalAmount
        case markupFee
        case markupFeePercentage
        case cardAcceptorID = "cardAcceptorId"
        case cardAcceptorAddress
        case cardAcceptorPhone
        case merchantCategoryCode
        case maskedPAN
        case transactionDetails
        case isInvoiced = "invoiced"
        case proprietaryBankTransactionCode
    }
}

/// Exchange Rate.
public struct ReportExchangeRate: Codable {
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var sourceCurrency: String
    public var exchangeRate: String
    public var unitCurrency: String
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var targetCurrency: String
    public var quotationDate: NaiveDate
    public var contractIdentification: String?

    public init(sourceCurrency: String, exchangeRate: String, unitCurrency: String, targetCurrency: String, quotationDate: NaiveDate, contractIdentification: String? = nil) {
        self.sourceCurrency = sourceCurrency
        self.exchangeRate = exchangeRate
        self.unitCurrency = unitCurrency
        self.targetCurrency = targetCurrency
        self.quotationDate = quotationDate
        self.contractIdentification = contractIdentification
    }
}

/// As in ISO pain.001.001.03.ch.02 ExchangeRateInformation1
public struct ExchangeRateInformation1: Codable {
    public var exchangeRate: String?
    public var contractIdentification: String?
    public var rateType: RateType?

    public enum RateType: String, Codable, CaseIterable {
        case spot = "SPOT"
        case sale = "SALE"
        case agrd = "AGRD"
    }

    public init(exchangeRate: String? = nil, contractIdentification: String? = nil, rateType: RateType? = nil) {
        self.exchangeRate = exchangeRate
        self.contractIdentification = contractIdentification
        self.rateType = rateType
    }
}

/// A single balance element.
public struct Balance: Codable {
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var balanceAmount: Amount
    /// The following balance types are defined:
    ///   - "closingBooked":
    ///     Balance of the account at the end of the pre-agreed account reporting period.
    ///     It is the sum of the opening booked balance at the beginning of the period and all entries booked
    ///     to the account during the pre-agreed account reporting period.
    /// 
    ///     For card-accounts, this is composed of
    /// 
    ///       - invoiced, but not yet paid entries
    /// 
    ///   - "expected":
    ///     Balance composed of booked entries and pending items known at the time of calculation,
    ///     which projects the end of day balance if everything is booked on the account and no other entry is posted.
    ///     
    ///     For card accounts, this is composed of:
    ///       - invoiced, but not yet paid entries
    ///       - not yet invoiced but already booked entries and
    ///       - pending items (not yet booked)
    ///     
    ///     For card-accounts:
    /// 
    ///     "money to spend with the value of a pre-approved credit limit on the card account"
    /// 
    ///   - "openingBooked":
    ///     Book balance of the account at the beginning of the account reporting period.
    ///     It always equals the closing book balance from the previous report.
    ///   - "interimAvailable":
    ///     Available balance calculated in the course of the account ?servicer?s business day,
    ///     at the time specified, and subject to further changes during the business day.
    ///     The interim balance is calculated on the basis of booked credit and debit items during the calculation
    ///     time/period specified.
    ///     
    ///     For card-accounts, this is composed of:
    ///       - invoiced, but not yet paid entries
    ///       - not yet invoiced but already booked entries
    ///   - "interimBooked":
    ///     Balance calculated in the course of the account servicer's business day, at the time specified,
    ///     and subject to further changes during the business day.
    ///     The interim balance is calculated on the basis of booked credit and debit items during the calculation time/period
    ///     specified.
    ///   - "forwardAvailable":
    ///     Forward available balance of money that is at the disposal of the account owner on the date specified.
    ///   - "nonInvoiced":
    ///     Only for card accounts, to be checked yet.
    public var balanceType: BalanceType
    /// A flag indicating if the credit limit of the corresponding account
    /// is included in the calculation of the balance, where applicable.
    ///
    /// Example: false
    public var isCreditLimitIncluded: Bool?
    /// This data element might be used to indicate e.g. with the expected or booked balance that no action is known
    /// on the account, which is not yet booked.
    public var lastChangeDateTime: Date?
    /// Indicates the date of the balance.
    public var referenceDate: NaiveDate?
    /// "entryReference" of the last commited transaction to support the TPP in identifying whether all
    /// PSU transactions are already known.
    public var lastCommittedTransaction: String?

    public init(balanceAmount: Amount, balanceType: BalanceType, isCreditLimitIncluded: Bool? = nil, lastChangeDateTime: Date? = nil, referenceDate: NaiveDate? = nil, lastCommittedTransaction: String? = nil) {
        self.balanceAmount = balanceAmount
        self.balanceType = balanceType
        self.isCreditLimitIncluded = isCreditLimitIncluded
        self.lastChangeDateTime = lastChangeDateTime
        self.referenceDate = referenceDate
        self.lastCommittedTransaction = lastCommittedTransaction
    }

    private enum CodingKeys: String, CodingKey {
        case balanceAmount
        case balanceType
        case isCreditLimitIncluded = "creditLimitIncluded"
        case lastChangeDateTime
        case referenceDate
        case lastCommittedTransaction
    }
}

/// Example:
///
/// {
///   "buildingnNumber" : "89",
///   "country" : "FR",
///   "postCode" : "75000",
///   "streetName" : "rue blue",
///   "townName" : "Paris"
/// }
public struct Address: Codable {
    public var streetName: String?
    public var buildingNumber: String?
    public var townName: String?
    public var postCode: String?
    /// ISO 3166 ALPHA2 country code.
    ///
    /// Example: "SE"
    public var country: String

    public init(streetName: String? = nil, buildingNumber: String? = nil, townName: String? = nil, postCode: String? = nil, country: String) {
        self.streetName = streetName
        self.buildingNumber = buildingNumber
        self.townName = townName
        self.postCode = postCode
        self.country = country
    }
}

/// Optional if supported by API provider.
/// 
/// Is asking for additional information as added within this structured object.
/// The usage of this data element requires at least one of the entries "accounts",
/// "transactions" or "balances" also to be contained in the object.
/// If detailed accounts are referenced, it is required in addition that any account addressed within
/// the additionalInformation attribute is also addressed by at least one of the attributes "accounts",
/// "transactions" or "balances".
public struct AdditionalInformationAccess: Codable {
    /// Is asking for account owner name of the accounts referenced within.
    /// If the array is empty in the request, the TPP is asking for the account
    /// owner name of all accessible accounts.
    /// This may be restricted in a PSU/ASPSP authorization dialogue.
    /// If the array is empty, also the arrays for accounts, balances or transactions shall be empty, if used.
    /// The ASPSP will indicate in the consent resource after a successful authorisation,
    /// whether the ownerName consent can be accepted by providing the accounts on which the ownerName will
    /// be delivered.
    /// This array can be empty.
    public var ownerName: [AccountReference16CH]?
    /// Optional if supported by API provider.
    /// Is asking for the trusted beneficiaries related to the accounts referenced within and related to the PSU.
    /// If the array is empty in the request, the TPP is asking for the lists of trusted beneficiaries of all accessible accounts.
    /// This may be restricted in a PSU/ASPSP authorization dialogue by the PSU if also the account lists addressed
    /// by the tags accounts, balances or transactions are empty.
    /// The ASPSP will indicate in the consent resource after a successful authorisation,
    /// whether the trustedBeneficiaries consent can be accepted by providing the accounts on which the list of trusted beneficiaries will be delivered.
    /// This array can be empty.
    public var trustedBeneficiaries: [AccountReference16CH]?

    public init(ownerName: [AccountReference16CH]? = nil, trustedBeneficiaries: [AccountReference16CH]? = nil) {
        self.ownerName = ownerName
        self.trustedBeneficiaries = trustedBeneficiaries
    }
}

/// Example:
///
/// {
///   "amount" : "123",
///   "currency" : "EUR"
/// }
public struct Amount: Codable {
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var currency: String
    /// The amount given with fractional digits, where fractions must be compliant to the currency definition.
    /// Up to 14 significant figures. Negative amounts are signed by minus.
    /// The decimal separator is a dot.
    /// 
    /// **Example:**
    /// Valid representations for EUR with up to two decimals are:
    /// 
    ///   * 1056
    ///   * 5768.2
    ///   * -1.50
    ///   * 5877.78
    ///
    /// Example: "5877.78"
    public var amount: String

    public init(currency: String, amount: String) {
        self.currency = currency
        self.amount = amount
    }
}

/// Charge Bearer. ChargeBearerType1Code from ISO20022.
public enum ChargeBearer: String, Codable, CaseIterable {
    case debt = "DEBT"
    case cred = "CRED"
    case shar = "SHAR"
    case slev = "SLEV"
}

/// Structured remittance information.
public struct RemittanceInformationStructured: Codable {
    /// Example: "15 00011 23456 78901 23456 78901"
    public var reference: String
    public var referenceType: String?
    public var referenceIssuer: String?
    /// Example: "SCOR"
    public var sCORorQRRorIPI: SCORorQRRorIPI?
    public var additionalRemittanceInformation: String?

    /// Example: "SCOR"
    public enum SCORorQRRorIPI: String, Codable, CaseIterable {
        case scor = "SCOR"
        case qrr = "QRR"
        case ipi = "IPI"
    }

    public init(reference: String, referenceType: String? = nil, referenceIssuer: String? = nil, sCORorQRRorIPI: SCORorQRRorIPI? = nil, additionalRemittanceInformation: String? = nil) {
        self.reference = reference
        self.referenceType = referenceType
        self.referenceIssuer = referenceIssuer
        self.sCORorQRRorIPI = sCORorQRRorIPI
        self.additionalRemittanceInformation = additionalRemittanceInformation
    }

    private enum CodingKeys: String, CodingKey {
        case reference
        case referenceType
        case referenceIssuer
        case sCORorQRRorIPI = "SCORorQRRorIPI"
        case additionalRemittanceInformation
    }
}

/// Specifies the external service level code in the format of character string with a maximum length of 4 characters.
public enum ExternalServiceLevel1Code: String, Codable, CaseIterable {
    case sepa = "SEPA"
    case prpt = "PRPT"
    case sdva = "SDVA"
    case urgp = "URGP"
}

public struct EntryDetailsElement: Codable {
    /// Unique end to end identity.
    public var endToEndID: String?
    /// Identification of Mandates, e.g. a SEPA Mandate ID.
    public var mandateID: String?
    /// Identification of a Cheque.
    public var checkID: String?
    /// Identification of Creditors, e.g. a SEPA Creditor ID.
    ///
    /// Example: "Creditor Id 5678"
    public var creditorID: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionAmount: Amount
    /// Array of exchange rates.
    public var currencyExchange: [ReportExchangeRate]?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var creditorAgent: String?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// Debtor name.
    ///
    /// Example: "Debtor Name"
    public var debtorName: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var debtorAgent: String?
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Array of unstructured remittance information.
    ///
    /// Example: ["Ref Number Merchant", "Some Other Text"]
    public var remittanceInformationUnstructuredArray: [String]?
    /// Structured remittance information.
    public var remittanceInformationStructured: RemittanceInformationStructured?
    /// Array of structured remittance information.
    public var remittanceInformationStructuredArray: [RemittanceInformationStructured]?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?

    public init(endToEndID: String? = nil, mandateID: String? = nil, checkID: String? = nil, creditorID: String? = nil, transactionAmount: Amount, currencyExchange: [ReportExchangeRate]? = nil, creditorName: String? = nil, creditorAccount: AccountReference16CH? = nil, creditorAgent: String? = nil, ultimateCreditor: String? = nil, debtorName: String? = nil, debtorAccount: AccountReference16CH? = nil, debtorAgent: String? = nil, ultimateDebtor: String? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationUnstructuredArray: [String]? = nil, remittanceInformationStructured: RemittanceInformationStructured? = nil, remittanceInformationStructuredArray: [RemittanceInformationStructured]? = nil, purposeCode: PurposeCode? = nil) {
        self.endToEndID = endToEndID
        self.mandateID = mandateID
        self.checkID = checkID
        self.creditorID = creditorID
        self.transactionAmount = transactionAmount
        self.currencyExchange = currencyExchange
        self.creditorName = creditorName
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.ultimateCreditor = ultimateCreditor
        self.debtorName = debtorName
        self.debtorAccount = debtorAccount
        self.debtorAgent = debtorAgent
        self.ultimateDebtor = ultimateDebtor
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationUnstructuredArray = remittanceInformationUnstructuredArray
        self.remittanceInformationStructured = remittanceInformationStructured
        self.remittanceInformationStructuredArray = remittanceInformationStructuredArray
        self.purposeCode = purposeCode
    }

    private enum CodingKeys: String, CodingKey {
        case endToEndID = "endToEndId"
        case mandateID = "mandateId"
        case checkID = "checkId"
        case creditorID = "creditorId"
        case transactionAmount
        case currencyExchange
        case creditorName
        case creditorAccount
        case creditorAgent
        case ultimateCreditor
        case debtorName
        case debtorAccount
        case debtorAgent
        case ultimateDebtor
        case remittanceInformationUnstructured
        case remittanceInformationUnstructuredArray
        case remittanceInformationStructured
        case remittanceInformationStructuredArray
        case purposeCode
    }
}

/// Is used if and only if the bookingStatus entry equals "information".
/// Every active standing order related to the dedicated payment account result into one entry.
public struct AdditionalInformationStructured: Codable {
    /// Details of underlying standing orders.
    public var standingOrderDetails: StandingOrderDetails

    public init(standingOrderDetails: StandingOrderDetails) {
        self.standingOrderDetails = standingOrderDetails
    }
}

/// Details of underlying standing orders.
public struct StandingOrderDetails: Codable {
    /// The first applicable day of execution starting from this date is the first payment.
    public var startDate: NaiveDate
    /// The following codes from the "EventFrequency7Code" of ISO 20022 are supported:
    /// - "Daily"
    /// - "Weekly"
    /// - "EveryTwoWeeks"
    /// - "Monthly"
    /// - "EveryTwoMonths"
    /// - "Quarterly"
    /// - "SemiAnnual"
    /// - "Annual"
    /// - "MonthlyVariable"
    public var frequency: FrequencyCode
    /// The last applicable day of execution.
    /// If not given, it is an infinite standing order.
    public var endDate: NaiveDate?
    /// "following" or "preceding" supported as values.
    /// This data attribute defines the behaviour when recurring payment dates falls on a weekend or bank holiday.
    /// The payment is then executed either the "preceding" or "following" working day.
    /// ASPSP might reject the request due to the communicated value, if rules in Online-Banking are not supporting
    /// this execution rule.
    public var executionRule: ExecutionRule?
    /// This element is only used in case of frequency equals "Monthly".
    /// 
    /// If this element equals false it has no effect.
    /// If this element equals true, then the execution rule is overruled if the day of execution would fall into a different month using the execution rule.
    /// 
    /// Example: executionRule equals "preceding", dayOfExecution equals "02" and the second of a month is a Sunday.
    /// In this case, the transaction date would be on the last day of the month before.
    ///  This would be overruled if withinAMonthFlag equals true and the payment is processed on Monday the third of the Month.
    /// Remark: This attribute is rarely supported in the market.
    public var isWithinAMonthFlag: Bool?
    /// The format is following the regular expression \d{1,2}.
    /// The array is restricted to 11 entries.
    /// The values contained in the array entries shall all be different and the maximum value of one entry is 12.
    /// This attribute is contained if and only if the frequency equals "MonthlyVariable".
    /// Example: An execution on January, April and October each year is addressed by ["1", "4", "10"].
    public var monthsOfExecution: MonthsOfExecution?
    /// This is multiplying the given frequency resulting the exact frequency,
    /// e.g. Frequency=weekly and multiplicator=3 means every 3 weeks.
    /// Remark: This attribute is rarely supported in the market.
    public var multiplicator: Int?
    /// Day of execution as string.
    /// 
    /// This string consists of up two characters.
    /// Leading zeroes are not allowed.
    /// 
    /// 31 is ultimo of the month.
    public var dayOfExecution: DayOfExecution?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var limitAmount: Amount?

    public init(startDate: NaiveDate, frequency: FrequencyCode, endDate: NaiveDate? = nil, executionRule: ExecutionRule? = nil, isWithinAMonthFlag: Bool? = nil, monthsOfExecution: MonthsOfExecution? = nil, multiplicator: Int? = nil, dayOfExecution: DayOfExecution? = nil, limitAmount: Amount? = nil) {
        self.startDate = startDate
        self.frequency = frequency
        self.endDate = endDate
        self.executionRule = executionRule
        self.isWithinAMonthFlag = isWithinAMonthFlag
        self.monthsOfExecution = monthsOfExecution
        self.multiplicator = multiplicator
        self.dayOfExecution = dayOfExecution
        self.limitAmount = limitAmount
    }

    private enum CodingKeys: String, CodingKey {
        case startDate
        case frequency
        case endDate
        case executionRule
        case isWithinAMonthFlag = "withinAMonthFlag"
        case monthsOfExecution
        case multiplicator
        case dayOfExecution
        case limitAmount
    }
}

/// ExternalPurpose1Code from ISO 20022.
/// 
/// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
public enum PurposeCode: String, Codable, CaseIterable {
    case sala = "SALA"
    case pens = "PENS"
}

/// The following codes from the "EventFrequency7Code" of ISO 20022 are supported:
/// - "Daily"
/// - "Weekly"
/// - "EveryTwoWeeks"
/// - "Monthly"
/// - "EveryTwoMonths"
/// - "Quarterly"
/// - "SemiAnnual"
/// - "Annual"
/// - "MonthlyVariable"
public enum FrequencyCode: String, Codable, CaseIterable {
    case daily = "Daily"
    case weekly = "Weekly"
    case everyTwoWeeks = "EveryTwoWeeks"
    case monthly = "Monthly"
    case everyTwoMonths = "EveryTwoMonths"
    case quarterly = "Quarterly"
    case semiAnnual = "SemiAnnual"
    case annual = "Annual"
    case monthlyVariable = "MonthlyVariable"
}

/// Day of execution as string.
/// 
/// This string consists of up two characters.
/// Leading zeroes are not allowed.
/// 
/// 31 is ultimo of the month.
public enum DayOfExecution: String, Codable, CaseIterable {
    case _1 = "1"
    case _2 = "2"
    case _3 = "3"
    case _4 = "4"
    case _5 = "5"
    case _6 = "6"
    case _7 = "7"
    case _8 = "8"
    case _9 = "9"
    case _10 = "10"
    case _11 = "11"
    case _12 = "12"
    case _13 = "13"
    case _14 = "14"
    case _15 = "15"
    case _16 = "16"
    case _17 = "17"
    case _18 = "18"
    case _19 = "19"
    case _20 = "20"
    case _21 = "21"
    case _22 = "22"
    case _23 = "23"
    case _24 = "24"
    case _25 = "25"
    case _26 = "26"
    case _27 = "27"
    case _28 = "28"
    case _29 = "29"
    case _30 = "30"
    case _31 = "31"
}

public typealias MonthsOfExecution = [MonthsOfExecutionItem]

public enum MonthsOfExecutionItem: String, Codable, CaseIterable {
    case _1 = "1"
    case _2 = "2"
    case _3 = "3"
    case _4 = "4"
    case _5 = "5"
    case _6 = "6"
    case _7 = "7"
    case _8 = "8"
    case _9 = "9"
    case _10 = "10"
    case _11 = "11"
    case _12 = "12"
}

/// "following" or "preceding" supported as values.
/// This data attribute defines the behaviour when recurring payment dates falls on a weekend or bank holiday.
/// The payment is then executed either the "preceding" or "following" working day.
/// ASPSP might reject the request due to the communicated value, if rules in Online-Banking are not supporting
/// this execution rule.
public enum ExecutionRule: String, Codable, CaseIterable {
    case following
    case preceding
}

/// PSU Data for Update PSU authentication.
public struct PsuData: Codable {
    /// Password.
    public var password: String?
    /// Encrypted password.
    public var encryptedPassword: String?
    /// Additional password in plaintext.
    public var additionalPassword: String?
    /// Additional encrypted password.
    public var additionalEncryptedPassword: String?

    public init(password: String? = nil, encryptedPassword: String? = nil, additionalPassword: String? = nil, additionalEncryptedPassword: String? = nil) {
        self.password = password
        self.encryptedPassword = encryptedPassword
        self.additionalPassword = additionalPassword
        self.additionalEncryptedPassword = additionalEncryptedPassword
    }
}

/// Generic Body for a payment initation via JSON.
/// 
/// This generic JSON body can be used to represent valid payment initiations for the following JSON based payment product,
/// which where defined in the Implementation Guidelines:
/// 
///   * domestic-swiss-credit-transfers-isr
///   * domestic-swiss-credit-transfers
///   * domestic-swiss-credit-transfers-qr
///   * domestic-swiss-foreign-credit-transfers
///   * swiss-sepa-credit-transfers
///   * swiss-cross-border-credit-transfers
/// 
/// For the convenience of the implementer additional which are already predefinded in the Implementation Guidelines
/// are included (but commented in source code), such that an ASPSP may add them easily.
/// 
/// Take care: Since the format is intended to fit for all payment products
/// there are additional conditions which are NOT covered by this specification.
/// Please check the SIX Swiss Payment Standards implementation guidelines for details.
/// 
/// 
/// The following data element are depending on the actual payment product available (in source code):
/// 
/// <table style="width:100%">
/// <tr><td></td><td>Payment Type 1: ISR</td><td>Payment Type 3: IBAN/postal account and IID/BIC</td><td>Payment Type 3: QR-bill</td><td>Payment Type 4: Foreign currency</td><td>Payment Type 5: Foreign SEPA</td><td>Payment Type 6: Foreign</td></tr>
/// <tr><td>CH Domestic Data Element</td><td>domestic-swiss-credit-transfers-isr</td><td>domestic-swiss-credit-transfers</td><td>domestic-swiss-credit-transfers-qr</td><td>domestic-swiss-foreign-credit-transfers</td><td>swiss-sepa-credit-transfers</td><td>swiss-cross-border-credit-transfers</td></tr>
/// <tr><td>endToEndIdentification</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>instructionIdentification</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>debtorAccount (incl. type)</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>debtorAgent</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>debtorName</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>debtorId</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td></tr>
/// <tr><td>ultimateDebtor</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>instructedAmount (incl. currency)</td><td>mandatory</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>equivalentAmount</td><td>n.a.</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>transactionCurrency</td><td>n.a.</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>exchangeRateInformation</td><td>n.a.</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td></tr>
/// <tr><td>creditorAccount</td><td>mandatory</td><td>mandatory</td><td>mandatory 8)</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>creditorAgent</td><td>n.a.</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td></tr>
/// <tr><td>creditorAgentName</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>dependent 5)</td><td>n.a.</td><td>dependent 5)</td></tr>
/// <tr><td>creditorName</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>creditorId</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>creditorAddress</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>creditorNameAndAddress</td><td>n.a.</td><td>dependent</td><td>dependent</td><td>dependent</td><td>dependent</td><td>dependent</td></tr>
/// <tr><td>ultimateCreditor</td><td>n.a.</td><td>optional</td><td>n.a. (for future use)</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>chargeBearer</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>purposeCode</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>serviceLevel</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>remittanceInformationUnstructured</td><td>n.a.</td><td>optional</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>remittanceInformationUnstructuredArray</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>remittanceInformationStructured</td><td>mandatory</td><td>optional</td><td>mandatory 6)</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>remittanceInformationStructuredArray</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>requestedExecutionDate</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>requestedExecutionTime</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>intermediaryAgent</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>optional 2)</td><td>n.a.</td><td>optional 2)</td></tr>
/// </table>
/// 
/// Footnotes from the table:
/// 1) This element may only be used by agreement with the instructed financial institution.
/// 2) The element may only be used in consultation with the financial institution commissioned.
/// 3) The element is currently ignored by financial institutions.
/// 4) Dependence on creditorAccount, see SIX Swiss Payments Standards implementation guidelines.
/// 5) Type 4(V3), 6(V2, V3): Must be present. Type 4(V2): May be present. Other species: May not be present.
/// 6) QR-reference, creditor reference or IPI reference
/// 7) transactionCurrency is a subfield of equivalentAmount and may only be used if equivalentAmount is used instead of instructedAmount.
/// 8) QR-IBAN (CH/LI) must be present.
/// 
/// IMPORTANT: In this API definition the following holds:
///   *  All data elements mentioned above are defined, but some of them are commented,
///     i.e. they are only visible in the source code and can be used by uncommenting them.
///   * Data elements which are mandatory in the table above for all payment products
///     are set to be mandatory in this specification.
///   * Data elements which are indicated in the table above as n.a. for all payment products are commented in the source code.
///   * Data elements which are indicated to be option, conditional or mandatory for at least one payment product
///     in the table above are set to be optional in the s specification except the case where all are definde to be mandatory.
///   * Data element which are inticated to be n.a. can be used by the ASPS if needed.
///     In this case uncomment tthe the relatetd lines in the source code.
///   * If one uses this data types for some payment products he has to ensure that the used data type is
///     valid according to the underlying payment product, e.g. by some appropriate validations.
public struct PaymentInitiationJSON: Codable {
    public var endToEndIdentification: String
    /// Debtor name.
    ///
    /// Example: "Debtor Name"
    public var debtorName: String
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH
    /// Debtor Id.
    ///
    /// Example: "Debtor Id 1234"
    public var debtorID: String?
    /// Reference to an debtorAgent by either
    ///   * BIC, of the debtor bank, or
    ///   * IID, of the debtor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH_BicOrClrId
    public var debtorAgent: DebtorAgent7CH?
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var instructedAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var equivalentAmount: Amount?
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var transactionCurrency: String?
    /// As in ISO pain.001.001.03.ch.02 ExchangeRateInformation1
    public var exchangeRateInformation: ExchangeRateInformation1?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH
    /// Reference to an creditorAgent by either
    ///   * BIC, of the creditor bank, or
    ///   * IID, of the creditor bank, or
    ///   * IID and optional name and address of the creditor bank or
    ///   * Name and address of the creditor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH
    public var creditorAgent: CreditorAgent7CH?
    /// Creditor agent name.
    ///
    /// Example: "Creditor Id 1234"
    public var creditorAgentName: String?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String
    /// Identification of Creditors, e.g. a SEPA Creditor ID.
    ///
    /// Example: "Creditor Id 5678"
    public var creditorID: String?
    /// Example:
    ///
    /// {
    ///   "buildingnNumber" : "89",
    ///   "country" : "FR",
    ///   "postCode" : "75000",
    ///   "streetName" : "rue blue",
    ///   "townName" : "Paris"
    /// }
    public var creditorAddress: Address?
    /// Creditor Name and Address in a free text field.
    ///
    /// Example: "Max Masters, Main Street 1, 12345 City, Example Country"
    public var creditorNameAndAddress: String?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?
    /// Specifies the external service level code in the format of character string with a maximum length of 4 characters.
    public var serviceLevel: ExternalServiceLevel1Code?
    /// Charge Bearer. ChargeBearerType1Code from ISO20022.
    public var chargeBearer: ChargeBearer?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Structured remittance information.
    public var remittanceInformationStructured: RemittanceInformationStructured?
    public var requestedExecutionDate: NaiveDate
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var intermediaryAgent: String?

    public init(endToEndIdentification: String, debtorName: String, debtorAccount: AccountReference16CH, debtorID: String? = nil, debtorAgent: DebtorAgent7CH? = nil, ultimateDebtor: String? = nil, instructedAmount: Amount? = nil, equivalentAmount: Amount? = nil, transactionCurrency: String? = nil, exchangeRateInformation: ExchangeRateInformation1? = nil, creditorAccount: AccountReference16CH, creditorAgent: CreditorAgent7CH? = nil, creditorAgentName: String? = nil, creditorName: String, creditorID: String? = nil, creditorAddress: Address? = nil, creditorNameAndAddress: String? = nil, ultimateCreditor: String? = nil, purposeCode: PurposeCode? = nil, serviceLevel: ExternalServiceLevel1Code? = nil, chargeBearer: ChargeBearer? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationStructured: RemittanceInformationStructured? = nil, requestedExecutionDate: NaiveDate, intermediaryAgent: String? = nil) {
        self.endToEndIdentification = endToEndIdentification
        self.debtorName = debtorName
        self.debtorAccount = debtorAccount
        self.debtorID = debtorID
        self.debtorAgent = debtorAgent
        self.ultimateDebtor = ultimateDebtor
        self.instructedAmount = instructedAmount
        self.equivalentAmount = equivalentAmount
        self.transactionCurrency = transactionCurrency
        self.exchangeRateInformation = exchangeRateInformation
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.creditorAgentName = creditorAgentName
        self.creditorName = creditorName
        self.creditorID = creditorID
        self.creditorAddress = creditorAddress
        self.creditorNameAndAddress = creditorNameAndAddress
        self.ultimateCreditor = ultimateCreditor
        self.purposeCode = purposeCode
        self.serviceLevel = serviceLevel
        self.chargeBearer = chargeBearer
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationStructured = remittanceInformationStructured
        self.requestedExecutionDate = requestedExecutionDate
        self.intermediaryAgent = intermediaryAgent
    }

    private enum CodingKeys: String, CodingKey {
        case endToEndIdentification
        case debtorName
        case debtorAccount
        case debtorID = "debtorId"
        case debtorAgent
        case ultimateDebtor
        case instructedAmount
        case equivalentAmount
        case transactionCurrency
        case exchangeRateInformation
        case creditorAccount
        case creditorAgent
        case creditorAgentName
        case creditorName
        case creditorID = "creditorId"
        case creditorAddress
        case creditorNameAndAddress
        case ultimateCreditor
        case purposeCode
        case serviceLevel
        case chargeBearer
        case remittanceInformationUnstructured
        case remittanceInformationStructured
        case requestedExecutionDate
        case intermediaryAgent
    }
}

/// Generic body for a bulk payment initation entry.
/// 
/// The bulk entry type is a type which follows the JSON formats for the supported products for single payments
/// excluding the data elements (if supported):
///   * debtorAccount
///   * requestedExecutionDate,
///   * requestedExecutionTime.
/// These data elements may not be contained in any bulk entry.
/// 
/// This data object can be used to represent valid bulk payment initiations entry for the following JSON based payment product,
/// which where defined in the Implementation Guidelines:
/// 
///   * domestic-swiss-credit-transfers-isr
///   * domestic-swiss-credit-transfers
///   * domestic-swiss-credit-transfers-qr
///   * domestic-swiss-foreign-credit-transfers
///   * swiss-sepa-credit-transfers
///   * swiss-cross-border-credit-transfers
/// 
/// For the convenience of the implementer additional which are already predefinded in the Implementation Guidelines
/// are included (but commented in source code), such that an ASPSP may add them easily.
/// 
/// Take care: Since the format is intended to fit for all payment products
/// there are additional conditions which are NOT covered by this specification.
/// Please check the SIX Swiss Payment Standards implementation guidelines for details.
/// 
/// 
/// The following data element are depending on the actual payment product available (in source code):
/// 
/// <table style="width:100%">
/// <tr><td></td><td>Payment Type 1: ISR</td><td>Payment Type 3: IBAN/postal account and IID/BIC</td><td>Payment Type 3: QR-bill</td><td>Payment Type 4: Foreign currency</td><td>Payment Type 5: Foreign SEPA</td><td>Payment Type 6: Foreign</td></tr>
/// <tr><td>CH Domestic Data Element</td><td>domestic-swiss-credit-transfers-isr</td><td>domestic-swiss-credit-transfers</td><td>domestic-swiss-credit-transfers-qr</td><td>domestic-swiss-foreign-credit-transfers</td><td>swiss-sepa-credit-transfers</td><td>swiss-cross-border-credit-transfers</td></tr>
/// <tr><td>endToEndIdentification</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>instructionIdentification</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>debtorName</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>debtorId</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td></tr>
/// <tr><td>ultimateDebtor</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>instructedAmount (incl. currency)</td><td>mandatory</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>equivalentAmount</td><td>n.a.</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>transactionCurrency</td><td>n.a.</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>exchangeRateInformation</td><td>n.a.</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td></tr>
/// <tr><td>creditorAccount</td><td>mandatory</td><td>mandatory</td><td>mandatory 8)</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>creditorAgent</td><td>n.a.</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td></tr>
/// <tr><td>creditorAgentName</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>dependent 5)</td><td>n.a.</td><td>dependent 5)</td></tr>
/// <tr><td>creditorName</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>creditorId</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>creditorAddress</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>creditorNameAndAddress</td><td>n.a.</td><td>dependent</td><td>dependent</td><td>dependent</td><td>dependent</td><td>dependent</td></tr>
/// <tr><td>ultimateCreditor</td><td>n.a.</td><td>optional</td><td>n.a. (for future use)</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>chargeBearer</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>purposeCode</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>serviceLevel</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>remittanceInformationUnstructured</td><td>n.a.</td><td>optional</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>remittanceInformationUnstructuredArray</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>remittanceInformationStructured</td><td>mandatory</td><td>optional</td><td>mandatory 6)</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>remittanceInformationStructuredArray</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>intermediaryAgent</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>optional 2)</td><td>n.a.</td><td>optional 2)</td></tr>
/// </table>
/// 
/// Footnotes from the table:
/// 1) This element may only be used by agreement with the instructed financial institution.
/// 2) The element may only be used in consultation with the financial institution commissioned.
/// 3) The element is currently ignored by financial institutions.
/// 4) Dependence on creditorAccount, see SIX Swiss Payments Standards implementation guidelines.
/// 5) Type 4(V3), 6(V2, V3): Must be present. Type 4(V2): May be present. Other species: May not be present.
/// 6) QR-reference, creditor reference or IPI reference
/// 7) currencyOfTransfer is a subfield of equivalentAmount and may only be used if equivalentAmount is used instead of instructedAmount.
/// 8) QR-IBAN (CH/LI) must be present.
/// 
/// IMPORTANT: In this API definition the following holds:
///   *  All data elements mentioned above are defined, but some of them are commented,
///     i.e. they are only visible in the source code and can be used by uncommenting them.
///   * Data elements which are mandatory in the table above for all payment products
///     are set to be mandatory in this specification.
///   * Data elements which are indicated in the table above as n.a. for all payment products are commented in the source code.
///   * Data elements which are indicated to be option, conditional or mandatory for at least one payment product
///     in the table above are set to be optional in the s specification except the case where all are definde to be mandatory.
///   * Data element which are inticated to be n.a. can be used by the ASPS if needed.
///     In this case uncomment tthe the relatetd lines in the source code.
///   * If one uses this data types for some payment products he has to ensure that the used data type is
///     valid according to the underlying payment product, e.g. by some appropriate validations.
public struct PaymentInitiationBulkElementJSON: Codable {
    public var endToEndIdentification: String
    /// Debtor name.
    ///
    /// Example: "Debtor Name"
    public var debtorName: String
    /// Debtor Id.
    ///
    /// Example: "Debtor Id 1234"
    public var debtorID: String?
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var instructedAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var equivalentAmount: Amount?
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var transactionCurrency: String?
    /// As in ISO pain.001.001.03.ch.02 ExchangeRateInformation1
    public var exchangeRateInformation: ExchangeRateInformation1?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH
    /// Reference to an creditorAgent by either
    ///   * BIC, of the creditor bank, or
    ///   * IID, of the creditor bank, or
    ///   * IID and optional name and address of the creditor bank or
    ///   * Name and address of the creditor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH
    public var creditorAgent: CreditorAgent7CH?
    /// Creditor agent name.
    ///
    /// Example: "Creditor Id 1234"
    public var creditorAgentName: String?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String
    /// Identification of Creditors, e.g. a SEPA Creditor ID.
    ///
    /// Example: "Creditor Id 5678"
    public var creditorID: String?
    /// Example:
    ///
    /// {
    ///   "buildingnNumber" : "89",
    ///   "country" : "FR",
    ///   "postCode" : "75000",
    ///   "streetName" : "rue blue",
    ///   "townName" : "Paris"
    /// }
    public var creditorAddress: Address?
    /// Creditor Name and Address in a free text field.
    ///
    /// Example: "Max Masters, Main Street 1, 12345 City, Example Country"
    public var creditorNameAndAddress: String?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?
    /// Specifies the external service level code in the format of character string with a maximum length of 4 characters.
    public var serviceLevel: ExternalServiceLevel1Code?
    /// Charge Bearer. ChargeBearerType1Code from ISO20022.
    public var chargeBearer: ChargeBearer?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Structured remittance information.
    public var remittanceInformationStructured: RemittanceInformationStructured?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var intermediaryAgent: String?

    public init(endToEndIdentification: String, debtorName: String, debtorID: String? = nil, ultimateDebtor: String? = nil, instructedAmount: Amount? = nil, equivalentAmount: Amount? = nil, transactionCurrency: String? = nil, exchangeRateInformation: ExchangeRateInformation1? = nil, creditorAccount: AccountReference16CH, creditorAgent: CreditorAgent7CH? = nil, creditorAgentName: String? = nil, creditorName: String, creditorID: String? = nil, creditorAddress: Address? = nil, creditorNameAndAddress: String? = nil, ultimateCreditor: String? = nil, purposeCode: PurposeCode? = nil, serviceLevel: ExternalServiceLevel1Code? = nil, chargeBearer: ChargeBearer? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationStructured: RemittanceInformationStructured? = nil, intermediaryAgent: String? = nil) {
        self.endToEndIdentification = endToEndIdentification
        self.debtorName = debtorName
        self.debtorID = debtorID
        self.ultimateDebtor = ultimateDebtor
        self.instructedAmount = instructedAmount
        self.equivalentAmount = equivalentAmount
        self.transactionCurrency = transactionCurrency
        self.exchangeRateInformation = exchangeRateInformation
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.creditorAgentName = creditorAgentName
        self.creditorName = creditorName
        self.creditorID = creditorID
        self.creditorAddress = creditorAddress
        self.creditorNameAndAddress = creditorNameAndAddress
        self.ultimateCreditor = ultimateCreditor
        self.purposeCode = purposeCode
        self.serviceLevel = serviceLevel
        self.chargeBearer = chargeBearer
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationStructured = remittanceInformationStructured
        self.intermediaryAgent = intermediaryAgent
    }

    private enum CodingKeys: String, CodingKey {
        case endToEndIdentification
        case debtorName
        case debtorID = "debtorId"
        case ultimateDebtor
        case instructedAmount
        case equivalentAmount
        case transactionCurrency
        case exchangeRateInformation
        case creditorAccount
        case creditorAgent
        case creditorAgentName
        case creditorName
        case creditorID = "creditorId"
        case creditorAddress
        case creditorNameAndAddress
        case ultimateCreditor
        case purposeCode
        case serviceLevel
        case chargeBearer
        case remittanceInformationUnstructured
        case remittanceInformationStructured
        case intermediaryAgent
    }
}

/// Generic Body for a periodic payment initation via JSON.
/// 
/// This generic JSON body can be used to represent valid periodic payment initiations for the following JSON based payment product,
/// which where defined in the Implementation Guidelines:
/// 
///   * domestic-swiss-credit-transfers-isr
///   * domestic-swiss-credit-transfers
///   * domestic-swiss-credit-transfers-qr
///   * domestic-swiss-foreign-credit-transfers
///   * swiss-sepa-credit-transfers
///   * swiss-cross-border-credit-transfers
/// 
/// For the convenience of the implementer additional which are already predefinded in the Implementation Guidelines
/// are included (but commented in source code), such that an ASPSP may add them easily.
/// 
/// Take care: Since the format is intended to fit for all payment products
/// there are additional conditions which are NOT covered by this specification.
/// Please check the SIX Swiss Payment Standards implementation guidelines for details.
/// 
/// 
/// The following data element are depending on the actual payment product available (in source code):
/// 
/// <table style="width:100%">
/// <tr><td></td><td>Payment Type 1: ISR</td><td>Payment Type 3: IBAN/postal account and IID/BIC</td><td>Payment Type 3: QR-bill</td><td>Payment Type 4: Foreign currency</td><td>Payment Type 5: Foreign SEPA</td><td>Payment Type 6: Foreign</td></tr>
/// <tr><td>CH Domestic Data Element</td><td>domestic-swiss-credit-transfers-isr</td><td>domestic-swiss-credit-transfers</td><td>domestic-swiss-credit-transfers-qr</td><td>domestic-swiss-foreign-credit-transfers</td><td>swiss-sepa-credit-transfers</td><td>swiss-cross-border-credit-transfers</td></tr>
/// <tr><td>endToEndIdentification</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>instructionIdentification</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>debtorAccount (incl. type)</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>debtorAgent</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>debtorName</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>debtorId</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td><td>optional 3)</td></tr>
/// <tr><td>ultimateDebtor</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>instructedAmount (incl. currency)</td><td>mandatory</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>equivalentAmount</td><td>n.a.</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>transactionCurrency</td><td>n.a.</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td><td>dependent 1)</td></tr>
/// <tr><td>exchangeRateInformation</td><td>n.a.</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td><td>optional 2)</td></tr>
/// <tr><td>creditorAccount</td><td>mandatory</td><td>mandatory</td><td>mandatory 8)</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>creditorAgent</td><td>n.a.</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td><td>dependent 4)</td></tr>
/// <tr><td>creditorAgentName</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>dependent 5)</td><td>n.a.</td><td>dependent 5)</td></tr>
/// <tr><td>creditorName</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>creditorId</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>creditorAddress</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>creditorNameAndAddress</td><td>n.a.</td><td>dependent</td><td>dependent</td><td>dependent</td><td>dependent</td><td>dependent</td></tr>
/// <tr><td>ultimateCreditor</td><td>n.a.</td><td>optional</td><td>n.a. (for future use)</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>chargeBearer</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>purposeCode</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>serviceLevel</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td><td>mandatory</td><td>optional</td></tr>
/// <tr><td>remittanceInformationUnstructured</td><td>n.a.</td><td>optional</td><td>n.a.</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>remittanceInformationUnstructuredArray</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>remittanceInformationStructured</td><td>mandatory</td><td>optional</td><td>mandatory 6)</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>remittanceInformationStructuredArray</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>requestedExecutionDate</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>requestedExecutionTime</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>n.a.</td></tr>
/// <tr><td>intermediaryAgent</td><td>n.a.</td><td>n.a.</td><td>n.a.</td><td>optional 2)</td><td>n.a.</td><td>optional 2)</td></tr>
/// <tr><td>startDate</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>endDate</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>executionRule</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td><td>optional</td></tr>
/// <tr><td>frequency</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td><td>mandatory</td></tr>
/// <tr><td>dayOfExecution</td><td>conditional</td><td>conditional</td><td>conditional</td><td>conditional</td><td>conditional</td><td>conditional</td></tr>
/// </table>
/// 
/// Footnotes from the table:
/// 1) This element may only be used by agreement with the instructed financial institution.
/// 2) The element may only be used in consultation with the financial institution commissioned.
/// 3) The element is currently ignored by financial institutions.
/// 4) Dependence on creditorAccount, see SIX Swiss Payments Standards implementation guidelines.
/// 5) Type 4(V3), 6(V2, V3): Must be present. Type 4(V2): May be present. Other species: May not be present.
/// 6) QR-reference, creditor reference or IPI reference
/// 7) currencyOfTransfer is a subfield of equivalentAmount and may only be used if equivalentAmount is used instead of instructedAmount.
/// 8) QR-IBAN (CH/LI) must be present.
/// 
/// IMPORTANT: In this API definition the following holds:
///   *  All data elements mentioned above are defined, but some of them are commented,
///     i.e. they are only visible in the source code and can be used by uncommenting them.
///   * Data elements which are mandatory in the table above for all payment products
///     are set to be mandatory in this specification.
///   * Data elements which are indicated in the table above as n.a. for all payment products are commented in the source code.
///   * Data elements which are indicated to be option, conditional or mandatory for at least one payment product
///     in the table above are set to be optional in the s specification except the case where all are definde to be mandatory.
///   * Data element which are inticated to be n.a. can be used by the ASPS if needed.
///     In this case uncomment tthe the relatetd lines in the source code.
///   * If one uses this data types for some payment products he has to ensure that the used data type is
///     valid according to the underlying payment product, e.g. by some appropriate validations.
public struct PeriodicPaymentInitiationJSON: Codable {
    public var endToEndIdentification: String
    /// Debtor name.
    ///
    /// Example: "Debtor Name"
    public var debtorName: String
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH
    /// Debtor Id.
    ///
    /// Example: "Debtor Id 1234"
    public var debtorID: String?
    /// Reference to an debtorAgent by either
    ///   * BIC, of the debtor bank, or
    ///   * IID, of the debtor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH_BicOrClrId
    public var debtorAgent: DebtorAgent7CH?
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var instructedAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var equivalentAmount: Amount?
    /// ISO 4217 Alpha 3 currency code.
    ///
    /// Example: "EUR"
    public var transactionCurrency: String?
    /// As in ISO pain.001.001.03.ch.02 ExchangeRateInformation1
    public var exchangeRateInformation: ExchangeRateInformation1?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH
    /// Reference to an creditorAgent by either
    ///   * BIC, of the creditor bank, or
    ///   * IID, of the creditor bank, or
    ///   * IID and optional name and address of the creditor bank or
    ///   * Name and address of the creditor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH
    public var creditorAgent: CreditorAgent7CH?
    /// Creditor agent name.
    ///
    /// Example: "Creditor Id 1234"
    public var creditorAgentName: String?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String
    /// Identification of Creditors, e.g. a SEPA Creditor ID.
    ///
    /// Example: "Creditor Id 5678"
    public var creditorID: String?
    /// Example:
    ///
    /// {
    ///   "buildingnNumber" : "89",
    ///   "country" : "FR",
    ///   "postCode" : "75000",
    ///   "streetName" : "rue blue",
    ///   "townName" : "Paris"
    /// }
    public var creditorAddress: Address?
    /// Creditor Name and Address in a free text field.
    ///
    /// Example: "Max Masters, Main Street 1, 12345 City, Example Country"
    public var creditorNameAndAddress: String?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?
    /// Specifies the external service level code in the format of character string with a maximum length of 4 characters.
    public var serviceLevel: ExternalServiceLevel1Code?
    /// Charge Bearer. ChargeBearerType1Code from ISO20022.
    public var chargeBearer: ChargeBearer?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Structured remittance information.
    public var remittanceInformationStructured: RemittanceInformationStructured?
    /// BICFI
    ///
    /// Example: "AAAADEBBXXX"
    public var intermediaryAgent: String?
    /// The first applicable day of execution starting from this date is the first payment.
    public var startDate: NaiveDate
    /// The last applicable day of execution.
    /// If not given, it is an infinite standing order.
    public var endDate: NaiveDate?
    /// "following" or "preceding" supported as values.
    /// This data attribute defines the behaviour when recurring payment dates falls on a weekend or bank holiday.
    /// The payment is then executed either the "preceding" or "following" working day.
    /// ASPSP might reject the request due to the communicated value, if rules in Online-Banking are not supporting
    /// this execution rule.
    public var executionRule: ExecutionRule?
    /// The following codes from the "EventFrequency7Code" of ISO 20022 are supported:
    /// - "Daily"
    /// - "Weekly"
    /// - "EveryTwoWeeks"
    /// - "Monthly"
    /// - "EveryTwoMonths"
    /// - "Quarterly"
    /// - "SemiAnnual"
    /// - "Annual"
    /// - "MonthlyVariable"
    public var frequency: FrequencyCode
    /// Day of execution as string.
    /// 
    /// This string consists of up two characters.
    /// Leading zeroes are not allowed.
    /// 
    /// 31 is ultimo of the month.
    public var dayOfExecution: DayOfExecution?

    public init(endToEndIdentification: String, debtorName: String, debtorAccount: AccountReference16CH, debtorID: String? = nil, debtorAgent: DebtorAgent7CH? = nil, ultimateDebtor: String? = nil, instructedAmount: Amount? = nil, equivalentAmount: Amount? = nil, transactionCurrency: String? = nil, exchangeRateInformation: ExchangeRateInformation1? = nil, creditorAccount: AccountReference16CH, creditorAgent: CreditorAgent7CH? = nil, creditorAgentName: String? = nil, creditorName: String, creditorID: String? = nil, creditorAddress: Address? = nil, creditorNameAndAddress: String? = nil, ultimateCreditor: String? = nil, purposeCode: PurposeCode? = nil, serviceLevel: ExternalServiceLevel1Code? = nil, chargeBearer: ChargeBearer? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationStructured: RemittanceInformationStructured? = nil, intermediaryAgent: String? = nil, startDate: NaiveDate, endDate: NaiveDate? = nil, executionRule: ExecutionRule? = nil, frequency: FrequencyCode, dayOfExecution: DayOfExecution? = nil) {
        self.endToEndIdentification = endToEndIdentification
        self.debtorName = debtorName
        self.debtorAccount = debtorAccount
        self.debtorID = debtorID
        self.debtorAgent = debtorAgent
        self.ultimateDebtor = ultimateDebtor
        self.instructedAmount = instructedAmount
        self.equivalentAmount = equivalentAmount
        self.transactionCurrency = transactionCurrency
        self.exchangeRateInformation = exchangeRateInformation
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.creditorAgentName = creditorAgentName
        self.creditorName = creditorName
        self.creditorID = creditorID
        self.creditorAddress = creditorAddress
        self.creditorNameAndAddress = creditorNameAndAddress
        self.ultimateCreditor = ultimateCreditor
        self.purposeCode = purposeCode
        self.serviceLevel = serviceLevel
        self.chargeBearer = chargeBearer
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationStructured = remittanceInformationStructured
        self.intermediaryAgent = intermediaryAgent
        self.startDate = startDate
        self.endDate = endDate
        self.executionRule = executionRule
        self.frequency = frequency
        self.dayOfExecution = dayOfExecution
    }

    private enum CodingKeys: String, CodingKey {
        case endToEndIdentification
        case debtorName
        case debtorAccount
        case debtorID = "debtorId"
        case debtorAgent
        case ultimateDebtor
        case instructedAmount
        case equivalentAmount
        case transactionCurrency
        case exchangeRateInformation
        case creditorAccount
        case creditorAgent
        case creditorAgentName
        case creditorName
        case creditorID = "creditorId"
        case creditorAddress
        case creditorNameAndAddress
        case ultimateCreditor
        case purposeCode
        case serviceLevel
        case chargeBearer
        case remittanceInformationUnstructured
        case remittanceInformationStructured
        case intermediaryAgent
        case startDate
        case endDate
        case executionRule
        case frequency
        case dayOfExecution
    }
}

/// Generic Body for a bulk payment initation via JSON.
/// 
/// paymentInformationId is contained in code but commented since it is n.a.
/// and not all ASPSP are able to support this field now.
/// In a later version the field will be mandatory.
public struct BulkPaymentInitiationJSON: Codable {
    /// If this element equals 'true', the PSU prefers only one booking entry.
    /// If this element equals 'false', the PSU prefers individual booking of all contained individual transactions.
    /// 
    /// The ASPSP will follow this preference according to contracts agreed on with the PSU.
    ///
    /// Example: false
    public var isBatchBookingPreferred: Bool?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH
    /// Reference to an debtorAgent by either
    ///   * BIC, of the debtor bank, or
    ///   * IID, of the debtor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH_BicOrClrId
    public var debtorAgent: DebtorAgent7CH
    public var requestedExecutionDate: NaiveDate?
    public var requestedExecutionTime: Date?
    /// A list of generic JSON bodies payment initations for bulk payments via JSON.
    /// 
    /// Note: Some fields from single payments do not occcur in a bulk payment element
    public var payments: [PaymentInitiationBulkElementJSON]

    public init(isBatchBookingPreferred: Bool? = nil, debtorAccount: AccountReference16CH, debtorAgent: DebtorAgent7CH, requestedExecutionDate: NaiveDate? = nil, requestedExecutionTime: Date? = nil, payments: [PaymentInitiationBulkElementJSON]) {
        self.isBatchBookingPreferred = isBatchBookingPreferred
        self.debtorAccount = debtorAccount
        self.debtorAgent = debtorAgent
        self.requestedExecutionDate = requestedExecutionDate
        self.requestedExecutionTime = requestedExecutionTime
        self.payments = payments
    }

    private enum CodingKeys: String, CodingKey {
        case isBatchBookingPreferred = "batchBookingPreferred"
        case debtorAccount
        case debtorAgent
        case requestedExecutionDate
        case requestedExecutionTime
        case payments
    }
}

/// JSON Request body for the "Confirmation of funds service".
/// 
/// <table>
/// <tr>
///   <td>cardNumber</td>
///   <td>String </td>
///   <td>Optional</td>
///   <td>Card Number of the card issued by the PIISP. Should be delivered if available.</td>
/// </tr>
/// <tr>
///   <td>account</td>
///   <td> Account Reference</td>
///   <td>Mandatory</td>
///   <td>PSU's account number.</td>
/// </tr>
/// <tr>
///   <td>payee</td>
///   <td>Max70Text</td>
///   <td>Optional</td>
///   <td>The merchant where the card is accepted as an information to the PSU.</td>
/// </tr>
/// <tr>
///   <td>instructedAmount</td>
///   <td>Amount</td>
///   <td>Mandatory</td>
///   <td>Transaction amount to be checked within the funds check mechanism.</td>
/// </tr>
/// </table>
public struct ConfirmationOfFunds: Codable {
    /// Card Number of the card issued by the PIISP.
    /// Should be delivered if available.
    public var cardNumber: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var account: AccountReference16CH
    /// Name payee.
    public var payee: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var instructedAmount: Amount

    public init(cardNumber: String? = nil, account: AccountReference16CH, payee: String? = nil, instructedAmount: Amount) {
        self.cardNumber = cardNumber
        self.account = account
        self.payee = payee
        self.instructedAmount = instructedAmount
    }
}

/// Content of the body of a consent request.
public struct Consents: Codable {
    /// Requested access services for a consent.
    public var access: AccountAccess
    /// "true", if the consent is for recurring access to the account data.
    /// 
    /// "false", if the consent is for one access to the account data.
    ///
    /// Example: false
    public var isRecurringIndicator: Bool
    /// This parameter is defining a valid until date (including the mentioned date) for the requested consent.
    /// The content is the local ASPSP date in ISO-Date format, e.g. 2017-10-30.
    /// 
    /// Future dates might get adjusted by ASPSP.
    /// 
    /// If a maximal available date is requested, a date in far future is to be used: "9999-12-31".
    /// 
    /// In both cases the consent object to be retrieved by the get consent request will contain the adjusted date.
    ///
    /// Example: "2020-12-31"
    public var validUntil: NaiveDate
    /// This field indicates the requested maximum frequency for an access without PSU involvement per day.
    /// For a one-off access, this attribute is set to "1".
    /// 
    /// The frequency needs to be greater equal to one.
    /// 
    /// If not otherwise agreed bilaterally between TPP and ASPSP, the frequency is less equal to 4.
    public var frequencyPerDay: Int
    /// If "true" indicates that a payment initiation service will be addressed in the same "session".
    ///
    /// Example: false
    public var isCombinedServiceIndicator: Bool

    public init(access: AccountAccess, isRecurringIndicator: Bool, validUntil: NaiveDate, frequencyPerDay: Int, isCombinedServiceIndicator: Bool) {
        self.access = access
        self.isRecurringIndicator = isRecurringIndicator
        self.validUntil = validUntil
        self.frequencyPerDay = frequencyPerDay
        self.isCombinedServiceIndicator = isCombinedServiceIndicator
    }

    private enum CodingKeys: String, CodingKey {
        case access
        case isRecurringIndicator = "recurringIndicator"
        case validUntil
        case frequencyPerDay
        case isCombinedServiceIndicator = "combinedServiceIndicator"
    }
}

/// Content of the body of a Update PSU authentication request
/// 
/// Password subfield is used.
public struct UpdatePsuAuthentication: Codable {
    /// PSU Data for Update PSU authentication.
    public var psuData: PsuData

    public init(psuData: PsuData) {
        self.psuData = psuData
    }
}

/// Content of the body of a Select PSU authentication method request
public struct SelectPsuAuthenticationMethod: Codable {
    /// An identification provided by the ASPSP for the later identification of the authentication method selection.
    ///
    /// Example: "myAuthenticationID"
    public var authenticationMethodID: String

    public init(authenticationMethodID: String) {
        self.authenticationMethodID = authenticationMethodID
    }

    private enum CodingKeys: String, CodingKey {
        case authenticationMethodID = "authenticationMethodId"
    }
}

/// Content of the body of a transaction authorisation request
public struct TransactionAuthorisation: Codable {
    /// SCA authentication data, depending on the chosen authentication method.
    /// If the data is binary, then it is base64 encoded.
    public var scaAuthenticationData: String

    public init(scaAuthenticationData: String) {
        self.scaAuthenticationData = scaAuthenticationData
    }
}

/// Content of the body of an authorisation confirmation request
public struct AuthorisationConfirmation: Codable {
    /// Confirmation Code as retrieved by the TPP from the redirect based SCA process.
    public var confirmationCode: String

    public init(confirmationCode: String) {
        self.confirmationCode = confirmationCode
    }
}

/// The multipart message definition for the initiation of a periodic payment initiation
/// where the information of the payment is contained in a pain.001 message (Part 1) and
/// the additional informations related to the periodic payment is an additional JSON message (Part 2).
public struct PeriodicPaymentInitiationMultipartBody: Codable {
    public var xmlSct: XmlSct?
    /// The body part 2 of a periodic payment initation request containes the execution related informations
    /// of the periodic payment.
    public var jsonStandingorderType: PeriodicPaymentInitiationXmlPart2StandingorderTypeJSON?

    public typealias XmlSct = String

    public init(xmlSct: XmlSct? = nil, jsonStandingorderType: PeriodicPaymentInitiationXmlPart2StandingorderTypeJSON? = nil) {
        self.xmlSct = xmlSct
        self.jsonStandingorderType = jsonStandingorderType
    }

    private enum CodingKeys: String, CodingKey {
        case xmlSct = "xml_sct"
        case jsonStandingorderType = "json_standingorderType"
    }
}

/// The body part 2 of a periodic payment initation request containes the execution related informations
/// of the periodic payment.
public struct PeriodicPaymentInitiationXmlPart2StandingorderTypeJSON: Codable {
    /// The first applicable day of execution starting from this date is the first payment.
    public var startDate: NaiveDate
    /// The last applicable day of execution.
    /// If not given, it is an infinite standing order.
    public var endDate: NaiveDate?
    /// "following" or "preceding" supported as values.
    /// This data attribute defines the behaviour when recurring payment dates falls on a weekend or bank holiday.
    /// The payment is then executed either the "preceding" or "following" working day.
    /// ASPSP might reject the request due to the communicated value, if rules in Online-Banking are not supporting
    /// this execution rule.
    public var executionRule: ExecutionRule?
    /// The following codes from the "EventFrequency7Code" of ISO 20022 are supported:
    /// - "Daily"
    /// - "Weekly"
    /// - "EveryTwoWeeks"
    /// - "Monthly"
    /// - "EveryTwoMonths"
    /// - "Quarterly"
    /// - "SemiAnnual"
    /// - "Annual"
    /// - "MonthlyVariable"
    public var frequency: FrequencyCode
    /// Day of execution as string.
    /// 
    /// This string consists of up two characters.
    /// Leading zeroes are not allowed.
    /// 
    /// 31 is ultimo of the month.
    public var dayOfExecution: DayOfExecution?

    public init(startDate: NaiveDate, endDate: NaiveDate? = nil, executionRule: ExecutionRule? = nil, frequency: FrequencyCode, dayOfExecution: DayOfExecution? = nil) {
        self.startDate = startDate
        self.endDate = endDate
        self.executionRule = executionRule
        self.frequency = frequency
        self.dayOfExecution = dayOfExecution
    }
}

/// Body of the response for a successful payment initiation status request in case of an JSON based endpoint.
public struct PaymentInitiationStatusResponse200JSON: Codable {
    /// The transaction status is filled with codes of the ISO 20022 data table:
    /// - 'ACCC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the creditor's account has been completed.
    /// - 'ACCP': 'AcceptedCustomerProfile' -
    ///   Preceding check of technical validation was successful.
    ///   Customer profile check was also successful.
    /// - 'ACSC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the debtoro?=s account has been completed.
    /// 
    ///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
    /// 
    ///   **Warning:** this status is provided for transaction status reasons, not for financial information.
    ///   It can only be used after bilateral agreement.
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'ACWP': 'AcceptedWithoutPosting' -
    ///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'PDNG': 'Pending' -
    ///   Payment initiation or individual transaction included in the payment initiation is pending.
    ///   Further checks and status update will be performed.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    /// - 'CANC': 'Cancelled'
    ///   Payment initiation has been cancelled before execution
    ///   Remark: This codeis accepted as new code by ISO20022.
    /// - 'ACFC': 'AcceptedFundsChecked' -
    ///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PATC': 'PartiallyAcceptedTechnical'
    ///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PART': 'PartiallyAccepted' -
    ///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
    ///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
    ///
    /// Example: "ACCP"
    public var transactionStatus: TransactionStatus
    /// Equals true if sufficient funds are available at the time of the request, false otherwise.
    /// 
    /// This datalemenet is allways contained in a confirmation of funds response.
    /// 
    /// This data element is contained in a payment status response,
    /// if supported by the ASPSP, if a funds check has been performed and
    /// if the transactionStatus is "ACTC", "ACWC" or "ACCP".
    public var isFundsAvailable: Bool?
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(transactionStatus: TransactionStatus, isFundsAvailable: Bool? = nil, psuMessage: String? = nil) {
        self.transactionStatus = transactionStatus
        self.isFundsAvailable = isFundsAvailable
        self.psuMessage = psuMessage
    }

    private enum CodingKeys: String, CodingKey {
        case transactionStatus
        case isFundsAvailable = "fundsAvailable"
        case psuMessage
    }
}

/// Body of the response for a successful payment initiation request.
public struct PaymentInitationRequestResponse201: Codable {
    /// The transaction status is filled with codes of the ISO 20022 data table:
    /// - 'ACCC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the creditor's account has been completed.
    /// - 'ACCP': 'AcceptedCustomerProfile' -
    ///   Preceding check of technical validation was successful.
    ///   Customer profile check was also successful.
    /// - 'ACSC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the debtoro?=s account has been completed.
    /// 
    ///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
    /// 
    ///   **Warning:** this status is provided for transaction status reasons, not for financial information.
    ///   It can only be used after bilateral agreement.
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'ACWP': 'AcceptedWithoutPosting' -
    ///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'PDNG': 'Pending' -
    ///   Payment initiation or individual transaction included in the payment initiation is pending.
    ///   Further checks and status update will be performed.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    /// - 'CANC': 'Cancelled'
    ///   Payment initiation has been cancelled before execution
    ///   Remark: This codeis accepted as new code by ISO20022.
    /// - 'ACFC': 'AcceptedFundsChecked' -
    ///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PATC': 'PartiallyAcceptedTechnical'
    ///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PART': 'PartiallyAccepted' -
    ///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
    ///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
    ///
    /// Example: "ACCP"
    public var transactionStatus: TransactionStatus
    /// Resource identification of the generated payment initiation resource.
    ///
    /// Example: "1234-wertiq-983"
    public var paymentID: String
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var currencyConversionFee: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedTotalAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedInterbankSettlementAmount: Amount?
    /// If equals 'true', the transaction will involve specific transaction cost as shown by the ASPSP in
    /// their public price list or as agreed between ASPSP and PSU.
    /// If equals 'false', the transaction will not involve additional specific transaction costs to the PSU unless the fee amount is given specifically in the data elements transactionFees and/or currencyConversionFees.
    /// If this data element is not used, there is no information about transaction fees unless the fee amount is given explicitly in the data element transactionFees and/or currencyConversionFees.
    public var isTransactionFeeIndicator: Bool?
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// A list of hyperlinks to be recognised by the TPP.
    /// The actual hyperlinks used in the response depend on the dynamical decisions of the ASPSP when
    /// processing the request.
    /// 
    /// **Remark:** All links can be relative or full links, to be decided by the ASPSP.
    /// 
    /// Type of links admitted in this response, (further links might be added for ASPSP defined extensions):
    /// 
    /// * 'scaRedirect':
    ///   In case of an SCA Redirect Approach, the ASPSP is transmitting the link to which to redirect the PSU browser.
    /// * 'scaOAuth':
    ///   In case of a SCA OAuth2 Approach, the ASPSP is transmitting the URI where the configuration of the Authorisation
    ///   Server can be retrieved. The configuration follows the OAuth 2.0 Authorisation Server Metadata specification.
    /// * 'confirmation':
    ///   Might be added by the ASPSP if either the "scaRedirect" or "scaOAuth" hyperlink is returned
    ///   in the same response message.
    ///   This hyperlink defines the URL to the resource which needs to be updated with
    ///     * a confirmation code as retrieved after the plain redirect authentication process with the ASPSP authentication server or
    ///     * an access token as retrieved by submitting an authorization code after the integrated OAuth based authentication process with the ASPSP authentication server.
    /// * 'startAuthorisation':
    ///   In case, where an explicit start of the transaction authorisation is needed, but no more data needs to be updated
    ///   (no authentication method to be selected, no PSU identification nor PSU authentication data to be uploaded).
    /// * 'startAuthorisationWithPsuIdentification':
    ///   The link to the authorisation end-point, where the authorisation sub-resource has to be generated while
    ///   uploading the PSU identification data.
    /// * 'startAuthorisationWithPsuAuthentication':
    ///   The link to the authorisation end-point, where the authorisation sub-resource has to be generated while
    ///   uploading the PSU authentication data.
    ///   * 'startAuthorisationWithEncryptedPsuAuthentication':
    ///     Same as startAuthorisactionWithPsuAuthentication where the authentication data need to be encrypted on
    ///     application layer in uploading.
    /// * 'startAuthorisationWithAuthenticationMethodSelection':
    ///   The link to the authorisation end-point, where the authorisation sub-resource has to be generated while
    ///   selecting the authentication method.
    ///   This link is contained under exactly the same conditions as the data element "scaMethods"
    /// * 'startAuthorisationWithTransactionAuthorisation':
    ///   The link to the authorisation end-point, where the authorisation sub-resource has to be generated while
    ///   authorising the transaction e.g. by uploading an OTP received by SMS.
    /// * 'self':
    ///   The link to the payment initiation resource created by this request.
    ///   This link can be used to retrieve the resource data.
    /// * 'status':
    ///   The link to retrieve the transaction status of the payment initiation.
    /// * 'scaStatus':
    ///   The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    ///   This link is only contained, if an authorisation sub-resource has been already created.
    ///
    /// Example:
    ///
    /// {
    ///   "scaRedirect" : {
    ///     "href" : "https:\/\/www.testbank.com\/asdfasdfasdf"
    ///   },
    ///   "self" : {
    ///     "href" : "\/v1\/payments\/swiss-sepa-credit-transfers\/1234-wertiq-983"
    ///   }
    /// }
    public var links: [String: HrefType]
    /// Text to be displayed to the PSU.
    public var psuMessage: String?
    public var tppMessages: [TppMessage2XX]?

    public init(transactionStatus: TransactionStatus, paymentID: String, transactionFees: Amount? = nil, currencyConversionFee: Amount? = nil, estimatedTotalAmount: Amount? = nil, estimatedInterbankSettlementAmount: Amount? = nil, isTransactionFeeIndicator: Bool? = nil, scaMethods: [AuthenticationObject]? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, links: [String: HrefType], psuMessage: String? = nil, tppMessages: [TppMessage2XX]? = nil) {
        self.transactionStatus = transactionStatus
        self.paymentID = paymentID
        self.transactionFees = transactionFees
        self.currencyConversionFee = currencyConversionFee
        self.estimatedTotalAmount = estimatedTotalAmount
        self.estimatedInterbankSettlementAmount = estimatedInterbankSettlementAmount
        self.isTransactionFeeIndicator = isTransactionFeeIndicator
        self.scaMethods = scaMethods
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.links = links
        self.psuMessage = psuMessage
        self.tppMessages = tppMessages
    }

    private enum CodingKeys: String, CodingKey {
        case transactionStatus
        case paymentID = "paymentId"
        case transactionFees
        case currencyConversionFee
        case estimatedTotalAmount
        case estimatedInterbankSettlementAmount
        case isTransactionFeeIndicator = "transactionFeeIndicator"
        case scaMethods
        case chosenScaMethod
        case challengeData
        case links = "_links"
        case psuMessage
        case tppMessages
    }
}

/// Body of the response for a successful cancel payment request.
public struct PaymentInitiationCancelResponse202: Codable {
    /// The transaction status is filled with codes of the ISO 20022 data table:
    /// - 'ACCC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the creditor's account has been completed.
    /// - 'ACCP': 'AcceptedCustomerProfile' -
    ///   Preceding check of technical validation was successful.
    ///   Customer profile check was also successful.
    /// - 'ACSC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the debtoro?=s account has been completed.
    /// 
    ///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
    /// 
    ///   **Warning:** this status is provided for transaction status reasons, not for financial information.
    ///   It can only be used after bilateral agreement.
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'ACWP': 'AcceptedWithoutPosting' -
    ///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'PDNG': 'Pending' -
    ///   Payment initiation or individual transaction included in the payment initiation is pending.
    ///   Further checks and status update will be performed.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    /// - 'CANC': 'Cancelled'
    ///   Payment initiation has been cancelled before execution
    ///   Remark: This codeis accepted as new code by ISO20022.
    /// - 'ACFC': 'AcceptedFundsChecked' -
    ///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PATC': 'PartiallyAcceptedTechnical'
    ///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PART': 'PartiallyAccepted' -
    ///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
    ///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
    ///
    /// Example: "ACCP"
    public var transactionStatus: TransactionStatus
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the response depend on the
    /// dynamical decisions of the ASPSP when processing the request.
    /// 
    /// Remark: All links can be relative or full links, to be decided by the ASPSP.
    /// 
    /// Type of links admitted in this response, (further links might be added for ASPSP defined extensions):
    /// 
    ///   * 'startAuthorisation':
    ///     In case, where just the authorisation process of the cancellation needs to be started,
    ///     but no additional data needs to be updated for time being (no authentication method to be selected,
    ///     no PSU identification nor PSU authentication data to be uploaded).
    ///   * 'startAuthorisationWithPsuIdentification':
    ///     In case where a PSU identification needs to be updated when starting the cancellation authorisation:
    ///     The link to the cancellation-authorisations end-point, where the cancellation sub-resource has to be
    ///     generated while uploading the PSU identification data.
    ///   * 'startAuthorisationWithPsuAuthentication':
    ///     In case of a yet to be created authorisation sub-resource: The link to the cancalation authorisation end-point,
    ///     where the authorisation sub-resource has to be generated while uploading the PSU authentication data.
    ///   * 'startAuthorisationWithEncryptedPsuAuthentication':
    ///     Same as startAuthorisactionWithPsuAuthentication where the authentication data need to be encrypted on
    ///     application layer in uploading.
    ///   * 'startAuthorisationWithAuthenticationMethodSelection':
    ///     The link to the authorisation end-point, where the cancellation-authorisation sub-resource has to be
    ///     generated while selecting the authentication method. This link is contained under exactly the same
    ///     conditions as the data element 'scaMethods'
    public var links: [String: HrefType]?

    public init(transactionStatus: TransactionStatus, scaMethods: [AuthenticationObject]? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, links: [String: HrefType]? = nil) {
        self.transactionStatus = transactionStatus
        self.scaMethods = scaMethods
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case transactionStatus
        case scaMethods
        case chosenScaMethod
        case challengeData
        case links = "_links"
    }
}

/// Generic JSON response body consistion of the corresponding payment initation JSON body together with an optional transaction status field.
public struct PaymentInitiationWithStatusResponse: Codable {
    public var endToEndIdentification: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var instructedAmount: Amount
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH
    /// Reference to an creditorAgent by either
    ///   * BIC, of the creditor bank, or
    ///   * IID, of the creditor bank, or
    ///   * IID and optional name and address of the creditor bank or
    ///   * Name and address of the creditor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH
    public var creditorAgent: CreditorAgent7CH?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String
    /// Example:
    ///
    /// {
    ///   "buildingnNumber" : "89",
    ///   "country" : "FR",
    ///   "postCode" : "75000",
    ///   "streetName" : "rue blue",
    ///   "townName" : "Paris"
    /// }
    public var creditorAddress: Address?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Array of unstructured remittance information.
    ///
    /// Example: ["Ref Number Merchant", "Some Other Text"]
    public var remittanceInformationUnstructuredArray: [String]?
    /// Structured remittance information.
    public var remittanceInformationStructured: RemittanceInformationStructured?
    public var requestedExecutionDate: NaiveDate?
    public var requestedExecutionTime: Date?
    /// The transaction status is filled with codes of the ISO 20022 data table:
    /// - 'ACCC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the creditor's account has been completed.
    /// - 'ACCP': 'AcceptedCustomerProfile' -
    ///   Preceding check of technical validation was successful.
    ///   Customer profile check was also successful.
    /// - 'ACSC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the debtoro?=s account has been completed.
    /// 
    ///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
    /// 
    ///   **Warning:** this status is provided for transaction status reasons, not for financial information.
    ///   It can only be used after bilateral agreement.
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'ACWP': 'AcceptedWithoutPosting' -
    ///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'PDNG': 'Pending' -
    ///   Payment initiation or individual transaction included in the payment initiation is pending.
    ///   Further checks and status update will be performed.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    /// - 'CANC': 'Cancelled'
    ///   Payment initiation has been cancelled before execution
    ///   Remark: This codeis accepted as new code by ISO20022.
    /// - 'ACFC': 'AcceptedFundsChecked' -
    ///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PATC': 'PartiallyAcceptedTechnical'
    ///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PART': 'PartiallyAccepted' -
    ///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
    ///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
    ///
    /// Example: "ACCP"
    public var transactionStatus: TransactionStatus?

    public init(endToEndIdentification: String? = nil, debtorAccount: AccountReference16CH, ultimateDebtor: String? = nil, instructedAmount: Amount, creditorAccount: AccountReference16CH, creditorAgent: CreditorAgent7CH? = nil, creditorName: String, creditorAddress: Address? = nil, ultimateCreditor: String? = nil, purposeCode: PurposeCode? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationUnstructuredArray: [String]? = nil, remittanceInformationStructured: RemittanceInformationStructured? = nil, requestedExecutionDate: NaiveDate? = nil, requestedExecutionTime: Date? = nil, transactionStatus: TransactionStatus? = nil) {
        self.endToEndIdentification = endToEndIdentification
        self.debtorAccount = debtorAccount
        self.ultimateDebtor = ultimateDebtor
        self.instructedAmount = instructedAmount
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.creditorName = creditorName
        self.creditorAddress = creditorAddress
        self.ultimateCreditor = ultimateCreditor
        self.purposeCode = purposeCode
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationUnstructuredArray = remittanceInformationUnstructuredArray
        self.remittanceInformationStructured = remittanceInformationStructured
        self.requestedExecutionDate = requestedExecutionDate
        self.requestedExecutionTime = requestedExecutionTime
        self.transactionStatus = transactionStatus
    }
}

/// Generic JSON response body consistion of the corresponding periodic payment initation JSON body together with an optional transaction status field.
public struct PeriodicPaymentInitiationWithStatusResponse: Codable {
    public var endToEndIdentification: String?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH
    /// Ultimate debtor.
    ///
    /// Example: "Ultimate Debtor"
    public var ultimateDebtor: String?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var instructedAmount: Amount
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var creditorAccount: AccountReference16CH
    /// Reference to an creditorAgent by either
    ///   * BIC, of the creditor bank, or
    ///   * IID, of the creditor bank, or
    ///   * IID and optional name and address of the creditor bank or
    ///   * Name and address of the creditor bank
    /// adapted from ISO pain.001.001.03.ch.02 FinancialInstitutionIdentification7-CH
    public var creditorAgent: CreditorAgent7CH?
    /// Creditor name.
    ///
    /// Example: "Creditor Name"
    public var creditorName: String
    /// Example:
    ///
    /// {
    ///   "buildingnNumber" : "89",
    ///   "country" : "FR",
    ///   "postCode" : "75000",
    ///   "streetName" : "rue blue",
    ///   "townName" : "Paris"
    /// }
    public var creditorAddress: Address?
    /// Ultimate creditor.
    ///
    /// Example: "Ultimate Creditor"
    public var ultimateCreditor: String?
    /// ExternalPurpose1Code from ISO 20022.
    /// 
    /// Values from ISO 20022 External Code List ExternalCodeSets_1Q2018 June 2018.
    public var purposeCode: PurposeCode?
    /// Unstructured remittance information.
    ///
    /// Example: "Ref Number Merchant"
    public var remittanceInformationUnstructured: String?
    /// Array of unstructured remittance information.
    ///
    /// Example: ["Ref Number Merchant", "Some Other Text"]
    public var remittanceInformationUnstructuredArray: [String]?
    /// Structured remittance information.
    public var remittanceInformationStructured: RemittanceInformationStructured?
    public var requestedExecutionDate: NaiveDate?
    public var requestedExecutionTime: Date?
    /// The first applicable day of execution starting from this date is the first payment.
    public var startDate: NaiveDate
    /// The last applicable day of execution.
    /// If not given, it is an infinite standing order.
    public var endDate: NaiveDate?
    /// "following" or "preceding" supported as values.
    /// This data attribute defines the behaviour when recurring payment dates falls on a weekend or bank holiday.
    /// The payment is then executed either the "preceding" or "following" working day.
    /// ASPSP might reject the request due to the communicated value, if rules in Online-Banking are not supporting
    /// this execution rule.
    public var executionRule: ExecutionRule?
    /// The following codes from the "EventFrequency7Code" of ISO 20022 are supported:
    /// - "Daily"
    /// - "Weekly"
    /// - "EveryTwoWeeks"
    /// - "Monthly"
    /// - "EveryTwoMonths"
    /// - "Quarterly"
    /// - "SemiAnnual"
    /// - "Annual"
    /// - "MonthlyVariable"
    public var frequency: FrequencyCode
    /// Day of execution as string.
    /// 
    /// This string consists of up two characters.
    /// Leading zeroes are not allowed.
    /// 
    /// 31 is ultimo of the month.
    public var dayOfExecution: DayOfExecution?
    /// The transaction status is filled with codes of the ISO 20022 data table:
    /// - 'ACCC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the creditor's account has been completed.
    /// - 'ACCP': 'AcceptedCustomerProfile' -
    ///   Preceding check of technical validation was successful.
    ///   Customer profile check was also successful.
    /// - 'ACSC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the debtoro?=s account has been completed.
    /// 
    ///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
    /// 
    ///   **Warning:** this status is provided for transaction status reasons, not for financial information.
    ///   It can only be used after bilateral agreement.
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'ACWP': 'AcceptedWithoutPosting' -
    ///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'PDNG': 'Pending' -
    ///   Payment initiation or individual transaction included in the payment initiation is pending.
    ///   Further checks and status update will be performed.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    /// - 'CANC': 'Cancelled'
    ///   Payment initiation has been cancelled before execution
    ///   Remark: This codeis accepted as new code by ISO20022.
    /// - 'ACFC': 'AcceptedFundsChecked' -
    ///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PATC': 'PartiallyAcceptedTechnical'
    ///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PART': 'PartiallyAccepted' -
    ///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
    ///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
    ///
    /// Example: "ACCP"
    public var transactionStatus: TransactionStatus?

    public init(endToEndIdentification: String? = nil, debtorAccount: AccountReference16CH, ultimateDebtor: String? = nil, instructedAmount: Amount, creditorAccount: AccountReference16CH, creditorAgent: CreditorAgent7CH? = nil, creditorName: String, creditorAddress: Address? = nil, ultimateCreditor: String? = nil, purposeCode: PurposeCode? = nil, remittanceInformationUnstructured: String? = nil, remittanceInformationUnstructuredArray: [String]? = nil, remittanceInformationStructured: RemittanceInformationStructured? = nil, requestedExecutionDate: NaiveDate? = nil, requestedExecutionTime: Date? = nil, startDate: NaiveDate, endDate: NaiveDate? = nil, executionRule: ExecutionRule? = nil, frequency: FrequencyCode, dayOfExecution: DayOfExecution? = nil, transactionStatus: TransactionStatus? = nil) {
        self.endToEndIdentification = endToEndIdentification
        self.debtorAccount = debtorAccount
        self.ultimateDebtor = ultimateDebtor
        self.instructedAmount = instructedAmount
        self.creditorAccount = creditorAccount
        self.creditorAgent = creditorAgent
        self.creditorName = creditorName
        self.creditorAddress = creditorAddress
        self.ultimateCreditor = ultimateCreditor
        self.purposeCode = purposeCode
        self.remittanceInformationUnstructured = remittanceInformationUnstructured
        self.remittanceInformationUnstructuredArray = remittanceInformationUnstructuredArray
        self.remittanceInformationStructured = remittanceInformationStructured
        self.requestedExecutionDate = requestedExecutionDate
        self.requestedExecutionTime = requestedExecutionTime
        self.startDate = startDate
        self.endDate = endDate
        self.executionRule = executionRule
        self.frequency = frequency
        self.dayOfExecution = dayOfExecution
        self.transactionStatus = transactionStatus
    }
}

/// Generic JSON response body consistion of the corresponding bulk payment initation JSON body together with an optional transaction status field.
public struct BulkPaymentInitiationWithStatusResponse: Codable {
    /// If this element equals 'true', the PSU prefers only one booking entry.
    /// If this element equals 'false', the PSU prefers individual booking of all contained individual transactions.
    /// 
    /// The ASPSP will follow this preference according to contracts agreed on with the PSU.
    ///
    /// Example: false
    public var isBatchBookingPreferred: Bool?
    public var requestedExecutionDate: NaiveDate?
    public var acceptorTransactionDateTime: Date?
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var debtorAccount: AccountReference16CH
    public var paymentInformationID: String?
    /// A list of generic JSON bodies payment initations for bulk payments via JSON.
    /// 
    /// Note: Some fields from single payments do not occcur in a bulk payment element
    public var payments: [PaymentInitiationBulkElementJSON]
    /// The transaction status is filled with codes of the ISO 20022 data table:
    /// - 'ACCC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the creditor's account has been completed.
    /// - 'ACCP': 'AcceptedCustomerProfile' -
    ///   Preceding check of technical validation was successful.
    ///   Customer profile check was also successful.
    /// - 'ACSC': 'AcceptedSettlementCompleted' -
    ///   Settlement on the debtoro?=s account has been completed.
    /// 
    ///   **Usage:** this can be used by the first agent to report to the debtor that the transaction has been completed.
    /// 
    ///   **Warning:** this status is provided for transaction status reasons, not for financial information.
    ///   It can only be used after bilateral agreement.
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'ACWP': 'AcceptedWithoutPosting' -
    ///   Payment instruction included in the credit transfer is accepted without being posted to the creditor customero?=s account.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'PDNG': 'Pending' -
    ///   Payment initiation or individual transaction included in the payment initiation is pending.
    ///   Further checks and status update will be performed.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    /// - 'CANC': 'Cancelled'
    ///   Payment initiation has been cancelled before execution
    ///   Remark: This codeis accepted as new code by ISO20022.
    /// - 'ACFC': 'AcceptedFundsChecked' -
    ///   Preceding check of technical validation and customer profile was successful and an automatic funds check was positive .
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PATC': 'PartiallyAcceptedTechnical'
    ///   Correct The payment initiation needs multiple authentications, where some but not yet all have been performed. Syntactical and semantical validations are successful.
    ///   Remark: This code is accepted as new code by ISO20022.
    /// - 'PART': 'PartiallyAccepted' -
    ///   A number of transactions have been accepted, whereas another number of transactions have not yet achieved 'accepted' status.
    ///   Remark: This code may be used only in case of bulk payments. It is only used in a situation where all mandated authorisations have been applied, but some payments have been rejected.
    ///
    /// Example: "ACCP"
    public var transactionStatus: TransactionStatus?

    public init(isBatchBookingPreferred: Bool? = nil, requestedExecutionDate: NaiveDate? = nil, acceptorTransactionDateTime: Date? = nil, debtorAccount: AccountReference16CH, paymentInformationID: String? = nil, payments: [PaymentInitiationBulkElementJSON], transactionStatus: TransactionStatus? = nil) {
        self.isBatchBookingPreferred = isBatchBookingPreferred
        self.requestedExecutionDate = requestedExecutionDate
        self.acceptorTransactionDateTime = acceptorTransactionDateTime
        self.debtorAccount = debtorAccount
        self.paymentInformationID = paymentInformationID
        self.payments = payments
        self.transactionStatus = transactionStatus
    }

    private enum CodingKeys: String, CodingKey {
        case isBatchBookingPreferred = "batchBookingPreferred"
        case requestedExecutionDate
        case acceptorTransactionDateTime
        case debtorAccount
        case paymentInformationID = "paymentInformationId"
        case payments
        case transactionStatus
    }
}

/// Body of the JSON response with SCA Status.
public struct ScaStatusResponse: Codable {
    /// This data element is containing information about the status of the SCA method applied.
    /// 
    /// The following codes are defined for this data type.
    /// 
    ///   * 'received':
    ///     An authorisation or cancellation-authorisation resource has been created successfully.
    ///   * 'psuIdentified':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified.
    ///   * 'psuAuthenticated':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified and authenticated e.g. by a password or by an access token.
    ///   * 'scaMethodSelected':
    ///     The PSU/TPP has selected the related SCA routine.
    ///     If the SCA method is chosen implicitly since only one SCA method is available,
    ///     then this is the first status to be reported instead of 'received'.
    ///   * 'unconfirmed':
    ///     SCA is technically successfully finalised by the PSU, but the authorisation resource needs a confirmation command by the TPP yet.
    ///   * 'started':
    ///     The addressed SCA routine has been started.
    ///   * 'finalised':
    ///     The SCA routine has been finalised successfully (including a potential confirmation command).
    ///     This is a final status of the authorisation resource.
    ///   * 'failed':
    ///     The SCA routine failed.
    ///     This is a final status of the authorisation resource.
    ///   * 'exempted':
    ///     SCA was exempted for the related transaction, the related authorisation is successful.
    ///     This is a final status of the authorisation resource.
    ///
    /// Example: "psuAuthenticated"
    public var scaStatus: ScaStatus
    /// Text to be displayed to the PSU.
    public var psuMessage: String?
    /// Additional Service: Trusted Benificiaries
    /// Within this data element, the ASPSP might optionally communicate towards the TPP whether the creditor was part of the related trusted beneficiary list.
    /// This attribute is only contained in case of a final scaStatus.
    ///
    /// Example: false
    public var isTrustedBeneficiaryFlag: Bool?

    public init(scaStatus: ScaStatus, psuMessage: String? = nil, isTrustedBeneficiaryFlag: Bool? = nil) {
        self.scaStatus = scaStatus
        self.psuMessage = psuMessage
        self.isTrustedBeneficiaryFlag = isTrustedBeneficiaryFlag
    }

    private enum CodingKeys: String, CodingKey {
        case scaStatus
        case psuMessage
        case isTrustedBeneficiaryFlag = "trustedBeneficiaryFlag"
    }
}

/// Body of the JSON response for a Start SCA authorisation request.
public struct StartScaprocessResponse: Codable {
    /// This data element is containing information about the status of the SCA method applied.
    /// 
    /// The following codes are defined for this data type.
    /// 
    ///   * 'received':
    ///     An authorisation or cancellation-authorisation resource has been created successfully.
    ///   * 'psuIdentified':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified.
    ///   * 'psuAuthenticated':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified and authenticated e.g. by a password or by an access token.
    ///   * 'scaMethodSelected':
    ///     The PSU/TPP has selected the related SCA routine.
    ///     If the SCA method is chosen implicitly since only one SCA method is available,
    ///     then this is the first status to be reported instead of 'received'.
    ///   * 'unconfirmed':
    ///     SCA is technically successfully finalised by the PSU, but the authorisation resource needs a confirmation command by the TPP yet.
    ///   * 'started':
    ///     The addressed SCA routine has been started.
    ///   * 'finalised':
    ///     The SCA routine has been finalised successfully (including a potential confirmation command).
    ///     This is a final status of the authorisation resource.
    ///   * 'failed':
    ///     The SCA routine failed.
    ///     This is a final status of the authorisation resource.
    ///   * 'exempted':
    ///     SCA was exempted for the related transaction, the related authorisation is successful.
    ///     This is a final status of the authorisation resource.
    ///
    /// Example: "psuAuthenticated"
    public var scaStatus: ScaStatus
    /// Resource identification of the related SCA.
    ///
    /// Example: "123auth456"
    public var authorisationID: String
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the
    /// response depend on the dynamical decisions of the ASPSP when processing the request.
    /// 
    /// **Remark:** All links can be relative or full links, to be decided by the ASPSP.
    /// 
    /// Type of links admitted in this response, (further links might be added for ASPSP defined
    /// extensions):
    /// 
    /// - 'scaRedirect':
    ///   In case of an SCA Redirect Approach, the ASPSP is transmitting the link to which to
    ///   redirect the PSU browser.
    /// - 'scaOAuth':
    ///   In case of a SCA OAuth2 Approach, the ASPSP is transmitting the URI where the configuration of the Authorisation Server can be retrieved. The configuration follows the OAuth 2.0 Authorisation Server Metadata specification.
    /// * 'confirmation':
    ///   Might be added by the ASPSP if either the "scaRedirect" or "scaOAuth" hyperlink is returned
    ///   in the same response message.
    ///   This hyperlink defines the URL to the resource which needs to be updated with
    ///     * a confirmation code as retrieved after the plain redirect authentication process with the ASPSP authentication server or
    ///     * an access token as retrieved by submitting an authorization code after the integrated OAuth based authentication process with the ASPSP authentication server.
    /// - 'updatePsuIdentification':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where PSU identification data needs to be uploaded.
    /// - 'startAuthorisationWithPsuAuthentication':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where PSU authentication data needs to be uploaded.
    /// - 'startAuthorisationWithEncryptedPsuAuthentication':
    ///     Same as startAuthorisactionWithPsuAuthentication where the authentication data need to be encrypted on
    ///     application layer in uploading.
    /// - 'selectAuthenticationMethod':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where the selected authentication method needs to be uploaded.
    ///   This link is contained under exactly the same conditions as the data element 'scaMethods'.
    /// - 'authoriseTransaction':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where the authorisation data has to be uploaded, e.g. the TOP received by SMS.
    /// - 'scaStatus':
    ///   The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    public var links: [String: HrefType]
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(scaStatus: ScaStatus, authorisationID: String, scaMethods: [AuthenticationObject]? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, links: [String: HrefType], psuMessage: String? = nil) {
        self.scaStatus = scaStatus
        self.authorisationID = authorisationID
        self.scaMethods = scaMethods
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.links = links
        self.psuMessage = psuMessage
    }

    private enum CodingKeys: String, CodingKey {
        case scaStatus
        case authorisationID = "authorisationId"
        case scaMethods
        case chosenScaMethod
        case challengeData
        case links = "_links"
        case psuMessage
    }
}

/// Body of the JSON response for an authorisation confirmation request.
public struct AuthorisationConfirmationResponse: Codable {
    /// This data element is containing information about the status of the SCA method in an authorisation confirmation response.
    /// 
    /// The following codes are defined for this data type.
    /// 
    ///   * 'finalised': if the transaction authorisation and confirmation was successfule.
    ///   * 'failed': if the transaction authorisation or confirmation was not successful.
    public var scaStatus: ScaStatusAuthorisationConfirmation
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the response depend on the dynamical decisions of the ASPSP when processing the request.
    /// 
    /// **Remark:** All links can be relative or full links, to be decided by the ASPSP.
    /// 
    /// Type of links admitted in this response, (further links might be added for ASPSP
    /// defined extensions):
    /// 
    /// - 'scaStatus': The link to retrieve the status of the corresponding transaction resource.
    public var links: [String: HrefType]
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(scaStatus: ScaStatusAuthorisationConfirmation, links: [String: HrefType], psuMessage: String? = nil) {
        self.scaStatus = scaStatus
        self.links = links
        self.psuMessage = psuMessage
    }

    private enum CodingKeys: String, CodingKey {
        case scaStatus
        case links = "_links"
        case psuMessage
    }
}

/// Body of the JSON response for a successful update PSU identification request.
public struct UpdatePsuIdenticationResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var currencyConversionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedTotalAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedInterbankSettlementAmount: Amount?
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the response depend on the dynamical decisions of the ASPSP when processing the request.
    /// 
    /// **Remark:** All links can be relative or full links, to be decided by the ASPSP.
    /// 
    /// Type of links admitted in this response, (further links might be added for ASPSP
    /// defined extensions):
    /// 
    /// - 'scaStatus': The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    /// - 'selectAuthenticationMethod': This is a link to a resource, where the TPP can select the applicable second factor authentication methods for the PSU, if there are several available authentication methods and if the PSU is already sufficiently authenticated.. If this link is contained, then there is also the data element "scaMethods" contained in the response body.
    public var links: [String: HrefType]
    /// This data element is containing information about the status of the SCA method applied.
    /// 
    /// The following codes are defined for this data type.
    /// 
    ///   * 'received':
    ///     An authorisation or cancellation-authorisation resource has been created successfully.
    ///   * 'psuIdentified':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified.
    ///   * 'psuAuthenticated':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified and authenticated e.g. by a password or by an access token.
    ///   * 'scaMethodSelected':
    ///     The PSU/TPP has selected the related SCA routine.
    ///     If the SCA method is chosen implicitly since only one SCA method is available,
    ///     then this is the first status to be reported instead of 'received'.
    ///   * 'unconfirmed':
    ///     SCA is technically successfully finalised by the PSU, but the authorisation resource needs a confirmation command by the TPP yet.
    ///   * 'started':
    ///     The addressed SCA routine has been started.
    ///   * 'finalised':
    ///     The SCA routine has been finalised successfully (including a potential confirmation command).
    ///     This is a final status of the authorisation resource.
    ///   * 'failed':
    ///     The SCA routine failed.
    ///     This is a final status of the authorisation resource.
    ///   * 'exempted':
    ///     SCA was exempted for the related transaction, the related authorisation is successful.
    ///     This is a final status of the authorisation resource.
    ///
    /// Example: "psuAuthenticated"
    public var scaStatus: ScaStatus
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(transactionFees: Amount? = nil, currencyConversionFees: Amount? = nil, estimatedTotalAmount: Amount? = nil, estimatedInterbankSettlementAmount: Amount? = nil, scaMethods: [AuthenticationObject]? = nil, links: [String: HrefType], scaStatus: ScaStatus, psuMessage: String? = nil) {
        self.transactionFees = transactionFees
        self.currencyConversionFees = currencyConversionFees
        self.estimatedTotalAmount = estimatedTotalAmount
        self.estimatedInterbankSettlementAmount = estimatedInterbankSettlementAmount
        self.scaMethods = scaMethods
        self.links = links
        self.scaStatus = scaStatus
        self.psuMessage = psuMessage
    }

    private enum CodingKeys: String, CodingKey {
        case transactionFees
        case currencyConversionFees
        case estimatedTotalAmount
        case estimatedInterbankSettlementAmount
        case scaMethods
        case links = "_links"
        case scaStatus
        case psuMessage
    }
}

/// Body of the JSON response for a successful update PSU authentication request.
public struct UpdatePsuAuthenticationResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var currencyConversionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedTotalAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedInterbankSettlementAmount: Amount?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// A list of hyperlinks to be recognised by the TPP. Might be contained, if several authentication methods
    /// are available for the PSU.
    /// Type of links admitted in this response:
    ///   * 'updateAdditionalPsuAuthentication':
    ///     The link to the payment initiation or account information resource,
    ///     which needs to be updated by an additional PSU password.
    ///     This link is only contained in rare cases,
    ///     where such additional passwords are needed for PSU authentications.
    ///   * 'updateAdditionalEncryptedPsuAuthentication':
    ///     The link to the payment initiation or account information resource,
    ///     which needs to be updated by an additional encrypted PSU password.
    ///     This link is only contained in rare cases, where such additional passwords are needed for PSU authentications.
    ///   * 'selectAuthenticationMethod':
    ///     This is a link to a resource, where the TPP can select the applicable second factor authentication
    ///     methods for the PSU, if there were several available authentication methods.
    ///     This link is only contained, if the PSU is already identified or authenticated with the first relevant
    ///     factor or alternatively an access token, if SCA is required and if the PSU has a choice between different
    ///     authentication methods.
    ///     If this link is contained, then there is also the data element 'scaMethods' contained in the response body.
    ///   * 'authoriseTransaction':
    ///     The link to the resource, where the "Transaction authorisation request" is sent to.
    ///     This is the link to the resource which will authorise the transaction by checking the SCA authentication
    ///     data within the Embedded SCA approach.
    ///   * 'scaStatus':
    ///     The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    public var links: [String: HrefType]?
    /// This data element is containing information about the status of the SCA method applied.
    /// 
    /// The following codes are defined for this data type.
    /// 
    ///   * 'received':
    ///     An authorisation or cancellation-authorisation resource has been created successfully.
    ///   * 'psuIdentified':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified.
    ///   * 'psuAuthenticated':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified and authenticated e.g. by a password or by an access token.
    ///   * 'scaMethodSelected':
    ///     The PSU/TPP has selected the related SCA routine.
    ///     If the SCA method is chosen implicitly since only one SCA method is available,
    ///     then this is the first status to be reported instead of 'received'.
    ///   * 'unconfirmed':
    ///     SCA is technically successfully finalised by the PSU, but the authorisation resource needs a confirmation command by the TPP yet.
    ///   * 'started':
    ///     The addressed SCA routine has been started.
    ///   * 'finalised':
    ///     The SCA routine has been finalised successfully (including a potential confirmation command).
    ///     This is a final status of the authorisation resource.
    ///   * 'failed':
    ///     The SCA routine failed.
    ///     This is a final status of the authorisation resource.
    ///   * 'exempted':
    ///     SCA was exempted for the related transaction, the related authorisation is successful.
    ///     This is a final status of the authorisation resource.
    ///
    /// Example: "psuAuthenticated"
    public var scaStatus: ScaStatus
    /// Text to be displayed to the PSU.
    public var psuMessage: String?
    /// Resource identification of the related SCA.
    ///
    /// Example: "123auth456"
    public var authorisationID: String?

    public init(transactionFees: Amount? = nil, currencyConversionFees: Amount? = nil, estimatedTotalAmount: Amount? = nil, estimatedInterbankSettlementAmount: Amount? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, scaMethods: [AuthenticationObject]? = nil, links: [String: HrefType]? = nil, scaStatus: ScaStatus, psuMessage: String? = nil, authorisationID: String? = nil) {
        self.transactionFees = transactionFees
        self.currencyConversionFees = currencyConversionFees
        self.estimatedTotalAmount = estimatedTotalAmount
        self.estimatedInterbankSettlementAmount = estimatedInterbankSettlementAmount
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.scaMethods = scaMethods
        self.links = links
        self.scaStatus = scaStatus
        self.psuMessage = psuMessage
        self.authorisationID = authorisationID
    }

    private enum CodingKeys: String, CodingKey {
        case transactionFees
        case currencyConversionFees
        case estimatedTotalAmount
        case estimatedInterbankSettlementAmount
        case chosenScaMethod
        case challengeData
        case scaMethods
        case links = "_links"
        case scaStatus
        case psuMessage
        case authorisationID = "authorisationId"
    }
}

/// Body of the JSON response for a successful select PSU authentication method request.
public struct SelectPsuAuthenticationMethodResponse: Codable {
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var transactionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var currencyConversionFees: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedTotalAmount: Amount?
    /// Example:
    ///
    /// {
    ///   "amount" : "123",
    ///   "currency" : "EUR"
    /// }
    public var estimatedInterbankSettlementAmount: Amount?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in
    /// the response depend on the dynamical decisions of the ASPSP when processing the request.
    /// 
    /// **Remark:** All links can be relative or full links, to be decided by the ASPSP.
    /// 
    /// **Remark:** This method can be applied before or after PSU identification.
    /// This leads to many possible hyperlink responses.
    /// Type of links admitted in this response, (further links might be added for ASPSP defined
    /// extensions):
    /// 
    /// - 'scaRedirect':
    ///   In case of an SCA Redirect Approach, the ASPSP is transmitting the link to which to
    ///   redirect the PSU browser.
    /// - 'scaOAuth':
    ///   In case of a SCA OAuth2 Approach, the ASPSP is transmitting the URI where the
    ///   configuration of the Authorisation Server can be retrieved.
    ///   The configuration follows the OAuth 2.0 Authorisation Server Metadata specification.
    /// * 'confirmation':
    ///   Might be added by the ASPSP if either the "scaRedirect" or "scaOAuth" hyperlink is returned
    ///   in the same response message.
    ///   This hyperlink defines the URL to the resource which needs to be updated with
    ///     * a confirmation code as retrieved after the plain redirect authentication process with the ASPSP authentication server or
    ///     * an access token as retrieved by submitting an authorization code after the integrated OAuth based authentication process with the ASPSP authentication server.
    /// - 'updatePsuIdentification':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where PSU identification data needs to be uploaded.
    /// - 'updatePsuAuthentication':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where PSU authentication data needs to be uploaded.
    ///   - 'updateEncryptedPsuAuthentication':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where PSU authentication encrypted data needs to be uploaded.
    /// - 'updateAdditionalPsuAuthentication':
    ///     The link to the payment initiation or account information resource,
    ///     which needs to be updated by an additional PSU password.
    /// - 'updateAdditionalEncryptedPsuAuthentication':
    ///     The link to the payment initiation or account information resource,
    ///     which needs to be updated by an additional encrypted PSU password.
    /// - 'authoriseTransaction':
    ///   The link to the authorisation or cancellation authorisation sub-resource,
    ///   where the authorisation data has to be uploaded, e.g. the TOP received by SMS.
    /// - 'scaStatus':
    ///   The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    public var links: [String: HrefType]?
    /// This data element is containing information about the status of the SCA method applied.
    /// 
    /// The following codes are defined for this data type.
    /// 
    ///   * 'received':
    ///     An authorisation or cancellation-authorisation resource has been created successfully.
    ///   * 'psuIdentified':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified.
    ///   * 'psuAuthenticated':
    ///     The PSU related to the authorisation or cancellation-authorisation resource has been identified and authenticated e.g. by a password or by an access token.
    ///   * 'scaMethodSelected':
    ///     The PSU/TPP has selected the related SCA routine.
    ///     If the SCA method is chosen implicitly since only one SCA method is available,
    ///     then this is the first status to be reported instead of 'received'.
    ///   * 'unconfirmed':
    ///     SCA is technically successfully finalised by the PSU, but the authorisation resource needs a confirmation command by the TPP yet.
    ///   * 'started':
    ///     The addressed SCA routine has been started.
    ///   * 'finalised':
    ///     The SCA routine has been finalised successfully (including a potential confirmation command).
    ///     This is a final status of the authorisation resource.
    ///   * 'failed':
    ///     The SCA routine failed.
    ///     This is a final status of the authorisation resource.
    ///   * 'exempted':
    ///     SCA was exempted for the related transaction, the related authorisation is successful.
    ///     This is a final status of the authorisation resource.
    ///
    /// Example: "psuAuthenticated"
    public var scaStatus: ScaStatus
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(transactionFees: Amount? = nil, currencyConversionFees: Amount? = nil, estimatedTotalAmount: Amount? = nil, estimatedInterbankSettlementAmount: Amount? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, links: [String: HrefType]? = nil, scaStatus: ScaStatus, psuMessage: String? = nil) {
        self.transactionFees = transactionFees
        self.currencyConversionFees = currencyConversionFees
        self.estimatedTotalAmount = estimatedTotalAmount
        self.estimatedInterbankSettlementAmount = estimatedInterbankSettlementAmount
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.links = links
        self.scaStatus = scaStatus
        self.psuMessage = psuMessage
    }

    private enum CodingKeys: String, CodingKey {
        case transactionFees
        case currencyConversionFees
        case estimatedTotalAmount
        case estimatedInterbankSettlementAmount
        case chosenScaMethod
        case challengeData
        case links = "_links"
        case scaStatus
        case psuMessage
    }
}

/// Body of the JSON response for a successful get signing basket request.
/// 
///   * 'payments': payment initiations which shall be authorised through this signing basket.
///   * 'consents': consent objects which shall be authorised through this signing basket.
///   * 'transactionStatus': Only the codes RCVD, ACTC, RJCT are used.
///   * '_links': The ASPSP might integrate hyperlinks to indicate next (authorisation) steps to be taken.
public struct SigningBasketResponse200: Codable {
    /// A list of paymentIds.
    public var payments: [String]?
    /// A list of consentIds.
    public var consents: [String]?
    /// The transaction status is filled with codes of the ISO 20022 data table.
    /// Only the codes RCVD, PATC, ACTC, ACWC and RJCT are used:
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    ///
    /// Example: "RCVD"
    public var transactionStatus: TransactionStatusSBS
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the
    /// response depend on the dynamical decisions of the ASPSP when processing the request.
    /// 
    /// Remark: All links can be relative or full links, to be decided by the ASPSP.
    /// Type of links admitted in this response, (further links might be added for ASPSP defined
    /// extensions):
    /// 
    ///   * 'scaRedirect':
    ///     In case of an SCA Redirect Approach, the ASPSP is transmitting the link to
    ///     which to redirect the PSU browser.
    ///   * 'scaOAuth':
    ///     In case of a SCA OAuth2 Approach, the ASPSP is transmitting the URI where the configuration of
    ///     the Authorisation Server can be retrieved. The configuration follows the
    ///     OAuth 2.0 Authorisation Server Metadata specification.
    ///   * 'startAuthorisation':
    ///     In case, where an explicit start of the transaction authorisation is needed,
    ///     but no more data needs to be updated (no authentication method to be selected,
    ///     no PSU identification nor PSU authentication data to be uploaded).
    ///   * 'startAuthorisationWithPsuIdentification':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while uploading the PSU identification data.
    ///   * 'startAuthorisationWithPsuAuthentication':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while uploading the PSU authentication data.
    ///   * 'startAuthorisationWithEncryptedPsuAuthentication':
    ///     The link to the authorisation end-point, where the authorisation sub-resource has
    ///     to be generated while uploading the encrypted PSU authentication data.
    ///   * 'startAuthorisationWithAuthenticationMethodSelection':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while selecting the authentication method.
    ///     This link is contained under exactly the same conditions as the data element 'scaMethods'
    ///   * 'startAuthorisationWithTransactionAuthorisation':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while authorising the transaction e.g. by uploading an
    ///     OTP received by SMS.
    ///   * 'self':
    ///     The link to the payment initiation resource created by this request.
    ///     This link can be used to retrieve the resource data.
    ///   * 'status':
    ///     The link to retrieve the transaction status of the payment initiation.
    ///   * 'scaStatus':
    ///     The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    ///     This link is only contained, if an authorisation sub-resource has been already created.
    public var links: LinksSigningBasket?

    public init(payments: [String]? = nil, consents: [String]? = nil, transactionStatus: TransactionStatusSBS, links: LinksSigningBasket? = nil) {
        self.payments = payments
        self.consents = consents
        self.transactionStatus = transactionStatus
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case payments
        case consents
        case transactionStatus
        case links = "_links"
    }
}

public struct SigningBasketStatusResponse200: Codable {
    /// The transaction status is filled with codes of the ISO 20022 data table.
    /// Only the codes RCVD, PATC, ACTC, ACWC and RJCT are used:
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    ///
    /// Example: "RCVD"
    public var transactionStatus: TransactionStatusSBS

    public init(transactionStatus: TransactionStatusSBS) {
        self.transactionStatus = transactionStatus
    }
}

/// Body of the JSON response for a successful create signing basket request.
public struct SigningBasketResponse201: Codable {
    /// The transaction status is filled with codes of the ISO 20022 data table.
    /// Only the codes RCVD, PATC, ACTC, ACWC and RJCT are used:
    /// - 'ACSP': 'AcceptedSettlementInProcess' -
    ///   All preceding checks such as technical validation and customer profile were successful and therefore the payment initiation has been accepted for execution.
    /// - 'ACTC': 'AcceptedTechnicalValidation' -
    ///   Authentication and syntactical and semantical validation are successful.
    /// - 'ACWC': 'AcceptedWithChange' -
    ///   Instruction is accepted but a change will be made, such as date or remittance not sent.
    /// - 'RCVD': 'Received' -
    ///   Payment initiation has been received by the receiving agent.
    /// - 'RJCT': 'Rejected' -
    ///   Payment initiation or individual transaction included in the payment initiation has been rejected.
    ///
    /// Example: "RCVD"
    public var transactionStatus: TransactionStatusSBS
    /// Resource identification of the generated signing basket resource.
    ///
    /// Example: "1234-basket-567"
    public var basketID: String
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the
    /// response depend on the dynamical decisions of the ASPSP when processing the request.
    /// 
    /// Remark: All links can be relative or full links, to be decided by the ASPSP.
    /// Type of links admitted in this response, (further links might be added for ASPSP defined
    /// extensions):
    /// 
    ///   * 'scaRedirect':
    ///     In case of an SCA Redirect Approach, the ASPSP is transmitting the link to
    ///     which to redirect the PSU browser.
    ///   * 'scaOAuth':
    ///     In case of a SCA OAuth2 Approach, the ASPSP is transmitting the URI where the configuration of
    ///     the Authorisation Server can be retrieved. The configuration follows the
    ///     OAuth 2.0 Authorisation Server Metadata specification.
    ///   * 'startAuthorisation':
    ///     In case, where an explicit start of the transaction authorisation is needed,
    ///     but no more data needs to be updated (no authentication method to be selected,
    ///     no PSU identification nor PSU authentication data to be uploaded).
    ///   * 'startAuthorisationWithPsuIdentification':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while uploading the PSU identification data.
    ///   * 'startAuthorisationWithPsuAuthentication':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while uploading the PSU authentication data.
    ///   * 'startAuthorisationWithEncryptedPsuAuthentication':
    ///     The link to the authorisation end-point, where the authorisation sub-resource has
    ///     to be generated while uploading the encrypted PSU authentication data.
    ///   * 'startAuthorisationWithAuthenticationMethodSelection':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while selecting the authentication method.
    ///     This link is contained under exactly the same conditions as the data element 'scaMethods'
    ///   * 'startAuthorisationWithTransactionAuthorisation':
    ///     The link to the authorisation end-point, where the authorisation sub-resource
    ///     has to be generated while authorising the transaction e.g. by uploading an
    ///     OTP received by SMS.
    ///   * 'self':
    ///     The link to the payment initiation resource created by this request.
    ///     This link can be used to retrieve the resource data.
    ///   * 'status':
    ///     The link to retrieve the transaction status of the payment initiation.
    ///   * 'scaStatus':
    ///     The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    ///     This link is only contained, if an authorisation sub-resource has been already created.
    public var links: LinksSigningBasket
    /// Text to be displayed to the PSU.
    public var psuMessage: String?
    public var tppMessages: [TppMessage2XX]?

    public init(transactionStatus: TransactionStatusSBS, basketID: String, scaMethods: [AuthenticationObject]? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, links: LinksSigningBasket, psuMessage: String? = nil, tppMessages: [TppMessage2XX]? = nil) {
        self.transactionStatus = transactionStatus
        self.basketID = basketID
        self.scaMethods = scaMethods
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.links = links
        self.psuMessage = psuMessage
        self.tppMessages = tppMessages
    }

    private enum CodingKeys: String, CodingKey {
        case transactionStatus
        case basketID = "basketId"
        case scaMethods
        case chosenScaMethod
        case challengeData
        case links = "_links"
        case psuMessage
        case tppMessages
    }
}

/// Body of the JSON response for a successful consent request.
public struct ConsentsResponse201: Codable {
    /// This is the overall lifecycle status of the consent.
    /// 
    /// Valid values are:
    ///   - 'received': The consent data have been received and are technically correct.
    ///     The data is not authorised yet.
    ///   - 'rejected': The consent data have been rejected e.g. since no successful authorisation has taken place.
    ///   - 'valid': The consent is accepted and valid for GET account data calls and others as specified in the consent object.
    ///   - 'revokedByPsu': The consent has been revoked by the PSU towards the ASPSP.
    ///   - 'expired': The consent expired.
    ///   - 'terminatedByTpp': The corresponding TPP has terminated the consent by applying the DELETE method to the consent resource.
    ///   - 'partiallyAuthorised': The consent is due to a multi-level authorisation, some but not all mandated authorisations have been performed yet.
    /// 
    /// The ASPSP might add further codes. These codes then shall be contained in the ASPSP's documentation of the XS2A interface
    /// and has to be added to this API definition as well.
    public var consentStatus: ConsentStatus
    /// ID of the corresponding consent object as returned by an account information consent request.
    public var consentID: String
    /// This data element might be contained, if SCA is required and if the PSU has a choice between different
    /// authentication methods.
    /// 
    /// Depending on the risk management of the ASPSP this choice might be offered before or after the PSU
    /// has been identified with the first relevant factor, or if an access token is transported.
    /// 
    /// If this data element is contained, then there is also a hyperlink of type 'startAuthorisationWithAuthenticationMethodSelection'
    /// contained in the response body.
    /// 
    /// These methods shall be presented towards the PSU for selection by the TPP.
    public var scaMethods: [AuthenticationObject]?
    /// Authentication object.
    public var chosenScaMethod: ChosenScaMethod?
    /// It is contained in addition to the data element 'chosenScaMethod' if challenge data is needed for SCA.
    /// In rare cases this attribute is also used in the context of the 'startAuthorisationWithPsuAuthentication' link.
    public var challengeData: ChallengeData?
    /// A list of hyperlinks to be recognised by the TPP.
    /// 
    /// Type of links admitted in this response (which might be extended by single ASPSPs as indicated in its XS2A
    /// documentation):
    ///   * 'scaRedirect':
    ///     In case of an SCA Redirect Approach, the ASPSP is transmitting the link to which to redirect the
    ///     PSU browser.
    ///   * 'scaOAuth':
    ///     In case of an OAuth2 based Redirect Approach, the ASPSP is transmitting the link where the configuration
    ///     of the OAuth2 Server is defined.
    ///     The configuration follows the OAuth 2.0 Authorisation Server Metadata specification.
    /// * 'confirmation':
    ///   Might be added by the ASPSP if either the "scaRedirect" or "scaOAuth" hyperlink is returned
    ///   in the same response message.
    ///   This hyperlink defines the URL to the resource which needs to be updated with
    ///     * a confirmation code as retrieved after the plain redirect authentication process with the ASPSP authentication server or
    ///     * an access token as retrieved by submitting an authorization code after the integrated OAuth based authentication process with the ASPSP authentication server.
    ///   * 'startAuthorisation':
    ///     In case, where an explicit start of the transaction authorisation is needed,
    ///     but no more data needs to be updated (no authentication method to be selected,
    ///     no PSU identification nor PSU authentication data to be uploaded).
    ///   * 'startAuthorisationWithPsuIdentification':
    ///     The link to the authorisation end-point, where the authorisation sub-resource has to be generated
    ///     while uploading the PSU identification data.
    ///   * 'startAuthorisationWithPsuAuthentication':
    ///     The link to the authorisation end-point, where the authorisation sub-resource has to be generated
    ///     while uploading the PSU authentication data.
    ///   * 'startAuthorisationWithEncryptedPsuAuthentication':
    ///     Same as startAuthorisactionWithPsuAuthentication where the authentication data need to be encrypted on
    ///     application layer in uploading.
    ///   * 'startAuthorisationWithAuthenticationMethodSelection':
    ///     The link to the authorisation end-point, where the authorisation sub-resource has to be generated
    ///     while selecting the authentication method. This link is contained under exactly the same conditions
    ///     as the data element 'scaMethods'
    ///   * 'startAuthorisationWithTransactionAuthorisation':
    ///     The link to the authorisation end-point, where the authorisation sub-resource has to be generated
    ///     while authorising the transaction e.g. by uploading an OTP received by SMS.
    ///   * 'self':
    ///     The link to the Establish Account Information Consent resource created by this request.
    ///     This link can be used to retrieve the resource data.
    ///   * 'status':
    ///     The link to retrieve the status of the account information consent.
    ///   * 'scaStatus': The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
    ///     This link is only contained, if an authorisation sub-resource has been already created.
    public var links: [String: HrefType]
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(consentStatus: ConsentStatus, consentID: String, scaMethods: [AuthenticationObject]? = nil, chosenScaMethod: ChosenScaMethod? = nil, challengeData: ChallengeData? = nil, links: [String: HrefType], psuMessage: String? = nil) {
        self.consentStatus = consentStatus
        self.consentID = consentID
        self.scaMethods = scaMethods
        self.chosenScaMethod = chosenScaMethod
        self.challengeData = challengeData
        self.links = links
        self.psuMessage = psuMessage
    }

    private enum CodingKeys: String, CodingKey {
        case consentStatus
        case consentID = "consentId"
        case scaMethods
        case chosenScaMethod
        case challengeData
        case links = "_links"
        case psuMessage
    }
}

/// Body of the JSON response for a successful get status request for a consent.
public struct ConsentStatusResponse200: Codable {
    /// This is the overall lifecycle status of the consent.
    /// 
    /// Valid values are:
    ///   - 'received': The consent data have been received and are technically correct.
    ///     The data is not authorised yet.
    ///   - 'rejected': The consent data have been rejected e.g. since no successful authorisation has taken place.
    ///   - 'valid': The consent is accepted and valid for GET account data calls and others as specified in the consent object.
    ///   - 'revokedByPsu': The consent has been revoked by the PSU towards the ASPSP.
    ///   - 'expired': The consent expired.
    ///   - 'terminatedByTpp': The corresponding TPP has terminated the consent by applying the DELETE method to the consent resource.
    ///   - 'partiallyAuthorised': The consent is due to a multi-level authorisation, some but not all mandated authorisations have been performed yet.
    /// 
    /// The ASPSP might add further codes. These codes then shall be contained in the ASPSP's documentation of the XS2A interface
    /// and has to be added to this API definition as well.
    public var consentStatus: ConsentStatus
    /// Text to be displayed to the PSU.
    public var psuMessage: String?

    public init(consentStatus: ConsentStatus, psuMessage: String? = nil) {
        self.consentStatus = consentStatus
        self.psuMessage = psuMessage
    }
}

/// Body of the JSON response for a successfull get consent request.
public struct ConsentInformationResponse200JSON: Codable {
    /// Requested access services for a consent.
    public var access: AccountAccess
    /// "true", if the consent is for recurring access to the account data.
    /// 
    /// "false", if the consent is for one access to the account data.
    ///
    /// Example: false
    public var isRecurringIndicator: Bool
    /// This parameter is defining a valid until date (including the mentioned date) for the requested consent.
    /// The content is the local ASPSP date in ISO-Date format, e.g. 2017-10-30.
    /// 
    /// Future dates might get adjusted by ASPSP.
    /// 
    /// If a maximal available date is requested, a date in far future is to be used: "9999-12-31".
    /// 
    /// In both cases the consent object to be retrieved by the get consent request will contain the adjusted date.
    ///
    /// Example: "2020-12-31"
    public var validUntil: NaiveDate
    /// This field indicates the requested maximum frequency for an access without PSU involvement per day.
    /// For a one-off access, this attribute is set to "1".
    /// 
    /// The frequency needs to be greater equal to one.
    /// 
    /// If not otherwise agreed bilaterally between TPP and ASPSP, the frequency is less equal to 4.
    public var frequencyPerDay: Int
    /// This date is containing the date of the last action on the consent object either through
    /// the XS2A interface or the PSU/ASPSP interface having an impact on the status.
    ///
    /// Example: "2018-07-01"
    public var lastActionDate: NaiveDate
    /// This is the overall lifecycle status of the consent.
    /// 
    /// Valid values are:
    ///   - 'received': The consent data have been received and are technically correct.
    ///     The data is not authorised yet.
    ///   - 'rejected': The consent data have been rejected e.g. since no successful authorisation has taken place.
    ///   - 'valid': The consent is accepted and valid for GET account data calls and others as specified in the consent object.
    ///   - 'revokedByPsu': The consent has been revoked by the PSU towards the ASPSP.
    ///   - 'expired': The consent expired.
    ///   - 'terminatedByTpp': The corresponding TPP has terminated the consent by applying the DELETE method to the consent resource.
    ///   - 'partiallyAuthorised': The consent is due to a multi-level authorisation, some but not all mandated authorisations have been performed yet.
    /// 
    /// The ASPSP might add further codes. These codes then shall be contained in the ASPSP's documentation of the XS2A interface
    /// and has to be added to this API definition as well.
    public var consentStatus: ConsentStatus
    /// A list of hyperlinks to be recognised by the TPP.
    /// 
    /// Links of type "account" and/or "cardAccount", depending on the nature of the consent.
    public var links: [String: HrefType]?

    public init(access: AccountAccess, isRecurringIndicator: Bool, validUntil: NaiveDate, frequencyPerDay: Int, lastActionDate: NaiveDate, consentStatus: ConsentStatus, links: [String: HrefType]? = nil) {
        self.access = access
        self.isRecurringIndicator = isRecurringIndicator
        self.validUntil = validUntil
        self.frequencyPerDay = frequencyPerDay
        self.lastActionDate = lastActionDate
        self.consentStatus = consentStatus
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case access
        case isRecurringIndicator = "recurringIndicator"
        case validUntil
        case frequencyPerDay
        case lastActionDate
        case consentStatus
        case links = "_links"
    }
}

/// Body of the response for a successful read balance for an account request.
public struct ReadAccountBalanceResponse200: Codable {
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var account: AccountReference16CH?
    /// A list of balances regarding this account, e.g. the current balance, the last booked balance.
    /// The list might be restricted to the current balance.
    public var balances: [Balance]

    public init(account: AccountReference16CH? = nil, balances: [Balance]) {
        self.account = account
        self.balances = balances
    }
}

/// Body of the response for a successful read balance for a card account request.
public struct ReadCardAccountBalanceResponse200: Codable {
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var cardAccount: AccountReference16CH?
    /// If true, the amounts of debits on the reports are quoted positive with the related consequence for balances.
    /// If false, the amount of debits on the reports are quoted negative.
    public var isDebitAccounting: Bool?
    /// A list of balances regarding this account, e.g. the current balance, the last booked balance.
    /// The list might be restricted to the current balance.
    public var balances: [Balance]

    public init(cardAccount: AccountReference16CH? = nil, isDebitAccounting: Bool? = nil, balances: [Balance]) {
        self.cardAccount = cardAccount
        self.isDebitAccounting = isDebitAccounting
        self.balances = balances
    }

    private enum CodingKeys: String, CodingKey {
        case cardAccount
        case isDebitAccounting = "debitAccounting"
        case balances
    }
}

/// Body of the JSON response for a successful read transaction list request.
/// This account report contains transactions resulting from the query parameters.
public struct TransactionsResponse200JSON: Codable {
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var account: AccountReference16CH?
    /// JSON based account report.
    /// This account report contains transactions resulting from the query parameters.
    /// 
    /// 'booked' shall be contained if bookingStatus parameter is set to "booked" or "both".
    /// 
    /// 'pending' is not contained if the bookingStatus parameter is set to "booked" or "information".
    /// 
    /// 'information' Only contained if the bookingStatus is set to "information" and if supported by ASPSP.
    public var transactions: AccountReport?
    /// A list of balances regarding this account, e.g. the current balance, the last booked balance.
    /// The list might be restricted to the current balance.
    public var balances: [Balance]?
    /// A list of hyperlinks to be recognised by the TPP.
    /// 
    /// Type of links admitted in this response:
    ///   - "download": a link to a resource, where the transaction report might be downloaded from in
    ///   case where transaction reports have a huge size.
    /// 
    /// Remark: This feature shall only be used where camt-data is requested which has a huge size.
    public var links: [String: HrefType]?

    public init(account: AccountReference16CH? = nil, transactions: AccountReport? = nil, balances: [Balance]? = nil, links: [String: HrefType]? = nil) {
        self.account = account
        self.transactions = transactions
        self.balances = balances
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case account
        case transactions
        case balances
        case links = "_links"
    }
}

/// Body of the JSON response for a successful read card account transaction list request.
/// This card account report contains transactions resulting from the query parameters.
public struct CardAccountsTransactionsResponse200: Codable {
    /// Reference to an account by either
    ///   * IBAN, of a payment accounts, or
    ///   * otherAccountIdentification, for payment accounts if there is no IBAN
    /// adapted from ISO pain.001.001.03.ch.02 CashAccount16-CH_IdTpCcy
    public var cardAccount: AccountReference16CH?
    /// If true, the amounts of debits on the reports are quoted positive with the related consequence for balances.
    /// If false, the amount of debits on the reports are quoted negative.
    public var isDebitAccounting: Bool?
    /// JSON based card account report.
    /// 
    /// This card account report contains transactions resulting from the query parameters.
    public var cardTransactions: CardAccountReport?
    /// A list of balances regarding this account, e.g. the current balance, the last booked balance.
    /// The list might be restricted to the current balance.
    public var balances: [Balance]?
    /// A list of hyperlinks to be recognised by the TPP.
    /// 
    /// Type of links admitted in this response:
    ///   - "download": a link to a resource, where the transaction report might be downloaded from in
    ///   case where transaction reports have a huge size.
    /// 
    /// Remark: This feature shall only be used where camt-data is requested which has a huge size.
    public var links: [String: HrefType]?

    public init(cardAccount: AccountReference16CH? = nil, isDebitAccounting: Bool? = nil, cardTransactions: CardAccountReport? = nil, balances: [Balance]? = nil, links: [String: HrefType]? = nil) {
        self.cardAccount = cardAccount
        self.isDebitAccounting = isDebitAccounting
        self.cardTransactions = cardTransactions
        self.balances = balances
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case cardAccount
        case isDebitAccounting = "debitAccounting"
        case cardTransactions
        case balances
        case links = "_links"
    }
}

/// A list of hyperlinks to be recognised by the TPP. The actual hyperlinks used in the
/// response depend on the dynamical decisions of the ASPSP when processing the request.
/// 
/// Remark: All links can be relative or full links, to be decided by the ASPSP.
/// Type of links admitted in this response, (further links might be added for ASPSP defined
/// extensions):
/// 
///   * 'scaRedirect':
///     In case of an SCA Redirect Approach, the ASPSP is transmitting the link to
///     which to redirect the PSU browser.
///   * 'scaOAuth':
///     In case of a SCA OAuth2 Approach, the ASPSP is transmitting the URI where the configuration of
///     the Authorisation Server can be retrieved. The configuration follows the
///     OAuth 2.0 Authorisation Server Metadata specification.
///   * 'startAuthorisation':
///     In case, where an explicit start of the transaction authorisation is needed,
///     but no more data needs to be updated (no authentication method to be selected,
///     no PSU identification nor PSU authentication data to be uploaded).
///   * 'startAuthorisationWithPsuIdentification':
///     The link to the authorisation end-point, where the authorisation sub-resource
///     has to be generated while uploading the PSU identification data.
///   * 'startAuthorisationWithPsuAuthentication':
///     The link to the authorisation end-point, where the authorisation sub-resource
///     has to be generated while uploading the PSU authentication data.
///   * 'startAuthorisationWithEncryptedPsuAuthentication':
///     The link to the authorisation end-point, where the authorisation sub-resource has
///     to be generated while uploading the encrypted PSU authentication data.
///   * 'startAuthorisationWithAuthenticationMethodSelection':
///     The link to the authorisation end-point, where the authorisation sub-resource
///     has to be generated while selecting the authentication method.
///     This link is contained under exactly the same conditions as the data element 'scaMethods'
///   * 'startAuthorisationWithTransactionAuthorisation':
///     The link to the authorisation end-point, where the authorisation sub-resource
///     has to be generated while authorising the transaction e.g. by uploading an
///     OTP received by SMS.
///   * 'self':
///     The link to the payment initiation resource created by this request.
///     This link can be used to retrieve the resource data.
///   * 'status':
///     The link to retrieve the transaction status of the payment initiation.
///   * 'scaStatus':
///     The link to retrieve the scaStatus of the corresponding authorisation sub-resource.
///     This link is only contained, if an authorisation sub-resource has been already created.
public struct LinksSigningBasket: Codable {
    /// Link to a resource.
    public var scaRedirect: HrefType?
    /// Link to a resource.
    public var scaOAuth: HrefType?
    /// Link to a resource.
    public var startAuthorisation: HrefType?
    /// Link to a resource.
    public var startAuthorisationWithPsuIdentification: HrefType?
    /// Link to a resource.
    public var startAuthorisationWithPsuAuthentication: HrefType?
    /// Link to a resource.
    public var startAuthorisationWithEncryptedPsuAuthentication: HrefType?
    /// Link to a resource.
    public var startAuthorisationWithAuthenticationMethodSelection: HrefType?
    /// Link to a resource.
    public var startAuthorisationWithTransactionAuthorisation: HrefType?
    /// Link to a resource.
    public var this: HrefType?
    /// Link to a resource.
    public var status: HrefType?
    /// Link to a resource.
    public var scaStatus: HrefType?

    public init(scaRedirect: HrefType? = nil, scaOAuth: HrefType? = nil, startAuthorisation: HrefType? = nil, startAuthorisationWithPsuIdentification: HrefType? = nil, startAuthorisationWithPsuAuthentication: HrefType? = nil, startAuthorisationWithEncryptedPsuAuthentication: HrefType? = nil, startAuthorisationWithAuthenticationMethodSelection: HrefType? = nil, startAuthorisationWithTransactionAuthorisation: HrefType? = nil, this: HrefType? = nil, status: HrefType? = nil, scaStatus: HrefType? = nil) {
        self.scaRedirect = scaRedirect
        self.scaOAuth = scaOAuth
        self.startAuthorisation = startAuthorisation
        self.startAuthorisationWithPsuIdentification = startAuthorisationWithPsuIdentification
        self.startAuthorisationWithPsuAuthentication = startAuthorisationWithPsuAuthentication
        self.startAuthorisationWithEncryptedPsuAuthentication = startAuthorisationWithEncryptedPsuAuthentication
        self.startAuthorisationWithAuthenticationMethodSelection = startAuthorisationWithAuthenticationMethodSelection
        self.startAuthorisationWithTransactionAuthorisation = startAuthorisationWithTransactionAuthorisation
        self.this = this
        self.status = status
        self.scaStatus = scaStatus
    }

    private enum CodingKeys: String, CodingKey {
        case scaRedirect
        case scaOAuth
        case startAuthorisation
        case startAuthorisationWithPsuIdentification
        case startAuthorisationWithPsuAuthentication
        case startAuthorisationWithEncryptedPsuAuthentication
        case startAuthorisationWithAuthenticationMethodSelection
        case startAuthorisationWithTransactionAuthorisation
        case this = "self"
        case status
        case scaStatus
    }
}

/// Category of the TPP message category.
public enum TppMessageCategory: String, Codable, CaseIterable {
    case error = "ERROR"
    case warning = "WARNING"
}

/// Message codes for HTTP Error codes 2XX.
public enum MessageCode2XX: String, Codable, CaseIterable {
    case warning = "WARNING"
}

/// Message codes defined for AIS for HTTP Error code 400 (BAD_REQUEST).
public enum MessageCode400AIS: String, Codable, CaseIterable {
    case formatError = "FORMAT_ERROR"
    case parameterNotConsistent = "PARAMETER_NOT_CONSISTENT"
    case parameterNotSupported = "PARAMETER_NOT_SUPPORTED"
    case serviceInvalid = "SERVICE_INVALID"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
    case resourceBlocked = "RESOURCE_BLOCKED"
    case timestampInvalid = "TIMESTAMP_INVALID"
    case periodInvalid = "PERIOD_INVALID"
    case scaMethodUnknown = "SCA_METHOD_UNKNOWN"
    case scaInvalid = "SCA_INVALID"
    case consentUnknown = "CONSENT_UNKNOWN"
    case sessionsNotSupported = "SESSIONS_NOT_SUPPORTED"
}

/// Message codes defined for PIS for HTTP Error code 400 (BAD_REQUEST).
public enum MessageCode400PIS: String, Codable, CaseIterable {
    case formatError = "FORMAT_ERROR"
    case parameterNotConsistent = "PARAMETER_NOT_CONSISTENT"
    case parameterNotSupported = "PARAMETER_NOT_SUPPORTED"
    case serviceInvalid = "SERVICE_INVALID"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
    case resourceBlocked = "RESOURCE_BLOCKED"
    case timestampInvalid = "TIMESTAMP_INVALID"
    case periodInvalid = "PERIOD_INVALID"
    case scaMethodUnknown = "SCA_METHOD_UNKNOWN"
    case scaInvalid = "SCA_INVALID"
    case consentUnknown = "CONSENT_UNKNOWN"
    case paymentFailed = "PAYMENT_FAILED"
    case executionDateInvalid = "EXECUTION_DATE_INVALID"
}

/// Message codes defined for PIIS for HTTP Error code 400 (BAD_REQUEST).
public enum MessageCode400PIIS: String, Codable, CaseIterable {
    case formatError = "FORMAT_ERROR"
    case parameterNotConsistent = "PARAMETER_NOT_CONSISTENT"
    case parameterNotSupported = "PARAMETER_NOT_SUPPORTED"
    case serviceInvalid = "SERVICE_INVALID"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
    case resourceBlocked = "RESOURCE_BLOCKED"
    case timestampInvalid = "TIMESTAMP_INVALID"
    case periodInvalid = "PERIOD_INVALID"
    case scaMethodUnknown = "SCA_METHOD_UNKNOWN"
    case scaInvalid = "SCA_INVALID"
    case consentUnknown = "CONSENT_UNKNOWN"
    case cardInvalid = "CARD_INVALID"
    case noPiisActivation = "NO_PIIS_ACTIVATION"
}

/// Message codes defined for signing baskets for HTTP Error code 400 (BAD_REQUEST).
public enum MessageCode400SBS: String, Codable, CaseIterable {
    case formatError = "FORMAT_ERROR"
    case parameterNotConsistent = "PARAMETER_NOT_CONSISTENT"
    case parameterNotSupported = "PARAMETER_NOT_SUPPORTED"
    case serviceInvalid = "SERVICE_INVALID"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
    case resourceBlocked = "RESOURCE_BLOCKED"
    case timestampInvalid = "TIMESTAMP_INVALID"
    case periodInvalid = "PERIOD_INVALID"
    case scaMethodUnknown = "SCA_METHOD_UNKNOWN"
    case scaInvalid = "SCA_INVALID"
    case consentUnknown = "CONSENT_UNKNOWN"
    case referenceMixInvalid = "REFERENCE_MIX_INVALID"
}

/// Message codes defined for PIS for HTTP Error code 401 (UNAUTHORIZED).
public enum MessageCode401PIS: String, Codable, CaseIterable {
    case certificateInvalid = "CERTIFICATE_INVALID"
    case roleInvalid = "ROLE_INVALID"
    case certificateExpired = "CERTIFICATE_EXPIRED"
    case certificateBlocked = "CERTIFICATE_BLOCKED"
    case certificateRevoke = "CERTIFICATE_REVOKE"
    case certificateMissing = "CERTIFICATE_MISSING"
    case signatureInvalid = "SIGNATURE_INVALID"
    case signatureMissing = "SIGNATURE_MISSING"
    case corporateIDInvalid = "CORPORATE_ID_INVALID"
    case psuCredentialsInvalid = "PSU_CREDENTIALS_INVALID"
    case consentInvalid = "CONSENT_INVALID"
    case consentExpired = "CONSENT_EXPIRED"
    case tokenUnknown = "TOKEN_UNKNOWN"
    case tokenInvalid = "TOKEN_INVALID"
    case tokenExpired = "TOKEN_EXPIRED"
    case requiredKidMissing = "REQUIRED_KID_MISSING"
}

/// Message codes defined for AIS for HTTP Error code 401 (UNAUTHORIZED).
public enum MessageCode401AIS: String, Codable, CaseIterable {
    case certificateInvalid = "CERTIFICATE_INVALID"
    case roleInvalid = "ROLE_INVALID"
    case certificateExpired = "CERTIFICATE_EXPIRED"
    case certificateBlocked = "CERTIFICATE_BLOCKED"
    case certificateRevoke = "CERTIFICATE_REVOKE"
    case certificateMissing = "CERTIFICATE_MISSING"
    case signatureInvalid = "SIGNATURE_INVALID"
    case signatureMissing = "SIGNATURE_MISSING"
    case corporateIDInvalid = "CORPORATE_ID_INVALID"
    case psuCredentialsInvalid = "PSU_CREDENTIALS_INVALID"
    case consentInvalid = "CONSENT_INVALID"
    case consentExpired = "CONSENT_EXPIRED"
    case tokenUnknown = "TOKEN_UNKNOWN"
    case tokenInvalid = "TOKEN_INVALID"
    case tokenExpired = "TOKEN_EXPIRED"
}

/// Message codes defined for PIIS for HTTP Error code 401 (UNAUTHORIZED).
public enum MessageCode401PIIS: String, Codable, CaseIterable {
    case certificateInvalid = "CERTIFICATE_INVALID"
    case roleInvalid = "ROLE_INVALID"
    case certificateExpired = "CERTIFICATE_EXPIRED"
    case certificateBlocked = "CERTIFICATE_BLOCKED"
    case certificateRevoke = "CERTIFICATE_REVOKE"
    case certificateMissing = "CERTIFICATE_MISSING"
    case signatureInvalid = "SIGNATURE_INVALID"
    case signatureMissing = "SIGNATURE_MISSING"
    case corporateIDInvalid = "CORPORATE_ID_INVALID"
    case psuCredentialsInvalid = "PSU_CREDENTIALS_INVALID"
    case consentInvalid = "CONSENT_INVALID"
    case consentExpired = "CONSENT_EXPIRED"
    case tokenUnknown = "TOKEN_UNKNOWN"
    case tokenInvalid = "TOKEN_INVALID"
    case tokenExpired = "TOKEN_EXPIRED"
}

/// Message codes defined for signing baskets for HTTP Error code 401 (UNAUTHORIZED).
public enum MessageCode401SBS: String, Codable, CaseIterable {
    case certificateInvalid = "CERTIFICATE_INVALID"
    case roleInvalid = "ROLE_INVALID"
    case certificateExpired = "CERTIFICATE_EXPIRED"
    case certificateBlocked = "CERTIFICATE_BLOCKED"
    case certificateRevoke = "CERTIFICATE_REVOKE"
    case certificateMissing = "CERTIFICATE_MISSING"
    case signatureInvalid = "SIGNATURE_INVALID"
    case signatureMissing = "SIGNATURE_MISSING"
    case corporateIDInvalid = "CORPORATE_ID_INVALID"
    case psuCredentialsInvalid = "PSU_CREDENTIALS_INVALID"
    case consentInvalid = "CONSENT_INVALID"
    case consentExpired = "CONSENT_EXPIRED"
    case tokenUnknown = "TOKEN_UNKNOWN"
    case tokenInvalid = "TOKEN_INVALID"
    case tokenExpired = "TOKEN_EXPIRED"
}

/// Message codes defined defined for PIS for PIS for HTTP Error code 403 (FORBIDDEN).
public enum MessageCode403PIS: String, Codable, CaseIterable {
    case consentUnknown = "CONSENT_UNKNOWN"
    case serviceBlocked = "SERVICE_BLOCKED"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
    case productInvalid = "PRODUCT_INVALID"
}

/// Message codes defined for AIS for HTTP Error code 403 (FORBIDDEN).
public enum MessageCode403AIS: String, Codable, CaseIterable {
    case consentUnknown = "CONSENT_UNKNOWN"
    case serviceBlocked = "SERVICE_BLOCKED"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
}

/// Message codes defined for PIIS for HTTP Error code 403 (FORBIDDEN).
public enum MessageCode403PIIS: String, Codable, CaseIterable {
    case consentUnknown = "CONSENT_UNKNOWN"
    case serviceBlocked = "SERVICE_BLOCKED"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
}

/// Message codes defined for signing baskets for HTTP Error code 403 (FORBIDDEN).
public enum MessageCode403SBS: String, Codable, CaseIterable {
    case consentUnknown = "CONSENT_UNKNOWN"
    case serviceBlocked = "SERVICE_BLOCKED"
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case resourceExpired = "RESOURCE_EXPIRED"
}

/// Message codes defined for PIS for HTTP Error code 404 (NOT FOUND).
public enum MessageCode404PIS: String, Codable, CaseIterable {
    case resourceUnknown = "RESOURCE_UNKNOWN"
    case productUnknown = "PRODUCT_UNKNOWN"
}

/// Message codes defined for AIS for HTTP Error code 404 (NOT FOUND).
public enum MessageCode404AIS: String, Codable, CaseIterable {
    case resourceUnknown = "RESOURCE_UNKNOWN"
}

/// Message codes defined for PIIS for HTTP Error code 404 (NOT FOUND).
public enum MessageCode404PIIS: String, Codable, CaseIterable {
    case resourceUnknown = "RESOURCE_UNKNOWN"
}

/// Message codes defined for signing baskets for HTTP Error code 404 (NOT FOUND).
public enum MessageCode404SBS: String, Codable, CaseIterable {
    case resourceUnknown = "RESOURCE_UNKNOWN"
}

/// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
public enum MessageCode405PIS: String, Codable, CaseIterable {
    case serviceInvalid = "SERVICE_INVALID"
}

/// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
public enum MessageCode405PISCANC: String, Codable, CaseIterable {
    case cancellationInvalid = "CANCELLATION_INVALID"
    case serviceInvalid = "SERVICE_INVALID"
}

/// Message codes defined for AIS for HTTP Error code 405 (METHOD NOT ALLOWED).
public enum MessageCode405AIS: String, Codable, CaseIterable {
    case serviceInvalid = "SERVICE_INVALID"
}

/// Message codes defined for PIIS for HTTP Error code 405 (METHOD NOT ALLOWED).
public enum MessageCode405PIIS: String, Codable, CaseIterable {
    case serviceInvalid = "SERVICE_INVALID"
}

/// Message codes defined for SBS for HTTP Error code 405 (METHOD NOT ALLOWED).
public enum MessageCode405SBS: String, Codable, CaseIterable {
    case serviceInvalid = "SERVICE_INVALID"
}

/// Message codes defined for AIS for HTTP Error code 406 (NOT ACCEPTABLE).
public enum MessageCode406AIS: String, Codable, CaseIterable {
    case requestedFormatsInvalid = "REQUESTED_FORMATS_INVALID"
}

/// Message codes defined for AIS for HTTP Error code 409 (CONFLICT).
public enum MessageCode409AIS: String, Codable, CaseIterable {
    case statusInvalid = "STATUS_INVALID"
}

/// Message codes defined for PIS for HTTP Error code 409 (CONFLICT).
public enum MessageCode409PIS: String, Codable, CaseIterable {
    case statusInvalid = "STATUS_INVALID"
}

/// Message codes defined for PIIS for HTTP Error code 409 (CONFLICT).
public enum MessageCode409PIIS: String, Codable, CaseIterable {
    case statusInvalid = "STATUS_INVALID"
}

/// Message codes defined for signing baskets for HTTP Error code 409 (CONFLICT).
public enum MessageCode409SBS: String, Codable, CaseIterable {
    case referenceStatusInvalid = "REFERENCE_STATUS_INVALID"
    case statusInvalid = "STATUS_INVALID"
}

/// Message codes for HTTP Error code 429 (TOO MANY REQUESTS).
public enum MessageCode429AIS: String, Codable, CaseIterable {
    case accessExceeded = "ACCESS_EXCEEDED"
}

public struct TppMessage2XX: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes for HTTP Error codes 2XX.
    public var code: MessageCode2XX
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode2XX, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage400AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode400AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage400PIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIS for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400PIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode400PIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage400PIIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIIS for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400PIIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode400PIIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage400SBS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for signing baskets for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400SBS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode400SBS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage401PIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIS for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401PIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode401PIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage401AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode401AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage401PIIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIIS for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401PIIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode401PIIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage401SBS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for signing baskets for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401SBS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode401SBS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage403PIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined defined for PIS for PIS for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403PIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode403PIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage403AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode403AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage403PIIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIIS for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403PIIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode403PIIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage403SBS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for signing baskets for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403SBS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode403SBS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage404PIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIS for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404PIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode404PIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage404AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode404AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage404PIIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIIS for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404PIIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode404PIIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage404SBS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for signing baskets for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404SBS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode404SBS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage405PIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405PIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode405PIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage405PISCANC: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405PISCANC
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode405PISCANC, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage405AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode405AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage405PIIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405PIIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode405PIIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage405SBS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for SBS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405SBS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode405SBS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage409PIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIS for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409PIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode409PIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage406AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 406 (NOT ACCEPTABLE).
    public var code: MessageCode406AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode406AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage409AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for AIS for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode409AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage409PIIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for PIIS for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409PIIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode409PIIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage409SBS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes defined for signing baskets for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409SBS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode409SBS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

public struct TppMessage429AIS: Codable {
    /// Category of the TPP message category.
    public var category: TppMessageCategory
    /// Message codes for HTTP Error code 429 (TOO MANY REQUESTS).
    public var code: MessageCode429AIS
    public var path: String?
    /// Additional explaining text to the TPP.
    public var text: String?

    public init(category: TppMessageCategory, code: MessageCode429AIS, path: String? = nil, text: String? = nil) {
        self.category = category
        self.code = code
        self.path = path
        self.text = text
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 400 for PIS.
public struct Error400PIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIS for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIS for HTTP Error code 400 (BAD_REQUEST).
        public var code: MessageCode400PIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode400PIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode400PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 400 for AIS.
public struct Error400AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 400 (BAD_REQUEST).
        public var code: MessageCode400AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode400AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode400AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 400 for PIIS.
public struct Error400PIIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIIS for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400PIIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIIS for HTTP Error code 400 (BAD_REQUEST).
        public var code: MessageCode400PIIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode400PIIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode400PIIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 400 for signing baskets.
public struct Error400SBS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for signing baskets for HTTP Error code 400 (BAD_REQUEST).
    public var code: MessageCode400SBS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for signing baskets for HTTP Error code 400 (BAD_REQUEST).
        public var code: MessageCode400SBS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode400SBS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode400SBS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 401 for PIS.
public struct Error401PIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIS for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIS for HTTP Error code 401 (UNAUTHORIZED).
        public var code: MessageCode401PIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode401PIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode401PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 401 for AIS.
public struct Error401AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 401 (UNAUTHORIZED).
        public var code: MessageCode401AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode401AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode401AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 401 for PIIS.
public struct Error401PIIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIS for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIIS for HTTP Error code 401 (UNAUTHORIZED).
        public var code: MessageCode401PIIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode401PIIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode401PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 401 for signing baskets.
public struct Error401SBS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for signing baskets for HTTP Error code 401 (UNAUTHORIZED).
    public var code: MessageCode401SBS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for signing baskets for HTTP Error code 401 (UNAUTHORIZED).
        public var code: MessageCode401SBS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode401SBS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode401SBS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 403 for PIS.
public struct Error403PIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined defined for PIS for PIS for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined defined for PIS for PIS for HTTP Error code 403 (FORBIDDEN).
        public var code: MessageCode403PIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode403PIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode403PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 403 for AIS.
public struct Error403AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 403 (FORBIDDEN).
        public var code: MessageCode403AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode403AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode403AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 403 for PIIS.
public struct Error403PIIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIIS for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403PIIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIIS for HTTP Error code 403 (FORBIDDEN).
        public var code: MessageCode403PIIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode403PIIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode403PIIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 403 for signing baskets.
public struct Error403SBS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for signing baskets for HTTP Error code 403 (FORBIDDEN).
    public var code: MessageCode403SBS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for signing baskets for HTTP Error code 403 (FORBIDDEN).
        public var code: MessageCode403SBS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode403SBS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode403SBS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 404 for PIS.
public struct Error404PIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIS for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIS for HTTP Error code 404 (NOT FOUND).
        public var code: MessageCode404PIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode404PIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode404PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 404 for AIS.
public struct Error404AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 404 (NOT FOUND).
        public var code: MessageCode404AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode404AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode404AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 404 for PIIS.
public struct Error404PIIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIIS for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404PIIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIIS for HTTP Error code 404 (NOT FOUND).
        public var code: MessageCode404PIIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode404PIIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode404PIIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 404 for signing baskets.
public struct Error404SBS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for signing baskets for HTTP Error code 404 (NOT FOUND).
    public var code: MessageCode404SBS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for signing baskets for HTTP Error code 404 (NOT FOUND).
        public var code: MessageCode404SBS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode404SBS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode404SBS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 405 for PIS.
public struct Error405PIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
        public var code: MessageCode405PIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode405PIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode405PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 405 for a pament cancelation (PIS).
public struct Error405PISCANC: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405PISCANC
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for payment cancelations PIS for HTTP Error code 405 (METHOD NOT ALLOWED).
        public var code: MessageCode405PISCANC

        public init(title: String? = nil, detail: String? = nil, code: MessageCode405PISCANC) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode405PISCANC, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 405 for AIS.
public struct Error405AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 405 (METHOD NOT ALLOWED).
        public var code: MessageCode405AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode405AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode405AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 405 for PIIS.
public struct Error405PIIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIIS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405PIIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIIS for HTTP Error code 405 (METHOD NOT ALLOWED).
        public var code: MessageCode405PIIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode405PIIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode405PIIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 405 for signing baskets.
public struct Error405SBS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for SBS for HTTP Error code 405 (METHOD NOT ALLOWED).
    public var code: MessageCode405SBS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for SBS for HTTP Error code 405 (METHOD NOT ALLOWED).
        public var code: MessageCode405SBS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode405SBS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode405SBS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 406 for AIS.
public struct Error406AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 406 (NOT ACCEPTABLE).
    public var code: MessageCode406AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 406 (NOT ACCEPTABLE).
        public var code: MessageCode406AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode406AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode406AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 409 for PIS.
public struct Error409PIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIS for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409PIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIS for HTTP Error code 409 (CONFLICT).
        public var code: MessageCode409PIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode409PIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode409PIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 409 for AIS.
public struct Error409AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for AIS for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for AIS for HTTP Error code 409 (CONFLICT).
        public var code: MessageCode409AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode409AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode409AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 409 for PIIS.
public struct Error409PIIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for PIIS for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409PIIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for PIIS for HTTP Error code 409 (CONFLICT).
        public var code: MessageCode409PIIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode409PIIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode409PIIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 409 for signing baskets.
public struct Error409SBS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes defined for signing baskets for HTTP Error code 409 (CONFLICT).
    public var code: MessageCode409SBS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807].
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes defined for signing baskets for HTTP Error code 409 (CONFLICT).
        public var code: MessageCode409SBS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode409SBS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode409SBS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// Standardised definition of reporting error information according to [RFC7807]
/// in case of a HTTP error code 429 for AIS.
public struct Error429AIS: Codable {
    /// A URI reference [RFC3986] that identifies the problem type.
    /// Remark For Future: These URI will be provided by NextGen in future.
    public var type: URL
    /// Short human readable description of error type.
    /// Could be in local language.
    /// To be provided by ASPSPs.
    public var title: String?
    /// Detailed human readable text specific to this instance of the error.
    /// XPath might be used to point to the issue generating the error in addition.
    /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
    public var detail: String?
    /// Message codes for HTTP Error code 429 (TOO MANY REQUESTS).
    public var code: MessageCode429AIS
    /// Array of Error Information Blocks.
    /// 
    /// Might be used if more than one error is to be communicated
    public var additionalErrors: [AdditionalError]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    /// This is a data element to support the declaration of additional errors in the context of [RFC7807]
    /// in case of a HTTP error code 429 for.
    public struct AdditionalError: Codable {
        /// Short human readable description of error type.
        /// Could be in local language.
        /// To be provided by ASPSPs.
        public var title: String?
        /// Detailed human readable text specific to this instance of the error.
        /// XPath might be used to point to the issue generating the error in addition.
        /// Remark for Future: In future, a dedicated field might be introduced for the XPath.
        public var detail: String?
        /// Message codes for HTTP Error code 429 (TOO MANY REQUESTS).
        public var code: MessageCode429AIS

        public init(title: String? = nil, detail: String? = nil, code: MessageCode429AIS) {
            self.title = title
            self.detail = detail
            self.code = code
        }
    }

    public init(type: URL, title: String? = nil, detail: String? = nil, code: MessageCode429AIS, additionalErrors: [AdditionalError]? = nil, links: [String: HrefType]? = nil) {
        self.type = type
        self.title = title
        self.detail = detail
        self.code = code
        self.additionalErrors = additionalErrors
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case type
        case title
        case detail
        case code
        case additionalErrors
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 400.
public struct Error400NGPIS: Codable {
    public var tppMessages: [TppMessage400PIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage400PIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 400.
public struct Error400NGAIS: Codable {
    public var tppMessages: [TppMessage400AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage400AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 400.
public struct Error400NGPIIS: Codable {
    public var tppMessages: [TppMessage400PIIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage400PIIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 400.
public struct Error400NGSBS: Codable {
    public var tppMessages: [TppMessage400SBS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage400SBS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error401NGPIS: Codable {
    public var tppMessages: [TppMessage401PIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage401PIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error401NGAIS: Codable {
    public var tppMessages: [TppMessage401AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage401AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error401NGPIIS: Codable {
    public var tppMessages: [TppMessage401PIIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage401PIIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error401NGSBS: Codable {
    public var tppMessages: [TppMessage401SBS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage401SBS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 403.
public struct Error403NGPIS: Codable {
    public var tppMessages: [TppMessage403PIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage403PIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 403.
public struct Error403NGAIS: Codable {
    public var tppMessages: [TppMessage403AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage403AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 403.
public struct Error403NGPIIS: Codable {
    public var tppMessages: [TppMessage403PIIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage403PIIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 403.
public struct Error403NGSBS: Codable {
    public var tppMessages: [TppMessage403SBS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage403SBS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 404.
public struct Error404NGPIS: Codable {
    public var tppMessages: [TppMessage404PIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage404PIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 404.
public struct Error404NGAIS: Codable {
    public var tppMessages: [TppMessage404AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage404AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 404.
public struct Error404NGPIIS: Codable {
    public var tppMessages: [TppMessage404PIIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage404PIIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 404.
public struct Error404NGSBS: Codable {
    public var tppMessages: [TppMessage404SBS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage404SBS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error405NGPIS: Codable {
    public var tppMessages: [TppMessage405PIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage405PIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error405NGPISCANC: Codable {
    public var tppMessages: [TppMessage405PISCANC]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage405PISCANC]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error405NGAIS: Codable {
    public var tppMessages: [TppMessage405AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage405AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error405NGPIIS: Codable {
    public var tppMessages: [TppMessage405PIIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage405PIIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 401.
public struct Error405NGSBS: Codable {
    public var tppMessages: [TppMessage405SBS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage405SBS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 406.
public struct Error406NGAIS: Codable {
    public var tppMessages: [TppMessage406AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage406AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 409.
///
/// Example:
///
/// [
///   {
///     "category" : "ERROR",
///     "code" : "STATUS_INVALID",
///     "text" : "additional text information of the ASPSP up to 500 characters"
///   }
/// ]
public struct Error409NGPIS: Codable {
    public var tppMessages: [TppMessage409PIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage409PIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 409.
///
/// Example:
///
/// [
///   {
///     "category" : "ERROR",
///     "code" : "STATUS_INVALID",
///     "text" : "additional text information of the ASPSP up to 500 characters"
///   }
/// ]
public struct Error409NGAIS: Codable {
    public var tppMessages: [TppMessage409AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage409AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 409.
///
/// Example:
///
/// [
///   {
///     "category" : "ERROR",
///     "code" : "STATUS_INVALID",
///     "text" : "additional text information of the ASPSP up to 500 characters"
///   }
/// ]
public struct Error409NGPIIS: Codable {
    public var tppMessages: [TppMessage409PIIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage409PIIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 409.
///
/// Example:
///
/// [
///   {
///     "category" : "ERROR",
///     "code" : "STATUS_INVALID",
///     "text" : "additional text information of the ASPSP up to 500 characters"
///   }
/// ]
public struct Error409NGSBS: Codable {
    public var tppMessages: [TppMessage409SBS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage409SBS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

/// NextGen specific definition of reporting error information in case of a HTTP error code 429.
///
/// Example:
///
/// [
///   {
///     "category" : "ERROR",
///     "code" : "ACCESS_EXCEEDED",
///     "text" : "additional text information of the ASPSP up to 500 characters"
///   }
/// ]
public struct Error429NGAIS: Codable {
    public var tppMessages: [TppMessage429AIS]?
    /// A _link object with all availabel link types.
    public var links: [String: HrefType]?

    public init(tppMessages: [TppMessage429AIS]? = nil, links: [String: HrefType]? = nil) {
        self.tppMessages = tppMessages
        self.links = links
    }

    private enum CodingKeys: String, CodingKey {
        case tppMessages
        case links = "_links"
    }
}

public enum AnyJSON: Equatable, Codable {
    case string(String)
    case number(Double)
    case object([String: AnyJSON])
    case array([AnyJSON])
    case bool(Bool)

    var value: Any {
        switch self {
        case .string(let string): return string
        case .number(let double): return double
        case .object(let dictionary): return dictionary
        case .array(let array): return array
        case .bool(let bool): return bool
        }
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case let .array(array): try container.encode(array)
        case let .object(object): try container.encode(object)
        case let .string(string): try container.encode(string)
        case let .number(number): try container.encode(number)
        case let .bool(bool): try container.encode(bool)
        }
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        if let object = try? container.decode([String: AnyJSON].self) {
            self = .object(object)
        } else if let array = try? container.decode([AnyJSON].self) {
            self = .array(array)
        } else if let string = try? container.decode(String.self) {
            self = .string(string)
        } else if let bool = try? container.decode(Bool.self) {
            self = .bool(bool)
        } else if let number = try? container.decode(Double.self) {
            self = .number(number)
        } else {
            throw DecodingError.dataCorrupted(
                .init(codingPath: decoder.codingPath, debugDescription: "Invalid JSON value.")
            )
        }
    }
}

struct StringCodingKey: CodingKey, ExpressibleByStringLiteral {
    private let string: String
    private var int: Int?

    var stringValue: String { return string }

    init(string: String) {
        self.string = string
    }

    init?(stringValue: String) {
        self.string = stringValue
    }

    var intValue: Int? { return int }

    init?(intValue: Int) {
        self.string = String(describing: intValue)
        self.int = intValue
    }

    init(stringLiteral value: String) {
        self.string = value
    }
}
