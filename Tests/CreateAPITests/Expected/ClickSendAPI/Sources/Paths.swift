// Generated by Create API
// https://github.com/kean/CreateAPI
//
// swiftlint:disable all

import Foundation
import Get

extension Paths {
    public static var account: Account {
        Account(path: "/account")
    }

    public struct Account {
        /// Path: `/account`
        public let path: String

        /// Get account
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new account
        ///
        /// **Note:** *Authentication isn't required to create a new account.*
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "account_name" : "The Awesome Company",
        ///   "country" : "US",
        ///   "password" : "pass",
        ///   "user_email" : "johndoe1@awesome.com",
        ///   "user_first_name" : "John",
        ///   "user_last_name" : "Doe",
        ///   "user_phone" : "518-481-1001",
        ///   "username" : "johndoe1"
        /// }
        public struct PostRequest: Encodable {
            /// Your delivery to value.
            public var accountName: String
            /// Your country.
            public var country: String
            /// Your password.
            public var password: String
            /// Your email.
            public var userEmail: String
            /// Your first name.
            public var userFirstName: String
            /// Your last name.
            public var userLastName: String
            /// Your phone number in E.164 format.
            public var userPhone: String
            /// Your username.
            public var username: String

            public init(accountName: String, country: String, password: String, userEmail: String, userFirstName: String, userLastName: String, userPhone: String, username: String) {
                self.accountName = accountName
                self.country = country
                self.password = password
                self.userEmail = userEmail
                self.userFirstName = userFirstName
                self.userLastName = userLastName
                self.userPhone = userPhone
                self.username = username
            }

            private enum CodingKeys: String, CodingKey {
                case accountName = "account_name"
                case country
                case password
                case userEmail = "user_email"
                case userFirstName = "user_first_name"
                case userLastName = "user_last_name"
                case userPhone = "user_phone"
                case username
            }
        }

        /// Update Account
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "account_name" : "The Awesome Company",
        ///   "country" : "AU",
        ///   "password" : "pass",
        ///   "private_uploads" : 1,
        ///   "setting_sms_hide_business_name" : 1,
        ///   "setting_sms_hide_your_number" : 0,
        ///   "timezone" : "Australia\/Melbourne",
        ///   "user_email" : "johndoe@awesome.com",
        ///   "user_first_name" : "John",
        ///   "user_last_name" : "Doe",
        ///   "user_phone" : "518-481-1002",
        ///   "username" : "johndoe"
        /// }
        public struct PutRequest: Encodable {
            /// Your delivery to value.
            public var accountName: String
            /// Your country.
            public var country: String
            /// Your password.
            public var password: String
            /// Set the private uploads flag. 0 or 1 only.
            public var privateUploads: Double?
            /// Set the private uploads flag. 0 or 1 only.
            public var settingSmsHideBusinessName: Double?
            /// Set the private uploads flag. 0 or 1 only.
            public var settingSmsHideYourNumber: Double?
            /// Timezone.
            public var timezone: String
            /// Your email.
            public var userEmail: String
            /// Your first name.
            public var userFirstName: String
            /// Your last name.
            public var userLastName: String
            /// Your phone number in E.164 format.
            public var userPhone: String
            /// Your username.
            public var username: String

            public init(accountName: String, country: String, password: String, privateUploads: Double? = nil, settingSmsHideBusinessName: Double? = nil, settingSmsHideYourNumber: Double? = nil, timezone: String, userEmail: String, userFirstName: String, userLastName: String, userPhone: String, username: String) {
                self.accountName = accountName
                self.country = country
                self.password = password
                self.privateUploads = privateUploads
                self.settingSmsHideBusinessName = settingSmsHideBusinessName
                self.settingSmsHideYourNumber = settingSmsHideYourNumber
                self.timezone = timezone
                self.userEmail = userEmail
                self.userFirstName = userFirstName
                self.userLastName = userLastName
                self.userPhone = userPhone
                self.username = username
            }

            private enum CodingKeys: String, CodingKey {
                case accountName = "account_name"
                case country
                case password
                case privateUploads = "private_uploads"
                case settingSmsHideBusinessName = "setting_sms_hide_business_name"
                case settingSmsHideYourNumber = "setting_sms_hide_your_number"
                case timezone
                case userEmail = "user_email"
                case userFirstName = "user_first_name"
                case userLastName = "user_last_name"
                case userPhone = "user_phone"
                case username
            }
        }
    }
}

extension Paths {
    public static var accountVerify: AccountVerify {
        AccountVerify(path: "/account-verify")
    }

    public struct AccountVerify {
        /// Path: `/account-verify`
        public let path: String
    }
}

extension Paths.AccountVerify {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/account-verify/send`
        public let path: String

        /// Send account activation token
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "country" : "US",
        ///   "type" : "sms",
        ///   "user_phone" : "352-394-4199"
        /// }
        public struct PutRequest: Encodable {
            public var country: String?
            public var type: String?
            public var userPhone: String?

            public init(country: String? = nil, type: String? = nil, userPhone: String? = nil) {
                self.country = country
                self.type = type
                self.userPhone = userPhone
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case type
                case userPhone = "user_phone"
            }
        }
    }
}

extension Paths.AccountVerify {
    public var verify: Verify {
        Verify(path: path + "/verify")
    }

    public struct Verify {
        /// Path: `/account-verify/verify`
        public let path: String
    }
}

extension Paths.AccountVerify.Verify {
    public func activationToken(_ activationToken: String) -> WithActivationToken {
        WithActivationToken(path: "\(path)/\(activationToken)")
    }

    public struct WithActivationToken {
        /// Path: `/account-verify/verify/{activation_token}`
        public let path: String

        /// Verify new account
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Account {
    public var usage: Usage {
        Usage(path: path + "/usage")
    }

    public struct Usage {
        /// Path: `/account/usage`
        public let path: String
    }
}

extension Paths.Account.Usage {
    public func year(_ year: String) -> WithYear {
        WithYear(path: "\(path)/\(year)")
    }

    public struct WithYear {
        /// Path: `/account/usage/{year}`
        public let path: String
    }
}

extension Paths.Account.Usage.WithYear {
    public func month(_ month: String) -> WithMonth {
        WithMonth(path: "\(path)/\(month)")
    }

    public struct WithMonth {
        /// Path: `/account/usage/{year}/{month}`
        public let path: String
    }
}

extension Paths.Account.Usage.WithYear.WithMonth {
    public func type(_ type: String) -> WithType {
        WithType(path: "\(path)/\(type)")
    }

    public struct WithType {
        /// Path: `/account/usage/{year}/{month}/{type}`
        public let path: String

        /// Account Usage
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var automations: Automations {
        Automations(path: "/automations")
    }

    public struct Automations {
        /// Path: `/automations`
        public let path: String
    }
}

extension Paths.Automations {
    public var email: Email {
        Email(path: path + "/email")
    }

    public struct Email {
        /// Path: `/automations/email`
        public let path: String
    }
}

extension Paths.Automations.Email {
    public var receipt: Receipt {
        Receipt(path: path + "/receipt")
    }

    public struct Receipt {
        /// Path: `/automations/email/receipt`
        public let path: String

        /// List Rules
        public var get: Request<String> {
            .get(path)
        }

        /// Create a New Rule
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "URL",
        ///   "action_address" : "http:\/\/yourdomain.com",
        ///   "enabled" : 1,
        ///   "match_type" : 0,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PostRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Enabled.
            public var enabled: Double
            /// Match Type. 0=All reports.
            public var matchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, enabled: Double, matchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }
    }
}

extension Paths.Automations.Email.Receipt {
    public func ruleID(_ ruleID: String) -> WithRuleID {
        WithRuleID(path: "\(path)/\(ruleID)")
    }

    public struct WithRuleID {
        /// Path: `/automations/email/receipt/{rule_id}`
        public let path: String

        /// Get a Specific Rule
        public var get: Request<String> {
            .get(path)
        }

        /// Update a Rule
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "URL",
        ///   "action_address" : "http:\/\/yourdomain.com",
        ///   "enabled" : 1,
        ///   "match_type" : 0,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PutRequest: Encodable {
            /// Action.
            public var action: String?
            /// Action Address.
            public var actionAddress: String?
            /// Enabled.
            public var enabled: Double?
            /// Match Type. 0=All reports.
            public var matchType: Double?
            /// Rule Name.
            public var ruleName: String?

            public init(action: String? = nil, actionAddress: String? = nil, enabled: Double? = nil, matchType: Double? = nil, ruleName: String? = nil) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }

        /// Delete a Rule
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Automations {
    public var fax: Fax {
        Fax(path: path + "/fax")
    }

    public struct Fax {
        /// Path: `/automations/fax`
        public let path: String
    }
}

extension Paths.Automations.Fax {
    public var inbound: Inbound {
        Inbound(path: path + "/inbound")
    }

    public struct Inbound {
        /// Path: `/automations/fax/inbound`
        public let path: String

        /// List rules
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new rule
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "email@domain.com",
        ///   "dedicated_number" : "+61298441484",
        ///   "enabled" : 1,
        ///   "rule_name" : "Rule Name"
        /// }
        public struct PostRequest: Encodable {
            /// Action
            public var action: String
            /// Action Address
            public var actionAddress: String
            /// Decicated Number
            public var dedicatedNumber: String
            /// Enable
            public var enabled: Double
            /// Rule Name
            public var ruleName: String

            public init(action: String, actionAddress: String, dedicatedNumber: String, enabled: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.dedicatedNumber = dedicatedNumber
                self.enabled = enabled
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case dedicatedNumber = "dedicated_number"
                case enabled
                case ruleName = "rule_name"
            }
        }
    }
}

extension Paths.Automations.Fax.Inbound {
    public func inboundRuleID(_ inboundRuleID: String) -> WithInboundRuleID {
        WithInboundRuleID(path: "\(path)/\(inboundRuleID)")
    }

    public struct WithInboundRuleID {
        /// Path: `/automations/fax/inbound/{inbound_rule_id}`
        public let path: String

        /// Get a specific rule
        public var get: Request<String> {
            .get(path)
        }

        /// Update a rule
        public func put(_ body: PutRequest) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "email@domain.com",
        ///   "dedicated_number" : "+61298441484",
        ///   "enabled" : 1,
        ///   "rule_name" : "Rule Name"
        /// }
        public struct PutRequest: Encodable {
            /// Action
            public var action: String
            /// Action Address
            public var actionAddress: String
            /// Decicated Number
            public var dedicatedNumber: String
            /// Enable
            public var enabled: Double
            /// Rule Name
            public var ruleName: String

            public init(action: String, actionAddress: String, dedicatedNumber: String, enabled: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.dedicatedNumber = dedicatedNumber
                self.enabled = enabled
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case dedicatedNumber = "dedicated_number"
                case enabled
                case ruleName = "rule_name"
            }
        }

        /// Delete a rule
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Automations.Fax {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/automations/fax/receipts`
        public let path: String

        /// List Rules
        public var get: Request<String> {
            .get(path)
        }

        /// Create a New Rule
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "enabled" : 1,
        ///   "match_type" : 2,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PostRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Enabled.
            public var enabled: Double
            /// Match Type. 0=All reports.
            public var matchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, enabled: Double, matchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }
    }
}

extension Paths.Automations.Fax.Receipts {
    public func ruleID(_ ruleID: String) -> WithRuleID {
        WithRuleID(path: "\(path)/\(ruleID)")
    }

    public struct WithRuleID {
        /// Path: `/automations/fax/receipts/{rule_id}`
        public let path: String

        /// Get a Specific Rule
        public var get: Request<String> {
            .get(path)
        }

        /// Update a Rule
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "enabled" : 1,
        ///   "match_type" : 1,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PutRequest: Encodable {
            /// Action.
            public var action: String?
            /// Action Address.
            public var actionAddress: String?
            /// Enabled.
            public var enabled: Double?
            /// Match Type. 0=All reports.
            public var matchType: Double?
            /// Rule Name.
            public var ruleName: String?

            public init(action: String? = nil, actionAddress: String? = nil, enabled: Double? = nil, matchType: Double? = nil, ruleName: String? = nil) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }

        /// Delete a Rule
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Automations {
    public var sms: Sms {
        Sms(path: path + "/sms")
    }

    public struct Sms {
        /// Path: `/automations/sms`
        public let path: String
    }
}

extension Paths.Automations.Sms {
    public var inbound: Inbound {
        Inbound(path: path + "/inbound")
    }

    public struct Inbound {
        /// Path: `/automations/sms/inbound`
        public let path: String

        /// Create a new rule
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "dedicated_number" : "+61298441484",
        ///   "enabled" : 1,
        ///   "message_search_term" : "My Search Term",
        ///   "message_search_type" : 3,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PostRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Dedicated Number.
            public var dedicatedNumber: Double
            /// Enabled.
            public var enabled: Double
            /// Message Search Term.
            public var messageSearchTerm: String
            /// Message Search Type: 0=Any message, 1=starts with, 2=contains, 3=does not contain.
            public var messageSearchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, dedicatedNumber: Double, enabled: Double, messageSearchTerm: String, messageSearchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.dedicatedNumber = dedicatedNumber
                self.enabled = enabled
                self.messageSearchTerm = messageSearchTerm
                self.messageSearchType = messageSearchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case dedicatedNumber = "dedicated_number"
                case enabled
                case messageSearchTerm = "message_search_term"
                case messageSearchType = "message_search_type"
                case ruleName = "rule_name"
            }
        }
    }
}

extension Paths.Automations.Sms.Inbound {
    public func inboundRuleID(_ inboundRuleID: String) -> WithInboundRuleID {
        WithInboundRuleID(path: "\(path)/\(inboundRuleID)")
    }

    public struct WithInboundRuleID {
        /// Path: `/automations/sms/inbound/{inbound_rule_id}`
        public let path: String

        /// Get a specific rule
        public var get: Request<String> {
            .get(path)
        }

        /// Update a rule
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "dedicated_number" : "+61298441484",
        ///   "enabled" : 1,
        ///   "message_search_term" : "My Search Term",
        ///   "message_search_type" : 3,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PutRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Dedicated Number
            public var dedicatedNumber: String
            /// Enabled.
            public var enabled: Double
            /// Message Search Term.
            public var messageSearchTerm: String
            /// Message Search Type: 0=Any message, 1=starts with, 2=contains, 3=does not contain.
            public var messageSearchType: Double

            public init(action: String, actionAddress: String, dedicatedNumber: String, enabled: Double, messageSearchTerm: String, messageSearchType: Double) {
                self.action = action
                self.actionAddress = actionAddress
                self.dedicatedNumber = dedicatedNumber
                self.enabled = enabled
                self.messageSearchTerm = messageSearchTerm
                self.messageSearchType = messageSearchType
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case dedicatedNumber = "dedicated_number"
                case enabled
                case messageSearchTerm = "message_search_term"
                case messageSearchType = "message_search_type"
            }
        }

        /// Delete a rule
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Automations.Sms {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/automations/sms/receipts`
        public let path: String

        /// List rules
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new rule
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "enabled" : 1,
        ///   "match_type" : 3,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PostRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Enabled.
            public var enabled: Double
            /// Match Type. 0=All reports, 1=Only failed, 2=Only successful.
            public var matchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, enabled: Double, matchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }
    }
}

extension Paths.Automations.Sms.Receipts {
    public func receiptRuleID(_ receiptRuleID: String) -> WithReceiptRuleID {
        WithReceiptRuleID(path: "\(path)/\(receiptRuleID)")
    }

    public struct WithReceiptRuleID {
        /// Path: `/automations/sms/receipts/{receipt_rule_id}`
        public let path: String

        /// Get a specific rule
        public var get: Request<String> {
            .get(path)
        }

        /// Update a rule
        public func put(_ body: PutRequest) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "enabled" : 1,
        ///   "match_type" : 3,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PutRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Enabled.
            public var enabled: Double
            /// Match Type. 0=All reports, 1=Only failed, 2=Only successful.
            public var matchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, enabled: Double, matchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }

        /// Delete a rule
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Automations {
    public var voice: Voice {
        Voice(path: path + "/voice")
    }

    public struct Voice {
        /// Path: `/automations/voice`
        public let path: String
    }
}

extension Paths.Automations.Voice {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/automations/voice/receipts`
        public let path: String

        /// List rules
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new rule
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "enabled" : 1,
        ///   "match_type" : 3,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PostRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Enabled.
            public var enabled: Double
            /// Match Type. 0=All reports, 1=Only failed, 2=Only successful.
            public var matchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, enabled: Double, matchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }
    }
}

extension Paths.Automations.Voice.Receipts {
    public func receiptRuleID(_ receiptRuleID: String) -> WithReceiptRuleID {
        WithReceiptRuleID(path: "\(path)/\(receiptRuleID)")
    }

    public struct WithReceiptRuleID {
        /// Path: `/automations/voice/receipts/{receipt_rule_id}`
        public let path: String

        /// Get a specific rule
        public var get: Request<String> {
            .get(path)
        }

        /// Update a rule
        public func put(_ body: PutRequest) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "action" : "EMAIL_FIXED",
        ///   "action_address" : "john@doe.com",
        ///   "enabled" : 1,
        ///   "match_type" : 3,
        ///   "rule_name" : "My Rule"
        /// }
        public struct PutRequest: Encodable {
            /// Action.
            public var action: String
            /// Action Address.
            public var actionAddress: String
            /// Enabled.
            public var enabled: Double
            /// Match Type. 0=All reports, 1=Only failed, 2=Only successful.
            public var matchType: Double
            /// Rule Name.
            public var ruleName: String

            public init(action: String, actionAddress: String, enabled: Double, matchType: Double, ruleName: String) {
                self.action = action
                self.actionAddress = actionAddress
                self.enabled = enabled
                self.matchType = matchType
                self.ruleName = ruleName
            }

            private enum CodingKeys: String, CodingKey {
                case action
                case actionAddress = "action_address"
                case enabled
                case matchType = "match_type"
                case ruleName = "rule_name"
            }
        }

        /// Delete a rule
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var contactSuggestions: ContactSuggestions {
        ContactSuggestions(path: "/contact-suggestions")
    }

    public struct ContactSuggestions {
        /// Path: `/contact-suggestions`
        public let path: String

        /// List Contact Suggestions
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var countries: Countries {
        Countries(path: "/countries")
    }

    public struct Countries {
        /// Path: `/countries`
        public let path: String

        /// Get all Countries
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var deliveryIssues: DeliveryIssues {
        DeliveryIssues(path: "/delivery-issues")
    }

    public struct DeliveryIssues {
        /// Path: `/delivery-issues`
        public let path: String

        /// Get Delivery Issues
        public var get: Request<String> {
            .get(path)
        }

        /// Create Delivery Issue
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "client_comments" : "test",
        ///   "description" : "This is a test",
        ///   "email_address" : "john_doe@user.com",
        ///   "message_id" : "B388828B-AD46-4366-8AD3-0305FF5E3FE5",
        ///   "type" : "SMS"
        /// }
        public struct PostRequest: Encodable {
            /// The user's comments.
            public var clientComments: String?
            /// The description of the message.
            public var description: String
            /// The user's email address.
            public var emailAddress: String
            /// The message id of the message.
            public var messageID: String
            /// The type of message, must be one of the following values: `SMS`, `MMS`, `VOICE`, `EMAIL_MARKETING`, `EMAIL_TRANSACTIONAL`, `FAX`, `POST`.
            public var type: String

            public init(clientComments: String? = nil, description: String, emailAddress: String, messageID: String, type: String) {
                self.clientComments = clientComments
                self.description = description
                self.emailAddress = emailAddress
                self.messageID = messageID
                self.type = type
            }

            private enum CodingKeys: String, CodingKey {
                case clientComments = "client_comments"
                case description
                case emailAddress = "email_address"
                case messageID = "message_id"
                case type
            }
        }
    }
}

extension Paths {
    public static var emailCampaigns: EmailCampaigns {
        EmailCampaigns(path: "/email-campaigns")
    }

    public struct EmailCampaigns {
        /// Path: `/email-campaigns`
        public let path: String

        /// Get All Email Campaigns
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.EmailCampaigns {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/email-campaigns/price`
        public let path: String

        /// Calculate Price
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "<p>This is a test<\/p>",
        ///   "from_email_address_id" : 2,
        ///   "from_name" : "From name",
        ///   "list_id" : 456,
        ///   "name" : "John Doe",
        ///   "subject" : "Lorem Ipsum",
        ///   "template_id" : 31
        /// }
        public struct PostRequest: Encodable {
            /// The allowed email address id.
            public var fromEmailAddressID: Double
            /// The name that will appear on the email.
            public var fromName: String
            /// The list id you want to access.
            public var listID: Double
            /// The name of the sender.
            public var name: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// The subject of the email campaign.
            public var subject: String
            /// The template id you want to use.
            public var templateID: Double

            public init(fromEmailAddressID: Double, fromName: String, listID: Double, name: String, schedule: Double? = nil, subject: String, templateID: Double) {
                self.fromEmailAddressID = fromEmailAddressID
                self.fromName = fromName
                self.listID = listID
                self.name = name
                self.schedule = schedule
                self.subject = subject
                self.templateID = templateID
            }

            private enum CodingKeys: String, CodingKey {
                case fromEmailAddressID = "from_email_address_id"
                case fromName = "from_name"
                case listID = "list_id"
                case name
                case schedule
                case subject
                case templateID = "template_id"
            }
        }
    }
}

extension Paths.EmailCampaigns {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/email-campaigns/send`
        public let path: String

        /// Create Email Campaign
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "<p>This is a test<\/p>",
        ///   "from_email_address_id" : 2,
        ///   "from_name" : "From name",
        ///   "list_id" : 456,
        ///   "name" : "John Doe",
        ///   "subject" : "Lorem Ipsum",
        ///   "template_id" : 31
        /// }
        public struct PostRequest: Encodable {
            /// The allowed email address id.
            public var fromEmailAddressID: Double
            /// The name that will appear on the email.
            public var fromName: String
            /// The list id you want to access.
            public var listID: Double
            /// The name of the sender.
            public var name: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// The subject of the email campaign.
            public var subject: String
            /// The template id you want to use.
            public var templateID: Double

            public init(fromEmailAddressID: Double, fromName: String, listID: Double, name: String, schedule: Double? = nil, subject: String, templateID: Double) {
                self.fromEmailAddressID = fromEmailAddressID
                self.fromName = fromName
                self.listID = listID
                self.name = name
                self.schedule = schedule
                self.subject = subject
                self.templateID = templateID
            }

            private enum CodingKeys: String, CodingKey {
                case fromEmailAddressID = "from_email_address_id"
                case fromName = "from_name"
                case listID = "list_id"
                case name
                case schedule
                case subject
                case templateID = "template_id"
            }
        }
    }
}

extension Paths.EmailCampaigns {
    public func campaignID(_ campaignID: String) -> WithCampaignID {
        WithCampaignID(path: "\(path)/\(campaignID)")
    }

    public struct WithCampaignID {
        /// Path: `/email-campaigns/{campaign_id}`
        public let path: String
    }
}

extension Paths.EmailCampaigns.WithCampaignID {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/email-campaigns/{campaign_id}/history`
        public let path: String

        /// Get Specific Email Campaign History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.EmailCampaigns {
    public func emailCampaignID(_ emailCampaignID: String) -> WithEmailCampaignID {
        WithEmailCampaignID(path: "\(path)/\(emailCampaignID)")
    }

    public struct WithEmailCampaignID {
        /// Path: `/email-campaigns/{email_campaign_id}`
        public let path: String

        /// Get Specific Email Campaign
        public var get: Request<String> {
            .get(path)
        }

        /// Update Email Campaign
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "<p>This is a test<\/p>",
        ///   "from_email_address_id" : 2,
        ///   "from_name" : "From name",
        ///   "list_id" : 456,
        ///   "name" : "John Doe",
        ///   "subject" : "Lorem Ipsum",
        ///   "template_id" : 31
        /// }
        public struct PutRequest: Encodable {
            /// The allowed email address id.
            public var fromEmailAddressID: Double?
            /// The name that will appear on the email.
            public var fromName: String?
            /// The list id you want to access.
            public var listID: Double?
            /// The name of the sender.
            public var name: String?
            /// Leave blank for immediate delivery. Will replace existing schedule (even if left blank). Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// The subject of the email campaign.
            public var subject: String?
            /// The template id you want to use.
            public var templateID: Double?

            public init(fromEmailAddressID: Double? = nil, fromName: String? = nil, listID: Double? = nil, name: String? = nil, schedule: Double? = nil, subject: String? = nil, templateID: Double? = nil) {
                self.fromEmailAddressID = fromEmailAddressID
                self.fromName = fromName
                self.listID = listID
                self.name = name
                self.schedule = schedule
                self.subject = subject
                self.templateID = templateID
            }

            private enum CodingKeys: String, CodingKey {
                case fromEmailAddressID = "from_email_address_id"
                case fromName = "from_name"
                case listID = "list_id"
                case name
                case schedule
                case subject
                case templateID = "template_id"
            }
        }
    }
}

extension Paths.EmailCampaigns.WithEmailCampaignID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/email-campaigns/{email_campaign_id}/cancel`
        public let path: String

        /// Cancel Email Campaign
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths {
    public static var email: Email {
        Email(path: "/email")
    }

    public struct Email {
        /// Path: `/email`
        public let path: String
    }
}

extension Paths.Email {
    public var addressVerify: AddressVerify {
        AddressVerify(path: path + "/address-verify")
    }

    public struct AddressVerify {
        /// Path: `/email/address-verify`
        public let path: String
    }
}

extension Paths.Email.AddressVerify {
    public func emailAddressID(_ emailAddressID: String) -> WithEmailAddressID {
        WithEmailAddressID(path: "\(path)/\(emailAddressID)")
    }

    public struct WithEmailAddressID {
        /// Path: `/email/address-verify/{email_address_id}`
        public let path: String
    }
}

extension Paths.Email.AddressVerify.WithEmailAddressID {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/email/address-verify/{email_address_id}/send`
        public let path: String

        /// Send Verification Token
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Email.AddressVerify.WithEmailAddressID {
    public var verify: Verify {
        Verify(path: path + "/verify")
    }

    public struct Verify {
        /// Path: `/email/address-verify/{email_address_id}/verify`
        public let path: String
    }
}

extension Paths.Email.AddressVerify.WithEmailAddressID.Verify {
    public func activationToken(_ activationToken: String) -> WithActivationToken {
        WithActivationToken(path: "\(path)/\(activationToken)")
    }

    public struct WithActivationToken {
        /// Path: `/email/address-verify/{email_address_id}/verify/{activation_token}`
        public let path: String

        /// Verify Allowed Email Address
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Email {
    public var addresses: Addresses {
        Addresses(path: path + "/addresses")
    }

    public struct Addresses {
        /// Path: `/email/addresses`
        public let path: String

        /// Get All Allowed Email Addresses
        public var get: Request<String> {
            .get(path)
        }

        /// Create Allowed Email Address
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "Body" : null,
        ///   "email_address" : "johndoe1@user.com"
        /// }
        public struct PostRequest: Encodable {
            /// {
            ///     "email_address" : "test222@user.com"
            /// }
            public var body: String?
            /// Your email.
            public var emailAddress: String

            public init(body: String? = nil, emailAddress: String) {
                self.body = body
                self.emailAddress = emailAddress
            }

            private enum CodingKeys: String, CodingKey {
                case body = "Body"
                case emailAddress = "email_address"
            }
        }
    }
}

extension Paths.Email.Addresses {
    public func emailAddressID(_ emailAddressID: String) -> WithEmailAddressID {
        WithEmailAddressID(path: "\(path)/\(emailAddressID)")
    }

    public struct WithEmailAddressID {
        /// Path: `/email/addresses/{email_address_id}`
        public let path: String

        /// Get Specific Allowed Email Address
        public var get: Request<String> {
            .get(path)
        }

        /// Delete Allowed Email Address
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Email {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/email/history`
        public let path: String

        /// Email History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email.History {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/email/history/export?filename={filename}`
        public let path: String

        /// Export History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email {
    public var masterTemplates: MasterTemplates {
        MasterTemplates(path: path + "/master-templates")
    }

    public struct MasterTemplates {
        /// Path: `/email/master-templates`
        public let path: String

        /// Get All Master Email Templates
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email {
    public var masterTemplatesCategories: MasterTemplatesCategories {
        MasterTemplatesCategories(path: path + "/master-templates-categories")
    }

    public struct MasterTemplatesCategories {
        /// Path: `/email/master-templates-categories`
        public let path: String

        /// Get All Master Template Categories
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email.MasterTemplatesCategories {
    public func categoryID(_ categoryID: String) -> WithCategoryID {
        WithCategoryID(path: "\(path)/\(categoryID)")
    }

    public struct WithCategoryID {
        /// Path: `/email/master-templates-categories/{category_id}`
        public let path: String

        /// Get Specific Email Template Category
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email.MasterTemplatesCategories.WithCategoryID {
    public var masterTemplates: MasterTemplates {
        MasterTemplates(path: path + "/master-templates")
    }

    public struct MasterTemplates {
        /// Path: `/email/master-templates-categories/{category_id}/master-templates`
        public let path: String

        /// Get All Templates For Category
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email.MasterTemplates {
    public func templateID(_ templateID: String) -> WithTemplateID {
        WithTemplateID(path: "\(path)/\(templateID)")
    }

    public struct WithTemplateID {
        /// Path: `/email/master-templates/{template_id}`
        public let path: String

        /// Get Specific Master Template
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Email {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/email/price`
        public let path: String

        /// Email Price
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "attachments" : [
        ///     {
        ///       "content" : "<string>",
        ///       "content_id" : "<string>",
        ///       "disposition" : "<string>",
        ///       "filename" : "<string>",
        ///       "type" : "<string>"
        ///     }
        ///   ],
        ///   "bcc" : [
        ///     {
        ///       "email" : "<string>",
        ///       "name" : "<string>"
        ///     }
        ///   ],
        ///   "body" : "<string>|required",
        ///   "cc" : [
        ///     {
        ///       "email" : "<string>",
        ///       "name" : "<string>"
        ///     }
        ///   ],
        ///   "from" : {
        ///     "email_address_id" : "<integer>|required",
        ///     "name" : "<string>"
        ///   },
        ///   "schedule" : "<integer>",
        ///   "subject" : "<string>|required",
        ///   "to" : [
        ///     {
        ///       "email" : "<string>|required",
        ///       "name" : "<string>"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// The attachments of the email. See sample request for more details.
            public var attachments: [AnyJSON]
            /// The bcc of the email. See sample request for more details.
            public var bcc: [AnyJSON]?
            /// The content of the email.
            public var body: String
            /// The cc of the email. See sample request for more details.
            public var cc: [AnyJSON]?
            /// The sender's email address id.
            public var fromEmailAddressID: Double
            /// The sender's name.
            public var fromName: String?
            /// The subject of the email.
            public var subject: String
            /// The recipients of the email. See sample request for more details.
            public var to: [AnyJSON]

            public init(attachments: [AnyJSON], bcc: [AnyJSON]? = nil, body: String, cc: [AnyJSON]? = nil, fromEmailAddressID: Double, fromName: String? = nil, subject: String, to: [AnyJSON]) {
                self.attachments = attachments
                self.bcc = bcc
                self.body = body
                self.cc = cc
                self.fromEmailAddressID = fromEmailAddressID
                self.fromName = fromName
                self.subject = subject
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case attachments
                case bcc
                case body
                case cc
                case fromEmailAddressID = "from.email_address_id"
                case fromName = "from.name"
                case subject
                case to
            }
        }
    }
}

extension Paths.Email {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/email/receipts`
        public let path: String

        /// Add a Test Delivery Receipt
        public func post(url: String) -> Request<String> {
            .post(path, body: ["url": url])
        }
    }
}

extension Paths.Email {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/email/send`
        public let path: String

        /// Email Send
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "attachments" : [
        ///     {
        ///       "content" : "ZmlsZSBjb250ZW50cw==",
        ///       "content_id" : "text",
        ///       "disposition" : "attachment",
        ///       "filename" : "text.txt",
        ///       "type" : "text\/plain"
        ///     }
        ///   ],
        ///   "bcc" : [
        ///     {
        ///       "email" : "test3@clicksend.com",
        ///       "name" : "Joseph Doe"
        ///     }
        ///   ],
        ///   "body" : "Lorem ipsum",
        ///   "cc" : [
        ///     {
        ///       "email" : "test2@clicksend.com",
        ///       "name" : "Jane Doe"
        ///     }
        ///   ],
        ///   "from" : {
        ///     "email_address_id" : 1,
        ///     "name" : "Joanne Doe"
        ///   },
        ///   "subject" : "Test subject",
        ///   "to" : [
        ///     {
        ///       "email" : "test@clicksend.com",
        ///       "name" : "John Doe"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// The attachments of the email.
            public var attachments: [AnyJSON]?
            /// The bcc of the email. Follows the same structure as `to`.
            public var bcc: [AnyJSON]?
            /// The content of the email.
            public var body: String
            /// The cc of the email. Follows the same structure as `to`.
            public var cc: [AnyJSON]?
            /// The sender's email address ID.
            public var fromEmailAddressID: Double
            /// The sender's name.
            public var fromName: String?
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// The recipients of the email.
            public var to: [AnyJSON]

            public init(attachments: [AnyJSON]? = nil, bcc: [AnyJSON]? = nil, body: String, cc: [AnyJSON]? = nil, fromEmailAddressID: Double, fromName: String? = nil, schedule: Double? = nil, to: [AnyJSON]) {
                self.attachments = attachments
                self.bcc = bcc
                self.body = body
                self.cc = cc
                self.fromEmailAddressID = fromEmailAddressID
                self.fromName = fromName
                self.schedule = schedule
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case attachments
                case bcc
                case body
                case cc
                case fromEmailAddressID = "from.email_address_id"
                case fromName = "from.name"
                case schedule
                case to
            }
        }
    }
}

extension Paths.Email {
    public var templates: Templates {
        Templates(path: path + "/templates")
    }

    public struct Templates {
        /// Path: `/email/templates`
        public let path: String

        /// Get All Email Templates
        public var get: Request<String> {
            .get(path)
        }

        /// Create New Email Template from Master Template
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "template_id_master" : 57,
        ///   "template_name" : "Minions"
        /// }
        public struct PostRequest: Encodable {
            /// The ID of the master template you want to base on.
            public var templateIDMaster: Double
            /// The intended name for the new template.
            public var templateName: String

            public init(templateIDMaster: Double, templateName: String) {
                self.templateIDMaster = templateIDMaster
                self.templateName = templateName
            }

            private enum CodingKeys: String, CodingKey {
                case templateIDMaster = "template_id_master"
                case templateName = "template_name"
            }
        }
    }
}

extension Paths.Email {
    public var templatesImages: TemplatesImages {
        TemplatesImages(path: path + "/templates-images")
    }

    public struct TemplatesImages {
        /// Path: `/email/templates-images`
        public let path: String
    }
}

extension Paths.Email.TemplatesImages {
    public func templateID(_ templateID: String) -> WithTemplateID {
        WithTemplateID(path: "\(path)/\(templateID)")
    }

    public struct WithTemplateID {
        /// Path: `/email/templates-images/{template_id}`
        public let path: String

        /// Upload Image to Specific Template
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "image" : "image.png",
        ///   "url" : "http:\/\/yourdomain.com\/image.png"
        /// }
        public struct PostRequest: Encodable {
            /// Uploads your selected image file.
            public var image: String?
            /// Uploads the image from the supplied URL.
            public var url: String?

            public init(image: String? = nil, url: String? = nil) {
                self.image = image
                self.url = url
            }
        }
    }
}

extension Paths.Email.Templates {
    public func templateID(_ templateID: String) -> WithTemplateID {
        WithTemplateID(path: "\(path)/\(templateID)")
    }

    public struct WithTemplateID {
        /// Path: `/email/templates/{template_id}`
        public let path: String

        /// Get Specific Email Template
        public var get: Request<String> {
            .get(path)
        }

        /// Update an Email Template
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        public struct PutRequest: Encodable {
            /// Your template body.
            public var body: String
            /// The intended name for the new template.
            public var templateName: String

            public init(body: String, templateName: String) {
                self.body = body
                self.templateName = templateName
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case templateName = "template_name"
            }
        }

        /// Delete Email Template
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var fax: Fax {
        Fax(path: "/fax")
    }

    public struct Fax {
        /// Path: `/fax`
        public let path: String
    }
}

extension Paths.Fax {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/fax/history`
        public let path: String
    }
}

extension Paths.Fax.History {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/fax/history/export?filename={filename}`
        public let path: String

        /// Export Fax History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Fax {
    public func dateFrom(_ dateFrom: String) -> WithHistoryDateFromDateToDateToQQOrderByOrderBy {
        WithHistoryDateFromDateToDateToQQOrderByOrderBy(path: "\(path)/history?date_from=\(dateFrom)&date_to={date_to}&q={q}&order_by={order_by}")
    }

    public struct WithHistoryDateFromDateToDateToQQOrderByOrderBy {
        /// Path: `/fax/history?date_from={date_from}&date_to={date_to}&q={q}&order_by={order_by}`
        public let path: String

        /// Get Fax History
        ///
        /// Get a list of Fax History.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Fax {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/fax/price`
        public let path: String

        /// Calculate Price
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "file_url" : "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/document.pdf",
        ///   "messages" : [
        ///     {
        ///       "country" : "AF",
        ///       "custom_string" : "custom_string",
        ///       "from_email" : "will@smith.com",
        ///       "schedule" : "1436874701",
        ///       "source" : "php",
        ///       "to" : "+61261111111"
        ///     },
        ///     {
        ///       "country" : "AF",
        ///       "custom_string" : "custom_string",
        ///       "from_email" : "john@doe.com",
        ///       "schedule" : "1436874701",
        ///       "source" : "php",
        ///       "to" : "+61261111122"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Recipient country.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Your URL to your PDF file.
            public var fileURL: String
            /// Your sender id. Must be a valid fax number.
            public var from: String?
            /// An email address where the reply should be emailed to.
            public var fromEmail: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Your messages.
            public var messages: [AnyJSON]
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String

            public init(country: String? = nil, customString: String? = nil, fileURL: String, from: String? = nil, fromEmail: String? = nil, listID: Double? = nil, messages: [AnyJSON], schedule: Double? = nil, source: String? = nil, to: String) {
                self.country = country
                self.customString = customString
                self.fileURL = fileURL
                self.from = from
                self.fromEmail = fromEmail
                self.listID = listID
                self.messages = messages
                self.schedule = schedule
                self.source = source
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case customString = "custom_string"
                case fileURL = "file_url"
                case from
                case fromEmail = "from_email"
                case listID = "list_id"
                case messages
                case schedule
                case source
                case to
            }
        }
    }
}

extension Paths.Fax {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/fax/receipts`
        public let path: String

        /// List of Fax Delivery Receipts
        public var get: Request<String> {
            .get(path)
        }

        /// Add a Test Delivery Receipt
        public func post(url: String) -> Request<String> {
            .post(path, body: ["url": url])
        }
    }
}

extension Paths.Fax {
    public var receiptsRead: ReceiptsRead {
        ReceiptsRead(path: path + "/receipts-read")
    }

    public struct ReceiptsRead {
        /// Path: `/fax/receipts-read`
        public let path: String

        /// Mark Fax Delivery Receipts as read
        public func put(dateBefore: Double? = nil) -> Request<String> {
            .put(path, body: ["date_before": dateBefore])
        }
    }
}

extension Paths.Fax.Receipts {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/fax/receipts/{message_id}`
        public let path: String

        /// Get a Specific Fax Delivery Receipt
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Fax {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/fax/send`
        public let path: String

        /// Send Fax
        ///
        /// **Letter File Options**
        /// 
        /// **Use existing URL**
        /// 
        /// With this option, you can use an existing URL to a PDF document. For example, you might generate the pdf on your server.
        /// 
        /// **Upload File to Our Server**
        /// 
        /// With this option, you can use the `/uploads` endpoint to upload the document. The `/uploads` endpoint returns a URL that can be used in the `/fax/send` endpoint.
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "file_url" : "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/document.pdf",
        ///   "messages" : [
        ///     {
        ///       "country" : "AF",
        ///       "custom_string" : "custom_string",
        ///       "from_email" : "will@smith.com",
        ///       "schedule" : "1436874701",
        ///       "source" : "php",
        ///       "to" : "+61261111111"
        ///     },
        ///     {
        ///       "country" : "AF",
        ///       "custom_string" : "custom_string",
        ///       "from_email" : "john@doe.com",
        ///       "schedule" : "1436874701",
        ///       "source" : "php",
        ///       "to" : "+61261111122"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Recipient country.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Your URL to your PDF file.
            public var fileURL: String
            /// Your sender id. Must be a valid fax number.
            public var from: String?
            /// An email address where the reply should be emailed to.
            public var fromEmail: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Your messages.
            public var messages: [AnyJSON]
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String

            public init(country: String? = nil, customString: String? = nil, fileURL: String, from: String? = nil, fromEmail: String? = nil, listID: Double? = nil, messages: [AnyJSON], schedule: Double? = nil, source: String? = nil, to: String) {
                self.country = country
                self.customString = customString
                self.fileURL = fileURL
                self.from = from
                self.fromEmail = fromEmail
                self.listID = listID
                self.messages = messages
                self.schedule = schedule
                self.source = source
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case customString = "custom_string"
                case fileURL = "file_url"
                case from
                case fromEmail = "from_email"
                case listID = "list_id"
                case messages
                case schedule
                case source
                case to
            }
        }
    }
}

extension Paths {
    public static var forgotPassword: ForgotPassword {
        ForgotPassword(path: "/forgot-password")
    }

    public struct ForgotPassword {
        /// Path: `/forgot-password`
        public let path: String

        /// Forgot Password
        public func put(username: String) -> Request<String> {
            .put(path, body: ["username": username])
        }
    }
}

extension Paths.ForgotPassword {
    public var verify: Verify {
        Verify(path: path + "/verify")
    }

    public struct Verify {
        /// Path: `/forgot-password/verify`
        public let path: String

        /// Verify Forgot Password
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "activation_token" : "9C648BAD-EB7F-4E7E-96BC-B433140C4F1F",
        ///   "password" : "0F6pKiiuca",
        ///   "subaccount_id" : 54
        /// }
        public struct PutRequest: Encodable {
            /// Your email activation token.
            public var activationToken: String
            /// Your new password.
            public var password: String
            /// Your subaccount id.
            public var subaccountID: Double

            public init(activationToken: String, password: String, subaccountID: Double) {
                self.activationToken = activationToken
                self.password = password
                self.subaccountID = subaccountID
            }

            private enum CodingKeys: String, CodingKey {
                case activationToken = "activation_token"
                case password
                case subaccountID = "subaccount_id"
            }
        }
    }
}

extension Paths {
    public static var forgotUsername: ForgotUsername {
        ForgotUsername(path: "/forgot-username")
    }

    public struct ForgotUsername {
        /// Path: `/forgot-username`
        public let path: String

        /// Forgot Username
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "country" : "US",
        ///   "phone_number" : "3108147982"
        /// }
        public struct PutRequest: Encodable {
            /// Your country. Used to format phone number. This is required if phone_number is not in international-format.
            public var country: String?
            /// Your email. This is required if phone_number is not present.
            public var email: String?
            /// Your phone number. This is required if email is not present.
            public var phoneNumber: Double?

            public init(country: String? = nil, email: String? = nil, phoneNumber: Double? = nil) {
                self.country = country
                self.email = email
                self.phoneNumber = phoneNumber
            }

            private enum CodingKeys: String, CodingKey {
                case country
                case email
                case phoneNumber = "phone_number"
            }
        }
    }
}

extension Paths {
    public static var lists: Lists {
        Lists(path: "/lists")
    }

    public struct Lists {
        /// Path: `/lists`
        public let path: String

        /// Get all Contact Lists
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new contact list
        public func post(listName: String) -> Request<String> {
            .post(path, body: ["list_name": listName])
        }
    }
}

extension Paths.Lists {
    public func fromListID(_ fromListID: String) -> WithFromListID {
        WithFromListID(path: "\(path)/\(fromListID)")
    }

    public struct WithFromListID {
        /// Path: `/lists/{from_list_id}`
        public let path: String
    }
}

extension Paths.Lists.WithFromListID {
    public var contacts: Contacts {
        Contacts(path: path + "/contacts")
    }

    public struct Contacts {
        /// Path: `/lists/{from_list_id}/contacts`
        public let path: String
    }
}

extension Paths.Lists.WithFromListID.Contacts {
    public func contactID(_ contactID: String) -> WithContactID {
        WithContactID(path: "\(path)/\(contactID)")
    }

    public struct WithContactID {
        /// Path: `/lists/{from_list_id}/contacts/{contact_id}`
        public let path: String
    }
}

extension Paths.Lists.WithFromListID.Contacts.WithContactID {
    public func toListID(_ toListID: String) -> WithToListID {
        WithToListID(path: "\(path)/\(toListID)")
    }

    public struct WithToListID {
        /// Path: `/lists/{from_list_id}/contacts/{contact_id}/{to_list_id}`
        public let path: String

        /// Transfer a Contact
        ///
        /// Transfers a specific contact to another list.
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Lists {
    public func listID(_ listID: String) -> WithListID {
        WithListID(path: "\(path)/\(listID)")
    }

    public struct WithListID {
        /// Path: `/lists/{list_id}`
        public let path: String

        /// Get a specific contact list
        public var get: Request<String> {
            .get(path)
        }

        /// Update a specific contact list
        public func put(listName: String? = nil) -> Request<String> {
            .put(path, body: ["list_name": listName])
        }

        /// Delete a specific contact list
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Lists.WithListID {
    public var contacts: Contacts {
        Contacts(path: path + "/contacts")
    }

    public struct Contacts {
        /// Path: `/lists/{list_id}/contacts`
        public let path: String

        /// Get all Contacts in a List
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new contact
        ///
        /// Note that the fields `phone_number`, `fax_number` and email` are all optional; however at least one of them must be specified, otherwise the API call will fail.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "address_city" : "Nevada",
        ///   "address_country" : "US",
        ///   "address_line_1" : "Block 2",
        ///   "address_line_2" : "Cool Bldg.",
        ///   "address_postal_code" : "36063",
        ///   "address_state" : "Las Vegas",
        ///   "custom_1" : "Custom 1",
        ///   "custom_2" : "Custom 2",
        ///   "custom_3" : "Custom 3",
        ///   "custom_4" : "Custom 4",
        ///   "email" : "ellen@diaz.com",
        ///   "fax_number" : "+16783270696",
        ///   "first_name" : "Ellen",
        ///   "last_name" : "Diaz",
        ///   "organization_name" : "Awesome Organization",
        ///   "phone_number" : "+16783270696"
        /// }
        public struct PostRequest: Encodable {
            /// Contact city.
            public var addressCity: String?
            /// Contact two-letter country code defined in ISO 3166.
            public var addressCountry: String?
            /// Contact address line 1.
            public var addressLine1: String?
            /// Contact address line 2.
            public var addressLine2: String?
            /// Contact postal code.
            public var addressPostalCode: String?
            /// Contact state.
            public var addressState: String?
            /// Contact custom 1 text.
            public var custom1: String?
            /// Contact custom 2 text.
            public var custom2: String?
            /// Contact custom 3 text.
            public var custom3: String?
            /// Contact custom 4 text.
            public var custom4: String?
            /// Contact email.
            public var email: String?
            /// Contact fax number.
            public var faxNumber: String?
            /// Contact firstname.
            public var firstName: String?
            /// Contact lastname.
            public var lastName: String?
            /// Your organization name.
            public var organizationName: String?
            /// Contact phone number in E.164 format.
            public var phoneNumber: String

            public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressPostalCode: String? = nil, addressState: String? = nil, custom1: String? = nil, custom2: String? = nil, custom3: String? = nil, custom4: String? = nil, email: String? = nil, faxNumber: String? = nil, firstName: String? = nil, lastName: String? = nil, organizationName: String? = nil, phoneNumber: String) {
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressPostalCode = addressPostalCode
                self.addressState = addressState
                self.custom1 = custom1
                self.custom2 = custom2
                self.custom3 = custom3
                self.custom4 = custom4
                self.email = email
                self.faxNumber = faxNumber
                self.firstName = firstName
                self.lastName = lastName
                self.organizationName = organizationName
                self.phoneNumber = phoneNumber
            }

            private enum CodingKeys: String, CodingKey {
                case addressCity = "address_city"
                case addressCountry = "address_country"
                case addressLine1 = "address_line_1"
                case addressLine2 = "address_line_2"
                case addressPostalCode = "address_postal_code"
                case addressState = "address_state"
                case custom1 = "custom_1"
                case custom2 = "custom_2"
                case custom3 = "custom_3"
                case custom4 = "custom_4"
                case email
                case faxNumber = "fax_number"
                case firstName = "first_name"
                case lastName = "last_name"
                case organizationName = "organization_name"
                case phoneNumber = "phone_number"
            }
        }
    }
}

extension Paths.Lists.WithListID.Contacts {
    public func contactID(_ contactID: String) -> WithContactID {
        WithContactID(path: "\(path)/\(contactID)")
    }

    public struct WithContactID {
        /// Path: `/lists/{list_id}/contacts/{contact_id}`
        public let path: String

        /// Get a specific contact
        public var get: Request<String> {
            .get(path)
        }

        /// Update a specific contact
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "address_city" : "Nevada",
        ///   "address_country" : "US",
        ///   "address_line_1" : "Block 6",
        ///   "address_line_2" : "Cool Bldg.",
        ///   "address_postal_code" : "36063",
        ///   "address_state" : "Las Vegas",
        ///   "custom_1" : "Custom S72oJ9Teba",
        ///   "custom_2" : "Custom NvrRJrKWeq",
        ///   "custom_3" : "Custom 2ws94p1Dop",
        ///   "custom_4" : "Custom Ku0AaIS5xb",
        ///   "email" : "ellen@diaz.com",
        ///   "fax_number" : "+16783276356",
        ///   "first_name" : "Ellen",
        ///   "last_name" : "Diaz",
        ///   "organization_name" : "Awesome Organization",
        ///   "phone_number" : "+16783275492"
        /// }
        public struct PutRequest: Encodable {
            /// Contact city.
            public var addressCity: String?
            /// Contact two-letter country code defined in ISO 3166.
            public var addressCountry: String?
            /// Contact address line 1.
            public var addressLine1: String?
            /// Contact address line 2.
            public var addressLine2: String?
            /// Contact postal code.
            public var addressPostalCode: String?
            /// Contact state.
            public var addressState: String?
            /// Contact custom 1 text.
            public var custom1: String?
            /// Contact custom 2 text.
            public var custom2: String?
            /// Contact custom 3 text.
            public var custom3: String?
            /// Contact custom 4 text.
            public var custom4: String?
            /// Contact email.
            public var email: String?
            /// Contact fax number.
            public var faxNumber: String?
            /// Contact firstname.
            public var firstName: String?
            /// Contact lastname.
            public var lastName: String?
            /// Contact organization name.
            public var organizationName: String?
            /// Contact phone number in E.164 format.
            public var phoneNumber: String?

            public init(addressCity: String? = nil, addressCountry: String? = nil, addressLine1: String? = nil, addressLine2: String? = nil, addressPostalCode: String? = nil, addressState: String? = nil, custom1: String? = nil, custom2: String? = nil, custom3: String? = nil, custom4: String? = nil, email: String? = nil, faxNumber: String? = nil, firstName: String? = nil, lastName: String? = nil, organizationName: String? = nil, phoneNumber: String? = nil) {
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressPostalCode = addressPostalCode
                self.addressState = addressState
                self.custom1 = custom1
                self.custom2 = custom2
                self.custom3 = custom3
                self.custom4 = custom4
                self.email = email
                self.faxNumber = faxNumber
                self.firstName = firstName
                self.lastName = lastName
                self.organizationName = organizationName
                self.phoneNumber = phoneNumber
            }

            private enum CodingKeys: String, CodingKey {
                case addressCity = "address_city"
                case addressCountry = "address_country"
                case addressLine1 = "address_line_1"
                case addressLine2 = "address_line_2"
                case addressPostalCode = "address_postal_code"
                case addressState = "address_state"
                case custom1 = "custom_1"
                case custom2 = "custom_2"
                case custom3 = "custom_3"
                case custom4 = "custom_4"
                case email
                case faxNumber = "fax_number"
                case firstName = "first_name"
                case lastName = "last_name"
                case organizationName = "organization_name"
                case phoneNumber = "phone_number"
            }
        }

        /// Delete a specific contact
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Lists.WithListID {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/lists/{list_id}/export?filename={filename}`
        public let path: String

        /// Export Contacts List
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Lists.WithListID {
    public var `import`: Import {
        Import(path: path + "/import")
    }

    public struct Import {
        /// Path: `/lists/{list_id}/import`
        public let path: String

        /// Import Contacts to List
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "field_order" : [
        ///     "phone",
        ///     "first_name",
        ///     "last_name",
        ///     "custom1",
        ///     "custom2",
        ///     "custom3",
        ///     "custom4",
        ///     "fax_number",
        ///     "organization_name",
        ///     "email",
        ///     "address_line_1",
        ///     "address_line_2",
        ///     "address_city",
        ///     "address_state",
        ///     "address_postal_code",
        ///     "address_country"
        ///   ],
        ///   "file_url" : "http:\/\/yourdomain.com\/import.csv"
        /// }
        public struct PostRequest: Encodable {
            /// Your field order for your contact import file.
            public var fieldOrder: [AnyJSON]
            /// Path to your CSV import file.
            public var fileURL: String

            public init(fieldOrder: [AnyJSON], fileURL: String) {
                self.fieldOrder = fieldOrder
                self.fileURL = fileURL
            }

            private enum CodingKeys: String, CodingKey {
                case fieldOrder = "field_order"
                case fileURL = "file_url"
            }
        }
    }
}

extension Paths.Lists.WithListID {
    public var importCsvPreview: ImportCsvPreview {
        ImportCsvPreview(path: path + "/import-csv-preview")
    }

    public struct ImportCsvPreview {
        /// Path: `/lists/{list_id}/import-csv-preview`
        public let path: String

        /// Show CSV Import File Preview
        ///
        /// Show first row of the csv import file.
        public func post(fileURL: String) -> Request<String> {
            .post(path, body: ["file_url": fileURL])
        }
    }
}

extension Paths.Lists.WithListID {
    public var importFields: ImportFields {
        ImportFields(path: path + "/import-fields")
    }

    public struct ImportFields {
        /// Path: `/lists/{list_id}/import-fields`
        public let path: String

        /// Get List of Acceptable Import Fields
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Lists.WithListID {
    public var removeDuplicates: RemoveDuplicates {
        RemoveDuplicates(path: path + "/remove-duplicates")
    }

    public struct RemoveDuplicates {
        /// Path: `/lists/{list_id}/remove-duplicates`
        public let path: String

        /// Remove Duplicate Contacts
        public func put(fields: [AnyJSON]) -> Request<String> {
            .put(path, body: ["fields": fields])
        }
    }
}

extension Paths.Lists.WithListID {
    public var removeOptedOutContacts: RemoveOptedOutContacts {
        RemoveOptedOutContacts(path: path + "/remove-opted-out-contacts")
    }

    public struct RemoveOptedOutContacts {
        /// Path: `/lists/{list_id}/remove-opted-out-contacts`
        public let path: String
    }
}

extension Paths.Lists.WithListID.RemoveOptedOutContacts {
    public func optOutListID(_ optOutListID: String) -> WithOptOutListID {
        WithOptOutListID(path: "\(path)/\(optOutListID)")
    }

    public struct WithOptOutListID {
        /// Path: `/lists/{list_id}/remove-opted-out-contacts/{opt_out_list_id}`
        public let path: String

        /// Remove Opted Out Contacts
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths {
    public static var mms: Mms {
        Mms(path: "/mms")
    }

    public struct Mms {
        /// Path: `/mms`
        public let path: String
    }
}

extension Paths.Mms {
    public var cancelAll: CancelAll {
        CancelAll(path: path + "/cancel-all")
    }

    public struct CancelAll {
        /// Path: `/mms/cancel-all`
        public let path: String

        /// Cancel All MMS
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Mms {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/mms/history`
        public let path: String
    }
}

extension Paths.Mms.History {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/mms/history/export?filename={filename}`
        public let path: String

        /// Export MMS History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Mms {
    public func q(_ q: String) -> WithHistoryQOrderByOrderByDateFromDateFromDateToDateTo {
        WithHistoryQOrderByOrderByDateFromDateFromDateToDateTo(path: "\(path)/history?q=\(q)&order_by={order_by}&date_from={date_from}&date_to={date_to}")
    }

    public struct WithHistoryQOrderByOrderByDateFromDateFromDateToDateTo {
        /// Path: `/mms/history?q={q}&order_by={order_by}&date_from={date_from}&date_to={date_to}`
        public let path: String

        /// Get MMS History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Mms {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/mms/price`
        public let path: String

        /// Get Price
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "media_file" : "http:\/\/yourdomain.com\/tpLaX6A.gif",
        ///   "messages" : [
        ///     {
        ///       "body" : "This is a test body with special character: ",
        ///       "country" : "AU",
        ///       "from" : "test",
        ///       "source" : "php",
        ///       "subject" : "This is a subject",
        ///       "to" : "+61437111222"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Your message.
            public var body: String
            /// Recipient country.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?
            /// An email address where the reply should be emailed to. If omitted, the reply will be emailed back to the user who sent the outgoing SMS.
            public var fromEmail: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Media file you want to send.
            public var mediaFile: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Subject line. Maximum 20 characters.
            public var subject: String
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String

            public init(body: String, country: String? = nil, customString: String? = nil, from: String? = nil, fromEmail: String? = nil, listID: Double? = nil, mediaFile: String, schedule: Double? = nil, source: String? = nil, subject: String, to: String) {
                self.body = body
                self.country = country
                self.customString = customString
                self.from = from
                self.fromEmail = fromEmail
                self.listID = listID
                self.mediaFile = mediaFile
                self.schedule = schedule
                self.source = source
                self.subject = subject
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case country
                case customString = "custom_string"
                case from
                case fromEmail = "from_email"
                case listID = "list_id"
                case mediaFile = "media_file"
                case schedule
                case source
                case subject
                case to
            }
        }
    }
}

extension Paths.Mms {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/mms/receipts`
        public let path: String

        /// Get all Delivery Receipts
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Mms {
    public var receiptsRead: ReceiptsRead {
        ReceiptsRead(path: path + "/receipts-read")
    }

    public struct ReceiptsRead {
        /// Path: `/mms/receipts-read`
        public let path: String

        /// Mark Receipts As Read
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Mms.Receipts {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/mms/receipts/{message_id}`
        public let path: String

        /// Get Delivery Receipt
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Mms {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/mms/send`
        public let path: String

        /// Send MMS
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "media_file" : "http:\/\/yourdomain.com\/tpLaX6A.gif",
        ///   "messages" : [
        ///     {
        ///       "body" : "This is a test body with special character: ",
        ///       "country" : "AU",
        ///       "from" : "test",
        ///       "source" : "php",
        ///       "subject" : "This is a subject",
        ///       "to" : "+61437111222"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Your message.
            public var body: String
            /// Recipient country.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// The number to send from. Either leave blank or use a ClickSend number only.
            public var from: String?
            /// An email address where the reply should be emailed to. If omitted, the reply will be emailed back to the user who sent the outgoing SMS.
            public var fromEmail: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Media file you want to send.
            public var mediaFile: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Subject line. Maximum 20 characters.
            public var subject: String
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String

            public init(body: String, country: String? = nil, customString: String? = nil, from: String? = nil, fromEmail: String? = nil, listID: Double? = nil, mediaFile: String, schedule: Double? = nil, source: String? = nil, subject: String, to: String) {
                self.body = body
                self.country = country
                self.customString = customString
                self.from = from
                self.fromEmail = fromEmail
                self.listID = listID
                self.mediaFile = mediaFile
                self.schedule = schedule
                self.source = source
                self.subject = subject
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case country
                case customString = "custom_string"
                case from
                case fromEmail = "from_email"
                case listID = "list_id"
                case mediaFile = "media_file"
                case schedule
                case source
                case subject
                case to
            }
        }
    }
}

extension Paths.Mms {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/mms/{message_id}`
        public let path: String
    }
}

extension Paths.Mms.WithMessageID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/mms/{message_id}/cancel`
        public let path: String

        /// Cancel MMS
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths {
    public static var numbers: Numbers {
        Numbers(path: "/numbers")
    }

    public struct Numbers {
        /// Path: `/numbers`
        public let path: String

        /// Get all Dedicated Numbers
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Numbers {
    public var buy: Buy {
        Buy(path: path + "/buy")
    }

    public struct Buy {
        /// Path: `/numbers/buy`
        public let path: String
    }
}

extension Paths.Numbers.Buy {
    public func dedicatedNumber(_ dedicatedNumber: String) -> WithDedicatedNumber {
        WithDedicatedNumber(path: "\(path)/\(dedicatedNumber)")
    }

    public struct WithDedicatedNumber {
        /// Path: `/numbers/buy/{dedicated_number}`
        public let path: String

        /// Buy dedicated number
        public var post: Request<String> {
            .post(path)
        }
    }
}

extension Paths.Numbers {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/numbers/search`
        public let path: String
    }
}

extension Paths.Numbers.Search {
    public func country(_ country: String) -> WithSearch1SearchType2 {
        WithSearch1SearchType2(path: "\(path)/\(country)?{search}=1&{search_type}=2")
    }

    public struct WithSearch1SearchType2 {
        /// Path: `/numbers/search/{country}?{search}=1&{search_type}=2`
        public let path: String

        /// Search Dedicated Numbers by Country
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var post: Post {
        Post(path: "/post")
    }

    public struct Post {
        /// Path: `/post`
        public let path: String
    }
}

extension Paths.Post {
    public var directMail: DirectMail {
        DirectMail(path: path + "/direct-mail")
    }

    public struct DirectMail {
        /// Path: `/post/direct-mail`
        public let path: String
    }
}

extension Paths.Post.DirectMail {
    public var campaigns: Campaigns {
        Campaigns(path: path + "/campaigns")
    }

    public struct Campaigns {
        /// Path: `/post/direct-mail/campaigns`
        public let path: String

        /// List Direct Mail Campaigns
        ///
        /// Get list of direct mail campaigns.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Post.DirectMail.Campaigns {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/post/direct-mail/campaigns/price`
        public let path: String

        /// Calculate Direct Mail Campaign Price
        ///
        /// Calculate direct mail campaign price.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "areas" : [
        ///     {
        ///       "location_id" : 22,
        ///       "quantity" : 12
        ///     },
        ///     {
        ///       "location_id" : 21,
        ///       "quantity" : 10
        ///     },
        ///     {
        ///       "location_id" : 21,
        ///       "quantity" : 10
        ///     }
        ///   ],
        ///   "custom_string" : "Custom String",
        ///   "file_urls" : [
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_front.pdf",
        ///     "https:\/\/rest.clicksend.com\/files\/F3CA1167-381B-47FE-A146-3DF87BE7EEC2.pdf"
        ///   ],
        ///   "name" : "My Campaign",
        ///   "schedule" : 1477384503,
        ///   "size" : "A5",
        ///   "source" : "My Source"
        /// }
        public struct PostRequest: Encodable {
            /// List of location where you want to send your campaign, and the quantity per location.
            public var areas: [AnyJSON]?
            /// Campaign file urls. You can submit max 2 file urls.
            public var fileURLs: [AnyJSON]
            /// Campaign name.
            public var name: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Campaign file size. It can be A5 or DL.
            public var size: String
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?

            public init(areas: [AnyJSON]? = nil, fileURLs: [AnyJSON], name: String, schedule: Double? = nil, size: String, source: String? = nil) {
                self.areas = areas
                self.fileURLs = fileURLs
                self.name = name
                self.schedule = schedule
                self.size = size
                self.source = source
            }

            private enum CodingKeys: String, CodingKey {
                case areas
                case fileURLs = "file_urls"
                case name
                case schedule
                case size
                case source
            }
        }
    }
}

extension Paths.Post.DirectMail.Campaigns {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/post/direct-mail/campaigns/send`
        public let path: String

        /// Create New Campaign
        ///
        /// Create new direct mail campaign.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "areas" : [
        ///     {
        ///       "location_id" : 1,
        ///       "quantity" : 100
        ///     },
        ///     {
        ///       "location_id" : 2,
        ///       "quantity" : 100
        ///     },
        ///     {
        ///       "location_id" : 3,
        ///       "quantity" : 50
        ///     }
        ///   ],
        ///   "file_urls" : [
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_front.pdf",
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_back.pdf"
        ///   ],
        ///   "name" : "My Campaign",
        ///   "schedule" : 1477032023,
        ///   "size" : "A5",
        ///   "source" : "wordpress"
        /// }
        public struct PostRequest: Encodable {
            /// List of location where you want to send your campaign, and the quantity per location.
            public var areas: [AnyJSON]?
            /// Campaign file urls. You can submit max 2 file urls.
            public var fileURLs: [AnyJSON]
            /// Campaign name.
            public var name: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Campaign file size. It can be A5 or DL.
            public var size: String
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?

            public init(areas: [AnyJSON]? = nil, fileURLs: [AnyJSON], name: String, schedule: Double? = nil, size: String, source: String? = nil) {
                self.areas = areas
                self.fileURLs = fileURLs
                self.name = name
                self.schedule = schedule
                self.size = size
                self.source = source
            }

            private enum CodingKeys: String, CodingKey {
                case areas
                case fileURLs = "file_urls"
                case name
                case schedule
                case size
                case source
            }
        }
    }
}

extension Paths.Post.DirectMail {
    public var locations: Locations {
        Locations(path: path + "/locations")
    }

    public struct Locations {
        /// Path: `/post/direct-mail/locations`
        public let path: String
    }
}

extension Paths.Post.DirectMail.Locations {
    public var search: Search {
        Search(path: path + "/search")
    }

    public struct Search {
        /// Path: `/post/direct-mail/locations/search`
        public let path: String
    }
}

extension Paths.Post.DirectMail.Locations.Search {
    public func country(_ country: String) -> WithCountry {
        WithCountry(path: "\(path)/\(country)")
    }

    public struct WithCountry {
        /// Path: `/post/direct-mail/locations/search/{country}`
        public let path: String
    }
}

extension Paths.Post.DirectMail.Locations.Search.WithCountry {
    public func query(_ query: String) -> WithQ {
        WithQ(path: "\(path)/?q=\(query)")
    }

    public struct WithQ {
        /// Path: `/post/direct-mail/locations/search/{country}/?q={query}`
        public let path: String

        /// Search Locations
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Post {
    public var letters: Letters {
        Letters(path: path + "/letters")
    }

    public struct Letters {
        /// Path: `/post/letters`
        public let path: String
    }
}

extension Paths.Post.Letters {
    public var detectAddress: DetectAddress {
        DetectAddress(path: path + "/detect-address")
    }

    public struct DetectAddress {
        /// Path: `/post/letters/detect-address`
        public let path: String

        /// Detect Address
        ///
        /// The `detect-address` endpoint accepts either a letter in PDF format or an address string and attempts to convert it to a standard address format. Note that the PDF should be in standard address format, having the recipient's name and address listed at the top.
        /// 
        /// The endpoint accepts two types of data:
        /// 1. A PDF file in `base64` encoding. In this case, submit the `base64`-encoded PDF file contents in the `content` field of the request body.
        /// 2. An address string. In this case, submit the address in a string using the `address` field of the request body.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Example:
            ///
            /// {
            ///   "content" : "Q29udGVudHMgb2YgZmlsZQ=="
            /// }
            public var a: A?
            /// Example:
            ///
            /// {
            ///   "address" : "John Doe, 123 Main Street, Perth WA 6000"
            /// }
            public var b: B?

            /// Example:
            ///
            /// {
            ///   "content" : "Q29udGVudHMgb2YgZmlsZQ=="
            /// }
            public struct A: Encodable {
                /// Your file contents encoded in `base64`.
                public var content: String

                public init(content: String) {
                    self.content = content
                }
            }

            /// Example:
            ///
            /// {
            ///   "address" : "John Doe, 123 Main Street, Perth WA 6000"
            /// }
            public struct B: Encodable {
                /// Your file contents encoded in `base64`.
                public var address: String

                public init(address: String) {
                    self.address = address
                }
            }

            public init(a: A? = nil, b: B? = nil) {
                self.a = a
                self.b = b
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = a { try container.encode(value) }
                if let value = b { try container.encode(value) }
            }
        }
    }
}

extension Paths.Post.Letters {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/post/letters/history`
        public let path: String

        /// Get Post Letter History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Post.Letters.History {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/post/letters/history/export?filename={filename}`
        public let path: String

        /// Export Post Letter History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Post.Letters {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/post/letters/price`
        public let path: String

        /// Calculate Price
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "colour" : 1,
        ///   "duplex" : 0,
        ///   "file_url" : "http:\/\/yourdomain.com\/file.pdf",
        ///   "priority_post" : 0,
        ///   "recipients" : [
        ///     {
        ///       "address_city" : "CITY",
        ///       "address_country" : "AU",
        ///       "address_line_1" : "Address 1",
        ///       "address_line_2" : "Address 2",
        ///       "address_name" : "My Home Address",
        ///       "address_postal_code" : 123456,
        ///       "address_state" : "State",
        ///       "custom_string" : "Custom kn0ChLhwn6",
        ///       "return_address_id" : 1,
        ///       "schedule" : 1449573604
        ///     }
        ///   ],
        ///   "template_used" : 1
        /// }
        public struct PostRequest: Encodable {
            /// Is it in colored?
            public var colour: Double?
            /// Is it in duplex?
            public var duplex: Double?
            /// Your URL to your PDF file.
            public var fileURL: String
            /// Is it priority? 0 = Not Priority, 1 = Priority.
            public var priorityPost: Double?
            /// Your recipients.
            public var recipients: [AnyJSON]?
            /// Whether you used our template or not ([More Info](http://help.clicksend.com/13996-Post/post-letter-template)).
            public var templateUsed: Double?

            public init(colour: Double? = nil, duplex: Double? = nil, fileURL: String, priorityPost: Double? = nil, recipients: [AnyJSON]? = nil, templateUsed: Double? = nil) {
                self.colour = colour
                self.duplex = duplex
                self.fileURL = fileURL
                self.priorityPost = priorityPost
                self.recipients = recipients
                self.templateUsed = templateUsed
            }

            private enum CodingKeys: String, CodingKey {
                case colour
                case duplex
                case fileURL = "file_url"
                case priorityPost = "priority_post"
                case recipients
                case templateUsed = "template_used"
            }
        }
    }
}

extension Paths.Post.Letters {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/post/letters/send`
        public let path: String

        /// Send Post Letter
        ///
        /// **Supported File Types**
        /// We support `pdf`, `docx` and `doc` files. Contact us to add support for any other file type. If you're using `docx` or `doc` files, you'll need to convert the file first using our uploads endpoint with the querystring parameter `convert=post` e.g. `POST /uploads?convert=post`. This will return a URL to the converted pdf file that can be used in the `/post/letters/send` endpoint.
        /// 
        /// **Letter File Options**
        /// 
        /// **Use existing URL**
        /// 
        /// With this option, you can use an existing URL to a `pdf` document. For example, you might generate the `pdf` on your server.
        /// 
        /// **Upload File to Our Server**
        /// 
        /// With this option, you can use the `/uploads` endpoint to upload the document. The `/uploads` endpoint returns a URL that can be used in the `/post/letters/send` endpoint.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "colour" : 1,
        ///   "duplex" : 0,
        ///   "file_url" : "http:\/\/yourdomain.com\/file.pdf",
        ///   "priority_post" : 0,
        ///   "recipients" : [
        ///     {
        ///       "address_city" : "CITY",
        ///       "address_country" : "AU",
        ///       "address_line_1" : "Address 1",
        ///       "address_line_2" : "Address 2",
        ///       "address_name" : "My Home Address",
        ///       "address_postal_code" : 123456,
        ///       "address_state" : "State",
        ///       "custom_string" : "Custom kn0ChLhwn6",
        ///       "return_address_id" : 1,
        ///       "schedule" : 1449573604
        ///     }
        ///   ],
        ///   "template_used" : 1
        /// }
        public struct PostRequest: Encodable {
            /// Is it in colour? 0 = Black and White, 1 = Colour.
            public var colour: Double?
            /// Is it in duplex? 0 = Simplex, 1 = Duplex.
            public var duplex: Double?
            /// Your URL to your PDF file.
            public var fileURL: String
            /// Is it priority? 0 = Not Priority, 1 = Priority.
            public var priorityPost: Double?
            /// Your recipients.
            public var recipients: [AnyJSON]?
            /// Whether you used our template or not ([More Info](http://help.clicksend.com/13996-Post/post-letter-template)).
            public var templateUsed: Double?

            public init(colour: Double? = nil, duplex: Double? = nil, fileURL: String, priorityPost: Double? = nil, recipients: [AnyJSON]? = nil, templateUsed: Double? = nil) {
                self.colour = colour
                self.duplex = duplex
                self.fileURL = fileURL
                self.priorityPost = priorityPost
                self.recipients = recipients
                self.templateUsed = templateUsed
            }

            private enum CodingKeys: String, CodingKey {
                case colour
                case duplex
                case fileURL = "file_url"
                case priorityPost = "priority_post"
                case recipients
                case templateUsed = "template_used"
            }
        }
    }
}

extension Paths.Post {
    public var postcards: Postcards {
        Postcards(path: path + "/postcards")
    }

    public struct Postcards {
        /// Path: `/post/postcards`
        public let path: String
    }
}

extension Paths.Post.Postcards {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/post/postcards/export?filename={filename}`
        public let path: String

        /// Export Postcard History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Post.Postcards {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/post/postcards/history`
        public let path: String

        /// Get Postcard History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Post.Postcards {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/post/postcards/price`
        public let path: String

        /// Calculate Pricing
        ///
        /// For `file_urls` field. You can attach at least 1 and max of 2 PDF file urls.
        /// 
        /// - Supply a single pdf with 2 pages (front and back)
        /// 
        /// - Supply 2 urls to seperate PDFs
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "file_urls" : [
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_front.pdf",
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_back.pdf"
        ///   ],
        ///   "recipients" : [
        ///     {
        ///       "address_city" : "City",
        ///       "address_country" : "AU",
        ///       "address_line_1" : "Address 1",
        ///       "address_line_2" : null,
        ///       "address_name" : "John Smith",
        ///       "address_postal_code" : "123456",
        ///       "address_state" : "State",
        ///       "custom_string" : "Custom abc123",
        ///       "return_address_id" : 1
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Postcard file urls. You can submit max 2 file urls.
            public var fileURLs: [AnyJSON]
            /// Your recipients.
            public var recipients: [AnyJSON]

            public init(fileURLs: [AnyJSON], recipients: [AnyJSON]) {
                self.fileURLs = fileURLs
                self.recipients = recipients
            }

            private enum CodingKeys: String, CodingKey {
                case fileURLs = "file_urls"
                case recipients
            }
        }
    }
}

extension Paths.Post.Postcards {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/post/postcards/send`
        public let path: String

        /// Send Postcard
        ///
        /// **Supported File Types**
        /// We support PDF, docx and doc. Contact us to add support for any other file type. If you're using docx or doc files, you'll need to convert the file first using our uploads endpoint with the querystring parameter ?convert=post. e.g. POST /uploads?convert=post. This will return a URL to the converted pdf file that can be used in the /post/postcards/send endpoint.
        /// 
        /// **Postcard File Options**
        /// 
        /// **Use existing URL**
        /// 
        /// With this option, you can use an existing URL to a PDF document. For example, you might generate the pdf on your server.
        /// 
        /// For `file_urls` field. You can attach at least 1 and max of 2 PDF file urls.
        /// 
        /// - Supply a single pdf with 2 pages (front and back)
        /// 
        /// - Supply 2 urls to seperate PDFs
        /// 
        /// **Upload File to Our Server**
        /// 
        /// With this option, you can use the `/uploads` endpoint to upload the document. The `/uploads` endpoint returns a URL that can be used in the `/post/postcards/send` endpoint.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "file_urls" : [
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_front.pdf",
        ///     "https:\/\/s3-ap-southeast-2.amazonaws.com\/clicksend-api-downloads\/_public\/_examples\/a5_back.pdf"
        ///   ],
        ///   "recipients" : [
        ///     {
        ///       "address_city" : "City",
        ///       "address_country" : "AU",
        ///       "address_line_1" : "Address 1",
        ///       "address_line_2" : null,
        ///       "address_name" : "John Smith",
        ///       "address_postal_code" : "123456",
        ///       "address_state" : "State",
        ///       "custom_string" : "Custom abc123",
        ///       "return_address_id" : 1
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Postcard file urls. You can submit max 2 file urls.
            public var fileURLs: [AnyJSON]
            /// Your recipients.
            public var recipients: [AnyJSON]

            public init(fileURLs: [AnyJSON], recipients: [AnyJSON]) {
                self.fileURLs = fileURLs
                self.recipients = recipients
            }

            private enum CodingKeys: String, CodingKey {
                case fileURLs = "file_urls"
                case recipients
            }
        }
    }
}

extension Paths.Post {
    public var returnAddresses: ReturnAddresses {
        ReturnAddresses(path: path + "/return-addresses")
    }

    public struct ReturnAddresses {
        /// Path: `/post/return-addresses`
        public let path: String

        /// Get List of Post Return Addresses
        public var get: Request<String> {
            .get(path)
        }

        /// Create a Post Return Address
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "address_city" : "Flynn",
        ///   "address_country" : "AU",
        ///   "address_line_1" : "Maritime Avenue",
        ///   "address_line_2" : null,
        ///   "address_name" : "John Smith",
        ///   "address_postal_code" : 6302,
        ///   "address_state" : "WA"
        /// }
        public struct PostRequest: Encodable {
            /// Your address city.
            public var addressCity: String
            /// Two-letter country code defined in ISO 3166.
            public var addressCountry: String
            /// Your address line 1.
            public var addressLine1: String
            /// Your address line 2.
            public var addressLine2: String?
            /// Your address name.
            public var addressName: String
            /// Your address postal code.
            public var addressPostalCode: Double
            /// Your address state.
            public var addressState: String

            public init(addressCity: String, addressCountry: String, addressLine1: String, addressLine2: String? = nil, addressName: String, addressPostalCode: Double, addressState: String) {
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressName = addressName
                self.addressPostalCode = addressPostalCode
                self.addressState = addressState
            }

            private enum CodingKeys: String, CodingKey {
                case addressCity = "address_city"
                case addressCountry = "address_country"
                case addressLine1 = "address_line_1"
                case addressLine2 = "address_line_2"
                case addressName = "address_name"
                case addressPostalCode = "address_postal_code"
                case addressState = "address_state"
            }
        }
    }
}

extension Paths.Post.ReturnAddresses {
    public func returnAddressID(_ returnAddressID: String) -> WithReturnAddressID {
        WithReturnAddressID(path: "\(path)/\(returnAddressID)")
    }

    public struct WithReturnAddressID {
        /// Path: `/post/return-addresses/{return_address_id}`
        public let path: String

        /// Get Post Return Address
        public var get: Request<String> {
            .get(path)
        }

        /// Update Post Return Address
        public func put(_ body: PutRequest) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "address_city" : "Flynn",
        ///   "address_country" : "AU",
        ///   "address_line_1" : "Maritime Avenue",
        ///   "address_line_2" : null,
        ///   "address_name" : "John Smith",
        ///   "address_postal_code" : 6302,
        ///   "address_state" : "WA"
        /// }
        public struct PutRequest: Encodable {
            /// Your address city.
            public var addressCity: String
            /// Two-letter country code defined in ISO 3166.
            public var addressCountry: String
            /// Your address line 1.
            public var addressLine1: String
            /// Your address line 2.
            public var addressLine2: String?
            /// Your address name.
            public var addressName: String
            /// Your address postal code.
            public var addressPostalCode: Double
            /// Your address state.
            public var addressState: String

            public init(addressCity: String, addressCountry: String, addressLine1: String, addressLine2: String? = nil, addressName: String, addressPostalCode: Double, addressState: String) {
                self.addressCity = addressCity
                self.addressCountry = addressCountry
                self.addressLine1 = addressLine1
                self.addressLine2 = addressLine2
                self.addressName = addressName
                self.addressPostalCode = addressPostalCode
                self.addressState = addressState
            }

            private enum CodingKeys: String, CodingKey {
                case addressCity = "address_city"
                case addressCountry = "address_country"
                case addressLine1 = "address_line_1"
                case addressLine2 = "address_line_2"
                case addressName = "address_name"
                case addressPostalCode = "address_postal_code"
                case addressState = "address_state"
            }
        }

        /// Delete Post Return Address
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths {
    public static var pricing: Pricing {
        Pricing(path: "/pricing")
    }

    public struct Pricing {
        /// Path: `/pricing`
        public let path: String
    }
}

extension Paths.Pricing {
    public func country(_ country: String) -> WithCurrencyCurrency {
        WithCurrencyCurrency(path: "\(path)/\(country)?currency={currency}")
    }

    public struct WithCurrencyCurrency {
        /// Path: `/pricing/{country}?currency={currency}`
        public let path: String

        /// Get Country Pricing
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var recharge: Recharge {
        Recharge(path: "/recharge")
    }

    public struct Recharge {
        /// Path: `/recharge`
        public let path: String
    }
}

extension Paths.Recharge {
    public var creditCard: CreditCard {
        CreditCard(path: path + "/credit-card")
    }

    public struct CreditCard {
        /// Path: `/recharge/credit-card`
        public let path: String

        /// Get Credit Card info
        public var get: Request<String> {
            .get(path)
        }

        /// Update Credit Card info
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "bank_name" : "Robotic Banking",
        ///   "cvc" : "123",
        ///   "expiry_month" : "05",
        ///   "expiry_year" : "2016",
        ///   "name" : "Roland Robot",
        ///   "number" : "5520000000000000"
        /// }
        public struct PutRequest: Encodable {
            /// Your bank's name that issued the credit card.
            public var bankName: String
            /// Your CVC digits.
            public var cvc: Double
            /// Your credit card expiry month.
            public var expiryMonth: Double
            /// Your credit card expiry year.
            public var expiryYear: Double?
            /// Your name.
            public var name: String
            /// Your credit card no.
            public var number: Double?

            public init(bankName: String, cvc: Double, expiryMonth: Double, expiryYear: Double? = nil, name: String, number: Double? = nil) {
                self.bankName = bankName
                self.cvc = cvc
                self.expiryMonth = expiryMonth
                self.expiryYear = expiryYear
                self.name = name
                self.number = number
            }

            private enum CodingKeys: String, CodingKey {
                case bankName = "bank_name"
                case cvc
                case expiryMonth = "expiry_month"
                case expiryYear = "expiry_year"
                case name
                case number
            }
        }
    }
}

extension Paths.Recharge {
    public func country(_ country: String) -> WithPackagesCountry {
        WithPackagesCountry(path: "\(path)/packages?country=\(country)")
    }

    public struct WithPackagesCountry {
        /// Path: `/recharge/packages?country={country}`
        public let path: String

        /// List of Packages
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Recharge {
    public var purchase: Purchase {
        Purchase(path: path + "/purchase")
    }

    public struct Purchase {
        /// Path: `/recharge/purchase`
        public let path: String
    }
}

extension Paths.Recharge.Purchase {
    public func packageID(_ packageID: String) -> WithPackageID {
        WithPackageID(path: "\(path)/\(packageID)")
    }

    public struct WithPackageID {
        /// Path: `/recharge/purchase/{package_id}`
        public let path: String

        /// Purchase a Package
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Recharge {
    public var transactions: Transactions {
        Transactions(path: path + "/transactions")
    }

    public struct Transactions {
        /// Path: `/recharge/transactions`
        public let path: String

        /// Get Transactions
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Recharge.Transactions {
    public func transactionID(_ transactionID: String) -> WithTransactionID {
        WithTransactionID(path: "\(path)/\(transactionID)")
    }

    public struct WithTransactionID {
        /// Path: `/recharge/transactions/{transaction_id}`
        public let path: String

        /// Get a specific transaction
        public var get: Request<Data> {
            .get(path)
        }
    }
}

extension Paths {
    public static var referral: Referral {
        Referral(path: "/referral")
    }

    public struct Referral {
        /// Path: `/referral`
        public let path: String
    }
}

extension Paths.Referral {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/referral/accounts`
        public let path: String

        /// Get List of Referral Accounts
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var reseller: Reseller {
        Reseller(path: "/reseller")
    }

    public struct Reseller {
        /// Path: `/reseller`
        public let path: String

        /// Get Reseller Setting
        ///
        /// Get reseller setting.
        public var get: Request<String> {
            .get(path)
        }

        /// Update Reseller Setting
        ///
        /// Update a specific reseller setting.
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "allow_public_signups" : 1,
        ///   "colour_navigation" : "#9999FF",
        ///   "company_name" : "MyCompany",
        ///   "default_margin" : 100,
        ///   "default_margin_numbers" : 150,
        ///   "logo_url_dark" : "http:\/\/yourdomain.com\/dark",
        ///   "logo_url_light" : "http:\/\/yourdomain.com\/light",
        ///   "subdomain" : "subdomain",
        ///   "trial_balance" : 50
        /// }
        public struct PutRequest: Encodable {
            /// Allow public signups.
            public var allowPublicSignups: Double
            /// Colour navigation.
            public var colourNavigation: String
            /// Company name.
            public var companyName: String
            /// Default margin.
            public var defaultMargin: Double
            /// Default margin numbers.
            public var defaultMarginNumbers: Double
            /// Logo URL (dark)
            public var logoURLDark: String
            /// Logo URL (light)
            public var logoURLLight: String
            /// Subdomain.
            public var subdomain: String
            /// Trial balance.
            public var trialBalance: Double

            public init(allowPublicSignups: Double, colourNavigation: String, companyName: String, defaultMargin: Double, defaultMarginNumbers: Double, logoURLDark: String, logoURLLight: String, subdomain: String, trialBalance: Double) {
                self.allowPublicSignups = allowPublicSignups
                self.colourNavigation = colourNavigation
                self.companyName = companyName
                self.defaultMargin = defaultMargin
                self.defaultMarginNumbers = defaultMarginNumbers
                self.logoURLDark = logoURLDark
                self.logoURLLight = logoURLLight
                self.subdomain = subdomain
                self.trialBalance = trialBalance
            }

            private enum CodingKeys: String, CodingKey {
                case allowPublicSignups = "allow_public_signups"
                case colourNavigation = "colour_navigation"
                case companyName = "company_name"
                case defaultMargin = "default_margin"
                case defaultMarginNumbers = "default_margin_numbers"
                case logoURLDark = "logo_url_dark"
                case logoURLLight = "logo_url_light"
                case subdomain
                case trialBalance = "trial_balance"
            }
        }
    }
}

extension Paths.Reseller {
    public var accounts: Accounts {
        Accounts(path: path + "/accounts")
    }

    public struct Accounts {
        /// Path: `/reseller/accounts`
        public let path: String

        /// List of Reseller Accounts
        ///
        /// Get list of Reseller Accounts
        public var get: Request<String> {
            .get(path)
        }

        /// Create Reseller Account
        public func post(_ body: PostRequest) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "account_name" : "The Awesome Company",
        ///   "country" : "US",
        ///   "password" : "pass",
        ///   "user_email" : "johndoe2@awesome.com",
        ///   "user_first_name" : "John",
        ///   "user_last_name" : "Doe",
        ///   "user_phone" : "518-481-1002",
        ///   "username" : "johndoe2"
        /// }
        public struct PostRequest: Encodable {
            /// Your delivery to value.
            public var accountName: String
            /// Client country.
            public var country: String
            /// Your password.
            public var password: String
            /// Your email.
            public var userEmail: String
            /// Your first name.
            public var userFirstName: String
            /// Your last name.
            public var userLastName: String
            /// Your phone number in E.164 format.
            public var userPhone: String
            /// Your username.
            public var username: String

            public init(accountName: String, country: String, password: String, userEmail: String, userFirstName: String, userLastName: String, userPhone: String, username: String) {
                self.accountName = accountName
                self.country = country
                self.password = password
                self.userEmail = userEmail
                self.userFirstName = userFirstName
                self.userLastName = userLastName
                self.userPhone = userPhone
                self.username = username
            }

            private enum CodingKeys: String, CodingKey {
                case accountName = "account_name"
                case country
                case password
                case userEmail = "user_email"
                case userFirstName = "user_first_name"
                case userLastName = "user_last_name"
                case userPhone = "user_phone"
                case username
            }
        }
    }
}

extension Paths.Reseller {
    public var accountsPublic: AccountsPublic {
        AccountsPublic(path: path + "/accounts-public")
    }

    public struct AccountsPublic {
        /// Path: `/reseller/accounts-public`
        public let path: String

        /// Create Reseller Account - Public
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "account_name" : "The Awesome Company",
        ///   "country" : "AU",
        ///   "password" : "pass",
        ///   "reseller_user_id" : 1,
        ///   "user_email" : "johnis@awesome.com",
        ///   "user_first_name" : "John",
        ///   "user_last_name" : "Awesome",
        ///   "user_phone" : "+61261063270",
        ///   "username" : "john_awesome"
        /// }
        public struct PostRequest: Encodable {
            /// Your delivery to value.
            public var accountName: String
            /// Client country.
            public var country: String
            /// Your password.
            public var password: String
            /// Reseller User ID.
            public var resellerUserID: Double
            /// Your email.
            public var userEmail: String
            /// Your first name.
            public var userFirstName: String
            /// Your last name.
            public var userLastName: String
            /// Your phone number in E.164 format.
            public var userPhone: String
            /// Your username.
            public var username: String

            public init(accountName: String, country: String, password: String, resellerUserID: Double, userEmail: String, userFirstName: String, userLastName: String, userPhone: String, username: String) {
                self.accountName = accountName
                self.country = country
                self.password = password
                self.resellerUserID = resellerUserID
                self.userEmail = userEmail
                self.userFirstName = userFirstName
                self.userLastName = userLastName
                self.userPhone = userPhone
                self.username = username
            }

            private enum CodingKeys: String, CodingKey {
                case accountName = "account_name"
                case country
                case password
                case resellerUserID = "reseller_user_id"
                case userEmail = "user_email"
                case userFirstName = "user_first_name"
                case userLastName = "user_last_name"
                case userPhone = "user_phone"
                case username
            }
        }
    }
}

extension Paths.Reseller.Accounts {
    public func clientUserID(_ clientUserID: String) -> WithClientUserID {
        WithClientUserID(path: "\(path)/\(clientUserID)")
    }

    public struct WithClientUserID {
        /// Path: `/reseller/accounts/{client_user_id}`
        public let path: String

        /// Get Reseller Account
        ///
        /// Get a specific reseller account.
        public var get: Request<String> {
            .get(path)
        }

        /// Update Reseller Account
        public func put(_ body: PutRequest) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "account_name" : "The Awesome Company",
        ///   "country" : "US",
        ///   "password" : "pass",
        ///   "user_email" : "johndoe2@awesome.com",
        ///   "user_first_name" : "John",
        ///   "user_last_name" : "Doe",
        ///   "user_phone" : "518-481-1002",
        ///   "username" : "johndoe2"
        /// }
        public struct PutRequest: Encodable {
            /// Your delivery to value.
            public var accountName: String
            /// Client country.
            public var country: String
            /// Your password.
            public var password: String
            /// Your email.
            public var userEmail: String
            /// Your first name.
            public var userFirstName: String
            /// Your last name.
            public var userLastName: String
            /// Your phone number in E.164 format.
            public var userPhone: String
            /// Your username.
            public var username: String

            public init(accountName: String, country: String, password: String, userEmail: String, userFirstName: String, userLastName: String, userPhone: String, username: String) {
                self.accountName = accountName
                self.country = country
                self.password = password
                self.userEmail = userEmail
                self.userFirstName = userFirstName
                self.userLastName = userLastName
                self.userPhone = userPhone
                self.username = username
            }

            private enum CodingKeys: String, CodingKey {
                case accountName = "account_name"
                case country
                case password
                case userEmail = "user_email"
                case userFirstName = "user_first_name"
                case userLastName = "user_last_name"
                case userPhone = "user_phone"
                case username
            }
        }
    }
}

extension Paths.Reseller {
    public var transferCredit: TransferCredit {
        TransferCredit(path: path + "/transfer-credit")
    }

    public struct TransferCredit {
        /// Path: `/reseller/transfer-credit`
        public let path: String

        /// Transfer Credit
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "balance" : 12,
        ///   "client_user_id" : 60,
        ///   "currency" : "USD"
        /// }
        public struct PutRequest: Encodable {
            /// Your amount.
            public var balance: Double
            /// Your client user id.
            public var clientUserID: String
            /// Your currency.
            public var currency: String

            public init(balance: Double, clientUserID: String, currency: String) {
                self.balance = balance
                self.clientUserID = clientUserID
                self.currency = currency
            }

            private enum CodingKeys: String, CodingKey {
                case balance
                case clientUserID = "client_user_id"
                case currency
            }
        }
    }
}

extension Paths.Reseller {
    public func subdomain(_ subdomain: String) -> WithSubdomain {
        WithSubdomain(path: "\(path)/\(subdomain)")
    }

    public struct WithSubdomain {
        /// Path: `/reseller/{subdomain}`
        public let path: String

        /// Reseller By Subdomain
        ///
        /// Get reseller setting by subdomin.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var sdkDownload: SdkDownload {
        SdkDownload(path: "/sdk-download")
    }

    public struct SdkDownload {
        /// Path: `/sdk-download`
        public let path: String
    }
}

extension Paths.SdkDownload {
    public func type(_ type: String) -> WithType {
        WithType(path: "\(path)/\(type)")
    }

    public struct WithType {
        /// Path: `/sdk-download/{type}`
        public let path: String

        /// SDK Download
        public var get: Request<Void> {
            .get(path)
        }
    }
}

extension Paths {
    public static var search: Search {
        Search(path: "/search")
    }

    public struct Search {
        /// Path: `/search`
        public let path: String
    }
}

extension Paths.Search {
    public func q(_ q: String) -> WithContactsListsQ {
        WithContactsListsQ(path: "\(path)/contacts-lists?q=\(q)")
    }

    public struct WithContactsListsQ {
        /// Path: `/search/contacts-lists?q={q}`
        public let path: String

        /// Search Contacts-Lists
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var smsCampaigns: SmsCampaigns {
        SmsCampaigns(path: "/sms-campaigns")
    }

    public struct SmsCampaigns {
        /// Path: `/sms-campaigns`
        public let path: String

        /// Get list of SMS Campaigns
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.SmsCampaigns {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/sms-campaigns/price`
        public let path: String

        /// Calculate Price for SMS Campaign
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "(First Name), this is your new campaign message.",
        ///   "from" : "+61353787448",
        ///   "list_id" : 428,
        ///   "name" : "My Campaign 1"
        /// }
        public struct PostRequest: Encodable {
            /// Your campaign message.
            public var body: String
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?
            /// Your list id.
            public var listID: Double
            /// Your campaign name.
            public var name: String

            public init(body: String, from: String? = nil, listID: Double, name: String) {
                self.body = body
                self.from = from
                self.listID = listID
                self.name = name
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case from
                case listID = "list_id"
                case name
            }
        }
    }
}

extension Paths.SmsCampaigns {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/sms-campaigns/send`
        public let path: String

        /// Use Short URL
        ///
        /// This is functionally identical to the **POST /sms-campaigns/send** endpoint, other than adding the `smsg.us/xxxxx` string to the message body additional `url_to_shorten` parameter.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "This is my new campaign message. Visit this url: smsg.us\/xxxxx",
        ///   "from" : "+61353787448",
        ///   "list_id" : 428,
        ///   "name" : "My Campaign 1",
        ///   "schedule" : 1444821615,
        ///   "url_to_shorten" : "http:\/\/yourdomain.com\/"
        /// }
        public struct PostRequest: Encodable {
            /// Your campaign message.
            public var body: String
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?
            /// Your list id.
            public var listID: Double
            /// Your campaign name.
            public var name: String
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// The URL you want to shorten (only required when using this feature). This must be only `http` or `https`.
            public var urlToShorten: String

            public init(body: String, from: String? = nil, listID: Double, name: String, schedule: Double? = nil, urlToShorten: String) {
                self.body = body
                self.from = from
                self.listID = listID
                self.name = name
                self.schedule = schedule
                self.urlToShorten = urlToShorten
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case from
                case listID = "list_id"
                case name
                case schedule
                case urlToShorten = "url_to_shorten"
            }
        }
    }
}

extension Paths.SmsCampaigns {
    public func campaignID(_ campaignID: String) -> WithCampaignID {
        WithCampaignID(path: "\(path)/\(campaignID)")
    }

    public struct WithCampaignID {
        /// Path: `/sms-campaigns/{campaign_id}`
        public let path: String
    }
}

extension Paths.SmsCampaigns.WithCampaignID {
    public func filename(_ filename: String) -> WithLinkExportFilename {
        WithLinkExportFilename(path: "\(path)/link-export?filename=\(filename)")
    }

    public struct WithLinkExportFilename {
        /// Path: `/sms-campaigns/{campaign_id}/link-export?filename={filename}`
        public let path: String

        /// Link Tracking Export
        ///
        /// Compile all link tracking for the specified campaign into a CSV for download.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.SmsCampaigns.WithCampaignID {
    public var linkStatistics: LinkStatistics {
        LinkStatistics(path: path + "/link-statistics")
    }

    public struct LinkStatistics {
        /// Path: `/sms-campaigns/{campaign_id}/link-statistics`
        public let path: String

        /// Link Statistics
        ///
        /// Get the breakdown of statistics for your campaign. Note that the returned values vary depending on your specific customers' interaction, so it's not safe to assume a value will always be specified.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.SmsCampaigns.WithCampaignID {
    public var linkTracking: LinkTracking {
        LinkTracking(path: path + "/link-tracking")
    }

    public struct LinkTracking {
        /// Path: `/sms-campaigns/{campaign_id}/link-tracking`
        public let path: String

        /// Link Tracking
        ///
        /// This endpoint gives you a paginated overview of all the links in a particular campaign, and who has and hasn't visited them.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.SmsCampaigns {
    public func smsCampaignID(_ smsCampaignID: String) -> WithSmsCampaignID {
        WithSmsCampaignID(path: "\(path)/\(smsCampaignID)")
    }

    public struct WithSmsCampaignID {
        /// Path: `/sms-campaigns/{sms_campaign_id}`
        public let path: String

        /// Get SMS Campaign
        public var get: Request<String> {
            .get(path)
        }

        /// Update an SMS Campaign
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "his is an awesome message.",
        ///   "from" : "+61353787447",
        ///   "list_id" : 428,
        ///   "name" : "Awesome campaign.",
        ///   "schedule" : 1444821615
        /// }
        public struct PutRequest: Encodable {
            /// Your campaign message.
            public var body: String
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?
            /// Your list id.
            public var listID: Double
            /// Your campaign name.
            public var name: String
            /// Leave blank for immediate delivery. Will replace existing schedule (even if left blank). Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?

            public init(body: String, from: String? = nil, listID: Double, name: String, schedule: Double? = nil) {
                self.body = body
                self.from = from
                self.listID = listID
                self.name = name
                self.schedule = schedule
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case from
                case listID = "list_id"
                case name
                case schedule
            }
        }
    }
}

extension Paths.SmsCampaigns.WithSmsCampaignID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/sms-campaigns/{sms_campaign_id}/cancel`
        public let path: String

        /// Cancel an SMS Campaign
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths {
    public static var sms: Sms {
        Sms(path: "/sms")
    }

    public struct Sms {
        /// Path: `/sms`
        public let path: String
    }
}

extension Paths.Sms {
    public var cancelAll: CancelAll {
        CancelAll(path: path + "/cancel-all")
    }

    public struct CancelAll {
        /// Path: `/sms/cancel-all`
        public let path: String

        /// Cancel all Scheduled Messages
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Sms {
    public var emailSms: EmailSms {
        EmailSms(path: path + "/email-sms")
    }

    public struct EmailSms {
        /// Path: `/sms/email-sms`
        public let path: String

        /// List of Email-to-SMS Allowed Address
        ///
        /// Get list of allowed email addresses.
        public var get: Request<String> {
            .get(path)
        }

        /// Create Email to SMS Allowed Address
        ///
        /// Create an allowed email address.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "email_address" : "Cv3p0@gmail.com",
        ///   "from" : "+17128845887"
        /// }
        public struct PostRequest: Encodable {
            /// Your email address.
            public var emailAddress: String
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?

            public init(emailAddress: String, from: String? = nil) {
                self.emailAddress = emailAddress
                self.from = from
            }

            private enum CodingKeys: String, CodingKey {
                case emailAddress = "email_address"
                case from
            }
        }
    }
}

extension Paths.Sms {
    public var emailSmsStrippedStrings: EmailSmsStrippedStrings {
        EmailSmsStrippedStrings(path: path + "/email-sms-stripped-strings")
    }

    public struct EmailSmsStrippedStrings {
        /// Path: `/sms/email-sms-stripped-strings`
        public let path: String

        /// List Stripped Strings
        public var get: Request<String> {
            .get(path)
        }

        /// Create Stripped String
        public func post(stripString: String) -> Request<String> {
            .post(path, body: ["strip_string": stripString])
        }
    }
}

extension Paths.Sms.EmailSmsStrippedStrings {
    public func ruleID(_ ruleID: String) -> WithRuleID {
        WithRuleID(path: "\(path)/\(ruleID)")
    }

    public struct WithRuleID {
        /// Path: `/sms/email-sms-stripped-strings/{rule_id}`
        public let path: String

        /// Find Specific Stripped String
        public var get: Request<String> {
            .get(path)
        }

        /// Update Stripped String
        public func put(stripString: String? = nil) -> Request<String> {
            .put(path, body: ["strip_string": stripString])
        }

        /// Delete Stripped String
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Sms.EmailSms {
    public func emailAddressID(_ emailAddressID: String) -> WithEmailAddressID {
        WithEmailAddressID(path: "\(path)/\(emailAddressID)")
    }

    public struct WithEmailAddressID {
        /// Path: `/sms/email-sms/{email_address_id}`
        public let path: String

        /// Get specific Email-to-SMS Allowed Address
        ///
        /// Get a specific allowed email address.
        public var get: Request<String> {
            .get(path)
        }

        /// Update Email-to-SMS Allowed Address
        ///
        /// Update a specific allowed email address.
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "email_address" : "pfvRZ@gmail.com",
        ///   "from" : "+17128842283"
        /// }
        public struct PutRequest: Encodable {
            /// Your email address.
            public var emailAddress: String
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?

            public init(emailAddress: String, from: String? = nil) {
                self.emailAddress = emailAddress
                self.from = from
            }

            private enum CodingKeys: String, CodingKey {
                case emailAddress = "email_address"
                case from
            }
        }

        /// Delete Email-to-SMS Allowed Address
        ///
        /// Delete a specific allowed email address.
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Sms {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/sms/history`
        public let path: String
    }
}

extension Paths.Sms.History {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/sms/history/export?filename={filename}`
        public let path: String

        /// Export SMS History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Sms {
    public func dateFrom(_ dateFrom: String) -> WithHistoryDateFromDateToDateTo {
        WithHistoryDateFromDateToDateTo(path: "\(path)/history?date_from=\(dateFrom)&date_to={date_to}")
    }

    public struct WithHistoryDateFromDateToDateTo {
        /// Path: `/sms/history?date_from={date_from}&date_to={date_to}`
        public let path: String

        /// Get all History
        ///
        /// **SMS Delivery Status**
        /// 
        /// **Status (status field)**
        /// 
        /// | Status | Description |
        /// |---|---|---|
        /// | `Completed` | Added to delivery queue. Waiting to be sent to the network.|
        /// | `Sent` | Message sent to the network.|
        /// | `Cancelled` | Message cancelled.|
        /// | `Scheduled` | Message scheduled.|
        /// | `WaitApproval` | Waiting approval by our team. This is temporary and will change to 'Sent' once approved. This only happens for a few messages that are flagged for approval by our automated spam-detection system.|
        /// 
        /// **Status Codes (status_code field)**
        /// 
        /// | Code | Text | Description |
        /// |---|---|---|
        /// | `200` | Sent by network| Temporary success|
        /// | `201` | Received on handset| Permanent success|
        /// | `300` | Delivery failure| Permanent failure|
        /// | `301` | Delivery failure| Permanent failure|
        /// | `302` | Delivery failure| Temporary failure - supplier routing issue|
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Sms {
    public var inbound: Inbound {
        Inbound(path: path + "/inbound")
    }

    public struct Inbound {
        /// Path: `/sms/inbound`
        public let path: String

        /// Get all Inbound SMS - Pull
        public var get: Request<String> {
            .get(path)
        }

        /// Add a Test Inbound SMS
        public func post(url: String) -> Request<String> {
            .post(path, body: ["url": url])
        }
    }
}

extension Paths.Sms {
    public var inboundRead: InboundRead {
        InboundRead(path: path + "/inbound-read")
    }

    public struct InboundRead {
        /// Path: `/sms/inbound-read`
        public let path: String

        /// Mark all Inbound SMS as read
        public func put(dateBefore: Double) -> Request<String> {
            .put(path, body: ["date_before": dateBefore])
        }
    }
}

extension Paths.Sms.InboundRead {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/sms/inbound-read/{message_id}`
        public let path: String

        /// Mark a specific Inbound SMS as read
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Sms.Inbound {
    public func outboundMessageID(_ outboundMessageID: String) -> WithOutboundMessageID {
        WithOutboundMessageID(path: "\(path)/\(outboundMessageID)")
    }

    public struct WithOutboundMessageID {
        /// Path: `/sms/inbound/{outbound_message_id}`
        public let path: String

        /// Get Specific Inbound - Pull
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Sms {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/sms/price`
        public let path: String

        /// Calculate Price
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "messages" : [
        ///     {
        ///       "body" : "Jelly liquorice marshmallow candy carrot cake 4Eyffjs1vL.",
        ///       "custom_string" : "this is a test",
        ///       "from" : "sendmobile",
        ///       "schedule" : 1436874701,
        ///       "source" : "php",
        ///       "to" : "+61411111111"
        ///     },
        ///     {
        ///       "body" : "Chocolate bar icing icing oat cake carrot cake jelly cotton MWEvciEPIr.",
        ///       "custom_string" : "this is a test",
        ///       "from" : "sendlist",
        ///       "list_id" : 428,
        ///       "schedule" : 1436876011,
        ///       "source" : "php"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Your message.
            public var body: String
            /// Recipient country.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String

            public init(body: String, country: String? = nil, customString: String? = nil, from: String? = nil, listID: Double? = nil, schedule: Double? = nil, source: String? = nil, to: String) {
                self.body = body
                self.country = country
                self.customString = customString
                self.from = from
                self.listID = listID
                self.schedule = schedule
                self.source = source
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case country
                case customString = "custom_string"
                case from
                case listID = "list_id"
                case schedule
                case source
                case to
            }
        }
    }
}

extension Paths.Sms {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/sms/receipts`
        public let path: String

        /// Get all Delivery Receipts
        public var get: Request<String> {
            .get(path)
        }

        /// Add a Test Delivery Receipt
        public func post(url: String) -> Request<String> {
            .post(path, body: ["url": url])
        }
    }
}

extension Paths.Sms {
    public var receiptsRead: ReceiptsRead {
        ReceiptsRead(path: path + "/receipts-read")
    }

    public struct ReceiptsRead {
        /// Path: `/sms/receipts-read`
        public let path: String

        /// Mark Delivery Receipts as read
        public func put(dateBefore: Double? = nil) -> Request<String> {
            .put(path, body: ["date_before": dateBefore])
        }
    }
}

extension Paths.Sms.Receipts {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/sms/receipts/{message_id}`
        public let path: String

        /// Get a Specific Delivery Receipt
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Sms {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/sms/send`
        public let path: String

        /// Send an SMS
        ///
        /// You can post **up to 1000 messages** with each API call.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "messages" : [
        ///     {
        ///       "body" : "Jelly liquorice marshmallow candy carrot cake 4Eyffjs1vL.",
        ///       "custom_string" : "this is a test",
        ///       "from" : "sendmobile",
        ///       "schedule" : 1436874701,
        ///       "source" : "php",
        ///       "to" : "+61411111111"
        ///     },
        ///     {
        ///       "body" : "Chocolate bar icing icing oat cake carrot cake jelly cotton MWEvciEPIr.",
        ///       "custom_string" : "this is a test",
        ///       "from" : "sendlist",
        ///       "list_id" : 428,
        ///       "schedule" : 1436876011,
        ///       "source" : "php"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Your message.
            public var body: String
            /// Recipient country.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Your sender id - [more info](http://help.clicksend.com/SMS/what-is-a-sender-id-or-sender-number).
            public var from: String?
            /// An email address where the reply should be emailed to. If omitted, the reply will be emailed back to the user who sent the outgoing SMS.
            public var fromEmail: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String

            public init(body: String, country: String? = nil, customString: String? = nil, from: String? = nil, fromEmail: String? = nil, listID: Double? = nil, schedule: Double? = nil, source: String? = nil, to: String) {
                self.body = body
                self.country = country
                self.customString = customString
                self.from = from
                self.fromEmail = fromEmail
                self.listID = listID
                self.schedule = schedule
                self.source = source
                self.to = to
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case country
                case customString = "custom_string"
                case from
                case fromEmail = "from_email"
                case listID = "list_id"
                case schedule
                case source
                case to
            }
        }
    }
}

extension Paths.Sms {
    public var templates: Templates {
        Templates(path: path + "/templates")
    }

    public struct Templates {
        /// Path: `/sms/templates`
        public let path: String

        /// List of Templates
        ///
        /// Get list of templates.
        public var get: Request<String> {
            .get(path)
        }

        /// Create a Template
        ///
        /// Create new template.
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "This is a sample content: H7YI68B3yk for this template.",
        ///   "template_name" : "Template 501916"
        /// }
        public struct PostRequest: Encodable {
            /// Your template body.
            public var body: String
            /// Your template name.
            public var templateName: String

            public init(body: String, templateName: String) {
                self.body = body
                self.templateName = templateName
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case templateName = "template_name"
            }
        }
    }
}

extension Paths.Sms.Templates {
    public func templateID(_ templateID: String) -> WithTemplateID {
        WithTemplateID(path: "\(path)/\(templateID)")
    }

    public struct WithTemplateID {
        /// Path: `/sms/templates/{template_id}`
        public let path: String

        /// Update a Template
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "body" : "This is a sample content: Sc0KNWgSMG for this template.",
        ///   "template_name" : "I am updated"
        /// }
        public struct PutRequest: Encodable {
            /// Your template body.
            public var body: String
            /// Your template name.
            public var templateName: String

            public init(body: String, templateName: String) {
                self.body = body
                self.templateName = templateName
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case templateName = "template_name"
            }
        }

        /// Delete a Template
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Sms {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/sms/{message_id}`
        public let path: String
    }
}

extension Paths.Sms.WithMessageID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/sms/{message_id}/cancel`
        public let path: String

        /// Cancel a Scheduled Message
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths {
    public static var statistics: Statistics {
        Statistics(path: "/statistics")
    }

    public struct Statistics {
        /// Path: `/statistics`
        public let path: String
    }
}

extension Paths.Statistics {
    public var sms: Sms {
        Sms(path: path + "/sms")
    }

    public struct Sms {
        /// Path: `/statistics/sms`
        public let path: String

        /// Get SMS Statistics
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Statistics {
    public var voice: Voice {
        Voice(path: path + "/voice")
    }

    public struct Voice {
        /// Path: `/statistics/voice`
        public let path: String

        /// Get Voice Statistics
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static var subaccounts: Subaccounts {
        Subaccounts(path: "/subaccounts")
    }

    public struct Subaccounts {
        /// Path: `/subaccounts`
        public let path: String

        /// Get all Subaccounts
        public var get: Request<String> {
            .get(path)
        }

        /// Create a new subaccount
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "api_username" : "nameP99",
        ///   "email" : "testvrq@gmail.com",
        ///   "first_name" : "FirstnameeGPqV",
        ///   "last_name" : "LastnamePvjJp",
        ///   "password" : "pass",
        ///   "phone_number" : "941-751-3278"
        /// }
        public struct PostRequest: Encodable {
            /// Your access billing flag value, must be 1 or 0.
            public var accessBilling: Double?
            /// Your access contacts flag value, must be 1 or 0.
            public var accessContacts: Double?
            /// Your access reporting flag value, must be 1 or 0.
            public var accessReporting: Double?
            /// Your access settings flag value, must be 1 or 0.
            public var accessSettings: Double?
            /// Your access users flag value, must be 1 or 0.
            public var accessUsers: Double?
            /// Your new api username.
            public var apiUsername: String
            /// Your new email.
            public var email: String
            /// Your firstname.
            public var firstName: String
            /// Your lastname.
            public var lastName: String
            /// Your new password.
            public var password: String
            /// Your phone number in E.164 format.
            public var phoneNumber: String
            /// Your share campaigns flag value, must be 1 or 0.
            public var shareCampaigns: Double?

            public init(accessBilling: Double? = nil, accessContacts: Double? = nil, accessReporting: Double? = nil, accessSettings: Double? = nil, accessUsers: Double? = nil, apiUsername: String, email: String, firstName: String, lastName: String, password: String, phoneNumber: String, shareCampaigns: Double? = nil) {
                self.accessBilling = accessBilling
                self.accessContacts = accessContacts
                self.accessReporting = accessReporting
                self.accessSettings = accessSettings
                self.accessUsers = accessUsers
                self.apiUsername = apiUsername
                self.email = email
                self.firstName = firstName
                self.lastName = lastName
                self.password = password
                self.phoneNumber = phoneNumber
                self.shareCampaigns = shareCampaigns
            }

            private enum CodingKeys: String, CodingKey {
                case accessBilling = "access_billing"
                case accessContacts = "access_contacts"
                case accessReporting = "access_reporting"
                case accessSettings = "access_settings"
                case accessUsers = "access_users"
                case apiUsername = "api_username"
                case email
                case firstName = "first_name"
                case lastName = "last_name"
                case password
                case phoneNumber = "phone_number"
                case shareCampaigns = "share_campaigns"
            }
        }
    }
}

extension Paths.Subaccounts {
    public func subaccountID(_ subaccountID: String) -> WithSubaccountID {
        WithSubaccountID(path: "\(path)/\(subaccountID)")
    }

    public struct WithSubaccountID {
        /// Path: `/subaccounts/{subaccount_id}`
        public let path: String

        /// Get a specific subaccount
        public var get: Request<String> {
            .get(path)
        }

        /// Update a specific subaccount
        public func put(_ body: PutRequest? = nil) -> Request<String> {
            .put(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "access_billing" : 1,
        ///   "access_contacts" : 1,
        ///   "access_email" : 1,
        ///   "access_fax" : 1,
        ///   "access_mms" : 1,
        ///   "access_post" : 1,
        ///   "access_reporting" : 1,
        ///   "access_reseller" : 1,
        ///   "access_settings" : 1,
        ///   "access_sms" : 1,
        ///   "access_users" : 1,
        ///   "access_voice" : 1,
        ///   "email" : "testfP0.updated@gmail.com",
        ///   "first_name" : "FirstnameKvdRZUpdated",
        ///   "last_name" : "LastnameHUPYGUpdated",
        ///   "notes" : null,
        ///   "password" : "pass",
        ///   "phone_number" : "+19417519130",
        ///   "share_campaigns" : 0
        /// }
        public struct PutRequest: Encodable {
            /// Your access billing flag value, must be 1 or 0.
            public var accessBilling: Double?
            /// Your access contacts flag value, must be 1 or 0.
            public var accessContacts: Double?
            /// Your access reporting flag value, must be 1 or 0.
            public var accessReporting: Double?
            /// Your access settings flag value, must be 1 or 0.
            public var accessSettings: Double?
            /// Your access users flag value, must be 1 or 0.
            public var accessUsers: Double?
            /// Your new email.
            public var email: String?
            /// Your firstname.
            public var firstName: String?
            /// Your lastname.
            public var lastName: String?
            /// Your new password.
            public var password: String?
            /// Your phone number in E.164 format.
            public var phoneNumber: String?
            /// Your share campaigns flag value, must be 1 or 0.
            public var shareCampaigns: Double?

            public init(accessBilling: Double? = nil, accessContacts: Double? = nil, accessReporting: Double? = nil, accessSettings: Double? = nil, accessUsers: Double? = nil, email: String? = nil, firstName: String? = nil, lastName: String? = nil, password: String? = nil, phoneNumber: String? = nil, shareCampaigns: Double? = nil) {
                self.accessBilling = accessBilling
                self.accessContacts = accessContacts
                self.accessReporting = accessReporting
                self.accessSettings = accessSettings
                self.accessUsers = accessUsers
                self.email = email
                self.firstName = firstName
                self.lastName = lastName
                self.password = password
                self.phoneNumber = phoneNumber
                self.shareCampaigns = shareCampaigns
            }

            private enum CodingKeys: String, CodingKey {
                case accessBilling = "access_billing"
                case accessContacts = "access_contacts"
                case accessReporting = "access_reporting"
                case accessSettings = "access_settings"
                case accessUsers = "access_users"
                case email
                case firstName = "first_name"
                case lastName = "last_name"
                case password
                case phoneNumber = "phone_number"
                case shareCampaigns = "share_campaigns"
            }
        }

        /// Delete a specific subaccount
        public var delete: Request<String> {
            .delete(path)
        }
    }
}

extension Paths.Subaccounts.WithSubaccountID {
    public var regenAPIKey: RegenAPIKey {
        RegenAPIKey(path: path + "/regen-api-key")
    }

    public struct RegenAPIKey {
        /// Path: `/subaccounts/{subaccount_id}/regen-api-key`
        public let path: String

        /// Regenerate API Key
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths {
    public static var timezones: Timezones {
        Timezones(path: "/timezones")
    }

    public struct Timezones {
        /// Path: `/timezones`
        public let path: String

        /// Get Timezones
        ///
        /// Get supported list of timezones.
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths {
    public static func convert(_ convert: String) -> WithUploadsConvert {
        WithUploadsConvert(path: "/uploads?convert=\(convert)")
    }

    public struct WithUploadsConvert {
        /// Path: `/uploads?convert={convert}`
        public let path: String

        /// Upload a file
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        public struct PostRequest: Encodable {
            /// Example:
            ///
            /// {
            ///   "content" : "PGh0bWw+PGhlYWQ+PHN0eWxlIHR5cGU9InRleHQvY3NzIj5ib2R5IHsgZm9udC1mYW1pbHk6J0FyaWFsJzsgfTwvc3R5bGU+PHRpdGxlPkhpPC90aXRsZT48L2hlYWQ+PGJvZHk+PGgxPkhlbGxvIHRoZXJlPC9oMT48aDI+SG93IGFyZSB5b3UgdG9kYXk\/PC9oMj48L2JvZHk+PC9odG1sPg=="
            /// }
            public var a: A?
            public var b: B?

            /// Example:
            ///
            /// {
            ///   "content" : "PGh0bWw+PGhlYWQ+PHN0eWxlIHR5cGU9InRleHQvY3NzIj5ib2R5IHsgZm9udC1mYW1pbHk6J0FyaWFsJzsgfTwvc3R5bGU+PHRpdGxlPkhpPC90aXRsZT48L2hlYWQ+PGJvZHk+PGgxPkhlbGxvIHRoZXJlPC9oMT48aDI+SG93IGFyZSB5b3UgdG9kYXk\/PC9oMj48L2JvZHk+PC9odG1sPg=="
            /// }
            public struct A: Encodable {
                /// Your file contents encoded in `base64`.
                public var content: String
                /// Conversion type: `fax`, `mms`, `csv` or `post`
                public var convert: String

                public init(content: String, convert: String) {
                    self.content = content
                    self.convert = convert
                }
            }

            public struct B: Encodable {
                /// Conversion type: `fax`, `mms`, `csv` or `post`
                public var convert: String
                /// Your file.
                public var file: String

                public init(convert: String, file: String) {
                    self.convert = convert
                    self.file = file
                }
            }

            public init(a: A? = nil, b: B? = nil) {
                self.a = a
                self.b = b
            }

            public func encode(to encoder: Encoder) throws {
                var container = encoder.singleValueContainer()
                if let value = a { try container.encode(value) }
                if let value = b { try container.encode(value) }
            }
        }
    }
}

extension Paths {
    public static var voice: Voice {
        Voice(path: "/voice")
    }

    public struct Voice {
        /// Path: `/voice`
        public let path: String
    }
}

extension Paths.Voice {
    public var cancelAll: CancelAll {
        CancelAll(path: path + "/cancel-all")
    }

    public struct CancelAll {
        /// Path: `/voice/cancel-all`
        public let path: String

        /// Cancel all Voice Calls
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Voice {
    public var history: History {
        History(path: path + "/history")
    }

    public struct History {
        /// Path: `/voice/history`
        public let path: String
    }
}

extension Paths.Voice.History {
    public func filename(_ filename: String) -> WithExportFilename {
        WithExportFilename(path: "\(path)/export?filename=\(filename)")
    }

    public struct WithExportFilename {
        /// Path: `/voice/history/export?filename={filename}`
        public let path: String

        /// Export Voice History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Voice {
    public func dateFrom(_ dateFrom: String) -> WithHistoryDateFromDateToDateTo {
        WithHistoryDateFromDateToDateTo(path: "\(path)/history?date_from=\(dateFrom)&date_to={date_to}")
    }

    public struct WithHistoryDateFromDateToDateTo {
        /// Path: `/voice/history?date_from={date_from}&date_to={date_to}`
        public let path: String

        /// Get Voice History
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Voice {
    public var lang: Lang {
        Lang(path: path + "/lang")
    }

    public struct Lang {
        /// Path: `/voice/lang`
        public let path: String

        /// Voice Languages
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Voice {
    public var price: Price {
        Price(path: path + "/price")
    }

    public struct Price {
        /// Path: `/voice/price`
        public let path: String

        /// Calculate Price
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "messages" : [
        ///     {
        ///       "body" : "Jelly liquorice marshmallow candy carrot cake 4Eyffjs1vL.",
        ///       "custom_string" : "this is a test",
        ///       "lang" : "en-au",
        ///       "schedule" : 1436874701,
        ///       "source" : "php",
        ///       "to" : "+61411111111",
        ///       "voice" : "female"
        ///     },
        ///     {
        ///       "body" : "Chocolate bar icing icing oat cake carrot cake jelly cotton MWEvciEPIr.",
        ///       "custom_string" : "this is a test",
        ///       "lang" : "en-au",
        ///       "list_id" : 428,
        ///       "require_input" : 1,
        ///       "schedule" : 1436876011,
        ///       "source" : "php",
        ///       "voice" : "female"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Your message.
            public var body: String
            /// The country of the recipient.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Au (string, required) - See section on available languages.
            public var lang: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'.
            public var listID: Double?
            /// Whether you want to receive a keypress from the call recipient (1 for on, 0 [default] for off)
            public var requireInput: Double?
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String
            /// Either 'female' or 'male'.
            public var voice: String

            public init(body: String, country: String? = nil, customString: String? = nil, lang: String? = nil, listID: Double? = nil, requireInput: Double? = nil, schedule: Double? = nil, source: String? = nil, to: String, voice: String) {
                self.body = body
                self.country = country
                self.customString = customString
                self.lang = lang
                self.listID = listID
                self.requireInput = requireInput
                self.schedule = schedule
                self.source = source
                self.to = to
                self.voice = voice
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case country
                case customString = "custom_string"
                case lang
                case listID = "list_id"
                case requireInput = "require_input"
                case schedule
                case source
                case to
                case voice
            }
        }
    }
}

extension Paths.Voice {
    public var receipts: Receipts {
        Receipts(path: path + "/receipts")
    }

    public struct Receipts {
        /// Path: `/voice/receipts`
        public let path: String

        /// Get Voice receipts
        public var get: Request<String> {
            .get(path)
        }

        /// Add a Test Delivery Receipt
        public func post(url: String) -> Request<String> {
            .post(path, body: ["url": url])
        }
    }
}

extension Paths.Voice {
    public func dateBefore(_ dateBefore: String) -> WithReceiptsReadDateBefore {
        WithReceiptsReadDateBefore(path: "\(path)/receipts-read?date_before=\(dateBefore)")
    }

    public struct WithReceiptsReadDateBefore {
        /// Path: `/voice/receipts-read?date_before={date_before}`
        public let path: String

        /// Marked Voice Receipts as Read
        public var put: Request<String> {
            .put(path)
        }
    }
}

extension Paths.Voice.Receipts {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/voice/receipts/{message_id}`
        public let path: String

        /// Get Specific Voice Receipt
        public var get: Request<String> {
            .get(path)
        }
    }
}

extension Paths.Voice {
    public var send: Send {
        Send(path: path + "/send")
    }

    public struct Send {
        /// Path: `/voice/send`
        public let path: String

        /// Send a Voice Call
        ///
        /// You can post **up to 1000 messages** with each API call.
        /// 
        /// We support some SSML tags allowing custom breaks or pauses to be entered, and the readout rate to be altered. [More info](https://help.clicksend.com/voice/how-to-adjust-tts-voice-calls).
        public func post(_ body: PostRequest? = nil) -> Request<String> {
            .post(path, body: body)
        }

        /// Example:
        ///
        /// {
        ///   "messages" : [
        ///     {
        ///       "body" : "Jelly liquorice marshmallow candy carrot cake 4Eyffjs1vL.",
        ///       "custom_string" : "this is a test",
        ///       "lang" : "en-au",
        ///       "machine_detection" : 1,
        ///       "require_input" : 1,
        ///       "schedule" : 1436874701,
        ///       "source" : "php",
        ///       "to" : "+61411111111",
        ///       "voice" : "female"
        ///     },
        ///     {
        ///       "body" : "Chocolate bar icing icing oat cake carrot cake jelly cotton MWEvciEPIr.",
        ///       "custom_string" : "this is a test",
        ///       "lang" : "en-au",
        ///       "list_id" : 428,
        ///       "schedule" : 1436876011,
        ///       "source" : "php",
        ///       "voice" : "female"
        ///     }
        ///   ]
        /// }
        public struct PostRequest: Encodable {
            /// Your message.
            public var body: String
            /// The country of the recipient.
            public var country: String?
            /// Your reference. Will be passed back with all replies and delivery reports.
            public var customString: String?
            /// Au (string, required) - See section on available languages.
            public var lang: String?
            /// Your list ID if sending to a whole list. Can be used instead of 'to'. Will override 'to' if both are used.
            public var listID: Double?
            /// Whether to attempt to detect an answering machine or voicemail service and leave a message (1 for on, 0 [default] for off)
            public var machineDetection: Double?
            /// Whether you want to receive a keypress from the call recipient (1 for on, 0 [default] for off)
            public var requireInput: Double?
            /// Leave blank for immediate delivery. Your schedule time as a [unix timestamp](http://help.clicksend.com/what-is-a-unix-timestamp).
            public var schedule: Double?
            /// Your method of sending e.g. 'wordpress', 'php', 'c#'.
            public var source: String?
            /// Recipient number in E.164 format or local format ([more info](https://help.clicksend.com/SMS/what-format-does-the-recipient-phone-number-need-to-be-in)).
            public var to: String
            /// Either 'female' or 'male'.
            public var voice: String

            public init(body: String, country: String? = nil, customString: String? = nil, lang: String? = nil, listID: Double? = nil, machineDetection: Double? = nil, requireInput: Double? = nil, schedule: Double? = nil, source: String? = nil, to: String, voice: String) {
                self.body = body
                self.country = country
                self.customString = customString
                self.lang = lang
                self.listID = listID
                self.machineDetection = machineDetection
                self.requireInput = requireInput
                self.schedule = schedule
                self.source = source
                self.to = to
                self.voice = voice
            }

            private enum CodingKeys: String, CodingKey {
                case body
                case country
                case customString = "custom_string"
                case lang
                case listID = "list_id"
                case machineDetection = "machine_detection"
                case requireInput = "require_input"
                case schedule
                case source
                case to
                case voice
            }
        }
    }
}

extension Paths.Voice {
    public func messageID(_ messageID: String) -> WithMessageID {
        WithMessageID(path: "\(path)/\(messageID)")
    }

    public struct WithMessageID {
        /// Path: `/voice/{message_id}`
        public let path: String
    }
}

extension Paths.Voice.WithMessageID {
    public var cancel: Cancel {
        Cancel(path: path + "/cancel")
    }

    public struct Cancel {
        /// Path: `/voice/{message_id}/cancel`
        public let path: String

        /// Cancel a Specific Voice Call
        public var put: Request<String> {
            .put(path)
        }
    }
}

public enum Paths {}
